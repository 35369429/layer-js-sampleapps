(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.layer = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = {
  Root: require('./src/root'),
  Client: require('./src/client'),
  ClientAuthenticator: require('./src/client-authenticator'),
  Syncable: require('./src/syncable'),
  Conversation: require('./src/conversation'),
  Message: require('./src/message'),
  Announcement: require('./src/announcement'),
  MessagePart: require('./src/message-part'),
  Query: require('./src/query'),
  QueryBuilder: require('./src/query-builder'),
  xhr: require('./src/xhr'),
  User: require('./src/user'),
  LayerError: require('./src/layer-error'),
  LayerEvent: require('./src/layer-event'),
  Content: require('./src/content'),
  SyncManager: require('./src/sync-manager'),
  SyncEvent: require('./src/sync-event').SyncEvent,
  XHRSyncEvent: require('./src/sync-event').XHRSyncEvent,
  WebsocketSyncEvent: require('./src/sync-event').WebsocketSyncEvent,
  Websockets: {
    SocketManager: require('./src/websockets/socket-manager'),
    RequestManager: require('./src/websockets/request-manager'),
    ChangeManager: require('./src/websockets/change-manager')
  },
  OnlineStateManager: require('./src/online-state-manager'),
  DbManager: require('./src/db-manager'),
  Constants: require('./src/const'),
  Util: require('./src/client-utils'),
  TypingIndicators: require('./src/typing-indicators/typing-indicators')
};
module.exports.TypingIndicators.TypingListener = require('./src/typing-indicators/typing-listener');
module.exports.TypingIndicators.TypingPublisher = require('./src/typing-indicators/typing-publisher');

},{"./src/announcement":7,"./src/client":11,"./src/client-authenticator":8,"./src/client-utils":10,"./src/const":12,"./src/content":13,"./src/conversation":14,"./src/db-manager":15,"./src/layer-error":16,"./src/layer-event":17,"./src/message":20,"./src/message-part":19,"./src/online-state-manager":21,"./src/query":23,"./src/query-builder":22,"./src/root":24,"./src/sync-event":25,"./src/sync-manager":26,"./src/syncable":27,"./src/typing-indicators/typing-indicators":29,"./src/typing-indicators/typing-listener":30,"./src/typing-indicators/typing-publisher":31,"./src/user":32,"./src/websockets/change-manager":33,"./src/websockets/request-manager":34,"./src/websockets/socket-manager":35,"./src/xhr":36}],2:[function(require,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  }else if (typeof define === "function"  && typeof define.amd == "object") {
    define(function() {
      return Events;
    });
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
/**
 * The layer.js.LayerPatchParser method will parse
 *
 * @method
 * @param {Boolean}   [camelCase=false]             Set the camel cased version of the name of the input object
 * @param {Object}    [propertyNameMap]             Maps property names in the operation to property names in the local object schema
 * @param {Object}    [changeCallbacks]             Callback made any time an object is changed
 * @param {Object}    [abortCallbacks]              Callback made to verify a change is permitted
 * @param {Function}  [doesObjectMatchIdCallback]   Callback returns boolean to indicate if a given object matches an ID.
 * @return {Boolean}                                Returns true if all operations completed successfully, false if some returned errors
 */

(function() {
  var opHandlers = {
    'set': setProp,
    'delete': deleteProp,
    'add': addProp,
    'remove': removeProp
  };

  function Parser(options) {
    this.camelCase = options.camelCase;
    this.propertyNameMap = options.propertyNameMap;
    this.changeCallbacks = options.changeCallbacks;
    this.abortCallbacks = options.abortCallbacks;
    this.getObjectCallback = options.getObjectCallback;
    this.doesObjectMatchIdCallback = options.doesObjectMatchIdCallback || function(id, obj) {
      return obj.id == id;
    };
    this.returnIds = options.returnIds;
    return this;
  };

  if (typeof module !== 'undefined') {
    module.exports = Parser;
  } else {
    window.LayerPatchParser = Parser;
  }

  Parser.prototype.parse = function(options) {
    var changes = {};
    options.operations.forEach(function(op) {
      var propertyDef = getPropertyDef.apply(this, [op.property, options, changes, op])
      opHandlers[op.operation].call(this,
        propertyDef,
        getValue.apply(this, [op, options]),
        op, options, changes);
    }, this);

    reportChanges.apply(this, [changes, options.object, options.type]);
  };

  function reportChanges(changes, updateObject, objectType) {
    if (this.changeCallbacks && objectType && this.changeCallbacks[objectType]) {
      Object.keys(changes).forEach(function(key) {
        if (this.changeCallbacks[objectType].all) {
          this.changeCallbacks[objectType].all(updateObject, updateObject[key], changes[key].before, changes[key].paths);
        }
        else if (this.changeCallbacks[objectType][key]) {
          this.changeCallbacks[objectType][key](updateObject, updateObject[key], changes[key].before, changes[key].paths);
        }
      }, this);
    }
  }

  function getPropertyDef(property, options, changes, operation) {
    var obj = options.object;
    var temporarySeparator = String.fromCharCode(145);
    property = property.replace(/\\\./g, temporarySeparator);
    property = property.replace(/\\(.)/g, '$1');
    var parts = property.split(/\./);

    var r = new RegExp(temporarySeparator, 'g')
    parts = parts.map(function(part) {
      return part.replace(r, '.');
    });

    if (this.camelCase) {
      parts[0] = parts[0].replace(/[-_]./g, function(str) {
        return str[1].toUpperCase();
      });
    }

    if (this.propertyNameMap) {
      var typeDef = this.propertyNameMap[options.type];
      parts[0] = (typeDef && typeDef[parts[0]]) || parts[0];
    }

    trackChanges.apply(this, [{
      baseName: parts[0],
      fullPath: property,
      object: options.object,
      options: options,
      changes: changes,
      operation: operation
    }]);

    var curObj = obj;
    for (var i = 0; i < parts.length-1; i++) {
      var part = parts[i];
      if (part in curObj) {
        curObj = curObj[part];
        if (curObj === null || typeof curObj !== 'object') throw new Error('Can not access property \'' + property + '\'');
      } else {
        curObj[part] = {};
        curObj = curObj[part];
      }
    }
    return {
      pointer: curObj,
      lastName: parts[parts.length-1],
      baseName: parts[0],
      fullPath: property,
      abortHandler: this.abortCallbacks && this.abortCallbacks[options.type] && (this.abortCallbacks[options.type].all || this.abortCallbacks[options.type][parts[0]])
    };
  }

  function getValue(op, options) {
    if (op.id) {
      if (!this.getObjectCallback) throw new Error('Must provide getObjectCallback in constructor to use ids');
      var result = this.getObjectCallback(op.id);
      if (result) return result;
      if (this.returnIds) return op.id;
      return null;
    } else {
      return op.value;
    }
  }

  function trackChanges(options) {
    if (!options.changes[options.baseName]) {
      var initialValue = options.object[options.baseName];
      if ('id' in options.operation && initialValue) {
        initialValue = initialValue.id;
      }
      var change = options.changes[options.baseName] = {paths: []};
      change.before = (initialValue && typeof initialValue === 'object') ? JSON.parse(JSON.stringify(initialValue)) : initialValue;
    }
    var paths = options.changes[options.baseName].paths;
    if (paths.indexOf(options.fullPath) === -1) {
      paths.push(options.fullPath);
    }
  }

  function setProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'set', value)) return;
    }
    propertyDef.pointer[propertyDef.lastName] = value;

  }

  function deleteProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'delete', value)) return;
    }
    delete propertyDef.pointer[propertyDef.lastName];
  }

  function addProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'add', value)) return;
    }
    var obj;
    if (propertyDef.lastName in propertyDef.pointer) {
      obj = propertyDef.pointer[propertyDef.lastName];
    } else {
      obj = propertyDef.pointer[propertyDef.lastName] = [];
    }
    if (!Array.isArray(obj)) throw new Error('The add operation requires an array or new structure to add to.');
    if (!op.id) {
      if (Array.isArray(value)) throw new Error('The add operation will not add arrays to sets.');
      if (value && typeof value === 'object') throw new Error('The add operation will not add objects to sets.');
    }
    if (obj.indexOf(value) === -1) obj.push(value);
  }

  function removeProp(propertyDef, value, op, options, changes) {
    if (propertyDef.abortHandler) {
      if (propertyDef.abortHandler(propertyDef.fullPath, 'remove', value)) return;
    }
    var obj;
    if (propertyDef.lastName in propertyDef.pointer) {
      obj = propertyDef.pointer[propertyDef.lastName];
    } else {
      obj = propertyDef.pointer[propertyDef.lastName] = [];
    }
    if (!Array.isArray(obj)) throw new Error('The remove operation requires an array or new structure to remove from.');

    if (!op.id) {
      if (Array.isArray(value)) throw new Error('The remove operation will not remove arrays from sets.');
      if (value && typeof value === 'object') throw new Error('The remove operation will not remove objects from sets.');

      var index = obj.indexOf(value);
      if (index !== -1) obj.splice(index, 1);
    } else {
      for (var i = 0; i < obj.length; i++) {
        if (this.doesObjectMatchIdCallback(op.id, obj[i])) {
          obj.splice(i, 1);
          break;
        }
      }
    }
  }
})();

},{}],5:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":5}],7:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Message = require('./message');
var Syncable = require('./syncable');
var Root = require('./root');

var Announcement = function (_Message) {
  _inherits(Announcement, _Message);

  function Announcement() {
    _classCallCheck(this, Announcement);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Announcement).apply(this, arguments));
  }

  _createClass(Announcement, [{
    key: 'send',
    value: function send() {}
  }, {
    key: 'getConversation',
    value: function getConversation() {}
  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.getClient()._addMessage(this);
    }

    /**
     * Creates a message from the server's representation of a message.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the message
     * @param  {layer.Conversation} conversation - Conversation for the message
     * @return {layer.Message}
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      return new Announcement({
        fromServer: message,
        clientId: client.appId,
        _notify: fromWebsocket && message.is_unread
      });
    }
  }]);

  return Announcement;
}(Message);

Announcement.prefixUUID = 'layer:///announcements/';

Announcement.inObjectIgnore = Message.inObjectIgnore;

Announcement.bubbleEventParent = 'getClient';

Announcement._supportedEvents = [].concat(Message._supportedEvents);

Root.initClass.apply(Announcement, [Announcement, 'Announcement']);
Syncable.subclasses.push(Announcement);
module.exports = Announcement;

},{"./message":20,"./root":24,"./syncable":27}],8:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Layer Client.  Access the layer by calling create and receiving it
 * from the "ready" callback.

  var client = new layer.Client({
    appId: "layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff",
    isTrustedDevice: false,
    challenge: function(evt) {
      myAuthenticator({
        nonce: evt.nonce,
        onSuccess: evt.callback
      });
    },
    ready: function(client) {
      alert("Yay, I finally got my client!");
    }
  }).connect("sampleuserId");

 * The Layer Client/ClientAuthenticator classes have been divided into:
 *
 * 1. ClientAuthenticator: Manages all authentication and connectivity related issues
 * 2. Client: Manages access to Conversations, Queries, Messages, Events, etc...
 *
 * @class layer.ClientAuthenticator
 * @private
 * @extends layer.Root
 * @author Michael Kantor
 *
 */

var xhr = require('./xhr');
var Root = require('./root');
var SocketManager = require('./websockets/socket-manager');
var WebsocketChangeManager = require('./websockets/change-manager');
var WebsocketRequestManager = require('./websockets/request-manager');
var LayerError = require('./layer-error');
var OnlineManager = require('./online-state-manager');
var SyncManager = require('./sync-manager');
var DbManager = require('./db-manager');

var _require = require('./sync-event');

var XHRSyncEvent = _require.XHRSyncEvent;
var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var _require2 = require('./const');

var ACCEPT = _require2.ACCEPT;
var LOCALSTORAGE_KEYS = _require2.LOCALSTORAGE_KEYS;

var atob = typeof window === 'undefined' ? require('atob') : window.atob;
var logger = require('./logger');

var MAX_XHR_RETRIES = 3;

var ClientAuthenticator = function (_Root) {
  _inherits(ClientAuthenticator, _Root);

  /**
   * Create a new Client.
   *
   * The appId is the only required parameter:
   *
   *      var client = new Client({
   *          appId: "layer:///apps/staging/uuid"
   *      });
   *
   * For trusted devices, you can enable storage of data to indexedDB and localStorage with the `isTrustedDevice` property:
   *
   *      var client = new Client({
   *          appId: "layer:///apps/staging/uuid",
   *          isTrustedDevice: true
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.appId           - "layer:///apps/production/uuid"; Identifies what
   *                                            application we are connecting to.
   * @param  {string} [options.url=https://api.layer.com] - URL to log into a different REST server
   * @param {number} [options.logLevel=ERROR] - Provide a log level that is one of layer.Constants.LOG.NONE, layer.Constants.LOG.ERROR,
   *                                            layer.Constants.LOG.WARN, layer.Constants.LOG.INFO, layer.Constants.LOG.DEBUG
   * @param {boolean} [options.isTrustedDevice=false] - If this is not a trusted device, no data will be written to indexedDB nor localStorage,
   *                                            regardless of any values in layer.Client.persistenceFeatures.
   * @param {Object} [options.persistenceFeatures=] If layer.Client.isTrustedDevice is true, then this specifies what types of data to store.
   *                                            Want to insure credit card data is not written? Disable writing of Messages to indexedDB.
   *                                            Default is for all data to be stored.
   *                                            * identities: Write identities to indexedDB? This allows for faster initialization.
   *                                            * conversations: Write conversations to indexedDB? This allows for faster rendering
   *                                                             of a Conversation List
   *                                            * messages: Write messages to indexedDB? This allows for full offline access
   *                                            * syncQueue: Write requests made while offline to indexedDB?  This allows the app
   *                                                         to complete sending messages after being relaunched.
   *                                            * sessionToken: Write the session token to localStorage for quick reauthentication on relaunching the app.
   */

  function ClientAuthenticator(options) {
    _classCallCheck(this, ClientAuthenticator);

    // Validate required parameters
    if (!options.appId) throw new Error(LayerError.dictionary.appIdMissing);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(ClientAuthenticator).call(this, options));
  }

  /**
   * Initialize the subcomponents of the ClientAuthenticator
   *
   * @method _initComponents
   * @private
   */


  _createClass(ClientAuthenticator, [{
    key: '_initComponents',
    value: function _initComponents() {
      // Setup the websocket manager; won't connect until we trigger an authenticated event
      this.socketManager = new SocketManager({
        client: this
      });

      this.socketChangeManager = new WebsocketChangeManager({
        client: this,
        socketManager: this.socketManager
      });

      this.socketRequestManager = new WebsocketRequestManager({
        client: this,
        socketManager: this.socketManager
      });

      this.onlineManager = new OnlineManager({
        socketManager: this.socketManager,
        testUrl: this.url + '/nonces?connection-test',
        connected: this._handleOnlineChange.bind(this),
        disconnected: this._handleOnlineChange.bind(this)
      });

      this.syncManager = new SyncManager({
        onlineManager: this.onlineManager,
        socketManager: this.socketManager,
        requestManager: this.socketRequestManager,
        client: this
      });
    }

    /**
     * Destroy the subcomponents of the ClientAuthenticator
     *
     * @method _destroyComponents
     * @private
     */

  }, {
    key: '_destroyComponents',
    value: function _destroyComponents() {
      this.syncManager.destroy();
      this.onlineManager.destroy();
      this.socketManager.destroy();
      this.socketChangeManager.destroy();
      this.socketRequestManager.destroy();
      if (this.dbManager) this.dbManager.destroy();
    }

    /**
     * Is Persisted Session Tokens disabled?
     *
     * @method _isPersistedSessionsDisabled
     * @returns {Boolean}
     * @private
     */

  }, {
    key: '_isPersistedSessionsDisabled',
    value: function _isPersistedSessionsDisabled() {
      return !global.localStorage || this.persistenceFeatures && !this.persistenceFeatures.sessionToken;
    }

    /**
     * Restore the sessionToken from localStorage.
     *
     * This sets the sessionToken rather than returning the token.
     *
     * @method _restoreLastSession
     * @private
     */

  }, {
    key: '_restoreLastSession',
    value: function _restoreLastSession() {
      if (this._isPersistedSessionsDisabled()) return;
      try {
        var sessionData = global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId];
        if (!sessionData) return;
        var parsedData = JSON.parse(sessionData);
        if (parsedData.expires < Date.now()) {
          global.localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
        } else {
          this.sessionToken = parsedData.sessionToken;
        }
      } catch (error) {
        // No-op
      }
    }

    /**
     * Has the userID changed since the last login?
     *
     * @method _hasUserIdChanged
     * @param {string} userId
     * @returns {boolean}
     * @private
     */

  }, {
    key: '_hasUserIdChanged',
    value: function _hasUserIdChanged(userId) {
      try {
        var sessionData = global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId];
        if (!sessionData) return false;
        return JSON.parse(sessionData).userId !== userId;
      } catch (error) {
        return true;
      }
    }

    /**
     * Initiates the connection.
     *
     * Called by constructor().
     *
     * Will either attempt to validate the cached sessionToken by getting converations,
     * or if no sessionToken, will call /nonces to start process of getting a new one.
     *
     * @method connect
     * @param {string} userId - User ID of the user you are logging in as
     * @returns {layer.ClientAuthenticator} this
     */

  }, {
    key: 'connect',
    value: function connect(userId) {
      var _this2 = this;

      this.isConnected = false;
      if (!this.isTrustedDevice || !userId || this._isPersistedSessionsDisabled() || this._hasUserIdChanged(userId)) {
        this._clearStoredData();
      }
      if (this.isTrustedDevice && userId) {
        this._restoreLastSession(userId);
      }
      this.userId = userId;
      if (this.sessionToken) {
        this._sessionTokenRestored();
      } else {
        this.xhr({
          url: '/nonces',
          method: 'POST',
          sync: false
        }, function (result) {
          return _this2._connectionResponse(result);
        });
      }
      return this;
    }

    /**
     * Initiates the connection with a session token.
     *
     * This call is for use when you have received a Session Token from some other source; such as your server,
     * and wish to use that instead of doing a full auth process.
     *
     * The Client will presume the token to be valid, and will asynchronously trigger the `ready` event.
     * If the token provided is NOT valid, this won't be detected until a request is made using this token,
     * at which point the `challenge` method will trigger.
     *
     * NOTE: The `connected` event will not be triggered on this path.
     *
     * @method connectWithSession
     * @param {String} userId
     * @param {String} sessionToken
     * @returns {layer.ClientAuthenticator} this
     */

  }, {
    key: 'connectWithSession',
    value: function connectWithSession(userId, sessionToken) {
      var _this3 = this;

      if (!userId || !sessionToken) throw new Error(LayerError.dictionary.sessionAndUserRequired);
      if (!this.isTrustedDevice || this._isPersistedSessionsDisabled() || this._hasUserIdChanged(userId)) {
        this._clearStoredData();
      }
      this.onlineManager.start();

      this.userId = userId;
      this.isConnected = true;
      setTimeout(function () {
        return _this3._authComplete({ session_token: sessionToken });
      }, 1);
    }

    /**
     * Called when our request for a nonce gets a response.
     *
     * If there is an error, calls _connectionError.
     *
     * If there is nonce, calls _connectionComplete.
     *
     * @method _connectionResponse
     * @private
     * @param  {Object} result
     */

  }, {
    key: '_connectionResponse',
    value: function _connectionResponse(result) {
      if (!result.success) {
        this._connectionError(result.data);
      } else {
        this._connectionComplete(result.data);
      }
    }

    /**
     * We are now connected (we have a nonce).
     *
     * If we have successfully retrieved a nonce, then
     * we have entered a "connected" but not "authenticated" state.
     * Set the state, trigger any events, and then start authentication.
     *
     * @method _connectionComplete
     * @private
     * @param  {Object} result
     * @param  {string} result.nonce - The nonce provided by the server
     *
     * @fires connected
     */

  }, {
    key: '_connectionComplete',
    value: function _connectionComplete(result) {
      this.isConnected = true;
      this.trigger('connected');
      this._authenticate(result.nonce);
    }

    /**
     * Called when we fail to get a nonce.
     *
     * @method _connectionError
     * @private
     * @param  {layer.LayerError} err
     *
     * @fires connected-error
     */

  }, {
    key: '_connectionError',
    value: function _connectionError(error) {
      this.trigger('connected-error', { error: error });
    }

    /* CONNECT METHODS END */

    /* AUTHENTICATE METHODS BEGIN */

    /**
     * Start the authentication step.
     *
     * We start authentication by triggering a "challenge" event that
     * tells the app to use the nonce to obtain an identity_token.
     *
     * @method _authenticate
     * @private
     * @param  {string} nonce - The nonce to provide your identity provider service
     *
     * @fires challenge
     */

  }, {
    key: '_authenticate',
    value: function _authenticate(nonce) {
      if (nonce) {
        this.trigger('challenge', {
          nonce: nonce,
          callback: this.answerAuthenticationChallenge.bind(this)
        });
      }
    }

    /**
     * Accept an identityToken and use it to create a session.
     *
     * Typically, this method is called using the function pointer provided by
     * the challenge event, but it can also be called directly.
     *
     *      getIdentityToken(nonce, function(identityToken) {
     *          client.answerAuthenticationChallenge(identityToken);
     *      });
     *
     * @method answerAuthenticationChallenge
     * @param  {string} identityToken - Identity token provided by your identity provider service
     */

  }, {
    key: 'answerAuthenticationChallenge',
    value: function answerAuthenticationChallenge(identityToken) {
      var _this4 = this;

      // Report an error if no identityToken provided
      if (!identityToken) {
        throw new Error(LayerError.dictionary.identityTokenMissing);
      } else {
        // Store the UserId and get a sessionToken; bypass the __adjustUserId connected test
        this.userId = JSON.parse(atob(identityToken.split('.')[1])).prn;
        this.xhr({
          url: '/sessions',
          method: 'POST',
          sync: false,
          data: {
            identity_token: identityToken,
            app_id: this.appId
          }
        }, function (result) {
          return _this4._authResponse(result, identityToken);
        });
      }
    }

    /**
     * Called when our request for a sessionToken receives a response.
     *
     * @private
     * @method _authResponse
     * @param  {Object} result
     * @param  {string} identityToken
     */

  }, {
    key: '_authResponse',
    value: function _authResponse(result, identityToken) {
      if (!result.success) {
        this._authError(result.data, identityToken);
      } else {
        this._authComplete(result.data);
      }
    }

    /**
     * Authentication is completed, update state and trigger events.
     *
     * @method _authComplete
     * @private
     * @param  {Object} result
     * @param  {string} result.session_token - Session token received from the server
     *
     * @fires authenticated
     */

  }, {
    key: '_authComplete',
    value: function _authComplete(result) {
      if (!result || !result.session_token) {
        throw new Error(LayerError.dictionary.sessionTokenMissing);
      }
      this.sessionToken = result.session_token;

      // NOTE: We store both items of data in a single key because someone listening for storage
      // events is listening for an asynchronous change, and we need to gaurentee that both
      // userId and session are available.
      if (!this._isPersistedSessionsDisabled()) {
        try {
          global.localStorage[LOCALSTORAGE_KEYS.SESSIONDATA + this.appId] = JSON.stringify({
            sessionToken: this.sessionToken || '',
            userId: this.userId || '',
            expires: Date.now() + 30 * 60 * 60 * 24
          });
        } catch (e) {
          // Do nothing
        }
      }

      this.isAuthenticated = true;
      this.trigger('authenticated');
      this._clientReady();
    }

    /**
     * Authentication has failed.
     *
     * @method _authError
     * @private
     * @param  {layer.LayerError} result
     * @param  {string} identityToken Not currently used
     *
     * @fires authenticated-error
     */

  }, {
    key: '_authError',
    value: function _authError(error, identityToken) {
      this.trigger('authenticated-error', { error: error });
    }

    /**
     * Sets state and triggers events for both connected and authenticated.
     *
     * If reusing a sessionToken cached in localStorage,
     * use this method rather than _authComplete.
     *
     * @method _sessionTokenRestored
     * @private
     *
     * @fires connected, authenticated
     */

  }, {
    key: '_sessionTokenRestored',
    value: function _sessionTokenRestored() {
      this.isConnected = true;
      this.trigger('connected');
      this.onlineManager.start();
      this.isAuthenticated = true;
      this.trigger('authenticated');
      this._clientReady();
    }

    /**
     * Called to flag the client as ready for action.
     *
     * This method is called after authenication AND
     * after initial conversations have been loaded.
     *
     * @method _clientReady
     * @private
     * @fires ready
     */

  }, {
    key: '_clientReady',
    value: function _clientReady() {
      if (!this.persistenceFeatures || !this.isTrustedDevice) {
        this.persistenceFeatures = {
          identity: this.isTrustedDevice,
          conversations: this.isTrustedDevice,
          messages: this.isTrustedDevice,
          syncQueue: this.isTrustedDevice,
          sessionToken: this.isTrustedDevice
        };
      }
      if (!this.dbManager) {
        this.dbManager = new DbManager({
          client: this,
          tables: this.persistenceFeatures
        });
      }

      if (!this.isReady) {
        this.isReady = true;
        this.trigger('ready');
        this.onlineManager.start();
      }
    }

    /* CONNECT METHODS END */

    /* START SESSION MANAGEMENT METHODS */

    /**
     * Deletes your sessionToken from the server, and removes all user data from the Client.
     * Call `client.login()` to restart the authentication process.
     *
     * @method logout
     * @return {layer.ClientAuthenticator} this
     */

  }, {
    key: 'logout',
    value: function logout() {
      if (this.isAuthenticated) {
        this.xhr({
          method: 'DELETE',
          url: '/sessions/' + escape(this.sessionToken)
        });
      }

      // Clear data even if isAuthenticated is false
      // Session may have expired, but data still cached.
      this._resetSession();
      this._clearStoredData();
      return this;
    }
  }, {
    key: '_clearStoredData',
    value: function _clearStoredData() {
      if (this.dbManager) this.dbManager.deleteTables();
      if (global.localStorage) localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
    }

    /**
     * Log out/clear session information.
     *
     * Use this to clear the sessionToken and all information from this session.
     *
     * @method _resetSession
     * @private
     * @returns {layer.ClientAuthenticator} this
     */

  }, {
    key: '_resetSession',
    value: function _resetSession() {
      this.isReady = false;
      if (this.sessionToken) {
        this.sessionToken = '';
        if (global.localStorage) {
          localStorage.removeItem(LOCALSTORAGE_KEYS.SESSIONDATA + this.appId);
        }
      }

      this.isConnected = false;
      this.isAuthenticated = false;

      this.trigger('deauthenticated');
      this.onlineManager.stop();
    }

    /**
     * Register your IOS device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method registerIOSPushToken
     * @param {Object} options
     * @param {string} options.deviceId - Your IOS device's device ID
     * @param {string} options.iosVersion - Your IOS device's version number
     * @param {string} options.token - Your Apple APNS Token
     * @param {string} [options.bundleId] - Your Apple APNS Bundle ID ("com.layer.bundleid")
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'registerIOSPushToken',
    value: function registerIOSPushToken(options, callback) {
      this.xhr({
        url: 'push_tokens',
        method: 'POST',
        sync: false,
        data: {
          token: options.token,
          type: 'apns',
          device_id: options.deviceId,
          ios_version: options.iosVersion,
          apns_bundle_id: options.bundleId
        }
      }, function (result) {
        return callback(result.data);
      });
    }

    /**
     * Register your Android device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method registerAndroidPushToken
     * @param {Object} options
     * @param {string} options.deviceId - Your IOS device's device ID
     * @param {string} options.token - Your GCM push Token
     * @param {string} options.senderId - Your GCM Sender ID/Project Number
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'registerAndroidPushToken',
    value: function registerAndroidPushToken(options, callback) {
      this.xhr({
        url: 'push_tokens',
        method: 'POST',
        sync: false,
        data: {
          token: options.token,
          type: 'gcm',
          device_id: options.deviceId,
          gcm_sender_id: options.senderId
        }
      }, function (result) {
        return callback(result.data);
      });
    }

    /**
     * Register your Android device to receive notifications.
     * For use with native code only (Cordova, React Native, Titanium, etc...)
     *
     * @method unregisterPushToken
     * @param {string} deviceId - Your IOS device's device ID
     * @param {Function} [callback=null] - Optional callback
     * @param {layer.LayerError} callback.error - LayerError if there was an error; null if successful
     */

  }, {
    key: 'unregisterPushToken',
    value: function unregisterPushToken(deviceId, callback) {
      this.xhr({
        url: 'push_tokens/' + deviceId,
        method: 'DELETE'
      }, function (result) {
        return callback(result.data);
      });
    }

    /* SESSION MANAGEMENT METHODS END */

    /* ACCESSOR METHODS BEGIN */

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.userAppId = 'xxx'` will cause an error to be thrown
     * if the client is already connected.
     *
     * @private
     * @method __adjustAppId
     * @param {string} value - New appId value
     */

  }, {
    key: '__adjustAppId',
    value: function __adjustAppId() {
      if (this.isConnected) throw new Error(LayerError.dictionary.cantChangeIfConnected);
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any attempt to execute `this.userId = 'xxx'` will cause an error to be thrown
     * if the client is already connected... unless setting it from scratch, or to the same value.
     *
     * @private
     * @method __adjustUserId
     * @param {string} value - New appId value
     */

  }, {
    key: '__adjustUserId',
    value: function __adjustUserId(userId) {
      if (this.isConnected && this.userId && this.userId !== userId || this.isAuthenticated) {
        throw new Error(LayerError.dictionary.cantChangeIfConnected);
      }
    }

    /* ACCESSOR METHODS END */

    /* COMMUNICATIONS METHODS BEGIN */

  }, {
    key: 'sendSocketRequest',
    value: function sendSocketRequest(params, callback) {
      if (params.sync) {
        var target = params.sync.target;
        var depends = params.sync.depends;
        if (target && !depends) depends = [target];

        this.syncManager.request(new WebsocketSyncEvent({
          data: params.body,
          operation: params.method,
          target: target,
          depends: depends,
          callback: callback
        }));
      } else {
        if (typeof params.data === 'function') params.data = params.data();
        this.socketRequestManager.sendRequest(params, callback);
      }
    }

    /**
     * This event handler receives events from the Online State Manager and generates an event for those subscribed
     * to client.on('online')
     *
     * @method _handleOnlineChange
     * @private
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_handleOnlineChange',
    value: function _handleOnlineChange(evt) {
      if (!this.isAuthenticated) return;
      var duration = evt.offlineDuration;
      var isOnline = evt.eventName === 'connected';
      var obj = { isOnline: isOnline };
      if (isOnline) {
        obj.reset = duration > ClientAuthenticator.ResetAfterOfflineDuration;
      }
      this.trigger('online', obj);
    }

    /**
     * Main entry point for sending xhr requests or for queing them in the syncManager.
     *
     * This call adjust arguments for our REST server.
     *
     * @method xhr
     * @protected
     * @param  {Object}   options
     * @param  {string}   options.url - URL relative client's url: "/conversations"
     * @param  {Function} callback
     * @param  {Object}   callback.result
     * @param  {Mixed}    callback.result.data - If an error occurred, this is a layer.LayerError;
     *                                          If the response was application/json, this will be an object
     *                                          If the response was text/empty, this will be text/empty
     * @param  {XMLHttpRequest} callback.result.xhr - Native xhr request object for detailed analysis
     * @param  {Object}         callback.result.Links - Hash of Link headers
     * @return {layer.ClientAuthenticator} this
     */

  }, {
    key: 'xhr',
    value: function xhr(options, callback) {
      if (!options.sync || !options.sync.target) {
        options.url = this._xhrFixRelativeUrls(options.url || '');
      }

      options.withCredentials = true;
      if (!options.method) options.method = 'GET';
      if (!options.headers) options.headers = {};
      this._xhrFixHeaders(options.headers);
      this._xhrFixAuth(options.headers);

      // Note: this is not sync vs async; this is syncManager vs fire it now
      if (options.sync === false) {
        this._nonsyncXhr(options, callback, 0);
      } else {
        this._syncXhr(options, callback);
      }
      return this;
    }
  }, {
    key: '_syncXhr',
    value: function _syncXhr(options, callback) {
      var _this5 = this;

      if (!options.sync) options.sync = {};
      var innerCallback = function innerCallback(result) {
        _this5._xhrResult(result, callback);
      };
      var target = options.sync.target;
      var depends = options.sync.depends;
      if (target && !depends) depends = [target];

      this.syncManager.request(new XHRSyncEvent({
        url: options.url,
        data: options.data,
        method: options.method,
        operation: options.sync.operation || options.method,
        headers: options.headers,
        callback: innerCallback,
        target: target,
        depends: depends
      }));
    }

    /**
     * For xhr calls that don't go through the sync manager,
     * fire the request, and if it fails, refire it up to 3 tries
     * before reporting an error.  1 second delay between requests
     * so whatever issue is occuring is a tiny bit more likely to resolve,
     * and so we don't hammer the server every time there's a problem.
     *
     * @method _nonsyncXhr
     * @param  {Object}   options
     * @param  {Function} callback
     * @param  {number}   retryCount
     */

  }, {
    key: '_nonsyncXhr',
    value: function _nonsyncXhr(options, callback, retryCount) {
      var _this6 = this;

      xhr(options, function (result) {
        if ([502, 503, 504].indexOf(result.status) !== -1 && retryCount < MAX_XHR_RETRIES) {
          setTimeout(function () {
            return _this6._nonsyncXhr(options, callback, retryCount + 1);
          }, 1000);
        } else {
          _this6._xhrResult(result, callback);
        }
      });
    }

    /**
     * Fix authentication header for an xhr request
     *
     * @method _xhrFixAuth
     * @private
     * @param  {Object} headers
     */

  }, {
    key: '_xhrFixAuth',
    value: function _xhrFixAuth(headers) {
      if (this.sessionToken && !headers.Authorization) {
        headers.authorization = 'Layer session-token="' + this.sessionToken + '"'; // eslint-disable-line
      }
    }

    /**
     * Fix relative URLs to create absolute URLs needed for CORS requests.
     *
     * @method _xhrFixRelativeUrls
     * @private
     * @param  {string} relative or absolute url
     * @return {string} absolute url
     */

  }, {
    key: '_xhrFixRelativeUrls',
    value: function _xhrFixRelativeUrls(url) {
      var result = url;
      if (url.indexOf('https://') === -1) {
        if (url[0] === '/') {
          result = this.url + url;
        } else {
          result = this.url + '/' + url;
        }
      }
      return result;
    }

    /**
     * Fixup all headers in preparation for an xhr call.
     *
     * 1. All headers use lower case names for standard/easy lookup
     * 2. Set the accept header
     * 3. If needed, set the content-type header
     *
     * @method _xhrFixHeaders
     * @private
     * @param  {Object} headers
     */

  }, {
    key: '_xhrFixHeaders',
    value: function _xhrFixHeaders(headers) {
      // Replace all headers in arbitrary case with all lower case
      // for easy matching.
      var headerNameList = Object.keys(headers);
      headerNameList.forEach(function (headerName) {
        if (headerName !== headerName.toLowerCase()) {
          headers[headerName.toLowerCase()] = headers[headerName];
          delete headers[headerName];
        }
      });

      if (!headers.accept) headers.accept = ACCEPT;

      if (!headers['content-type']) headers['content-type'] = 'application/json';
    }

    /**
     * Handle the result of an xhr call
     *
     * @method _xhrResult
     * @private
     * @param  {Object}   result     Standard xhr response object from the xhr lib
     * @param  {Function} [callback] Callback on completion
     */

  }, {
    key: '_xhrResult',
    value: function _xhrResult(result, callback) {
      if (this.isDestroyed) return;

      if (!result.success) {
        // Replace the response with a LayerError instance
        if (result.data && _typeof(result.data) === 'object') {
          this._generateError(result);
        }

        // If its an authentication error, reauthenticate
        // don't call _resetSession as that wipes all data and screws with UIs, and the user
        // is still authenticated on the customer's app even if not on Layer.
        if (result.status === 401 && this.isAuthenticated) {
          logger.warn('SESSION EXPIRED!');
          this.isAuthenticated = false;
          this.trigger('deauthenticated');
          this._authenticate(result.data.getNonce());
        }
      }
      if (callback) callback(result);
    }

    /**
     * Transforms xhr error response into a layer.LayerError instance.
     *
     * Adds additional information to the result object including
     *
     * * url
     * * data
     *
     * @method _generateError
     * @private
     * @param  {Object} result - Result of the xhr call
     */

  }, {
    key: '_generateError',
    value: function _generateError(result) {
      result.data = new LayerError(result.data);
      if (!result.data.httpStatus) result.data.httpStatus = result.status;
      result.data.log();
    }

    /* END COMMUNICATIONS METHODS */

  }]);

  return ClientAuthenticator;
}(Root);

/**
 * State variable; indicates that client is currently authenticated by the server.
 * Should never be true if isConnected is false.
 * @type {Boolean}
 */


ClientAuthenticator.prototype.isAuthenticated = false;

/**
 * State variable; indicates that client is currently connected to server
 * (may not be authenticated yet)
 * @type {Boolean}
 */
ClientAuthenticator.prototype.isConnected = false;

/**
 * State variable; indicates that client is ready for the app to use.
 * Use the 'ready' event to be notified when this value changes to true.
 *
 * @type {boolean}
 */
ClientAuthenticator.prototype.isReady = false;

/**
 * Your Layer Application ID. This value can not be changed once connected.
 * To find your Layer Application ID, see your Layer Developer Dashboard.
 * @type {String}
 */
ClientAuthenticator.prototype.appId = '';

/**
 * You can use this to find the userId you are logged in as.
 * You can set this in the constructor to verify that the client
 * will only restore a session if that session belonged to that same userId.
 * @type {String}
 */
ClientAuthenticator.prototype.userId = '';

/**
 * Your current session token that authenticates your requests.
 * @type {String}
 */
ClientAuthenticator.prototype.sessionToken = '';

/**
 * URL to Layer's Web API server.
 * @type {String}
 */
ClientAuthenticator.prototype.url = 'https://api.layer.com';

/**
 * Web Socket Manager
 * @type {layer.Websockets.SocketManager}
 */
ClientAuthenticator.prototype.socketManager = null;

/**
 * Web Socket Request Manager
* @type {layer.Websockets.RequestManager}
 */
ClientAuthenticator.prototype.socketRequestManager = null;

/**
 * Web Socket Manager
 * @type {layer.Websockets.ChangeManager}
 */
ClientAuthenticator.prototype.socketChangeManager = null;

/**
 * Service for managing online as well as offline server requests
 * @type {layer.SyncManager}
 */
ClientAuthenticator.prototype.syncManager = null;

/**
 * Service for managing online/offline state and events
 * @type {layer.OnlineStateManager}
 */
ClientAuthenticator.prototype.onlineManager = null;

/**
 * If this is a trusted device, then we can write personal data to persistent memory.
 * @type {boolean}
 */
ClientAuthenticator.prototype.isTrustedDevice = false;

/**
 * If this layer.Client.isTrustedDevice is true, then you can control which types of data are persisted.
 *
 * Properties of this Object can be:
 *
 * * identities: Write identities to indexedDB? This allows for faster initialization.
 * * conversations: Write conversations to indexedDB? This allows for faster rendering
 *                  of a Conversation List
 * * messages: Write messages to indexedDB? This allows for full offline access
 * * syncQueue: Write requests made while offline to indexedDB?  This allows the app
 *              to complete sending messages after being relaunched.
 * * sessionToken: Write the session token to localStorage for quick reauthentication on relaunching the app.
 *
 *      new layer.Client({
 *        isTrustedDevice: true,
 *        persistenceFeatures: {
 *          conversations: true,
 *          identities: true,
 *          messages: false,
 *          syncQueue: false,
 *          sessionToken: true
 *        }
 *      });
 *
 * @type {object}
 */
ClientAuthenticator.prototype.persistenceFeatures = null;

/**
 * Database Manager for read/write to IndexedDB
 * @type {layer.DbManager}
 */
ClientAuthenticator.prototype.dbManager = null;

/**
 * Unique identifier for the client.
 *
 * This ID is used to differentiate this instance with instances that may run in other tabs of the browser.
 */
ClientAuthenticator.prototype.id = '';

/**
 * Is true if the client is authenticated and connected to the server;
 *
 * Typically used to determine if there is a connection to the server.
 *
 * Typically used in conjunction with the `online` event.
 *
 * @type {boolean}
 */
Object.defineProperty(ClientAuthenticator.prototype, 'isOnline', {
  enumerable: true,
  get: function get() {
    return this.onlineManager && this.onlineManager.isOnline;
  }
});

/**
 * Log levels; one of:
 *
 *    * layer.Constants.LOG.NONE
 *    * layer.Constants.LOG.ERROR
 *    * layer.Constants.LOG.WARN
 *    * layer.Constants.LOG.INFO
 *    * layer.Constants.LOG.DEBUG
 *
 * @type {number}
 */
Object.defineProperty(ClientAuthenticator.prototype, 'logLevel', {
  enumerable: false,
  get: function get() {
    return logger.level;
  },
  set: function set(value) {
    logger.level = value;
  }
});

/**
 * Time to be offline after which we don't do a WebSocket Events.replay,
 * but instead just refresh all our Query data.  Defaults to 30 hours.
 *
 * @type {number}
 * @static
 */
ClientAuthenticator.ResetAfterOfflineDuration = 1000 * 60 * 60 * 30;

/**
 * List of events supported by this class
 * @static
 * @protected
 * @type {string[]}
 */
ClientAuthenticator._supportedEvents = [
/**
 * The client is ready for action
 *
 *      client.on('ready', function(evt) {
 *          renderMyUI();
 *      });
 *
 * @event
 */
'ready',

/**
 * Fired when connected to the server.
 * Currently just means we have a nonce.
 * Not recommended for typical applications.
 * @event connected
 */
'connected',

/**
 * Fired when unsuccessful in obtaining a nonce
 * Not recommended for typical applications.
 * @event connected-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
'connected-error',

/**
 * We now have a session and any requests we send aught to work.
 * Typically you should use the ready event instead of the authenticated event.
 * @event authenticated
 */
'authenticated',

/**
 * Failed to authenticate your client.
 *
 * Either your identity-token was invalid, or something went wrong
 * using your identity-token.
 *
 * @event authenticated-error
 * @param {Object} event
 * @param {layer.LayerError} event.error
 */
'authenticated-error',

/**
 * This event fires when a session has expired or when `layer.Client.logout` is called.
 * Typically, it is enough to subscribe to the challenge event
 * which will let you reauthenticate; typical applications do not need
 * to subscribe to this.
 *
 * @event deauthenticated
 */
'deauthenticated',

/**
 * @event challenge
 * Verify the user's identity.
 *
 * This event is where you verify that the user is who we all think the user is,
 * and provide an identity token to validate that.
 *
 * @param {Object} event
 * @param {string} event.nonce - A nonce for you to provide to your identity provider
 * @param {Function} event.callback - Call this once you have an identity-token
 * @param {string} event.callback.identityToken - Identity token provided by your identity provider service
 */
'challenge',

/**
 * @event session-terminated
 * If your session has been terminated in such a way as to prevent automatic reconnect,
 *
 * this event will fire.  Common scenario: user has two tabs open;
 * one tab the user logs out (or you call client.logout()).
 * The other tab will detect that the sessionToken has been removed,
 * and will terminate its session as well.  In this scenario we do not want
 * to automatically trigger a challenge and restart the login process.
 */
'session-terminated',

/**
 * @event online
 *
 * This event is used to detect when the client is online (connected to the server)
 * or offline (still able to accept API calls but no longer able to sync to the server).
 *
 *      client.on('online', function(evt) {
 *         if (evt.isOnline) {
 *             statusDiv.style.backgroundColor = 'green';
 *         } else {
 *             statusDiv.style.backgroundColor = 'red';
 *         }
 *      });
 *
 * @param {Object} event
 * @param {boolean} event.isOnline
 */
'online'].concat(Root._supportedEvents);

Root.initClass.apply(ClientAuthenticator, [ClientAuthenticator, 'ClientAuthenticator']);

module.exports = ClientAuthenticator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./const":12,"./db-manager":15,"./layer-error":16,"./logger":18,"./online-state-manager":21,"./root":24,"./sync-event":25,"./sync-manager":26,"./websockets/change-manager":33,"./websockets/request-manager":34,"./websockets/socket-manager":35,"./xhr":36,"atob":3}],9:[function(require,module,exports){
"use strict";

/**
 * Allows all components to have a clientId instead of a client pointer.
 * Allows an app to have multiple Clients, each with its own appId.
 * Provides a global utility that can be required by all modules for accessing
 * the client.
 *
 * @class  layer.ClientRegistry
 * @private
 */

var registry = {};

/**
 * Register a new Client; will destroy any previous client with the same appId.
 *
 * @method register
 * @param  {layer.Client} client
 */
function register(client) {
  var appId = client.appId;
  if (registry[appId] && !registry[appId].isDestroyed) {
    registry[appId].destroy();
  }
  registry[appId] = client;
}

/**
 * Removes a Client.
 *
 * @method unregister
 * @param  {layer.Client} client
 */
function unregister(client) {
  if (registry[client.appId]) delete registry[client.appId];
}

/**
 * Get a Client by appId
 *
 * @method get
 * @param  {string} appId
 * @return {layer.Client}
 */
function get(appId) {
  return registry[appId];
}

function getAll() {
  return Object.keys(registry).map(function (key) {
    return registry[key];
  });
}

module.exports = {
  get: get,
  getAll: getAll,
  register: register,
  unregister: unregister
};

},{}],10:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/**
 * Utility methods
 *
 * @class layer.ClientUtils
 */

var LayerParser = require('layer-patch');
var uuid = require('uuid');

/**
 * Generate a random UUID
 *
 * @method
 * @return {string}
 */
exports.generateUUID = uuid.v4;

/**
 * Returns the 'type' portion of a Layer ID.
 *
 *         switch(Utils.typeFromID(id)) {
 *             case 'conversations':
 *                 ...
 *             case 'message':
 *                 ...
 *             case: 'queries':
 *                 ...
 *         }
 *
 * Does not currently handle Layer App IDs.
 *
 * @method
 * @param  {string} id
 * @return {string}
 */
exports.typeFromID = function (id) {
  var matches = id.match(/layer\:\/\/\/(.*?)\//);
  return matches ? matches[1] : '';
};

exports.isEmpty = function (obj) {
  return Object.prototype.toString.apply(obj) === '[object Object]' && Object.keys(obj).length === 0;
};

/**
 * Simplified sort method.
 *
 * Provides a function to return the value to compare rather than do the comparison.
 *
 *      sortBy([{v: 3}, {v: 1}, v: 33}], function(value) {
 *          return value.v;
 *      }, false);
 *
 * @method
 * @param  {Mixed[]}   inArray      Array to sort
 * @param  {Function} fn            Function that will return a value to compare
 * @param  {Function} fn.value      Current value from inArray we are comparing, and from which a value should be extracted
 * @param  {boolean}  [reverse=false] Sort ascending (false) or descending (true)
 */
exports.sortBy = function (inArray, fn, reverse) {
  reverse = reverse ? -1 : 1;
  inArray.sort(function (valueA, valueB) {
    var aa = fn(valueA);
    var bb = fn(valueB);
    if (aa === undefined && bb === undefined) return 0;
    if (aa === undefined && bb !== undefined) return 1;
    if (aa !== undefined && bb === undefined) return -1;
    if (aa > bb) return 1 * reverse;
    if (aa < bb) return -1 * reverse;
    return 0;
  });
};

/**
 * Quick and easy clone method.
 *
 * Does not work on circular references; should not be used
 * on objects with event listeners.
 *
 *      var newObj = Utils.clone(oldObj);
 *
 * @method
 * @param  {Object}     Object to clone
 * @return {Object}     New Object
 */
exports.clone = function (obj) {
  return JSON.parse(JSON.stringify(obj));
};

/**
 * Execute this function asynchronously.
 *
 * Defer will use SOME technique to delay execution of your function.
 * Defer() is intended for anything that should be processed after current execution has
 * completed, even if that means 0ms delay.
 *
 *      defer(function() {alert('That wasn't very long now was it!');});
 *
 * TODO: WEB-842: Add a postMessage handler.
 *
 * @method
 * @param  {Function} f
 */
exports.defer = function (func) {
  return setTimeout(func, 0);
};

/**
 * Returns a delay in seconds needed to follow an exponential
 * backoff pattern of delays for retrying a connection.
 *
 * Algorithm has two motivations:
 *
 * 1. Retry with increasingly long intervals up to some maximum interval
 * 2. Randomize the retry interval enough so that a thousand clients
 * all following the same algorithm at the same time will not hit the
 * server at the exact same times.
 *
 * The following are results before jitter for some values of counter:

      0: 0.1
      1: 0.2
      2: 0.4
      3: 0.8
      4: 1.6
      5: 3.2
      6: 6.4
      7: 12.8
      8: 25.6
      9: 51.2
      10: 102.4
      11. 204.8
      12. 409.6
      13. 819.2
      14. 1638.4 (27 minutes)

 * @method getExponentialBackoffSeconds
 * @param  {number} maxSeconds - This is not the maximum seconds delay, but rather
 * the maximum seconds delay BEFORE adding a randomized value.
 * @param  {number} counter - Current counter to use for calculating the delay; should be incremented up to some reasonable maximum value for each use.
 * @return {number}     Delay in seconds/fractions of a second
 */
exports.getExponentialBackoffSeconds = function getExponentialBackoffSeconds(maxSeconds, counter) {
  var secondsWaitTime = Math.pow(2, counter) / 10,
      secondsOffset = Math.random(); // value between 0-1 seconds.
  if (counter < 2) secondsOffset = secondsOffset / 4; // values less than 0.2 should be offset by 0-0.25 seconds
  else if (counter < 6) secondsOffset = secondsOffset / 2; // values between 0.2 and 1.0 should be offset by 0-0.5 seconds

  if (secondsWaitTime >= maxSeconds) secondsWaitTime = maxSeconds;

  return secondsWaitTime + secondsOffset;
};

var parser = undefined;

/**
 * Creates a LayerParser
 *
 * @method
 * @private
 * @param {Object} request - see layer.ClientUtils.layerParse
 */
function createParser(request) {
  request.client.once('destroy', function () {
    return parser = null;
  });

  parser = new LayerParser({
    camelCase: true,
    getObjectCallback: function getObjectCallback(id) {
      return request.client._getObject(id);
    },
    propertyNameMap: {
      Conversation: {
        unreadMessageCount: 'unreadCount'
      }
    },
    changeCallbacks: {
      Message: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      },
      Conversation: {
        all: function all(updateObject, newValue, oldValue, paths) {
          updateObject._handlePatchEvent(newValue, oldValue, paths);
        }
      }
    }
  });
}

/**
 * Run the Layer Parser on the request.
 *
 * Parameters here
 * are the parameters specied in [Layer-Patch](https://github.com/layerhq/node-layer-patch), plus
 * a client object.
 *
 *      Util.layerParse({
 *          object: conversation,
 *          type: 'Conversation',
 *          operations: layerPatchOperations,
 *          client: client
 *      });
 *
 * @method
 * @param {Object} request - layer-patch parameters
 * @param {Object} request.object - Object being updated  by the operations
 * @param {string} request.type - Type of object being updated
 * @param {Object[]} request.operations - Array of change operations to perform upon the object
 * @param {layer.Client} request.client
 */
exports.layerParse = function (request) {
  if (!parser) createParser(request);
  parser.parse(request);
};

/**
 * Object comparison.
 *
 * Does a recursive traversal of two objects verifying that they are the same.
 * Is able to make metadata-restricted assumptions such as that
 * all values are either plain Objects or strings.
 *
 *      if (Utils.doesObjectMatch(conv1.metadata, conv2.metadata)) {
 *          alert('These two metadata objects are the same');
 *      }
 *
 * @method
 * @param  {Object} requestedData
 * @param  {Object} actualData
 * @return {boolean}
 */
exports.doesObjectMatch = function (requestedData, actualData) {
  if (!requestedData && actualData || requestedData && !actualData) return false;
  var requestedKeys = Object.keys(requestedData).sort();
  var actualKeys = Object.keys(actualData).sort();

  // If there are a different number of keys, fail.
  if (requestedKeys.length !== actualKeys.length) return false;

  // Compare key name and value at each index
  for (var index = 0; index < requestedKeys.length; index++) {
    var k1 = requestedKeys[index];
    var k2 = actualKeys[index];
    var v1 = requestedData[k1];
    var v2 = actualData[k2];
    if (k1 !== k2) return false;
    if (v1 && (typeof v1 === 'undefined' ? 'undefined' : _typeof(v1)) === 'object') {
      // Array comparison is not used by the Web SDK at this time.
      if (Array.isArray(v1)) {
        throw new Error('Array comparison not handled yet');
      } else if (!exports.doesObjectMatch(v1, v2)) {
        return false;
      }
    } else if (v1 !== v2) {
      return false;
    }
  }
  return true;
};

/**
 * Simple array inclusion test
 * @method includes
 * @param {Mixed[]} items
 * @param {Mixed} value
 * @returns {boolean}
 */
exports.includes = function (items, value) {
  return items.indexOf(value) !== -1;
};

},{"layer-patch":4,"uuid":6}],11:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Layer Client; this is the top level component for any Layer based application.

    var client = new layer.Client({
      appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff',
      userId: 'Fred',
      challenge: function(evt) {
        myAuthenticator({
          nonce: evt.nonce,
          onSuccess: evt.callback
        });
      },
      ready: function(client) {
        alert('I am Client; Server: Serve me!');
      }
    });
 *
 * You can also initialize this as

    var client = new layer.Client({
      appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff',
      userId: 'Fred'
    });

    client.on('challenge', function(evt) {
      myAuthenticator({
        nonce: evt.nonce,
        onSuccess: evt.callback
      });
    });

    client.on('ready', function(client) {
      alert('I am Client; Server: Serve me!');
    });
 *
 * ## API Synopsis:
 *
 * The following Properties, Methods and Events are the most commonly used ones.  See the full API below
 * for the rest of the API.
 *
 * ### Properties:
 *
 * * layer.Client.userId: User ID of the authenticated user
 * * layer.Client.appId: The ID for your application
 *
 *
 * ### Methods:
 *
 * * layer.Client.createConversation(): Create a new layer.Conversation.
 * * layer.Client.createQuery(): Create a new layer.Query.
 * * layer.Client.getMessage(): Input a Message ID, and output a Message from cache.
 * * layer.Client.getConversation(): Input a Conversation ID, and output a Conversation from cache.
 * * layer.Client.on() and layer.Conversation.off(): event listeners
 * * layer.Client.destroy(): Cleanup all resources used by this client, including all Messages and Conversations.
 *
 * ### Events:
 *
 * * `challenge`: Provides a nonce and a callback; you call the callback once you have an Identity Token.
 * * `ready`: Your application can now start using the Layer services
 * * `messages:notify`: Used to notify your application of new messages for which a local notification may be suitable.
 *
 * ## Logging:
 *
 * There are two ways to change the log level for Layer's logger:
 *
 *     layer.Client.prototype.logLevel = layer.Constants.LOG.INFO;
 *
 * or
 *
 *     var client = new layer.Client({
 *        appId: 'layer:///apps/staging/ffffffff-ffff-ffff-ffff-ffffffffffff',
 *        userId: 'Fred',
 *        logLevel: layer.Constants.LOG.INFO
 *     });
 *
 * @class  layer.Client
 * @extends layer.ClientAuthenticator
 *
 */

var ClientAuth = require('./client-authenticator');
var Conversation = require('./conversation');
var Query = require('./query');
var LayerError = require('./layer-error');
var Syncable = require('./syncable');
var Message = require('./message');
var Announcement = require('./announcement');
var User = require('./user');
var TypingIndicatorListener = require('./typing-indicators/typing-indicator-listener');
var Util = require('./client-utils');
var Root = require('./root');
var ClientRegistry = require('./client-registry');
var logger = require('./logger');

var Client = function (_ClientAuth) {
  _inherits(Client, _ClientAuth);

  /*
   * Adds conversations, messages and websockets on top of the authentication client.
   * jsdocs on parent class constructor.
   */

  function Client(options) {
    _classCallCheck(this, Client);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Client).call(this, options));

    ClientRegistry.register(_this);

    // Initialize Properties
    _this._conversationsHash = {};
    _this._messagesHash = {};
    _this._queriesHash = {};
    _this._scheduleCheckAndPurgeCacheItems = [];

    if (!options.users) {
      _this.users = [];
    } else {
      _this.__updateUsers(_this.users);
    }

    _this._initComponents();

    _this.on('online', _this._connectionRestored.bind(_this));
    return _this;
  }

  /* See parent method docs */


  _createClass(Client, [{
    key: '_initComponents',
    value: function _initComponents() {
      var _this2 = this;

      _get(Object.getPrototypeOf(Client.prototype), '_initComponents', this).call(this);

      this._typingIndicators = new TypingIndicatorListener({
        clientId: this.appId
      });

      // Instantiate Plugins
      Object.keys(Client.plugins).forEach(function (propertyName) {
        _this2[propertyName] = new Client.plugins[propertyName](_this2);
      });
    }

    /**
     * Cleanup all resources (Conversations, Messages, etc...) prior to destroy or reauthentication.
     *
     * @method _cleanup
     * @private
     */

  }, {
    key: '_cleanup',
    value: function _cleanup() {
      var _this3 = this;

      if (this.isDestroyed) return;
      this._inCleanup = true;

      Object.keys(this._conversationsHash).forEach(function (id) {
        var c = _this3._conversationsHash[id];
        if (c && !c.isDestroyed) {
          c.destroy();
        }
      });
      this._conversationsHash = null;

      Object.keys(this._messagesHash).forEach(function (id) {
        var m = _this3._messagesHash[id];
        if (m && !m.isDestroyed) {
          m.destroy();
        }
      });
      this._messagesHash = null;

      Object.keys(this._queriesHash).forEach(function (id) {
        _this3._queriesHash[id].destroy();
      });
      this._queriesHash = null;
      if (this.users) [].concat(this.users).forEach(function (user) {
        return user.destroy ? user.destroy() : null;
      });

      // Ideally we'd set it to null, but _adjustUsers would make it []
      this.users = [];

      if (this.socketManager) this.socketManager.close();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this4 = this;

      // Cleanup all plugins
      Object.keys(Client.plugins).forEach(function (propertyName) {
        if (_this4[propertyName]) {
          _this4[propertyName].destroy();
          delete _this4[propertyName];
        }
      });

      // Cleanup all resources (Conversations, Messages, etc...)
      this._cleanup();

      this._destroyComponents();

      ClientRegistry.unregister(this);

      _get(Object.getPrototypeOf(Client.prototype), 'destroy', this).call(this);
      this._inCleanup = false;
    }

    /**
     * Retrieve a conversation by Identifier.
     *
     *      var c = client.getConversation('layer:///conversations/uuid');
     *
     * If there is not a conversation with that id, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Conversation instance that has no data; the conversations:loaded/conversations:loaded-error events
     * will let you know when the conversation has finished/failed loading from the server.
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          // Render the Conversation with all of its details loaded
     *          myrerender(c);
     *      });
     *      // Render a placeholder for c until the details of c have loaded
     *      myrender(c);
     *
     * @method getConversation
     * @param  {string} id
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a conversation from
     *                                    the server if not found
     * @return {layer.Conversation}
     */

  }, {
    key: 'getConversation',
    value: function getConversation(id, canLoad) {
      if (typeof id !== 'string') throw new Error(LayerError.dictionary.idParamRequired);
      if (this._conversationsHash[id]) {
        return this._conversationsHash[id];
      } else if (canLoad) {
        return Conversation.load(id, this);
      }
    }

    /**
     * Adds a conversation to the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _addConversation for you:
     *
     *      var conv = new layer.Conversation({
     *          client: client,
     *          participants: ['a', 'b']
     *      });
     *
     *      // OR:
     *      var conv = client.createConversation(['a', 'b']);
     *
     * @method _addConversation
     * @protected
     * @param  {layer.Conversation} c
     * @returns {layer.Client} this
     */

  }, {
    key: '_addConversation',
    value: function _addConversation(conversation) {
      var id = conversation.id;
      if (!this._conversationsHash[id]) {
        // Register the Conversation
        this._conversationsHash[id] = conversation;

        // Make sure the client is set so that the next event bubbles up
        if (conversation.clientId !== this.appId) conversation.clientId = this.appId;
        this._triggerAsync('conversations:add', { conversations: [conversation] });

        this._scheduleCheckAndPurgeCache(conversation);
      }
      return this;
    }

    /**
     * Removes a conversation from the client.
     *
     * Typically, you do not need to call this; the following code
     * automatically calls _removeConversation for you:
     *
     *      converation.destroy();
     *
     * @method _removeConversation
     * @protected
     * @param  {layer.Conversation} c
     * @returns {layer.Client} this
     */

  }, {
    key: '_removeConversation',
    value: function _removeConversation(conversation) {
      var _this5 = this;

      // Insure we do not get any events, such as message:remove
      conversation.off(null, null, this);

      if (this._conversationsHash[conversation.id]) {
        delete this._conversationsHash[conversation.id];
        this._triggerAsync('conversations:remove', { conversations: [conversation] });
      }

      // Remove any Message associated with this Conversation
      Object.keys(this._messagesHash).forEach(function (id) {
        if (_this5._messagesHash[id].conversationId === conversation.id) {
          _this5._messagesHash[id].destroy();
        }
      });

      return this;
    }

    /**
     * If the Conversation ID changes, we need to reregister the Conversation
     *
     * @method _updateConversationId
     * @protected
     * @param  {layer.Conversation} conversation - Conversation whose ID has changed
     * @param  {string} oldId - Previous ID
     */

  }, {
    key: '_updateConversationId',
    value: function _updateConversationId(conversation, oldId) {
      var _this6 = this;

      if (this._conversationsHash[oldId]) {
        this._conversationsHash[conversation.id] = conversation;
        delete this._conversationsHash[oldId];

        // This is a nasty way to work... but need to find and update all
        // conversationId properties of all Messages or the Query's won't
        // see these as matching the query.
        Object.keys(this._messagesHash).filter(function (id) {
          return _this6._messagesHash[id].conversationId === oldId;
        }).forEach(function (id) {
          return _this6._messagesHash[id].conversationId = conversation.id;
        });
      }
    }

    /**
     * Retrieve the message or announcement id.
     *
     * Useful for finding a message when you have only the ID.
     *
     * If the message is not found, it will return null.
     *
     * If you want it to load it from cache and then from server if not in cache, use the `canLoad` parameter.
     * If loading from the server, the method will return
     * a layer.Message instance that has no data; the messages:loaded/messages:loaded-error events
     * will let you know when the message has finished/failed loading from the server.
     *
     *      var m = client.getMessage('layer:///messages/123', true)
     *      .on('messages:loaded', function() {
     *          // Render the Message with all of its details loaded
     *          myrerender(m);
     *      });
     *      // Render a placeholder for m until the details of m have loaded
     *      myrender(m);
     *
     *
     * @method getMessage
     * @param  {string} id              - layer:///messages/uuid
     * @param  {boolean} [canLoad=false] - Pass true to allow loading a message from the server if not found
     * @return {layer.Message}
     */

  }, {
    key: 'getMessage',
    value: function getMessage(id, canLoad) {
      if (typeof id !== 'string') throw new Error(LayerError.dictionary.idParamRequired);

      if (this._messagesHash[id]) {
        return this._messagesHash[id];
      } else if (canLoad) {
        return Syncable.load(id, this);
      }
    }

    /**
     * Get a MessagePart by ID
     * @method getMessagePart
     * @param {String} id - ID of the Message Part; layer:///messages/uuid/parts/5
     */

  }, {
    key: 'getMessagePart',
    value: function getMessagePart(id) {
      if (typeof id !== 'string') throw new Error(LayerError.dictionary.idParamRequired);

      var messageId = id.replace(/\/parts.*$/, '');
      var message = this.getMessage(messageId);
      if (message) return message.getPartById(id);
    }

    /**
     * Registers a message in _messagesHash and triggers events.
     *
     * May also update Conversation.lastMessage.
     *
     * @method _addMessage
     * @protected
     * @param  {layer.Message} message
     */

  }, {
    key: '_addMessage',
    value: function _addMessage(message) {
      if (!this._messagesHash[message.id]) {
        this._messagesHash[message.id] = message;
        this._triggerAsync('messages:add', { messages: [message] });
        if (message._notify) {
          this._triggerAsync('messages:notify', { message: message });
          message._notify = false;
        }

        var conversation = message.getConversation(false);
        if (conversation && (!conversation.lastMessage || conversation.lastMessage.position < message.position)) {
          var lastMessageWas = conversation.lastMessage;
          conversation.lastMessage = message;
          if (lastMessageWas) this._scheduleCheckAndPurgeCache(lastMessageWas);
        } else {
          this._scheduleCheckAndPurgeCache(message);
        }
      }
    }

    /**
     * Removes message from _messagesHash.
     *
     * Accepts IDs or Message instances
     *
     * TODO: Remove support for remove by ID
     *
     * @method _removeMessage
     * @private
     * @param  {layer.Message|string} message or Message ID
     */

  }, {
    key: '_removeMessage',
    value: function _removeMessage(message) {
      var id = typeof message === 'string' ? message : message.id;
      message = this._messagesHash[id];
      if (message) {
        delete this._messagesHash[id];
        if (!this._inCleanup) {
          this._triggerAsync('messages:remove', { messages: [message] });
          var conv = message.getConversation(false);
          if (conv && conv.lastMessage === message) conv.lastMessage = null;
        }
      }
    }

    /**
     * Handles delete from position event from Websocket.
     *
     * A WebSocket may deliver a `delete` Conversation event with a
     * from_position field indicating that all Messages at the specified position
     * and earlier should be deleted.
     *
     * @method _purgeMessagesByPosition
     * @private
     * @param {string} conversationId
     * @param {number} fromPosition
     */

  }, {
    key: '_purgeMessagesByPosition',
    value: function _purgeMessagesByPosition(conversationId, fromPosition) {
      var _this7 = this;

      Object.keys(this._messagesHash).forEach(function (mId) {
        var message = _this7._messagesHash[mId];
        if (message.conversationId === conversationId && message.position <= fromPosition) {
          message.destroy();
        }
      });
    }

    /**
     * Takes as input an object id, and either calls getConversation() or getMessage() as needed.
     *
     * Will only get cached objects, will not get objects from the server.
     *
     * This is not a public method mostly so there's no ambiguity over using getXXX
     * or _getObject.  getXXX typically has an option to load the resource, which this
     * does not.
     *
     * @method _getObject
     * @protected
     * @param  {string} id - Message, Conversation or Query id
     * @return {layer.Message|layer.Conversation|layer.Query}
     */

  }, {
    key: '_getObject',
    value: function _getObject(id) {
      switch (Util.typeFromID(id)) {
        case 'messages':
        case 'announcements':
          return this.getMessage(id);
        case 'conversations':
          return this.getConversation(id);
        case 'queries':
          return this.getQuery(id);
      }
    }

    /**
     * Takes an object description from the server and either updates it (if cached)
     * or creates and caches it .
     *
     * @method _createObject
     * @protected
     * @param  {Object} obj - Plain javascript object representing a Message or Conversation
     */

  }, {
    key: '_createObject',
    value: function _createObject(obj) {
      var item = this._getObject(obj.id);
      if (item) {
        item._populateFromServer(obj);
        return item;
      } else {
        // TODO: Factory method in Syncable class?
        switch (Util.typeFromID(obj.id)) {
          case 'messages':
            return Message._createFromServer(obj, this);

          case 'announcements':
            return Announcement._createFromServer(obj, this);

          case 'conversations':
            return Conversation._createFromServer(obj, this);
        }
      }
    }

    /**
     * Merge events into smaller numbers of more complete events.
     *
     * Before any delayed triggers are fired, fold together all of the conversations:add
     * and conversations:remove events so that 100 conversations:add events can be fired as
     * a single event.
     *
     * @method _processDelayedTriggers
     * @private
     */

  }, {
    key: '_processDelayedTriggers',
    value: function _processDelayedTriggers() {
      if (this.isDestroyed) return;

      var addConversations = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'conversations:add';
      });
      var removeConversations = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'conversations:remove';
      });
      this._foldEvents(addConversations, 'conversations', this);
      this._foldEvents(removeConversations, 'conversations', this);

      var addMessages = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'messages:add';
      });
      var removeMessages = this._delayedTriggers.filter(function (evt) {
        return evt[0] === 'messages:remove';
      });

      this._foldEvents(addMessages, 'messages', this);
      this._foldEvents(removeMessages, 'messages', this);

      _get(Object.getPrototypeOf(Client.prototype), '_processDelayedTriggers', this).call(this);
    }
  }, {
    key: 'trigger',
    value: function trigger(eventName, evt) {
      this._triggerLogger(eventName, evt);
      _get(Object.getPrototypeOf(Client.prototype), 'trigger', this).call(this, eventName, evt);
    }

    /**
     * Does logging on all triggered events.
     *
     * All logging is done at `debug` or `info` levels.
     *
     * @method _triggerLogger
     * @private
     */

  }, {
    key: '_triggerLogger',
    value: function _triggerLogger(eventName, evt) {
      var infoEvents = ['conversations:add', 'conversations:remove', 'conversations:change', 'messages:add', 'messages:remove', 'messages:change', 'challenge', 'ready'];
      if (infoEvents.indexOf(eventName) !== -1) {
        if (evt && evt.isChange) {
          logger.info('Client Event: ' + eventName + ' ' + evt.changes.map(function (change) {
            return change.property;
          }).join(', '));
        } else {
          var text = '';
          if (evt) {
            if (evt.message) text = evt.message.id;
            if (evt.messages) text = evt.messages.length + ' messages';
            if (evt.conversation) text = evt.conversation.id;
            if (evt.conversations) text = evt.conversations.length + ' conversations';
          }
          logger.info('Client Event: ' + eventName + ' ' + text);
        }
        if (evt) logger.debug(evt);
      } else {
        logger.debug(eventName, evt);
      }
    }

    /**
     * Searches locally cached conversations for a matching conversation.
     *
     * Iterates over conversations calling a matching function until
     * the conversation is found or all conversations tested.
     *
     *      var c = client.findConversation(function(conversation) {
     *          if (conversation.participants.indexOf('a') != -1) return true;
     *      });
     *
     * @method findCachedConversation
     * @param  {Function} f - Function to call until we find a match
     * @param  {layer.Conversation} f.conversation - A conversation to test
     * @param  {boolean} f.return - Return true if the conversation is a match
     * @param  {Object} [context] - Optional context for the *this* object
     * @return {layer.Conversation}
     *
     * @deprecated
     * This should be replaced by iterating over your layer.Query data.
     */

  }, {
    key: 'findCachedConversation',
    value: function findCachedConversation(func, context) {
      var test = context ? func.bind(context) : func;
      var list = Object.keys(this._conversationsHash);
      var len = list.length;
      for (var index = 0; index < len; index++) {
        var key = list[index];
        var conversation = this._conversationsHash[key];
        if (test(conversation, index)) return conversation;
      }
    }

    /**
     * If the session has been reset, dump all data.
     *
     * @method _resetSession
     * @private
     */

  }, {
    key: '_resetSession',
    value: function _resetSession() {
      this._cleanup();
      this.users = [];
      this._conversationsHash = {};
      this._messagesHash = {};
      this._queriesHash = {};
      return _get(Object.getPrototypeOf(Client.prototype), '_resetSession', this).call(this);
    }

    /**
     * Add a user to the users array.
     *
     * By doing this instead of just directly `this.client.users.push(user)`
     * the user will get its conversations property setup correctly.
     *
     * @method addUser
     * @param  {layer.User} user [description]
     * @returns {layer.Client} this
     */

  }, {
    key: 'addUser',
    value: function addUser(user) {
      this.users.push(user);
      user.setClient(this);
      this.trigger('users:change');
      return this;
    }

    /**
     * Searches `client.users` array for the specified id.
     *
     * Use of the `client.users` array is optional.
     *
     *      function getSenderDisplayName(message) {
     *          var user = client.findUser(message.sender.userId);
     *          return user ? user.displayName : 'Unknown User';
     *      }
     *
     * @method findUser
     * @param  {string} id
     * @return {layer.User}
     */

  }, {
    key: 'findUser',
    value: function findUser(id) {
      var l = this.users.length;
      for (var i = 0; i < l; i++) {
        var u = this.users[i];
        if (u.id === id) return u;
      }
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Insure that any attempt to set the `users` property sets it to an array.
     *
     * @method __adjustUsers
     * @private
     */

  }, {
    key: '__adjustUsers',
    value: function __adjustUsers(users) {
      if (!users) return [];
      if (!Array.isArray(users)) return [users];
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Insure that each user in the users array gets its client property setup.
     *
     * @method __adjustUsers
     * @private
     */

  }, {
    key: '__updateUsers',
    value: function __updateUsers(users) {
      var _this8 = this;

      users.forEach(function (u) {
        if (u instanceof User) u.setClient(_this8);
      });
      this.trigger('users:change');
    }

    /**
     * This method is recommended way to create a Conversation.
     *
     * There are a few ways to invoke it; note that the default behavior is to create a Distinct Conversation
     * unless otherwise stated via the layer.Conversation.distinct property.
     *
     *         client.createConversation(['a', 'b']);
     *
     *         client.createConversation({participants: ['a', 'b']});
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             distinct: false
     *         });
     *
     *         client.createConversation({
     *             participants: ['a', 'b'],
     *             metadata: {
     *                 title: 'I am a title'
     *             }
     *         });
     *
     * If you try to create a Distinct Conversation that already exists,
     * you will get back an existing Conversation, and any requested metadata
     * will NOT be set; you will get whatever metadata the matching Conversation
     * already had.
     *
     * The default value for distinct is `true`.
     *
     * Whether the Conversation already exists or not, a 'conversations:sent' event
     * will be triggered asynchronously and the Conversation object will be ready
     * at that time.  Further, the event will provide details on the result:
     *
     *       var conversation = client.createConversation(['a', 'b']);
     *       conversation.on('conversations:sent', function(evt) {
     *           switch(evt.result) {
     *               case Conversation.CREATED:
     *                   alert(conversation.id + ' was created');
     *                   break;
     *               case Conversation.FOUND:
     *                   alert(conversation.id + ' was found');
     *                   break;
     *               case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
     *                   alert(conversation.id + ' was found but it already has a title so your requested title was not set');
     *                   break;
     *            }
     *       });
     *
     * @method createConversation
     * @param  {Object/string[]} options Either an array of participants,
     *                                  or an object with parameters to pass to
     *                                  Conversation's constructor
     * @param {Boolean} [options.distinct=true] Is this a distinct Converation?
     * @param {Object} [options.metadata={}] Metadata for your Conversation
     * @return {layer.Conversation}
     */

  }, {
    key: 'createConversation',
    value: function createConversation(options) {
      var opts = undefined;
      if (Array.isArray(options)) {
        opts = {
          participants: options
        };
      } else {
        opts = options;
      }
      if (!('distinct' in opts)) opts.distinct = true;
      opts.client = this;
      return Conversation.create(opts);
    }

    /**
     * Retrieve the query by query id.
     *
     * Useful for finding a Query when you only have the ID
     *
     * @method getQuery
     * @param  {string} id              - layer:///messages/uuid
     * @return {layer.Query}
     */

  }, {
    key: 'getQuery',
    value: function getQuery(id) {
      if (typeof id !== 'string') throw new Error(LayerError.dictionary.idParamRequired);

      if (this._queriesHash[id]) {
        return this._queriesHash[id];
      }
    }

    /**
     * There are two options to create a new layer.Query instance.
     *
     * The direct way:
     *
     *     var query = client.createQuery({
     *         model: layer.Query.Message,
     *         predicate: 'conversation.id = '' + conv.id + ''',
     *         paginationWindow: 50
     *     });
     *
     * A Builder approach that allows for a simpler syntax:
     *
     *     var qBuilder = QueryBuilder
     *      .messages()
     *      .forConversation('layer:///conversations/ffffffff-ffff-ffff-ffff-ffffffffffff')
     *      .paginationWindow(100);
     *     var query = client.createQuery(qBuilder);
     *
     * @method createQuery
     * @param  {layer.QueryBuilder|Object} options - Either a layer.QueryBuilder instance, or parameters for the layer.Query constructor
     * @return {layer.Query}
     */

  }, {
    key: 'createQuery',
    value: function createQuery(options) {
      var query = undefined;
      if (typeof options.build === 'function') {
        query = new Query(this, options);
      } else {
        options.client = this;
        query = new Query(options);
      }
      this._addQuery(query);
      return query;
    }

    /**
     * Register the layer.Query.
     *
     * @method _addQuery
     * @private
     * @param  {layer.Query} query
     */

  }, {
    key: '_addQuery',
    value: function _addQuery(query) {
      this._queriesHash[query.id] = query;
    }

    /**
     * Deregister the layer.Query.
     *
     * @method _removeQuery
     * @private
     * @param  {layer.Query} query [description]
     */

  }, {
    key: '_removeQuery',
    value: function _removeQuery(query) {
      var _this9 = this;

      if (query) {
        delete this._queriesHash[query.id];
        if (!this._inCleanup) {
          var data = query.data.map(function (obj) {
            return _this9._getObject(obj.id);
          }).filter(function (obj) {
            return obj;
          });
          this._checkAndPurgeCache(data);
        }
        this.off(null, null, query);
      }
    }

    /**
     * Check to see if the specified objects can safely be removed from cache.
     *
     * Removes from cache if an object is not part of any Query's result set.
     *
     * @method _checkAndPurgeCache
     * @private
     * @param  {layer.Root[]} objects - Array of Messages or Conversations
     */

  }, {
    key: '_checkAndPurgeCache',
    value: function _checkAndPurgeCache(objects) {
      var _this10 = this;

      objects.forEach(function (obj) {
        if (!obj.isDestroyed && !_this10._isCachedObject(obj)) {
          if (obj instanceof Root === false) obj = _this10._getObject(obj.id);
          obj.destroy();
        }
      });
    }

    /**
     * Schedules _runScheduledCheckAndPurgeCache if needed, and adds this object
     * to the list of objects it will validate for uncaching.
     *
     * Note that any object that does not exist on the server (!isSaved()) is an object that the
     * app created and can only be purged by the app and not by the SDK.  Once its been
     * saved, and can be reloaded from the server when needed, its subject to standard caching.
     *
     * @method _scheduleCheckAndPurgeCache
     * @private
     * @param {layer.Root}
     */

  }, {
    key: '_scheduleCheckAndPurgeCache',
    value: function _scheduleCheckAndPurgeCache(object) {
      var _this11 = this;

      if (object.isSaved()) {
        if (this._scheduleCheckAndPurgeCacheAt < Date.now()) {
          this._scheduleCheckAndPurgeCacheAt = Date.now() + Client.CACHE_PURGE_INTERVAL;
          setTimeout(function () {
            return _this11._runScheduledCheckAndPurgeCache();
          }, Client.CACHE_PURGE_INTERVAL);
        }
        this._scheduleCheckAndPurgeCacheItems.push(object);
      }
    }

    /**
     * Calls _checkAndPurgeCache on accumulated objects and resets its state
     */

  }, {
    key: '_runScheduledCheckAndPurgeCache',
    value: function _runScheduledCheckAndPurgeCache() {
      var list = this._scheduleCheckAndPurgeCacheItems;
      this._scheduleCheckAndPurgeCacheItems = [];
      this._checkAndPurgeCache(list);
      this._scheduleCheckAndPurgeCacheAt = 0;
    }

    /**
     * Returns true if the specified object should continue to be part of the cache.
     *
     * Result is based on whether the object is part of the data for a Query.
     *
     * @method _isCachedObject
     * @private
     * @param  {layer.Root} obj - A Message or Conversation Instance
     * @return {Boolean}
     */

  }, {
    key: '_isCachedObject',
    value: function _isCachedObject(obj) {
      var list = Object.keys(this._queriesHash);
      for (var i = 0; i < list.length; i++) {
        var query = this._queriesHash[list[i]];
        if (query._getItem(obj.id)) return true;
      }
    }

    /**
     * On restoring a connection, determine what steps need to be taken to update our data.
     *
     * A reset boolean property is passed; set based on  layer.ClientAuthenticator.ResetAfterOfflineDuration.
     *
     * Note it is possible for an application to have logic that causes queries to be created/destroyed
     * as a side-effect of layer.Query.reset destroying all data. So we must test to see if queries exist.
     *
     * @method _connectionRestored
     * @private
     * @param {boolean} reset - Should the session reset/reload all data or attempt to resume where it left off?
     */

  }, {
    key: '_connectionRestored',
    value: function _connectionRestored(evt) {
      var _this12 = this;

      if (evt.reset) {
        logger.debug('Client Connection Restored; Resetting all Queries');
        Object.keys(this._queriesHash).forEach(function (id) {
          var query = _this12._queriesHash[id];
          if (query) query.reset();
        });
      }
    }

    /**
     * Remove the specified object from cache
     *
     * @method _removeObject
     * @private
     * @param  {layer.Root}  obj - A Message or Conversation Instance
     */

  }, {
    key: '_removeObject',
    value: function _removeObject(obj) {
      if (obj) obj.destroy();
    }

    /**
     * Creates a layer.TypingIndicators.TypingListener instance
     * bound to the specified dom node.
     *
     *      var typingListener = client.createTypingListener(document.getElementById('myTextBox'));
     *      typingListener.setConversation(mySelectedConversation);
     *
     * Use this method to instantiate a listener, and call
     * layer.TypingIndicators.TypingListener.setConversation every time you want to change which Conversation
     * it reports your user is typing into.
     *
     * @method createTypingListener
     * @param  {HTMLElement} inputNode - Text input to watch for keystrokes
     * @return {layer.TypingIndicators.TypingListener}
     */

  }, {
    key: 'createTypingListener',
    value: function createTypingListener(inputNode) {
      var TypingListener = require('./typing-indicators/typing-listener');
      return new TypingListener({
        clientId: this.appId,
        input: inputNode
      });
    }

    /**
     * Creates a layer.TypingIndicators.TypingPublisher.
     *
     * The TypingPublisher lets you manage your Typing Indicators without using
     * the layer.TypingIndicators.TypingListener.
     *
     *      var typingPublisher = client.createTypingPublisher();
     *      typingPublisher.setConversation(mySelectedConversation);
     *      typingPublisher.setState(layer.TypingIndicators.STARTED);
     *
     * Use this method to instantiate a listener, and call
     * layer.TypingIndicators.TypingPublisher.setConversation every time you want to change which Conversation
     * it reports your user is typing into.
     *
     * Use layer.TypingIndicators.TypingPublisher.setState to inform other users of your current state.
     * Note that the `STARTED` state only lasts for 2.5 seconds, so you
     * must repeatedly call setState for as long as this state should continue.
     * This is typically done by simply calling it every time a user hits
     * a key.
     *
     * @method createTypingPublisher
     * @return {layer.TypingIndicators.TypingPublisher}
     */

  }, {
    key: 'createTypingPublisher',
    value: function createTypingPublisher() {
      var TypingPublisher = require('./typing-indicators/typing-publisher');
      return new TypingPublisher({
        clientId: this.appId
      });
    }

    /**
     * Accessor for getting a Client by appId.
     *
     * Most apps will only have one client,
     * and will not need this method.
     *
     * @method getClient
     * @static
     * @param  {string} appId
     * @return {layer.Client}
     */

  }], [{
    key: 'getClient',
    value: function getClient(appId) {
      return ClientRegistry.get(appId);
    }
  }, {
    key: 'destroyAllClients',
    value: function destroyAllClients() {
      ClientRegistry.getAll().forEach(function (client) {
        return client.destroy();
      });
    }

    /*
     * Registers a plugin which can add capabilities to the Client.
     *
     * Capabilities must be triggered by Events/Event Listeners.
     *
     * This concept is a bit premature and unused/untested...
     * As implemented, it provides for a plugin that will be
     * instantiated by the Client and passed the Client as its parameter.
     * This allows for a library of plugins that can be shared among
     * different companies/projects but that are outside of the core
     * app logic.
     *
     *      // Define the plugin
     *      function MyPlugin(client) {
     *          this.client = client;
     *          client.on('messages:add', this.onMessagesAdd, this);
     *      }
     *
     *      MyPlugin.prototype.onMessagesAdd = function(event) {
     *          var messages = event.messages;
     *          alert('You now have ' + messages.length  + ' messages');
     *      }
     *
     *      // Register the Plugin
     *      Client.registerPlugin('myPlugin34', MyPlugin);
     *
     *      var client = new Client({appId: 'layer:///apps/staging/uuid'});
     *
     *      // Trigger the plugin's behavior
     *      client.myPlugin34.addMessages({messages:[]});
     *
     * @method registerPlugin
     * @static
     * @param  {string} name     [description]
     * @param  {Function} classDef [description]
     */

  }, {
    key: 'registerPlugin',
    value: function registerPlugin(name, classDef) {
      Client.plugins[name] = classDef;
    }
  }]);

  return Client;
}(ClientAuth);

/**
 * Hash of layer.Conversation objects for quick lookup by id
 *
 * @private
 * @property {Object}
 */


Client.prototype._conversationsHash = null;

/**
 * Hash of layer.Message objects for quick lookup by id
 *
 * @private
 * @type {Object}
 */
Client.prototype._messagesHash = null;

/**
 * Hash of layer.Query objects for quick lookup by id
 *
 * @private
 * @type {Object}
 */
Client.prototype._queriesHash = null;

/**
 * Array of items to be checked to see if they can be uncached.
 *
 * @private
 * @type {layer.Root[]}
 */
Client.prototype._scheduleCheckAndPurgeCacheItems = null;

/**
 * Time that the next call to _runCheckAndPurgeCache() is scheduled for in ms since 1970.
 *
 * @private
 * @type {number}
 */
Client.prototype._scheduleCheckAndPurgeCacheAt = 0;

/**
 * Array of layer.User objects.
 *
 * Use of this property is optional; but by storing
 * an array of layer.User objects in this array, you can
 * then use the `client.findUser(userId)` method to lookup
 * users; and you can use the layer.User objects to find
 * suitable Conversations so you can associate a Direct
 * Message conversation with each user.
 *
 * @type {layer.User[]}
 */
Client.prototype.users = null;

/**
 * Any Conversation or Message that is part of a Query's results are kept in memory for as long as it
 * remains in that Query.  However, when a websocket event delivers new Messages and Conversations that
 * are NOT part of a Query, how long should they stick around in memory?  Why have them stick around?
 * Perhaps an app wants to post a notification of a new Message or Conversation... and wants to keep
 * the object local for a little while.  Default is 10 minutes before checking to see if
 * the object is part of a Query or can be uncached.  Value is in miliseconds.
 * @static
 * @type {number}
 */
Client.CACHE_PURGE_INTERVAL = 10 * 60 * 1000;

Client._ignoredEvents = ['conversations:loaded', 'conversations:loaded-error'];

Client._supportedEvents = [

/**
 * One or more layer.Conversation objects have been added to the client.
 *
 * They may have been added via the websocket, or via the user creating
 * a new Conversation locally.
 *
 *      client.on('conversations:add', function(evt) {
 *          evt.conversations.forEach(function(conversation) {
 *              myView.addConversation(conversation);
 *          });
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Conversation[]} evt.conversations - Array of conversations added
 */
'conversations:add',

/**
 * One or more layer.Conversation objects have been removed.
 *
 * A removed Conversation is not necessarily deleted, its just
 * no longer being held in local memory.
 *
 * Note that typically you will want the conversations:delete event
 * rather than conversations:remove.
 *
 *      client.on('conversations:remove', function(evt) {
 *          evt.conversations.forEach(function(conversation) {
 *              myView.removeConversation(conversation);
 *          });
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Conversation[]} evt.conversations - Array of conversations removed
 */
'conversations:remove',

/**
 * The conversation is now on the server.
 *
 * Called after creating the conversation
 * on the server.  The Result property is one of:
 *
 * * layer.Conversation.CREATED: A new Conversation has been created
 * * layer.Conversation.FOUND: A matching Distinct Conversation has been found
 * * layer.Conversation.FOUND_WITHOUT_REQUESTED_METADATA: A matching Distinct Conversation has been found
 *                       but note that the metadata is NOT what you requested.
 *
 * All of these results will also mean that the updated property values have been
 * copied into your Conversation object.  That means your metadata property may no
 * longer be its initial value; it will be the value found on the server.
 *
 *      client.on('conversations:sent', function(evt) {
 *          switch(evt.result) {
 *              case Conversation.CREATED:
 *                  alert(evt.target.id + ' Created!');
 *                  break;
 *              case Conversation.FOUND:
 *                  alert(evt.target.id + ' Found!');
 *                  break;
 *              case Conversation.FOUND_WITHOUT_REQUESTED_METADATA:
 *                  alert(evt.target.id + ' Found, but does not have the requested metadata!');
 *                  break;
 *          }
 *      });
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {string} event.result
 * @param {layer.Conversation} target
 */
'conversations:sent',

/**
 * A conversation failed to load or create on the server.
 *
 *      client.on('conversations:sent-error', function(evt) {
 *          alert(evt.data.message);
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.LayerError} evt.data
 * @param {layer.Conversation} target
 */
'conversations:sent-error',

/**
 * A conversation had a change in its properties.
 *
 * This change may have been delivered from a remote user
 * or as a result of a local operation.
 *
 *      client.on('conversations:change', function(evt) {
 *          var metadataChanges = evt.getChangesFor('metadata');
 *          var participantChanges = evt.getChangesFor('participants');
 *          if (metadataChanges.length) {
 *              myView.renderTitle(evt.target.metadata.title);
 *          }
 *          if (participantChanges.length) {
 *              myView.renderParticipants(evt.target.participants);
 *          }
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Conversation} evt.target
 * @param {Object[]} evt.changes
 * @param {Mixed} evt.changes.newValue
 * @param {Mixed} evt.changes.oldValue
 * @param {string} evt.changes.property - Name of the property that has changed
 */
'conversations:change',

/**
 * A call to layer.Conversation.load has completed successfully
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Conversation} evt.target
 */
'conversations:loaded',

/**
 * A new message has been received for which a notification may be suitable.
 * This event is triggered for messages that are:
 *
 * 1. Added via websocket rather than other IO
 * 2. Not yet been marked as read
 * 3. Not sent by this user
 *
        client.on('messages:notify', function(evt) {
            myNotify(evt.message);
        })
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.Message
 */
'messages:notify',

/**
 * Messages have been added to a conversation.
 *
 * This event is triggered on
 *
 * * creating/sending a new message
 * * Receiving a new Message via websocket
 * * Querying/downloading a set of Messages
 *
        client.on('messages:add', function(evt) {
            evt.messages.forEach(function(message) {
                myView.addMessage(message);
            });
        });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message[]} evt.messages
 */
'messages:add',

/**
 * A message has been removed from a conversation.
 *
 * A removed Message is not necessarily deleted,
 * just no longer being held in memory.
 *
 * Note that typically you will want the messages:delete event
 * rather than messages:remove.
 *
 *      client.on('messages:remove', function(evt) {
 *          evt.messages.forEach(function(message) {
 *              myView.removeMessage(message);
 *          });
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.message
 */
'messages:remove',

/**
 * A message has been sent.
 *
 *      client.on('messages:sent', function(evt) {
 *          alert(evt.target.getText() + ' has been sent');
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 */
'messages:sent',

/**
 * A message is about to be sent.
 *
 * Useful if you want to
 * add parts to the message before it goes out.
 *
 *      client.on('messages:sending', function(evt) {
 *          evt.target.addPart({
 *              mimeType: 'text/plain',
 *              body: 'this is just a test'
 *          });
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 */
'messages:sending',

/**
 * Server failed to receive a Message.
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.LayerError} evt.error
 */
'messages:sent-error',

/**
 * A message has had a change in its properties.
 *
 * This change may have been delivered from a remote user
 * or as a result of a local operation.
 *
 *      client.on('messages:change', function(evt) {
 *          var recpientStatusChanges = evt.getChangesFor('recipientStatus');
 *          if (recpientStatusChanges.length) {
 *              myView.renderStatus(evt.target);
 *          }
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 * @param {Object[]} evt.changes
 * @param {Mixed} evt.changes.newValue
 * @param {Mixed} evt.changes.oldValue
 * @param {string} evt.changes.property - Name of the property that has changed
 */
'messages:change',

/**
 * A message has been marked as read.
 *
 * This is can be triggered by a local event, or by this same user on a separate device or browser.
 *
 *      client.on('messages:read', function(evt) {
 *          myView.renderUnreadStatus(evt.target);
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 */
'messages:read',

/**
 * A call to layer.Message.load has completed successfully
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 */
'messages:loaded',

/**
 * A Conversation has been deleted from the server.
 *
 * Caused by either a successful call to layer.Conversation.delete() on the Conversation
 * or by a remote user.
 *
 *      client.on('conversations:delete', function(evt) {
 *          myView.removeConversation(evt.target);
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Conversation} evt.target
 */
'conversations:delete',

/**
 * A Message has been deleted from the server.
 *
 * Caused by either a successful call to layer.Message.delete() on the Message
 * or by a remote user.
 *
 *      client.on('messages:delete', function(evt) {
 *          myView.removeMessage(evt.target);
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message} evt.target
 */
'messages:delete',

/**
 * A User has been added or changed in the users array.
 *
 * This event is not yet well supported.
 * @event
 */
'users:change',

/**
 * A Typing Indicator state has changed.
 *
 * Either a change has been received
 * from the server, or a typing indicator state has expired.
 *
 *      client.on('typing-indicator-change', function(evt) {
 *          if (evt.conversationId === myConversationId) {
 *              alert(evt.typing.join(', ') + ' are typing');
 *              alert(evt.paused.join(', ') + ' are paused');
 *          }
 *      });
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {string} conversationId - ID of the Conversation users are typing into
 * @param {string[]} typing - Array of user IDs who are currently typing
 * @param {string[]} paused - Array of user IDs who are currently paused;
 *                            A paused user still has text in their text box.
 */
'typing-indicator-change'].concat(ClientAuth._supportedEvents);

Client.plugins = {};

Root.initClass.apply(Client, [Client, 'Client']);
module.exports = Client;

},{"./announcement":7,"./client-authenticator":8,"./client-registry":9,"./client-utils":10,"./conversation":14,"./layer-error":16,"./logger":18,"./message":20,"./query":23,"./root":24,"./syncable":27,"./typing-indicators/typing-indicator-listener":28,"./typing-indicators/typing-listener":30,"./typing-indicators/typing-publisher":31,"./user":32}],12:[function(require,module,exports){
'use strict';

/**
 * Layer Constants are stored in two places:
 *
 * 1. As part of the layer.Constants singleton
 * 2. As static properties on classes.
 *
 * Typically the static property constants are designed to be changed by developers to customize behaviors,
 * and tend to only be used by that single class.
 *
 * @class layer.Constants
 * @singleton
 */
module.exports = {
  /**
   * Is the object synchronized with the server?
   * @property {Object} [SYNC_STATE=null]
   * @property {string} SYNC_STATE.NEW      - Object is newly created, was created locally, not from server data, and has not yet been sent to the server.
   * @property {string} SYNC_STATE.SAVING   - Object is newly created and is being sent to the server.
   * @property {string} SYNC_STATE.SYNCING  - Object exists both locally and on server but is being synced with changes.
   * @property {string} SYNC_STATE.SYNCED   - Object exists both locally and on server and at last check was in sync.
   * @property {string} SYNC_STATE.LOADING  - Object is being loaded from the server and may not have its properties set yet.
   */
  SYNC_STATE: {
    NEW: 'NEW',
    SAVING: 'SAVING',
    SYNCING: 'SYNCING',
    SYNCED: 'SYNCED',
    LOADING: 'LOADING'
  },

  /**
   * Values for readStatus/deliveryStatus
   * @property {Object} [RECIPIENT_STATE=]
   * @property {string} RECIPIENT_STATE.NONE - No users have read (or received) this Message
   * @property {string} RECIPIENT_STATE.SOME - Some users have read (or received) this Message
   * @property {string} RECIPIENT_STATE.ALL  - All users have read (or received) this Message
   */
  RECIPIENT_STATE: {
    NONE: 'NONE',
    SOME: 'SOME',
    ALL: 'ALL'
  },

  /**
   * Values for recipientStatus
   * @property {Object} [RECEIPT_STATE=]
   * @property {string} RECEIPT_STATE.SENT      - The Message has been sent to the specified user but it has not yet been received by their device.
   * @property {string} RECEIPT_STATE.DELIVERED - The Message has been delivered to the specified use but has not yet been read.
   * @property {string} RECEIPT_STATE.READ      - The Message has been read by the specified user.
   * @property {string} RECEIPT_STATE.PENDING   - The request to send this Message to the specified user has not yet been received by the server.
   */
  RECEIPT_STATE: {
    SENT: 'sent',
    DELIVERED: 'delivered',
    READ: 'read',
    PENDING: 'pending'
  },
  LOCALSTORAGE_KEYS: {
    SESSIONDATA: 'layer-session-data-'
  },
  ACCEPT: 'application/vnd.layer+json; version=1.0',

  /**
   * Log levels
   * @property {Object} [LOG=]
   * @property {number} LOG.DEBUG     Log detailed information about requests, responses, events, state changes, etc...
   * @property {number} LOG.INFO      Log sparse information about requests, responses and events
   * @property {number} LOG.WARN      Log failures that are expected, normal, handled, but suggests that an operation didn't complete as intended
   * @property {number} LOG.ERROR     Log failures that are not expected or could not be handled
   * @property {number} LOG.NONE      Logs? Who needs em?
   */
  LOG: {
    DEBUG: 4,
    INFO: 3,
    WARN: 2,
    ERROR: 1,
    NONE: 0
  },

  /**
   * Deletion Modes
   * @property {Object} [DELETION_MODE=]
   * @property {number} DELETION_MODE.ALL          Delete Message/Conversation for All users but remain in the Conversation;
   *                                               new Messages will restore this Conversation minus any Message History prior to deletion.
   * @property {number} DELETION_MODE.MY_DEVICES   Delete Message or Conversation; but see layer.Conversation.leave if you want to delete
   *                                               a Conversation and not have it come back.
   */
  DELETION_MODE: {
    ALL: 1,
    MY_DEVICES: 2
  }
};

},{}],13:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Content class represents Rich Content.
 *
 * Note that instances of this class will automatically be
 * generated for developers based on whether their message parts
 * require it.
 *
 * That means for the most part, you should never need to
 * instantiate one of these directly.
 *
 *      var content = new layer.Content({
 *          id: 'layer:///content/8c839735-5f95-439a-a867-30903c0133f2'
 *      });
 *
 * @class  layer.Content
 * @protected
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require('./root');
var xhr = require('./xhr');

var Content = function (_Root) {
  _inherits(Content, _Root);

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options
   * @param  {string} options.id - Identifier for the content
   * @param  {string} [options.downloadUrl=null] - Url to download the content from
   * @param  {Date} [options.expiration] - Expiration date for the url
   * @param  {string} [options.refreshUrl] - Url to access to get a new downloadUrl after it has expired
   *
   * @return {layer.Content}
   */

  function Content(options) {
    _classCallCheck(this, Content);

    if (typeof options === 'string') {
      options = { id: options };
    }
    return _possibleConstructorReturn(this, Object.getPrototypeOf(Content).call(this, options));
  }

  /**
   * Loads the data from google's cloud storage.
   *
   * Data is provided via callback.
   *
   * Note that typically one should use layer.MessagePart.fetchContent() rather than layer.Content.loadContent()
   *
   * @method loadContent
   * @param {string} mimeType - Mime type for the Blob
   * @param {Function} callback
   * @param {Blob} callback.data - A Blob instance representing the data downloaded.  If Blob object is not available, then may use other format.
   */


  _createClass(Content, [{
    key: 'loadContent',
    value: function loadContent(mimeType, callback) {
      xhr({
        url: this.downloadUrl,
        responseType: 'arraybuffer'
      }, function (result) {
        if (result.success) {
          if (typeof Blob !== 'undefined') {
            var blob = new Blob([result.data], { type: mimeType });
            callback(null, blob);
          } else {
            // If the blob class isn't defined (nodejs) then just return the result as is
            callback(null, result.data);
          }
        } else {
          callback(result.data, null);
        }
      });
    }

    /**
     * Refreshes the URL, which updates the URL and resets the expiration time for the URL
     *
     * @method refreshContent
     * @param {layer.Client} client
     * @param {Function} [callback]
     */

  }, {
    key: 'refreshContent',
    value: function refreshContent(client, callback) {
      var _this2 = this;

      client.xhr({
        url: this.refreshUrl,
        method: 'GET'
      }, function (result) {
        var data = result.data;

        _this2.expiration = new Date(data.expiration);
        _this2.downloadUrl = data.download_url;
        if (callback) callback(_this2.downloadUrl);
      });
    }

    /**
     * Is the download url expired or about to expire?
     * We can't be sure of the state of the device's internal clock,
     * so if its within 10 minutes of expiring, just treat it as expired.
     *
     * @method isExpired
     * @returns {Boolean}
     */

  }, {
    key: 'isExpired',
    value: function isExpired() {
      var expirationLeeway = 10 * 60 * 1000;
      return this.expiration.getTime() - expirationLeeway < Date.now();
    }

    /**
     * Creates a MessagePart from a server representation of the part
     *
     * @method _createFromServer
     * @private
     * @static
     * @param  {Object} part - Server representation of a part
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(part) {
      return new Content({
        id: part.id,
        downloadUrl: part.download_url,
        expiration: new Date(part.expiration),
        refreshUrl: part.refresh_url
      });
    }
  }]);

  return Content;
}(Root);

/**
 * Server generated identifier
 * @type {string}
 */


Content.prototype.id = '';

Content.prototype.blob = null;

/**
 * Server generated url for downloading the content
 * @type {string}
 */
Content.prototype.downloadUrl = '';

/**
 * Url for refreshing the downloadUrl after it has expired
 * @type {string}
 */
Content.prototype.refreshUrl = '';

/**
 * Size of the content.
 *
 * This property only has a value when in the process
 * of Creating the rich content and sending the Message.
 *
 * @type {number}
 */
Content.prototype.size = 0;

/**
 * Expiration date for the downloadUrl
 * @type {Date}
 */
Content.prototype.expiration = null;

Root.initClass.apply(Content, [Content, 'Content']);
module.exports = Content;

},{"./root":24,"./xhr":36}],14:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A Conversation object represents a dialog amongst a set
 * of participants.
 *
 * Create a Conversation using the client:
 *
 *      var conversation = client.createConversation({
 *          participants: ['a','b'],
 *          distinct: true
 *      });
 *
 * In addition, there is a shortcut method for creating
 * a conversation, which will default to creating a Distinct
 * Conversation.
 *
 *      var conversation = client.createConversation(['a','b']);
 *
 * NOTE:   Do not create a conversation with new layer.Conversation(...),
 *         This will fail to handle the distinct property short of going to the server for evaluation.
 *
 * NOTE:   Creating a Conversation is a local action.  A Conversation will not be
 *         sent to the server until either:
 *
 * 1. A message is sent on that Conversation
 * 2. `Conversation.send()` is called (not recommended as mobile clients
 *    expect at least one layer.Message in a Conversation)
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Conversation.id: this property is worth being familiar with; it identifies the
 *   Conversation and can be used in `client.getConversation(id)` to retrieve it.
 * * layer.Conversation.internalId: This property makes for a handy unique ID for use in dom nodes;
 *   gaurenteed not to change during this session.
 * * layer.Conversation.lastMessage: This property makes it easy to show info about the most recent Message
 *    when rendering a list of Conversations.
 * * layer.Conversation.metadata: Custom data for your Conversation; commonly used to store a 'title' property
 *    to name your Conversation.
 *
 * Methods:
 *
 * * layer.Conversation.addParticipants and layer.Conversation.removeParticipants: Change the participants of the Conversation
 * * layer.Conversation.setMetadataProperties: Set metadata.title to 'My Conversation with Layer Support' (uh oh)
 * * layer.Conversation.on() and layer.Conversation.off(): event listeners built on top of the `backbone-events-standalone` npm project
 * * layer.Conversation.leave() to leave the Conversation
 *
 * Events:
 *
 * * `conversations:change`: Useful for observing changes to participants and metadata
 *   and updating rendering of your open Conversation
 *
 * Finally, to access a list of Messages in a Conversation, see layer.Query.
 *
 * @class  layer.Conversation
 * @extends layer.Syncable
 * @author  Michael Kantor
 */

var Syncable = require('./syncable');
var Message = require('./message');
var LayerError = require('./layer-error');
var Util = require('./client-utils');
var Constants = require('./const');
var Root = require('./root');
var LayerEvent = require('./layer-event');
var ClientRegistry = require('./client-registry');
var logger = require('./logger');

var Conversation = function (_Syncable) {
  _inherits(Conversation, _Syncable);

  /**
   * Create a new conversation.
   *
   * The static `layer.Conversation.create()` method
   * will correctly lookup distinct Conversations and
   * return them; `new layer.Conversation()` will not.
   *
   * Developers should use `layer.Conversation.create()`.
   *
   * @method constructor
   * @protected
   * @param  {Object} options
   * @param {string[]} options.participants - Array of participant ids
   * @param {boolean} [options.distinct=true] - Is the conversation distinct
   * @param {Object} [options.metadata] - An object containing Conversation Metadata.
   * @return {layer.Conversation}
   */

  function Conversation() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Conversation);

    // Setup default values
    if (!options.participants) options.participants = [];
    if (!options.metadata) options.metadata = {};

    // Make sure the ID from handle fromServer parameter is used by the Root.constructor
    if (options.fromServer) options.id = options.fromServer.id;

    // Make sure we have an clientId property
    if (options.client) options.clientId = options.client.appId;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Conversation).call(this, options));

    _this.isInitializing = true;
    var client = _this.getClient();

    // If the options contains a full server definition of the object,
    // copy it in with _populateFromServer; this will add the Conversation
    // to the Client as well.
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    }

    // Setup participants
    else if (client && _this.participants.indexOf(client.userId) === -1) {
        _this.participants.push(client.userId);
      }

    _this.localCreatedAt = new Date();

    if (client) client._addConversation(_this);
    _this.isInitializing = false;
    return _this;
  }

  /**
   * Destroy the local copy of this Conversation, cleaning up all resources
   * it consumes.
   *
   * @method destroy
   */


  _createClass(Conversation, [{
    key: 'destroy',
    value: function destroy() {
      this.lastMessage = null;

      // Client fires 'conversations:remove' and then removes the Conversation.
      if (this.clientId) this.getClient()._removeConversation(this);

      _get(Object.getPrototypeOf(Conversation.prototype), 'destroy', this).call(this);

      this.participants = null;
      this.metadata = null;
    }

    /**
     * Get the client associated with this Conversation.
     *
     * @method getClient
     * @return {layer.Client}
     */

  }, {
    key: 'getClient',
    value: function getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Create this Conversation on the server.
     *
     * On completion, this instance will receive
     * an id, url and createdAt.  It may also receive metadata
     * if there was a FOUND_WITHOUT_REQUESTED_METADATA result.
     *
     * Note that the optional Message parameter should NOT be used except
     * by the layer.Message class itself.
     *
     * Note that recommended practice is to send the Conversation by sending a Message in the Conversation,
     * and NOT by calling Conversation.send.
     *
     *      client.createConversation({
     *          participants: ['a', 'b'],
     *          distinct: false
     *      })
     *      .send()
     *      .on('conversations:sent', function(evt) {
     *          alert('Done');
     *      });
     *
     * @method send
     * @param {layer.Message} [message] Tells the Conversation what its last_message will be
     * @return {layer.Conversation} this
     */

  }, {
    key: 'send',
    value: function send(message) {
      var _this2 = this;

      var client = this.getClient();
      if (!client) throw new Error(LayerError.dictionary.clientMissing);

      // If this is part of a create({distinct:true}).send() call where
      // the distinct conversation was found, just trigger the cached event and exit
      if (this._sendDistinctEvent) return this._handleLocalDistinctConversation();

      // If a message is passed in, then that message is being sent, and is our
      // new lastMessage (until the websocket tells us otherwise)
      if (message) {
        // Setting a position is required if its going to get sorted correctly by query.
        // The correct position will be written by _populateFromServer when the object
        // is returned from the server.  We increment the position by the time since the prior lastMessage was sent
        // so that if multiple tabs are sending messages and writing them to indexedDB, they will have positions in correct chronological order.
        // WARNING: The query will NOT be resorted using the server's position value.
        var position = undefined;
        if (this.lastMessage) {
          position = this.lastMessage.position + Date.now() - this.lastMessage.sentAt.getTime();
          if (position === this.lastMessage.position) position++;
        } else {
          position = 0;
        }
        message.position = position;
        this.lastMessage = message;
      }

      // If the Conversation is already on the server, don't send.
      if (this.syncState !== Constants.SYNC_STATE.NEW) return this;

      // Make sure this user is a participant (server does this for us, but
      // this insures the local copy is correct until we get a response from
      // the server
      if (this.participants.indexOf(client.userId) === -1) {
        this.participants.push(client.userId);
      }

      // If there is only one participant, its client.userId.  Not enough
      // for us to have a good Conversation on the server.  Abort.
      if (this.participants.length === 1) {
        throw new Error(LayerError.dictionary.moreParticipantsRequired);
      }

      // Update the syncState
      this._setSyncing();

      client.sendSocketRequest({
        method: 'POST',
        body: {}, // see _getSendData
        sync: {
          depends: this.id,
          target: this.id
        }
      }, function (result) {
        return _this2._createResult(result);
      });
      return this;
    }

    /**
     * Handles the case where a Distinct Create Conversation found a local match.
     *
     * When an app calls client.createConversation([...])
     * and requests a Distinct Conversation (default setting),
     * and the Conversation already exists, what do we do to help
     * them access it?
     *
     *      client.createConversation(["fred"]).on("conversations:sent", function(evt) {
     *        render();
     *      });
     *
     * Under normal conditions, calling `c.send()` on a matching distinct Conversation
     * would either throw an error or just be a no-op.  We use this method to trigger
     * the expected "conversations:sent" event even though its already been sent and
     * we did nothing.  Use the evt.result property if you want to know whether the
     * result was a new conversation or matching one.
     *
     * @method _handleLocalDistinctConversation
     * @private
     */

  }, {
    key: '_handleLocalDistinctConversation',
    value: function _handleLocalDistinctConversation() {
      var evt = this._sendDistinctEvent;
      this._sendDistinctEvent = null;

      // delay so there is time to setup an event listener on this conversation
      this._triggerAsync('conversations:sent', evt);
      return this;
    }

    /**
     * Gets the data for a Create request.
     *
     * The layer.SyncManager needs a callback to create the Conversation as it
     * looks NOW, not back when `send()` was called.  This method is called
     * by the layer.SyncManager to populate the POST data of the call.
     *
     * @method _getSendData
     * @private
     * @return {Object} Websocket data for the request
     */

  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      var isMetadataEmpty = Util.isEmpty(this.metadata);
      return {
        method: 'Conversation.create',
        data: {
          participants: this.participants,
          distinct: this.distinct,
          metadata: isMetadataEmpty ? null : this.metadata,
          id: this.id
        }
      };
    }

    /**
     * Process result of send method.
     *
     * Note that we use _triggerAsync so that
     * events reporting changes to the layer.Conversation.id can
     * be applied before reporting on it being sent.
     *
     * Example: Query will now have the resolved Distinct IDs rather than the proposed ID
     * when this event is triggered.
     *
     * @method _createResult
     * @private
     * @param  {Object} result
     */

  }, {
    key: '_createResult',
    value: function _createResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      if (this.isDestroyed) return;
      if (success) {
        this._createSuccess(data);
      } else if (data.id === 'conflict') {
        this._populateFromServer(data.data);
        this._triggerAsync('conversations:sent', {
          result: Conversation.FOUND_WITHOUT_REQUESTED_METADATA
        });
      } else {
        this.trigger('conversations:sent-error', { error: data });
        this.destroy();
      }
    }

    /**
     * Process the successful result of a create call
     *
     * @method _createSuccess
     * @private
     * @param  {Object} data Server description of Conversation
     */

  }, {
    key: '_createSuccess',
    value: function _createSuccess(data) {
      this._populateFromServer(data);
      if (!this.distinct) {
        this._triggerAsync('conversations:sent', {
          result: Conversation.CREATED
        });
      } else {
        // Currently the websocket does not tell us if its
        // returning an existing Conversation.  So guess...
        // if there is no lastMessage, then most likely, there was
        // no existing Conversation.  Sadly, API-834; last_message is currently
        // always null.
        this._triggerAsync('conversations:sent', {
          result: !this.lastMessage ? Conversation.CREATED : Conversation.FOUND
        });
      }
    }

    /**
     * Populates this instance using server-data.
     *
     * Side effects add this to the Client.
     *
     * @method _populateFromServer
     * @private
     * @param  {Object} conversation - Server representation of the conversation
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(conversation) {
      var client = this.getClient();

      // Disable events if creating a new Conversation
      // We still want property change events for anything that DOES change
      this._disableEvents = this.syncState === Constants.SYNC_STATE.NEW;

      this._setSynced();

      var id = this.id;
      this.id = conversation.id;

      // IDs change if the server returns a matching Distinct Conversation
      if (id !== this.id) {
        client._updateConversationId(this, id);
        this._triggerAsync('conversations:change', {
          oldValue: id,
          newValue: this.id,
          property: 'id'
        });
      }

      this.url = conversation.url;
      this.participants = conversation.participants;
      this.distinct = conversation.distinct;
      this.createdAt = new Date(conversation.created_at);
      this.metadata = conversation.metadata;
      this.unreadCount = conversation.unread_message_count;
      this.isCurrentParticipant = this.participants.indexOf(client.userId) !== -1;

      client._addConversation(this);

      if (conversation.last_message) {
        this.lastMessage = client._createObject(conversation.last_message);
      } else {
        this.lastMessage = null;
      }

      this._disableEvents = false;
    }

    /**
     * Add an array of participant ids to the conversation.
     *
     *      conversation.addParticipants(['a', 'b']);
     *
     * New participants will immediately show up in the Conversation,
     * but may not have synced with the server yet.
     *
     * TODO WEB-967: Roll participants back on getting a server error
     *
     * @method addParticipants
     * @param  {string[]} participants - Array of participant ids
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'addParticipants',
    value: function addParticipants(participants) {
      var _this3 = this;

      // Only add those that aren't already in the list.
      var adding = participants.filter(function (participant) {
        return _this3.participants.indexOf(participant) === -1;
      });
      this._patchParticipants({ add: adding, remove: [] });
      return this;
    }

    /**
     * Removes an array of participant ids from the conversation.
     *
     *      conversation.removeParticipants(['a', 'b']);
     *
     * Removed participants will immediately be removed from this Conversation,
     * but may not have synced with the server yet.
     *
     * Throws error if you attempt to remove ALL participants.
     *
     * TODO  WEB-967: Roll participants back on getting a server error
     *
     * @method removeParticipants
     * @param  {string[]} participants - Array of participant ids
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'removeParticipants',
    value: function removeParticipants(participants) {
      var _this4 = this;

      var currentParticipants = this.participants.concat([]).sort();
      var removing = participants.filter(function (participant) {
        return _this4.participants.indexOf(participant) !== -1;
      }).sort();
      if (JSON.stringify(currentParticipants) === JSON.stringify(removing)) {
        throw new Error(LayerError.dictionary.moreParticipantsRequired);
      }
      this._patchParticipants({ add: [], remove: removing });
      return this;
    }

    /**
     * Replaces all participants with a new array of of participant ids.
     *
     *      conversation.replaceParticipants(['a', 'b']);
     *
     * Changed participants will immediately show up in the Conversation,
     * but may not have synced with the server yet.
     *
     * TODO WEB-967: Roll participants back on getting a server error
     *
     * @method replaceParticipants
     * @param  {string[]} participants - Array of participant ids
     * @returns {layer.Conversation} this
     */

  }, {
    key: 'replaceParticipants',
    value: function replaceParticipants(participants) {
      if (!participants || !participants.length) {
        throw new Error(LayerError.dictionary.moreParticipantsRequired);
      }

      var change = this._getParticipantChange(participants, this.participants);
      this._patchParticipants(change);
      return this;
    }

    /**
     * Update the server with the new participant list.
     *
     * Executes as follows:
     *
     * 1. Updates the participants property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method _patchParticipants
     * @private
     * @param  {Object[]} operations - Array of JSON patch operation
     * @param  {Object} eventData - Data describing the change for use in an event
     */

  }, {
    key: '_patchParticipants',
    value: function _patchParticipants(change) {
      var _this5 = this;

      this._applyParticipantChange(change);
      this.isCurrentParticipant = this.participants.indexOf(this.getClient().userId) !== -1;

      var ops = [];
      change.remove.forEach(function (id) {
        ops.push({
          operation: 'remove',
          property: 'participants',
          value: id
        });
      });

      change.add.forEach(function (id) {
        ops.push({
          operation: 'add',
          property: 'participants',
          value: id
        });
      });

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(ops),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success) _this5._load();
      });
    }

    /**
     * Internally we use `{add: [], remove: []}` instead of LayerOperations.
     *
     * So control is handed off to this method to actually apply the changes
     * to the participants array.
     *
     * @method _applyParticipantChange
     * @private
     * @param  {Object} change
     * @param  {string[]} change.add - Array of userids to add
     * @param  {string[]} change.remove - Array of userids to remove
     */

  }, {
    key: '_applyParticipantChange',
    value: function _applyParticipantChange(change) {
      var participants = [].concat(this.participants);
      change.add.forEach(function (id) {
        if (participants.indexOf(id) === -1) participants.push(id);
      });
      change.remove.forEach(function (id) {
        var index = participants.indexOf(id);
        if (index !== -1) participants.splice(index, 1);
      });
      this.participants = participants;
    }

    /**
     * Delete the Conversation from the server and removes this user as a participant.
     *
     * @method leave
     * @return null
     */

  }, {
    key: 'leave',
    value: function leave() {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      this._delete('mode=my_devices&leave=true');
    }

    /**
     * Delete the Conversation from the server, but deletion mode may cause user to remain a participant.
     *
     * This call will support various deletion modes.
     *
     * Deletion Modes:
     *
     * * layer.Constants.DELETION_MODE.ALL: This deletes the local copy immediately, and attempts to also
     *   delete the server's copy.
     * * layer.Constants.DELETION_MODE.MY_DEVICES: Deletes the local copy immediately, and attempts to delete it from all
     *   of my devices.  Other users retain access.
     * * true: For backwards compatibility thi is the same as ALL.
     *
     * MY_DEVICES does not remove this user as a participant.  That means a new Message on this Conversation will recreate the
     * Conversation for this user.  See layer.Conversation.leave() instead.
     *
     * Executes as follows:
     *
     * 1. Submits a request to be sent to the server to delete the server's object
     * 2. Delete's the local object
     * 3. If there is an error, no errors are fired except by layer.SyncManager, but the Conversation will be reloaded from the server,
     *    triggering a conversations:add event.
     *
     * @method delete
     * @param {number} deletionMode - layer.Constants.DELETION_MODE.ALL is only supported mode at this time
     * @return null
     */

  }, {
    key: 'delete',
    value: function _delete(mode) {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);

      var queryStr = undefined;
      switch (mode) {
        case Constants.DELETION_MODE.ALL:
        case true:
          queryStr = 'mode=all_participants';
          break;
        case Constants.DELETION_MODE.MY_DEVICES:
          queryStr = 'mode=my_devices&leave=false';
          break;
        default:
          throw new Error(LayerError.dictionary.deletionModeUnsupported);
      }

      this._delete(queryStr);
    }

    /**
     * Delete the Conversation from the server (internal version).
     *
     * This version of Delete takes a Query String that is packaged up by
     * layer.Conversation.delete and layer.Conversation.leave.
     *
     * @method _delete
     * @private
     * @param {string} queryStr - Query string for the DELETE request
     */

  }, {
    key: '_delete',
    value: function _delete(queryStr) {
      var id = this.id;
      var client = this.getClient();
      this._xhr({
        method: 'DELETE',
        url: '?' + queryStr
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found')) Conversation.load(id, client);
      });

      this._deleted();
      this.destroy();
    }

    /**
     * The Conversation has been deleted.
     *
     * Called from WebsocketManager and from layer.Conversation.delete();
     *
     * Destroy must be called separately, and handles most cleanup.
     *
     * @method _deleted
     * @protected
     */

  }, {
    key: '_deleted',
    value: function _deleted() {
      this.trigger('conversations:delete');
    }

    /**
     * Create a new layer.Message instance within this conversation
     *
     *      var message = conversation.createMessage('hello');
     *
     *      var message = conversation.createMessage({
     *          parts: [new layer.MessagePart({
     *                      body: 'hello',
     *                      mimeType: 'text/plain'
     *                  })]
     *      });
     *
     * See layer.Message for more options for creating the message.
     *
     * @method createMessage
     * @param  {string|Object} options - If its a string, a MessagePart is created around that string.
     * @param {layer.MessagePart[]} options.parts - An array of MessageParts.  There is some tolerance for
     *                                               it not being an array, or for it being a string to be turned
     *                                               into a MessagePart.
     * @return {layer.Message}
     */

  }, {
    key: 'createMessage',
    value: function createMessage() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var messageConfig = typeof options === 'string' ? {
        parts: [{ body: options, mimeType: 'text/plain' }]
      } : options;
      messageConfig.clientId = this.clientId;
      messageConfig.conversationId = this.id;

      return new Message(messageConfig);
    }

    /**
     * Accepts json-patch operations for modifying participants or metadata
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      // Certain types of __update handlers are disabled while values are being set by
      // layer patch parser because the difference between setting a value (triggers an event)
      // and change a property of a value (triggers only this callback) result in inconsistent
      // behaviors.  Enable them long enough to allow __update calls to be made
      this._inLayerParser = false;
      try {
        var events = this._disableEvents;
        this._disableEvents = false;
        if (paths[0].indexOf('metadata') === 0) {
          this.__updateMetadata(newValue, oldValue, paths);
        } else if (paths[0] === 'participants') {
          this.__updateParticipants(newValue, oldValue);
        }
        this._disableEvents = events;
      } catch (err) {
        // do nothing
      }
      this._inLayerParser = true;
    }

    /**
     * Given the oldValue and newValue for participants,
     * generate a list of whom was added and whom was removed.
     *
     * @method _getParticipantChange
     * @private
     * @param  {string[]} newValue
     * @param  {string[]} oldValue
     * @return {Object} Returns changes in the form of `{add: [...], remove: [...]}`
     */

  }, {
    key: '_getParticipantChange',
    value: function _getParticipantChange(newValue, oldValue) {
      var change = {};
      change.add = newValue.filter(function (participant) {
        return oldValue.indexOf(participant) === -1;
      });
      change.remove = oldValue.filter(function (participant) {
        return newValue.indexOf(participant) === -1;
      });
      return change;
    }

    /**
     * Updates specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.setMetadataProperties({
     *          'title': 'I am a title',
     *          'colors.background': 'red',
     *          'colors.text': {
     *              'fill': 'blue',
     *              'shadow': 'black'
     *           },
     *           'colors.title.fill': 'red'
     *      });
     *
     * Use setMetadataProperties to specify the path to a property, and a new value for that property.
     * Multiple properties can be changed this way.  Whatever value was there before is
     * replaced with the new value; so in the above example, whatever other keys may have
     * existed under `colors.text` have been replaced by the new object `{fill: 'blue', shadow: 'black'}`.
     *
     * Note also that only string and subobjects are accepted as values.
     *
     * Keys with '.' will update a field of an object (and create an object if it wasn't there):
     *
     * Initial metadata: {}
     *
     *      conversation.setMetadataProperties({
     *          'colors.background': 'red',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red'}}`
     *
     *      conversation.setMetadataProperties({
     *          'colors.foreground': 'black',
     *      });
     *
     * Metadata is now: `{colors: {background: 'red', foreground: 'black'}}`
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method setMetadataProperties
     * @param  {Object} properties
     * @return {layer.Conversation} this
     *
     */

  }, {
    key: 'setMetadataProperties',
    value: function setMetadataProperties(props) {
      var _this6 = this;

      var layerPatchOperations = [];
      Object.keys(props).forEach(function (name) {
        var fullName = name;
        if (name) {
          if (name !== 'metadata' && name.indexOf('metadata.') !== 0) {
            fullName = 'metadata.' + name;
          }
          layerPatchOperations.push({
            operation: 'set',
            property: fullName,
            value: props[name]
          });
        }
      });

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success) _this6._load();
      });

      return this;
    }

    /**
     * Deletes specified metadata keys.
     *
     * Updates the local object's metadata and syncs the change to the server.
     *
     *      conversation.deleteMetadataProperties(
     *          ['title', 'colors.background', 'colors.title.fill']
     *      );
     *
     * Use deleteMetadataProperties to specify paths to properties to be deleted.
     * Multiple properties can be deleted.
     *
     * Executes as follows:
     *
     * 1. Updates the metadata property of the local object
     * 2. Triggers a conversations:change event
     * 3. Submits a request to be sent to the server to update the server's object
     * 4. If there is an error, no errors are fired except by layer.SyncManager, but another
     *    conversations:change event is fired as the change is rolled back.
     *
     * @method deleteMetadataProperties
     * @param  {string[]} properties
     * @return {layer.Conversation}
     *
     */

  }, {
    key: 'deleteMetadataProperties',
    value: function deleteMetadataProperties(props) {
      var _this7 = this;

      var layerPatchOperations = [];
      props.forEach(function (property) {
        if (property !== 'metadata' && property.indexOf('metadata.') !== 0) {
          property = 'metadata.' + property;
        }
        layerPatchOperations.push({
          operation: 'delete',
          property: property
        });
      }, this);

      this._inLayerParser = true;

      // Do this before setSyncing as if there are any errors, we should never even
      // start setting up a request.
      Util.layerParse({
        object: this,
        type: 'Conversation',
        operations: layerPatchOperations,
        client: this.getClient()
      });
      this._inLayerParser = false;

      this._xhr({
        url: '',
        method: 'PATCH',
        data: JSON.stringify(layerPatchOperations),
        headers: {
          'content-type': 'application/vnd.layer-patch+json'
        }
      }, function (result) {
        if (!result.success) _this7._load();
      });

      return this;
    }

    /**
     * Any xhr method called on this conversation uses the conversation's url.
     *
     * For details on parameters see {@link layer.ClientAuthenticator#xhr}
     *
     * @method _xhr
     * @protected
     * @return {layer.Conversation} this
     */

  }, {
    key: '_xhr',
    value: function _xhr(args, callback) {
      var _this8 = this;

      var client = this.getClient();

      // Validation
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      if (!client) throw new Error(LayerError.dictionary.clientMissing);
      if (!('url' in args)) throw new Error(LayerError.dictionary.urlRequired);
      if (args.method !== 'POST' && this.syncState === Constants.SYNC_STATE.NEW) return this;

      if (args.sync !== false) {
        if (!args.sync) args.sync = {};
        if (!args.sync.target) {
          args.sync.target = this.id;
        }
      }

      if (args.url && !args.url.match(/^(\/|\?)/)) args.url = '/' + args.url;
      if (!args.sync) args.url = this.url + args.url;

      if (args.method && args.method !== 'GET') {
        this._setSyncing();
      }

      client.xhr(args, function (result) {
        if (args.method && args.method !== 'GET' && !_this8.isDestroyed) {
          _this8._setSynced();
        }
        if (callback) callback(result);
      });

      return this;
    }
  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.getClient()._addConversation(this);
    }

    /**
     * Standard `on()` provided by layer.Root.
     *
     * Adds some special handling of 'conversations:loaded' so that calls such as
     *
     *      var c = client.getConversation('layer:///conversations/123', true)
     *      .on('conversations:loaded', function() {
     *          myrerender(c);
     *      });
     *      myrender(c); // render a placeholder for c until the details of c have loaded
     *
     * can fire their callback regardless of whether the client loads or has
     * already loaded the Conversation.
     *
     * @method on
     * @param  {string} eventName
     * @param  {Function} callback
     * @param  {Object} context
     * @return {layer.Conversation} this
     */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var hasLoadedEvt = name === 'conversations:loaded' || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name['conversations:loaded'];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === 'conversations:loaded' ? callback : name['conversations:loaded'];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Conversation.prototype), 'on', this).call(this, name, callback, context);

      return this;
    }

    /*
     * Insure that conversation.unreadCount-- can never reduce the value to negative values.
     */

  }, {
    key: '__adjustUnreadCount',
    value: function __adjustUnreadCount(newValue) {
      if (newValue < 0) return 0;
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the unreadCount property will call this method and fire a
     * change event.
     *
     * Any triggering of this from a websocket patch unread_message_count should wait a second before firing any events
     * so that if there are a series of these updates, we don't see a lot of jitter.
     *
     * NOTE: _oldUnreadCount is used to pass data to _updateUnreadCountEvent because this method can be called many times
     * a second, and we only want to trigger this with a summary of changes rather than each individual change.
     *
     * @method __updateUnreadCount
     * @private
     * @param  {number} newValue
     * @param  {number} oldValue
     */

  }, {
    key: '__updateUnreadCount',
    value: function __updateUnreadCount(newValue, oldValue) {
      var _this9 = this;

      if (this._inLayerParser) {
        if (this._oldUnreadCount === undefined) this._oldUnreadCount = oldValue;
        if (this._updateUnreadCountTimeout) clearTimeout(this._updateUnreadCountTimeout);
        this._updateUnreadCountTimeout = setTimeout(function () {
          return _this9._updateUnreadCountEvent();
        }, 1000);
      } else {
        this._updateUnreadCountEvent();
      }
    }

    /**
     * Fire events related to changes to unreadCount
     *
     * @method _updateUnreadCountEvent
     * @private
     */

  }, {
    key: '_updateUnreadCountEvent',
    value: function _updateUnreadCountEvent() {
      if (this.isDestroyed) return;
      var oldValue = this._oldUnreadCount;
      var newValue = this.__unreadCount;
      this._oldUnreadCount = undefined;

      if (newValue === oldValue) return;
      this._triggerAsync('conversations:change', {
        newValue: newValue,
        oldValue: oldValue,
        property: 'unreadCount'
      });
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the lastMessage pointer will call this method and fire a
     * change event.  Changes to properties within the lastMessage object will
     * not trigger this call.
     *
     * @method __updateLastMessage
     * @private
     * @param  {layer.Message} newValue
     * @param  {layer.Message} oldValue
     */

  }, {
    key: '__updateLastMessage',
    value: function __updateLastMessage(newValue, oldValue) {
      if (newValue && oldValue && newValue.id === oldValue.id) return;
      this._triggerAsync('conversations:change', {
        property: 'lastMessage',
        newValue: newValue,
        oldValue: oldValue
      });
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the participants property will call this method and fire a
     * change event.  Changes to the participants array that don't replace the array
     * with a new array will require directly calling this method.
     *
     * @method __updateParticipants
     * @private
     * @param  {string[]} newValue
     * @param  {string[]} oldValue
     */

  }, {
    key: '__updateParticipants',
    value: function __updateParticipants(newValue, oldValue) {
      if (this._inLayerParser) return;
      var change = this._getParticipantChange(newValue, oldValue);
      if (change.add.length || change.remove.length) {
        change.property = 'participants';
        change.oldValue = oldValue;
        change.newValue = newValue;
        this._triggerAsync('conversations:change', change);
      }
    }

    /**
     * __ Methods are automatically called by property setters.
     *
     * Any change in the metadata property will call this method and fire a
     * change event.  Changes to the metadata object that don't replace the object
     * with a new object will require directly calling this method.
     *
     * @method __updateMetadata
     * @private
     * @param  {Object} newValue
     * @param  {Object} oldValue
     */

  }, {
    key: '__updateMetadata',
    value: function __updateMetadata(newValue, oldValue, paths) {
      if (this._inLayerParser) return;
      if (JSON.stringify(newValue) !== JSON.stringify(oldValue)) {
        this._triggerAsync('conversations:change', {
          property: 'metadata',
          newValue: newValue,
          oldValue: oldValue,
          paths: paths
        });
      }
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Conversation instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Conversation.prototype), 'toObject', this).call(this);
        this._toObject.metadata = Util.clone(this.metadata);
        this._toObject.isNew = this.isNew();
        this._toObject.isSaving = this.isSaving();
        this._toObject.isSaved = this.isSaved();
        this._toObject.isSynced = this.isSynced();
      }
      return this._toObject;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Conversation.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Conversation.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Create a conversation instance from a server representation of the conversation.
     *
     * If the Conversation already exists, will update the existing copy with
     * presumably newer values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} conversation - Server representation of a Conversation
     * @param  {layer.Client} client [description]
     * @return {layer.Conversation}        [description]
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(conversation, client) {
      // If the Conversation already exists in cache, update the cache
      return new Conversation({
        client: client,
        fromServer: conversation,
        _fromDB: conversation._fromDB
      });
    }

    /**
     * Find or create a new converation.
     *
     *      var conversation = layer.Conversation.create({
     *          participants: ['a', 'b'],
     *          distinct: true,
     *          metadata: {
     *              title: 'I am not a title!'
     *          },
     *          client: client,
     *          'conversations:loaded': function(evt) {
     *
     *          }
     *      });
     *
     * Only tries to find a Conversation if its a Distinct Conversation.
     * Distinct defaults to true.
     *
     * Recommend using `client.createConversation({...})`
     * instead of `Conversation.create({...})`.
     *
     * @method create
     * @static
     * @protected
     * @param  {Object} options
     * @param  {layer.Client} options.client
     * @param  {string[]} options.participants - Array of participant ids
     * @param {boolean} [options.distinct=false] - Create a distinct conversation
     * @param {Object} [options.metadata={}] - Initial metadata for Conversation
     * @return {layer.Conversation}
     */

  }, {
    key: 'create',
    value: function create(options) {
      if (!options.client) throw new Error(LayerError.dictionary.clientMissing);
      if (options.distinct) {
        var conv = this._createDistinct(options);
        if (conv) return conv;
      }

      return new Conversation(options);
    }

    /**
     * Create or Find a Distinct Conversation.
     *
     * If the static Conversation.create method gets a request for a Distinct Conversation,
     * see if we have one cached.
     *
     * Will fire the 'conversations:loaded' event if one is provided in this call,
     * and a Conversation is found.
     *
     * @method _createDistinct
     * @static
     * @private
     * @param  {Object} options - See layer.Conversation.create options
     * @return {layer.Conversation}
     */

  }, {
    key: '_createDistinct',
    value: function _createDistinct(options) {
      if (options.participants.indexOf(options.client.userId) === -1) {
        options.participants.push(options.client.userId);
      }

      var participants = options.participants.sort();
      var pString = participants.join(',');

      var conv = options.client.findCachedConversation(function (aConv) {
        if (aConv.distinct && aConv.participants.length === participants.length) {
          var participants2 = aConv.participants.sort();
          return participants2.join(',') === pString;
        }
      });

      if (conv) {
        conv._sendDistinctEvent = new LayerEvent({
          target: conv,
          result: !options.metadata || Util.doesObjectMatch(options.metadata, conv.metadata) ? Conversation.FOUND : Conversation.FOUND_WITHOUT_REQUESTED_METADATA
        }, 'conversations:sent');
        return conv;
      }
    }

    /**
     * Identifies whether a Conversation receiving the specified patch data should be loaded from the server.
     *
     * Any change to a Conversation indicates that the Conversation is active and of potential interest; go ahead and load that
     * Conversation in case the app has need of it.  In the future we may ignore changes to unread count.  Only relevant
     * when we get Websocket events for a Conversation that has not been loaded/cached on Client.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }, {
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return true;
    }
  }]);

  return Conversation;
}(Syncable);

/**
 * Array of participant ids.
 *
 * Do not directly manipulate;
 * use addParticipants, removeParticipants and replaceParticipants
 * to manipulate the array.
 *
 * @type {string[]}
 */


Conversation.prototype.participants = null;

/**
 * layer.Client that the conversation belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */
Conversation.prototype.clientId = '';

/**
 * Time that the conversation was created on the server.
 *
 * @type {Date}
 */
Conversation.prototype.createdAt = null;

/**
 * Conversation unique identifier.
 *
 * @type {string}
 */
Conversation.prototype.id = '';

/**
 * URL to access the conversation on the server.
 *
 * @type {string}
 */
Conversation.prototype.url = '';

/**
 * Number of unread messages in the conversation.
 *
 * @type {number}
 */
Conversation.prototype.unreadCount = 0;

/**
 * This is a Distinct Conversation.
 *
 * You can have 1 distinct conversation among a set of participants.
 * There are no limits to how many non-distinct Conversations you have have
 * among a set of participants.
 *
 * @type {boolean}
 */
Conversation.prototype.distinct = true;

/**
 * Metadata for the conversation.
 *
 * Metadata values can be plain objects and strings, but
 * no arrays, numbers, booleans or dates.
 * @type {Object}
 */
Conversation.prototype.metadata = null;

/**
 * Time that the conversation object was instantiated
 * in the current client.
 * @type {Date}
 */
Conversation.prototype.localCreatedAt = null;

/**
 * The authenticated user is a current participant in this Conversation.
 *
 * Set to false if the authenticated user has been removed from this conversation.
 *
 * A removed user can see messages up to the time they were removed,
 * but can no longer interact with the conversation.
 *
 * A removed user can no longer see the participant list.
 *
 * Read and Delivery receipts will fail on any Message in such a Conversation.
 *
 * @type {Boolean}
 */
Conversation.prototype.isCurrentParticipant = true;

/**
 * The last layer.Message to be sent/received for this Conversation.
 *
 * Value may be a Message that has been locally created but not yet received by server.
 * @type {layer.Message}
 */
Conversation.prototype.lastMessage = null;

/**
 * Caches last result of toObject()
 * @type {Object}
 * @private
 */
Conversation.prototype._toObject = null;

Conversation.eventPrefix = 'conversations';

/**
 * Cache's a Distinct Event.
 *
 * On creating a Distinct Conversation that already exists,
 * when the send() method is called, we should trigger
 * specific events detailing the results.  Results
 * may be determined locally or on the server, but same Event may be needed.
 *
 * @type {layer.LayerEvent}
 * @private
 */
Conversation.prototype._sendDistinctEvent = null;

Conversation.prototype._fromDB = false;

/**
 * Prefix to use when generating an ID for instances of this class
 * @type {String}
 * @static
 * @private
 */
Conversation.prefixUUID = 'layer:///conversations/';

/**
 * Property to look for when bubbling up events.
 * @type {String}
 * @static
 * @private
 */
Conversation.bubbleEventParent = 'getClient';

/**
 * The Conversation that was requested has been created.
 *
 * Used in 'conversations:sent' events.
 * @type {String}
 * @static
 */
Conversation.CREATED = 'Created';

/**
 * The Conversation that was requested has been found.
 *
 * This means that it did not need to be created.
 *
 * Used in 'conversations:sent' events.
 * @type {String}
 * @static
 */
Conversation.FOUND = 'Found';

/**
 * The Conversation that was requested has been found, but there was a mismatch in metadata.
 *
 * If the createConversation request contained metadata and it did not match the Distinct Conversation
 * that matched the requested participants, then this value is passed to notify your app that the Conversation
 * was returned but does not exactly match your request.
 *
 * Used in 'conversations:sent' events.
 * @type {String}
 * @static
 */
Conversation.FOUND_WITHOUT_REQUESTED_METADATA = 'FoundMismatch';

Conversation._supportedEvents = [

/**
 * The conversation is now on the server.
 *
 * Called after successfully creating the conversation
 * on the server.  The Result property is one of:
 *
 * * Conversation.CREATED: A new Conversation has been created
 * * Conversation.FOUND: A matching Distinct Conversation has been found
 * * Conversation.FOUND_WITHOUT_REQUESTED_METADATA: A matching Distinct Conversation has been found
 *                       but note that the metadata is NOT what you requested.
 *
 * All of these results will also mean that the updated property values have been
 * copied into your Conversation object.  That means your metadata property may no
 * longer be its initial value; it may be the value found on the server.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {string} event.result
 */
'conversations:sent',

/**
 * An attempt to send this conversation to the server has failed.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'conversations:sent-error',

/**
 * The conversation is now loaded from the server.
 *
 * Note that this is only used in response to the layer.Conversation.load() method.
 * from the server.
 * @event
 * @param {layer.LayerEvent} event
 */
'conversations:loaded',

/**
 * An attempt to load this conversation from the server has failed.
 *
 * Note that this is only used in response to the layer.Conversation.load() method.
 * @event
 * @param {layer.LayerEvent} event
 * @param {layer.LayerError} event.error
 */
'conversations:loaded-error',

/**
 * The conversation has been deleted from the server.
 *
 * Caused by either a successful call to delete() on this instance
 * or by a remote user.
 * @event
 * @param {layer.LayerEvent} event
 */
'conversations:delete',

/**
 * This conversation has changed.
 *
 * @event
 * @param {layer.LayerEvent} event
 * @param {Object[]} event.changes - Array of changes reported by this event
 * @param {Mixed} event.changes.newValue
 * @param {Mixed} event.changes.oldValue
 * @param {string} event.changes.property - Name of the property that changed
 * @param {layer.Conversation} event.target
 */
'conversations:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Conversation, [Conversation, 'Conversation']);
Syncable.subclasses.push(Conversation);
module.exports = Conversation;

},{"./client-registry":9,"./client-utils":10,"./const":12,"./layer-error":16,"./layer-event":17,"./logger":18,"./message":20,"./root":24,"./syncable":27}],15:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Persistence manager.
 *
 * This class manages all indexedDB access.  It is not responsible for any localStorage access, though it may
 * receive configurations related to data stored in localStorage.  It will simply ignore those configurations.
 *
 * TODO:
 * 0. Redesign this so that knowledge of the data is not hard-coded in
 * 1. JSDuck this class
 * 2. Update documentation repo
 * @class layer.db-manager
 * @protected
 */

var DB_VERSION = 13;
var Root = require('./root');
var logger = require('./logger');
var SyncEvent = require('./sync-event');
var Constants = require('./const');
var Util = require('./client-utils');

function getDate(inDate) {
  return inDate ? inDate.toISOString() : null;
}

var DbManager = function (_Root) {
  _inherits(DbManager, _Root);

  /**
   * Create the DB Manager
   *
   * Key configuration is the layer.DbManager.persistenceFeatures property.
   *
   * @param {Object} options
   * @param {layer.Client} options.client
   * @param {Object} options.persistenceFeatures
   * @return {layer.DbManager} this
   */

  function DbManager(options) {
    _classCallCheck(this, DbManager);

    // If Client is a layer.ClientAuthenticator, it won't support these events; this affects Unit Tests

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DbManager).call(this, options));

    if (_this.client.constructor._supportedEvents.indexOf('conversations:add') !== -1) {
      _this.client.on('conversations:add', function (evt) {
        return _this.writeConversations(evt.conversations, false);
      });
      _this.client.on('conversations:change', function (evt) {
        return _this.writeConversations([evt.target], true);
      });
      _this.client.on('conversations:delete', function (evt) {
        return _this.deleteObjects('conversations', [evt.target]);
      });

      _this.client.on('messages:add', function (evt) {
        return _this.writeMessages(evt.messages, false);
      });
      _this.client.on('messages:change', function (evt) {
        return _this.writeMessages([evt.target], true);
      });
      _this.client.on('messages:delete', function (evt) {
        return _this.deleteObjects('messages', [evt.target]);
      });
    }

    _this.client.syncManager.on('sync:add', function (evt) {
      return _this.writeSyncEvents([evt.request], false);
    });
    _this.client.syncManager.on('sync:abort sync:error', function (evt) {
      return _this.deleteObjects('syncQueue', [evt.request]);
    });

    // If no indexedDB, treat everything as disabled.
    if (!window.indexedDB) {
      _this.tables = {
        identities: true,
        conversations: true,
        messages: true,
        syncQueue: true
      };
    }

    // Sync Queue only really works properly if we have the Messages and Conversations written to the DB; turn it off
    // if that won't be the case.
    if (!_this.tables.conversations || !_this.tables.messages) {
      _this.tables.syncQueue = false;
    }
    _this._open();
    return _this;
  }

  /**
   * Open the Database Connection.
   *
   * This is only called by the constructor.
   * @method _open
   * @private
   */


  _createClass(DbManager, [{
    key: '_open',
    value: function _open() {
      var _this2 = this;

      // Abort if all tables are disabled
      if (Object.keys(this.tables).filter(function (key) {
        return _this2.tables[key];
      }).length === 0) return;

      // Open the database
      var request = window.indexedDB.open('LayerWebSDK_' + this.client.appId + '_' + this.client.userId, DB_VERSION);

      request.onerror = function (evt) {
        return console.error('Database Unable to Open: ', evt.target.error);
      };
      request.onupgradeneeded = function (evt) {
        return _this2._onUpgradeNeeded(evt);
      };
      request.onsuccess = function (evt) {
        _this2.db = evt.target.result;
        _this2.isOpen = true;
        _this2.trigger('open');

        _this2.db.onversionchange = function () {
          _this2.db.close();
          _this2.isOpen = false;
        };

        _this2.db.error = function (err) {
          logger.error('db-manager Error: ', err);
        };
      };
    }

    /**
     * Use this to setup a call to happen as soon as the database is open.
     *
     * Typically, this call will immediately, synchronously call your callback.
     * But if the DB is not open yet, your callback will be called once its open.
     * @method onOpen
     * @param {Function} callback
     */

  }, {
    key: 'onOpen',
    value: function onOpen(callback) {
      if (this.isOpen) callback();else this.once('open', callback);
    }

    /**
     * The onUpgradeNeeded function is called by IndexedDB any time DB_VERSION is incremented.
     *
     * This invocation is part of the built-in lifecycle of IndexedDB.
     *
     * @method _onUpgradeNeeded
     * @param {IDBVersionChangeEvent} event
     * @private
     */
    /* istanbul ignore next */

  }, {
    key: '_onUpgradeNeeded',
    value: function _onUpgradeNeeded(event) {
      var db = event.target.result;
      try {
        db.deleteObjectStore('conversations');
      } catch (e) {
        // Noop
      }
      try {
        db.deleteObjectStore('identities');
      } catch (e) {
        // Noop
      }
      try {
        db.deleteObjectStore('messages');
      } catch (e) {
        // Noop
      }
      try {
        db.deleteObjectStore('syncQueue');
      } catch (e) {
        // Noop
      }
      var stores = [db.createObjectStore('conversations', { keyPath: 'id' }), db.createObjectStore('messages', { keyPath: 'id' }), db.createObjectStore('identities', { keyPath: 'id' }), db.createObjectStore('syncQueue', { keyPath: 'id' })];

      stores[1].createIndex('conversation', 'conversation', { unique: false });

      var completeCount = 0;
      function onComplete() {
        completeCount++;
        if (completeCount === stores.length) {
          this.isOpen = true;
          this.trigger('open');
        }
      }

      stores.forEach(function (store) {
        return store.transaction.oncomplete = onComplete;
      });
    }

    /**
     * Convert array of Conversation instances into Conversation DB Entries.
     *
     * A Conversation DB entry looks a lot like the server representation, but
     * includes a sync_state property, and `last_message` contains a message ID not
     * a Message object.
     *
     * @method _getConversationData
     * @private
     * @param {layer.Conversation[]} conversations
     * @return {Object[]} conversations
     */

  }, {
    key: '_getConversationData',
    value: function _getConversationData(conversations) {
      return conversations.filter(function (conversation) {
        if (conversation._fromDB) {
          conversation._fromDB = false;
          return false;
        } else if (conversation.isLoading) {
          return false;
        } else {
          return true;
        }
      }).map(function (conversation) {
        var item = {
          id: conversation.id,
          url: conversation.url,
          participants: conversation.participants,
          distinct: conversation.distinct,
          created_at: getDate(conversation.createdAt),
          metadata: conversation.metadata,
          unread_message_count: conversation.unreadCount,
          last_message: conversation.lastMessage ? conversation.lastMessage.id : '',
          sync_state: conversation.syncState
        };
        return item;
      });
    }

    /**
     * Writes an array of Conversations to the Database.
     *
     * There are times when you will not know if this is an Insert or Update operation;
     * if there is uncertainy, set `isUpdate` to false, and the correct end result will
     * still be achieved (but less efficiently).
     *
     * @method writeConversations
     * @param {layer.Conversation[]} conversations - Array of Conversations to write
     * @param {boolean} isUpdate - If true, then update an entry; if false, insert an entry... and if one is found to already exist, update it.
     * @param {Function} [callback]
     */

  }, {
    key: 'writeConversations',
    value: function writeConversations(conversations, isUpdate, callback) {
      this._writeObjects('conversations', this._getConversationData(conversations.filter(function (conversation) {
        return !conversation.isDestroyed;
      })), isUpdate, callback);
    }

    /**
     * Convert array of Message instances into Message DB Entries.
     *
     * A Message DB entry looks a lot like the server representation, but
     * includes a sync_state property.
     *
     * @method _getMessageData
     * @private
     * @param {layer.Message[]} messages
     * @return {Object[]} messages
     */

  }, {
    key: '_getMessageData',
    value: function _getMessageData(messages) {
      return messages.filter(function (message) {
        if (message._fromDB) {
          message._fromDB = false;
          return false;
        } else if (message.syncState === Constants.SYNC_STATE.LOADING) {
          return false;
        } else {
          return true;
        }
      }).map(function (message) {
        return {
          id: message.id,
          url: message.url,
          parts: message.parts.map(function (part) {
            return {
              id: part.id,
              body: part.body,
              encoding: part.encoding,
              mime_type: part.mimeType,
              content: !part._content ? null : {
                id: part._content.id,
                download_url: part._content.downloadUrl,
                expiration: part._content.expiration,
                refresh_url: part._content.refreshUrl,
                size: part._content.size
              }
            };
          }),
          position: message.position,
          sender: {
            name: message.sender.name,
            user_id: message.sender.userId
          },
          recipient_status: message.recipientStatus,
          sent_at: getDate(message.sentAt),
          received_at: getDate(message.receivedAt),
          conversation: message.constructor.prefixUUID === 'layer:///announcements/' ? 'announcement' : message.conversationId,
          sync_state: message.syncState
        };
      });
    }

    /**
     * Writes an array of Messages to the Database.
     *
     * There are times when you will not know if this is an Insert or Update operation;
     * if there is uncertainy, set `isUpdate` to false, and the correct end result will
     * still be achieved (but less efficiently).
     *
     * @method writeMessages
     * @param {layer.Message[]} messages - Array of Messages to write
     * @param {boolean} isUpdate - If true, then update an entry; if false, insert an entry... and if one is found to already exist, update it.
     * @param {Function} [callback]
     */

  }, {
    key: 'writeMessages',
    value: function writeMessages(messages, isUpdate, callback) {
      this._writeObjects('messages', this._getMessageData(messages.filter(function (message) {
        return !message.isDestroyed;
      })), isUpdate, callback);
    }

    /**
     * Convert array of SyncEvent instances into SyncEvent DB Entries.
     *
     * @method _getSyncEventData
     * @param {layer.SyncEvent[]} syncEvents
     * @return {Object[]} syncEvents
     * @private
     */

  }, {
    key: '_getSyncEventData',
    value: function _getSyncEventData(syncEvents) {
      return syncEvents.filter(function (syncEvt) {
        if (syncEvt.fromDB) {
          syncEvt.fromDB = false;
          return false;
        } else {
          return true;
        }
      }).map(function (syncEvent) {
        var item = {
          id: syncEvent.id,
          target: syncEvent.target,
          depends: syncEvent.depends,
          isWebsocket: syncEvent instanceof SyncEvent.WebsocketSyncEvent,
          operation: syncEvent.operation,
          data: syncEvent.data,
          url: syncEvent.url || '',
          headers: syncEvent.headers || null,
          method: syncEvent.method || null,
          created_at: syncEvent.createdAt
        };
        return item;
      });
    }

    /**
     * Writes an array of SyncEvent to the Database.
     *
     * @method writeSyncEvents
     * @param {layer.SyncEvent[]} syncEvents - Array of Sync Events to write
     * @param {boolean} isUpdate - If true, then update an entry; if false, insert an entry... and if one is found to already exist, update it.
     * @param {Function} [callback]
     */

  }, {
    key: 'writeSyncEvents',
    value: function writeSyncEvents(syncEvents, isUpdate, callback) {
      this._writeObjects('syncQueue', this._getSyncEventData(syncEvents), isUpdate, callback);
    }

    /**
     * Write an array of data to the specified Database table.
     *
     * @method _writeObjects
     * @param {string} tableName - The name of the table to write to
     * @param {Object[]} data - Array of POJO data to write
     * @param {Boolean} isUpdate - If true, then update an entry; if false, insert an entry... and if one is found to already exist, update it.
     * @param {Function} [callback] - Called when all data is written
     * @protected
     */

  }, {
    key: '_writeObjects',
    value: function _writeObjects(tableName, data, isUpdate, callback) {
      var _this3 = this;

      // Just quit if no data to write
      if (!data.length) {
        if (callback) callback();
        return;
      }

      // transactionComplete will call the callback after all writes are done.
      // Note that the number of transactions is 1 + number of failed inserts
      var transactionCount = 1,
          transactionCompleteCount = 0;
      function transactionComplete() {
        transactionCompleteCount++;
        if (transactionCompleteCount === transactionCount && callback) callback();
      }

      // PUT (udpate) or ADD (insert) each item of data one at a time, but all as part of one large transaction.
      this.onOpen(function () {
        var transaction = _this3.db.transaction([tableName], 'readwrite');
        var store = transaction.objectStore(tableName);
        transaction.oncomplete = transaction.onerror = transactionComplete;

        data.forEach(function (item) {
          var req = isUpdate ? store.put(item) : store.add(item);

          // If the request fails, and we were doing an insert, try an update instead.
          // This will create one transaction per error.
          // TODO: Investigate capturing all errors and then using a single transaction to update all failed items.
          req.onerror = function () {
            if (!isUpdate) {
              transactionCount++;
              var transaction2 = _this3.db.transaction([tableName], 'readwrite');
              var store2 = transaction2.objectStore(tableName);
              transaction2.oncomplete = transaction2.onerror = transactionComplete;
              store2.put(item);
            }
          };
        });
      });
    }

    /**
     * Load all conversations from the database.
     *
     * @method loadConversations
     * @param {Function} callback
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: 'loadConversations',
    value: function loadConversations(callback) {
      var _this4 = this;

      // Step 1: Get all Conversations
      this._loadAll('conversations', function (data) {

        // Step 2: Gather all Message IDs needed to initialize these Conversation's lastMessage properties.
        var messagesToLoad = data.map(function (item) {
          return item.last_message;
        }).filter(function (messageId) {
          return messageId && !_this4.client.getMessage(messageId);
        });

        // Step 3: Load all Messages needed to initialize these Conversation's lastMessage properties.
        _this4.getObjects('messages', messagesToLoad, function (messages) {
          _this4._loadConversationsResult(data, messages, callback);
        });
      });
    }

    /**
     * Assemble all LastMessages and Conversation POJOs into layer.Message and layer.Conversation instances.
     *
     * @method _loadConversationsResult
     * @private
     * @param {Object[]} conversations
     * @param {Object[]} messages
     * @param {Function} callback
     * @param {layer.Conversation[]} callback.result
     */

  }, {
    key: '_loadConversationsResult',
    value: function _loadConversationsResult(conversations, messages, callback) {
      var _this5 = this;

      // Instantiate and Register each Message
      messages.forEach(function (message) {
        return _this5._createMessage(message);
      });

      // Instantiate and Register each Conversation; will find any lastMessage that was registered.
      conversations.forEach(function (conversation) {
        return _this5._createConversation(conversation);
      });
      var newData = conversations.map(function (conversation) {
        return _this5.client.getConversation(conversation.id);
      }).filter(function (conversation) {
        return conversation;
      });

      // Return the data
      if (callback) callback(newData);
    }

    /**
     * Load all messages for a given Conversation ID from the database.
     *
     * Use _loadAll if loading All Messages rather than all Messages for a Conversation.
     *
     * @method loadMessages
     * @param {string} conversationId - ID of the Conversation whose Messages are of interest.
     * @param {Function} callback
     * @param {layer.Message[]} callback.result
     */

  }, {
    key: 'loadMessages',
    value: function loadMessages(conversationId, callback) {
      var _this6 = this;

      this._loadByIndex('messages', 'conversation', conversationId, function (data) {
        _this6._loadMessagesResult(data, callback);
      });
    }

    /**
     * Load all Announcements from the database.
     *
     * @method loadAnnouncements
     * @param {Function} callback
     * @param {layer.Announcement[]} callback.result
     */

  }, {
    key: 'loadAnnouncements',
    value: function loadAnnouncements(callback) {
      var _this7 = this;

      this._loadByIndex('messages', 'conversation', 'announcement', function (data) {
        _this7._loadMessagesResult(data, callback);
      });
    }

    /**
     * Registers and sorts the message objects from the database.
     *
     * TODO: Encode limits on this, else we are sorting tens of thousands
     * of messages in javascript.
     *
     * @method _loadMessagesResult
     * @private
     * @param {Object[]} Message objects from the database.
     * @param {Function} callback
     * @param {layer.Message} callback.result - Message instances created from the database
     */

  }, {
    key: '_loadMessagesResult',
    value: function _loadMessagesResult(messages, callback) {
      var _this8 = this;

      // Instantiate and Register each Message
      messages.forEach(function (message) {
        return _this8._createMessage(message);
      });

      // Retrieve all Messages registered or preregistered in this way
      var newData = messages.map(function (message) {
        return _this8.client.getMessage(message.id);
      }).filter(function (message) {
        return message;
      });

      // Sort the results by position
      Util.sortBy(newData, function (item) {
        return item.position;
      });

      // Return the results
      if (callback) callback(newData);
    }

    /**
     * Instantiate and Register the Conversation from a conversation DB Entry.
     *
     * If the layer.Conversation already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * Attempts to assign the lastMessage property to refer to appropriate Message.  If it fails,
     * it will be set to null.
     *
     * @method _createConversation
     * @param {Object} conversation
     * @returns {layer.Conversation}
     */

  }, {
    key: '_createConversation',
    value: function _createConversation(conversation) {
      if (!this.client.getConversation(conversation.id)) {
        conversation._fromDB = true;
        var lastMessage = conversation.last_message;
        conversation.last_message = '';
        var newConversation = this.client._createObject(conversation);
        newConversation.syncState = conversation.sync_state;
        newConversation.lastMessage = this.client.getMessage(lastMessage) || null;
        return newConversation;
      }
    }

    /**
     * Instantiate and Register the Message from a message DB Entry.
     *
     * If the layer.Message already exists, then its presumed that whatever is in
     * javascript cache is more up to date than whats in IndexedDB cache.
     *
     * @method _createMessage
     * @param {Object} message
     * @returns {layer.Message}
     */

  }, {
    key: '_createMessage',
    value: function _createMessage(message) {
      if (!this.client.getMessage(message.id)) {
        message._fromDB = true;
        message.conversation = { id: message.conversation };
        var newMessage = this.client._createObject(message);
        newMessage.syncState = message.sync_state;
        return newMessage;
      }
    }

    /**
     * Load all Sync Events from the database.
     *
     * @method loadSyncQueue
     * @param {Function} callback
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: 'loadSyncQueue',
    value: function loadSyncQueue(callback) {
      var _this9 = this;

      this._loadAll('syncQueue', function (syncEvents) {
        _this9._loadSyncEventRelatedData(syncEvents, callback);
      });
    }

    /**
     * Validate that we have appropriate data for each SyncEvent and instantiate it.
     *
     * Any operation that is not a DELETE must have a valid target found in the database or javascript cache,
     * otherwise it can not be executed.
     *
     * TODO: Need to cleanup sync entries that have invalid targets
     *
     * @method _loadSyncEventRelatedData
     * @private
     * @param {Object[]} syncEvents
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventRelatedData',
    value: function _loadSyncEventRelatedData(syncEvents, callback) {
      var _this10 = this;

      // Gather all Message IDs that are targets of operations.
      var messageIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/messages/);
      }).map(function (item) {
        return item.target;
      });

      // Gather all Conversation IDs that are targets of operations.
      var conversationIds = syncEvents.filter(function (item) {
        return item.operation !== 'DELETE' && item.target && item.target.match(/conversations/);
      }).map(function (item) {
        return item.target;
      });

      // Load any Messages/Conversations that are targets of operations.
      // Call _createMessage or _createConversation on all targets found.
      this.getObjects('messages', messageIds, function (messages) {
        messages.forEach(function (message) {
          return _this10._createMessage(message);
        });
        _this10.getObjects('conversations', conversationIds, function (conversations) {
          conversations.forEach(function (conversation) {
            return _this10._createConversation(conversation);
          });
          _this10._loadSyncEventResults(syncEvents, callback);
        });
      });
    }

    /**
     * Turn an array of Sync Event DB Entries into an array of layer.SyncEvent.
     *
     * @method _loadSyncEventResults
     * @private
     * @param {Object[]} syncEvents
     * @param {layer.SyncEvent[]} callback.result
     */

  }, {
    key: '_loadSyncEventResults',
    value: function _loadSyncEventResults(syncEvents, callback) {
      var _this11 = this;

      // If the target is present in the sync event, but does not exist in the system,
      // do NOT attempt to instantiate this event... unless its a DELETE operation.
      var newData = syncEvents.filter(function (syncEvent) {
        var hasTarget = Boolean(syncEvent.target && _this11.client._getObject(syncEvent.target));
        return syncEvent.operation === 'DELETE' || hasTarget;
      }).map(function (syncEvent) {
        if (syncEvent.isWebsocket) {
          return new SyncEvent.WebsocketSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        } else {
          return new SyncEvent.XHRSyncEvent({
            target: syncEvent.target,
            depends: syncEvent.depends,
            operation: syncEvent.operation,
            id: syncEvent.id,
            data: syncEvent.data,
            method: syncEvent.method,
            headers: syncEvent.headers,
            url: syncEvent.url,
            fromDB: true,
            createdAt: syncEvent.created_at
          });
        }
      });

      // Sort the results and then return them.
      Util.sortBy(newData, function (item) {
        return item.createdAt;
      });
      callback(newData);
    }

    /**
     * Load all data from the specified table.
     *
     * @method _loadAll
     * @protected
     * @param {String} tableName
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadAll',
    value: function _loadAll(tableName, callback) {
      var _this12 = this;

      if (!this.tables[tableName]) return callback([]);
      this.onOpen(function () {
        var data = [];
        _this12.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          var cursor = evt.target.result;
          if (cursor) {
            data.push(cursor.value);
            cursor.continue();
          } else {
            if (!_this12.isDestroyed) callback(data);
          }
        };
      });
    }

    /**
     * Load all data from the specified table and with the specified index value.
     *
     * @method _loadByIndex
     * @protected
     * @param {String} tableName
     * @param {String} indexName
     * @param {String} indexValue
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: '_loadByIndex',
    value: function _loadByIndex(tableName, indexName, indexValue, callback) {
      var _this13 = this;

      if (!this.tables[tableName]) return callback([]);
      this.onOpen(function () {
        var data = [];
        var range = window.IDBKeyRange.only(indexValue);
        _this13.db.transaction([tableName], 'readonly').objectStore(tableName).index(indexName).openCursor(range).onsuccess = function (evt) {
          var cursor = evt.target.result;
          if (cursor) {
            data.push(cursor.value);
            cursor.continue();
          } else {
            if (!_this13.isDestroyed) callback(data);
          }
        };
      });
    }

    /**
     * Deletes the specified objects from the specified table.
     *
     * Currently takes an array of data to delete rather than an array of IDs;
     * If you only have an ID, [{id: myId}] should work.
     *
     * @method deleteObjects
     * @param {String} tableName
     * @param {Object[]} data
     * @param {Function} [callback]
     */

  }, {
    key: 'deleteObjects',
    value: function deleteObjects(tableName, data, callback) {
      var _this14 = this;

      if (!this.tables[tableName]) return callback ? callback() : null;
      this.onOpen(function () {
        var transaction = _this14.db.transaction([tableName], 'readwrite');
        var store = transaction.objectStore(tableName);
        transaction.oncomplete = callback;
        data.forEach(function (item) {
          return store.delete(item.id);
        });
      });
    }

    /**
     * Retrieve the identified objects from the specified database table.
     *
     * Turning these into instances is the responsibility of the caller.
     *
     * Inspired by http://www.codeproject.com/Articles/744986/How-to-do-some-magic-with-indexedDB
     *
     * @method getObjects
     * @param {String} tableName
     * @param {String[]} ids
     * @param {Function} callback
     * @param {Object[]} callback.result
     */

  }, {
    key: 'getObjects',
    value: function getObjects(tableName, ids, callback) {
      var _this15 = this;

      if (!this.tables[tableName]) return callback([]);
      var data = [];

      // Gather, sort, and filter replica IDs
      var sortedIds = ids.sort();
      for (var i = sortedIds.length - 1; i > 0; i--) {
        if (sortedIds[i] === sortedIds[i - 1]) sortedIds.splice(i, 1);
      }
      var index = 0;

      // Iterate over the table searching for the specified IDs
      this.onOpen(function () {
        _this15.db.transaction([tableName], 'readonly').objectStore(tableName).openCursor().onsuccess = function (evt) {
          var cursor = evt.target.result;
          if (!cursor) {
            callback(data);
            return;
          }
          var key = cursor.key;

          // The cursor has passed beyond this key. Check next.
          while (key > sortedIds[index]) {
            index++;
          } // The cursor is pointing at one of our IDs, get it and check next.
          if (key === sortedIds[index]) {
            data.push(cursor.value);
            index++;
          }

          // Done or check next
          if (index === sortedIds.length) {
            if (!_this15.isDestroyed) callback(data);
          } else {
            cursor.continue(sortedIds[index]);
          }
        };
      });
    }

    /**
     * Claim a Sync Event.
     *
     * A sync event is claimed by locking the table,  validating that it is still in the table... and then deleting it from the table.
     *
     * @method claimSyncEvent
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Boolean} callback.result
     */

  }, {
    key: 'claimSyncEvent',
    value: function claimSyncEvent(syncEvent, callback) {
      var _this16 = this;

      if (!this.tables.syncQueue) return callback(true);
      this.onOpen(function () {
        var transaction = _this16.db.transaction(['syncQueue'], 'readwrite');
        var store = transaction.objectStore('syncQueue');
        store.get(syncEvent.id).onsuccess = function (evt) {
          return callback(Boolean(evt.target.result));
        };
        store.delete(syncEvent.id);
      });
    }

    /**
     * Delete all data from all tables.
     *
     * This should be called from layer.Client.logout()
     *
     * @method deleteTables
     * @param {Function} [calllback]
     */

  }, {
    key: 'deleteTables',
    value: function deleteTables(callback) {
      var _this17 = this;

      this.onOpen(function () {
        try {
          var transaction = _this17.db.transaction(['conversations', 'identities', 'messages', 'syncQueue'], 'readwrite');
          transaction.objectStore('conversations').clear();
          transaction.objectStore('identities').clear();
          transaction.objectStore('messages').clear();
          transaction.objectStore('syncQueue').clear();
          transaction.oncomplete = callback;
        } catch (e) {
          // Noop
        }
      });
    }
  }]);

  return DbManager;
}(Root);

/**
 * @type {layer.Client} Layer Client instance
 */


DbManager.prototype.client = null;

/**
 * @type {boolean} is the db connection open
 */
DbManager.prototype.isOpen = false;

/**
 * @type {Object} A list of tables that are enabled.
 *
 * Disabled tables are omitted or false.
 * sync-events can only be enabled IF conversations and messages are enabled
 */
DbManager.prototype.tables = null;

/**
 * @type IDBDatabase
 */
DbManager.prototype.db = null;

DbManager._supportedEvents = ['open'];

Root.initClass.apply(DbManager, [DbManager, 'DbManager']);
module.exports = DbManager;

},{"./client-utils":10,"./const":12,"./logger":18,"./root":24,"./sync-event":25}],16:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * This class represents a Layer Error.
 *
 * At this point, a LayerError is only used in response to an error from the server.
 * It may be extended to report on internal errors... but typically internal errors
 * are reported via `throw new Error(...);`
 *
 * Layer Error is passed as part of the layer.LayerEvent's data property.
 *
 *     object.trigger('xxx-error', new LayerEvent({
 *       data: new LayerError()
 *     }));
 *
 * @class layer.LayerError
 */
var Logger = require('./logger');

var LayerError = function () {
  function LayerError(options) {
    var _this = this;

    _classCallCheck(this, LayerError);

    if (options instanceof LayerError) {
      options = {
        errType: options.errType,
        httpStatus: options.httpStatus,
        message: options.message,
        code: options.code,
        url: options.url,
        data: options.data
      };
    } else if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {
      options.errType = options.id;
    } else {
      options = {
        message: options
      };
    }

    Object.keys(options).forEach(function (name) {
      return _this[name] = options[name];
    });
    if (!this.data) this.data = {};
  }

  /**
   * Returns either '' or a nonce.
   *
   * If a nonce has been returned
   * by the server as part of a session-expiration error,
   * then this method will return that nonce.
   *
   * @method getNonce
   * @return {string} nonce
   */


  _createClass(LayerError, [{
    key: 'getNonce',
    value: function getNonce() {
      return this.data && this.data.nonce ? this.data.nonce : '';
    }

    /**
     * String representation of the error
     *
     * @method toString
     * @return {string}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.code + ' (' + this.id + '): ' + this.message + '; (see ' + this.url + ')';
    }

    /**
     * Log the errors
     *
     * @method log
     * @deprecated see layer.Logger
     */

  }, {
    key: 'log',
    value: function log() {
      Logger.error('Layer-Error: ' + this.toString());
    }
  }]);

  return LayerError;
}();

/**
 * A string name for the event; these names are paired with codes.
 *
 * Codes can be looked up at https://github.com/layerhq/docs/blob/web-api/specs/rest-api.md#client-errors
 * @type {String}
 */


LayerError.prototype.errType = '';

/**
 * Numerical error code.
 *
 * https://developer.layer.com/docs/client/rest#full-list
 * @type {Number}
 */
LayerError.prototype.code = 0;

/**
 * URL to go to for more information on this error.
 * @type {String}
 */
LayerError.prototype.url = '';

/**
 * Detailed description of the error.
 * @type {String}
 */
LayerError.prototype.message = '';

/**
 * Http error code; no value if its a websocket response.
 * @type {Number}
 */
LayerError.prototype.httpStatus = 0;

/**
 * Contains data from the xhr request object.
 *
 *  * url: the url to the service endpoint
 *  * data: xhr.data,
 *  * xhr: XMLHttpRequest object
 *
 * @type {Object}
 */
LayerError.prototype.request = null;

/**
 * Any additional details about the error sent as additional properties.
 * @type {Object}
 */
LayerError.prototype.data = null;

/**
 * Pointer to the xhr object that fired the actual request and contains the response.
 * @type {XMLHttpRequest}
 */
LayerError.prototype.xhr = null;

/**
 * Dictionary of error messages
 * @property {Object} [dictionary={}]
 */
LayerError.dictionary = {
  appIdMissing: 'Property missing: appId is required',
  identityTokenMissing: 'Identity Token missing: answerAuthenticationChallenge requires an identity token',
  sessionTokenMissing: 'Session Token missing: _authComplete requires a {session_token: value} input',
  clientMissing: 'Property missing: client is required',
  conversationMissing: 'Property missing: conversation is required',
  partsMissing: 'Property missing: parts is required',
  moreParticipantsRequired: 'Conversation needs participants other than the current user',
  isDestroyed: 'Object is destroyed',
  urlRequired: 'Object needs a url property',
  invalidUrl: 'URL is invalid',
  invalidId: 'Identifier is invalid',
  idParamRequired: 'The ID Parameter is required',
  wrongClass: 'Parameter class error; should be: ',
  inProgress: 'Operation already in progress',
  cantChangeIfConnected: 'You can not change value after connecting',
  alreadySent: 'Already sent or sending',
  contentRequired: 'MessagePart requires rich content for this call',
  alreadyDestroyed: 'This object has already been destroyed',
  deletionModeUnsupported: 'Call to deletion was made with an unsupported deletion mode',
  sessionAndUserRequired: 'connectWithSession requires both a userId and a sessionToken'
};

module.exports = LayerError;

},{"./logger":18}],17:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * This class represents a Layer Event, and is used as the parameter for all event handlers.
 *
 * Calls to
 *
 *      obj.trigger('eventName2', {hey: 'ho'});
 *
 * results in:
 *
 *      obj.on('eventName2', function(layerEvent) {
 *          alert(layerEvent.target.toString() + ' has fired a value of ' + layerEvent.hey);
 *      });
 *
 * Change events (events ending in ':change') get special handling:
 *
 *      obj.trigger('obj:change', {
 *          newValue: 55,
 *          oldValue: 25,
 *          property: 'hey'
 *      });
 *
 * results in your event data being wrapped in a `changes` array:
 *
 *      obj.on('obj:change', function(layerEvent) {
 *          layerEvent.changes.forEach(function(change) {
 *              alert(layerEvent.target.toString() + ' changed ' +
 *                    change.property + ' from ' + change.oldValue +
 *                    ' to ' + change.newValue);
 *          });
 *      });
 *
 * The `layer.LayerEvent.getChangesFor()` and `layer.LayerEvent.hasProperty()` methods
 * simplify working with xxx:change events so you don't need
 * to iterate over the `changes` array.
 *
 * @class layer.LayerEvent
 */

var LayerEvent = function () {
  /**
   * Constructor for LayerEvent.
   *
   * @method
   * @param  {Object} args - Properties to mixin to the event
   * @param  {string} eventName - Name of the event that generated this LayerEvent.
   * @return {layer.LayerEvent}
   */

  function LayerEvent(args, eventName) {
    var _this = this;

    _classCallCheck(this, LayerEvent);

    var ptr = this;

    // Is it a change event?  if so, setup the change properties.
    if (eventName.match(/:change$/)) {
      this.changes = [{}];
      // All args get copied into the changes object instead of this
      ptr = this.changes[0];
      this.isChange = true;
    } else {
      this.isChange = false;
    }

    // Copy the args into either this Event object... or into the change object.
    // Wouldn't be needed if this inherited from Root.
    Object.keys(args).forEach(function (name) {
      // Even if we are copying properties into the change object, target remains
      // a property of LayerEvent.
      if (ptr !== _this && name === 'target') {
        _this.target = args.target;
      } else {
        ptr[name] = args[name];
      }
    });
    this.eventName = eventName;
  }

  /**
   * Returns true if the specified property was changed.
   *
   * Returns false if this is not a change event.
   *
   *      if (layerEvent.hasProperty('age')) {
   *          handleAgeChange(obj.age);
   *      }
   *
   * @method hasProperty
   * @param  {string}  name - Name of the property
   * @return {Boolean}
   */


  _createClass(LayerEvent, [{
    key: 'hasProperty',
    value: function hasProperty(name) {
      if (!this.isChange) return false;
      return Boolean(this.changes.filter(function (change) {
        return change.property === name;
      }).length);
    }

    /**
     * Get all changes to the property.
     *
     * Returns an array of changes.
     * If this is not a change event, will return []
     * Changes are typically of the form:
     *
     *      layerEvent.getChangesFor('age');
     *      > [{
     *          oldValue: 10,
     *          newValue: 5,
     *          property: 'age'
     *      }]
     *
     * @method getChangesFor
     * @param  {string} name - Name of the property whose changes are of interest
     * @return {Object[]}
     */

  }, {
    key: 'getChangesFor',
    value: function getChangesFor(name) {
      if (!this.isChange) return [];
      return this.changes.filter(function (change) {
        return change.property === name;
      });
    }

    /**
     * Merge changes into a single changes array.
     *
     * The other event will need to be deleted.
     *
     * @method _mergeChanges
     * @protected
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_mergeChanges',
    value: function _mergeChanges(evt) {
      this.changes = this.changes.concat(evt.changes);
    }
  }]);

  return LayerEvent;
}();

/**
 * Indicates that this is a change event.
 *
 * If the event name ends with ':change' then
 * it is treated as a change event;  such
 * events are assumed to come with `newValue`, `oldValue` and `property` in the layer.LayerEvent.changes property.
 * @type {Boolean}
 */


LayerEvent.prototype.isChange = false;

/**
 * Array of changes (Change Events only).
 *
 * If its a Change Event, then the changes property contains an array of change objects
 * which each contain:
 *
 * * oldValue
 * * newValue
 * * property
 *
 * @type {Object[]}
 */
LayerEvent.prototype.changes = null;

/**
 * Component that was the source of the change.
 *
 * If one calls
 *
 *      obj.trigger('event');
 *
 * then obj will be the target.
 * @type {layer.Root}
 */
LayerEvent.prototype.target = null;

/**
 * The name of the event that created this instance.
 *
 * If one calls
 *
 *      obj.trigger('myevent');
 *
 * then eventName = 'myevent'
 *
 * @type {String}
 */
LayerEvent.prototype.eventName = '';

module.exports = LayerEvent;

},{}],18:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class layer.Logger
 * @private
 *
 */

var _require$LOG = require('./const').LOG;

var DEBUG = _require$LOG.DEBUG;
var INFO = _require$LOG.INFO;
var WARN = _require$LOG.WARN;
var ERROR = _require$LOG.ERROR;
var NONE = _require$LOG.NONE;

var _require = require('./client-utils');

var isEmpty = _require.isEmpty;

// Pretty arbitrary test that IE/edge fails and others don't.  Yes I could do a more direct
// test for IE/edge but its hoped that MS will fix this around the time they cleanup their internal console object.

var supportsConsoleFormatting = Boolean(console.assert && console.assert.toString().match(/assert/));
var LayerCss = 'color: #888; font-weight: bold;';
var Black = 'color: black';
/* istanbulify ignore next */

var Logger = function () {
  function Logger() {
    _classCallCheck(this, Logger);
  }

  _createClass(Logger, [{
    key: 'log',
    value: function log(msg, obj, type, color) {
      /* istanbul ignore else */
      if (typeof msg === 'string') {
        var timestamp = new Date().toLocaleTimeString();
        if (supportsConsoleFormatting) {
          console.log('%cLayer%c ' + type + '%c [' + timestamp + ']: ' + msg, LayerCss, 'color: ' + color, Black);
        } else {
          console.log('Layer ' + type + ' [' + timestamp + ']: ' + msg);
        }
      } else {
        this._logObj(msg, type, color);
      }
      if (obj) this._logObj(obj, type, color);
    }
  }, {
    key: '_logObj',
    value: function _logObj(obj, type, color) {
      /* istanbul ignore next */
      if (!obj || isEmpty(obj)) return;
      /* istanbul ignore next */
      if (obj.constructor.name === 'Object') {
        if (supportsConsoleFormatting) {
          console.log('%cLayer%c ' + type + '%c: ' + JSON.stringify(obj, null, 4), LayerCss, 'color: ' + color, Black);
        } else {
          console.log('Layer ' + type + ': ' + JSON.stringify(obj, null, 4));
        }
      } else {
        if (supportsConsoleFormatting) {
          console.log('%cLayer%c ' + type + '%c: %O', LayerCss, 'color: ' + color, Black, obj);
        } else {
          console.log('Layer ' + type + ':', obj);
        }
      }
    }
  }, {
    key: 'debug',
    value: function debug(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= DEBUG) this.log(msg, obj, 'DEBUG', '#888');
    }
  }, {
    key: 'info',
    value: function info(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= INFO) this.log(msg, obj, 'INFO', 'black');
    }
  }, {
    key: 'warn',
    value: function warn(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= WARN) this.log(msg, obj, 'WARN', 'orange');
    }
  }, {
    key: 'error',
    value: function error(msg, obj) {
      /* istanbul ignore next */
      if (this.level >= ERROR) this.log(msg, obj, 'ERROR', 'red');
    }
  }]);

  return Logger;
}();

/* istanbul ignore next */


Logger.prototype.level = typeof jasmine === 'undefined' ? ERROR : NONE;

var logger = new Logger();

module.exports = logger;

},{"./client-utils":10,"./const":12}],19:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The MessagePart class represents an element of a message.
 *
 *      // Create a Message Part with any mimeType
 *      var part = new layer.MessagePart({
 *          body: "hello",
 *          mimeType: "text/plain"
 *      });
 *
 *      // Create a text/plain only Message Part
 *      var part = new layer.MessagePart("Hello I am text/plain");
 *
 * You can also create a Message Part from a File Input dom node:
 *
 *      var fileInputNode = document.getElementById("myFileInput");
 *      var part = new layer.MessagePart(fileInputNode.files[0]);
 *
 * You can also create Message Parts from a file drag and drop operation:
 *
 *      onFileDrop: function(evt) {
 *           var files = evt.dataTransfer.files;
 *           var m = conversation.createMessage({
 *               parts: files.map(function(file) {
 *                  return new layer.MessagePart({body: file, mimeType: file.type});
 *               }
 *           });
 *      });
 *
 * You can also use base64 encoded data:
 *
 *      var part = new layer.MessagePart({
 *          encoding: 'base64',
 *          mimeType: 'image/png',
 *          body: 'iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAECElEQVR4Xu2ZO44TURREa0SAWBASKST8xCdDQMAq+OyAzw4ISfmLDBASISERi2ADEICEWrKlkYWny6+77fuqalJfz0zVOXNfv/ER8mXdwJF1+oRHBDCXIAJEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8wbM42cDRADzBszjZwNEAPMGzONnA0QA8waWjX8OwHcAv5f9Me3fPRugvbuxd14C8B7AVwA3q0oQAcYwtr2+hn969faPVSWIAG2AT3rXJvz17CcAN6ptgggwrwDb4JeVIALMJ8AY/JISRIB5BGDhr3/aZwDXKxwHEWC6AJcBvAOwfuBjvuNfABcBfGGGl5yJANPabYV/B8DLaT96nndHgPYeu4c/RI8AbQJIwO9FgDMAfrVxWuRdMvB7EOA+gHsALgD4uQjO3b6pFPzqAjwA8HTF5weA8weWQA5+ZQGOw1//jR5SAkn4VQV4CODJls18CAmuAHjbcM8vc9U76ZSrdgt4BODxyLG8Twla4P8BcLfKPX/sEaeSAAz8fR4H8vArHQHXAHwYs3Xj9SU3gQX8SgKcAvBitTp38WAJCWzgVxJg+F0qSGAFv5oAh5bADn5FAQ4lwVUAb3a86nX1tL/tXK10Czj+O+7zOLCFX3UDrEXYhwTW8KsLsPRx0Ap/+A/fq12uKpVnqx4BSx8Hgb9quAcB5t4EgX/sz6sXAeaSIPA3zqOeBJgqwTMAzxuuelJn/ubzSG8CTJFg12ex4Z4vDb+HW8A2aK1XRFYCC/g9C7DkJrCB37sAS0hgBV9BgDklGODfBvCaPScU5np8CPxf71OfCSzhq2yAqZ8d2MJXE6DlOLCGryjALhLYw1cVgJEg8Dv7MKjlgXvbg2Hgd/ph0BwSBH7nHwZNkeCW4z1/rDCV/wOM5RyOg7MAvo0Nur3uIoAbVzpvBKCr0hyMAJpc6VQRgK5KczACaHKlU0UAuirNwQigyZVOFQHoqjQHI4AmVzpVBKCr0hyMAJpc6VQRgK5KczACaHKlU0UAuirNwQigyZVOFQHoqjQHI4AmVzpVBKCr0hyMAJpc6VQRgK5KczACaHKlU0UAuirNwQigyZVOFQHoqjQHI4AmVzpVBKCr0hyMAJpc6VQRgK5KczACaHKlU0UAuirNwQigyZVOFQHoqjQHI4AmVzpVBKCr0hyMAJpc6VQRgK5KczACaHKlU0UAuirNwQigyZVOFQHoqjQHI4AmVzpVBKCr0hz8BzIXtYE3VcPnAAAAAElFTkSuQmCC'
 *      });
 *
 * ### Accesing Rich Content
 *
 * There are two ways of accessing rich content
 *
 * 1. Access the data directly: `part.fetchContent(function(data) {myRenderData(data);})`. This approach downloads the data,
 *    writes it to the the `body` property, writes a Data URI to the part's `url` property, and then calls your callback.
 *    By downloading the data and storing it in `body`, the data does not expire.
 * 2. Access the URL rather than the data: `part.fetchStream(callback)`.  URLs are needed for streaming, and for content that doesn't
 *    yet need to be rendered (hyperlinks to data that will render when clicked).  These URLs expire.  The url property will return a
 *    string if the url is valid, or '' if its expired and fetchStream must be called to update the url.
 *    The following pattern is recommended:
 *
 *        if (!part.url) {
 *          part.fetchStream(function(url) {myRenderUrl(url)});
 *        } else {
 *          myRenderUrl(part.url);
 *        }
 *
 * NOTE: `layer.MessagePart.url` should have a value when the message is first received, and will only fail `if (!part.url)` once the url has expired.
 *
 * @class  layer.MessagePart
 * @extends layer.Root
 * @author Michael Kantor
 */

var Root = require('./root');
var Content = require('./content');
var xhr = require('./xhr');
var ClientRegistry = require('./client-registry');
var LayerError = require('./layer-error');
var HasBlob = typeof Blob !== 'undefined';

/* istanbul ignore next */
var LocalFileReader = typeof window === 'undefined' ? require('filereader') : FileReader;

var MessagePart = function (_Root) {
  _inherits(MessagePart, _Root);

  /**
   * Constructor
   *
   * @method constructor
   * @param  {Object} options - Can be an object with body and mimeType, or it can be a string, or a Blob/File
   * @param  {string} options.body - To send binary, use base64 encoded string
   * @param  {string} [options.mimeType=text/plain] - Mime type; can be anything; if your client doesn't have a renderer for it, it will be ignored.
   * @param  {string} [options.encoding=] - Encoding for your MessagePart; use 'base64' if the body is a base64 string; else leave blank.
   * @param  {number} [options.size=0] - Size of your part. Will be calculated for you if not provided.
   *
   * @return {layer.MessagePart}
   */

  function MessagePart(options) {
    _classCallCheck(this, MessagePart);

    var newOptions = options;
    if (typeof options === 'string') {
      newOptions = { body: options };
      if (arguments.length - 1 > 0) {
        newOptions.mimeType = arguments.length <= 1 ? undefined : arguments[1];
      } else {
        newOptions.mimeType = 'text/plain';
      }
    } else if (HasBlob && (options instanceof Blob || options.body instanceof Blob)) {
      var bodyBlob = options instanceof Blob ? options : options.body;
      newOptions = {
        mimeType: bodyBlob.type,
        body: bodyBlob,
        size: bodyBlob.size,
        hasContent: true
      };
    }

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MessagePart).call(this, newOptions));

    if (!_this.size && _this.body) _this.size = _this.body.length;
    if (HasBlob && _this.body instanceof Blob) {
      _this.url = URL.createObjectURL(_this.body);
    }
    return _this;
  }

  _createClass(MessagePart, [{
    key: 'destroy',
    value: function destroy() {
      if (this.__url) {
        URL.revokeObjectURL(this.__url);
        this.__url = null;
      }
      this.body = null;
      _get(Object.getPrototypeOf(MessagePart.prototype), 'destroy', this).call(this);
    }

    /**
     * Get the layer.Client associated with this layer.MessagePart.
     *
     * Uses the layer.MessagePart.clientId property.
     *
     * @method _getClient
     * @private
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Get the layer.Message associated with this layer.MessagePart.
     *
     * @method _getMessage
     * @private
     * @return {layer.Message}
     */

  }, {
    key: '_getMessage',
    value: function _getMessage() {
      return this._getClient().getMessage(this.id.replace(/\/parts.*$/, ''));
    }

    /**
     * Download Rich Content from cloud server.
     *
     * For MessageParts with rich content, will load the data from google's cloud storage.
     * The body property of this MessagePart is set to the result.
     *
     *      messagepart.fetchContent()
     *      .on("content-loaded", function() {
     *          render(messagepart.body);
     *      });
     *
     * @method fetchContent
     * @param {Function} [callback]
     * @param {Mixed} callback.data - Either a string (mimeType=text/plain) or a Blob (all other mimeTypes)
     */

  }, {
    key: 'fetchContent',
    value: function fetchContent(callback) {
      var _this2 = this;

      if (this._content && !this.isFiring) {
        this.isFiring = true;
        var type = this.mimeType === 'image/jpeg+preview' ? 'image/jpeg' : this.mimeType;
        this._content.loadContent(type, function (err, result) {
          return _this2._fetchContentCallback(err, result, callback);
        });
      }
      return this;
    }
  }, {
    key: '_fetchContentCallback',
    value: function _fetchContentCallback(err, result, callback) {
      var _this3 = this;

      if (err) {
        this.trigger('content-loaded-error', err);
      } else {
        this.url = URL.createObjectURL(result);
        this.isFiring = false;
        if (this.mimeType === 'text/plain') {
          (function () {
            var reader = new LocalFileReader();
            reader.addEventListener('loadend', function () {
              _this3._fetchContentComplete(reader.result, callback);
            });
            reader.readAsText(result);
          })();
        } else {
          this._fetchContentComplete(result, callback);
        }
      }
    }
  }, {
    key: '_fetchContentComplete',
    value: function _fetchContentComplete(body, callback) {
      var message = this._getMessage();

      this.body = body;

      this.trigger('content-loaded');
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });
      if (callback) callback(this.body);
    }

    /**
     * Access the URL to the remote resource.
     *
     * For MessageParts with Rich Content, will lookup a URL to your Rich Content.
     * Useful for streaming and content so that you don't have to download the entire file before rendering it.
     *
     *      messagepart.fetchStream(function(url) {
     *          render(url);
     *      });
     *
     * @method fetchStream
     * @param {Function} [callback]
     * @param {Mixed} callback.url
     */

  }, {
    key: 'fetchStream',
    value: function fetchStream(callback) {
      var _this4 = this;

      if (!this._content) throw new Error(LayerError.dictionary.contentRequired);
      if (this._content.isExpired()) {
        this._content.refreshContent(this._getClient(), function (url) {
          return _this4._fetchStreamComplete(url, callback);
        });
      } else {
        this._fetchStreamComplete(this._content.downloadUrl, callback);
      }
    }

    // Does not set this.url; instead relies on fact that this._content.downloadUrl has been updated

  }, {
    key: '_fetchStreamComplete',
    value: function _fetchStreamComplete(url, callback) {
      var message = this._getMessage();

      this.trigger('url-loaded');
      message._triggerAsync('messages:change', {
        oldValue: message.parts,
        newValue: message.parts,
        property: 'parts'
      });
      if (callback) callback(url);
    }

    /**
     * Preps a MessagePart for sending.  Normally that is trivial.
     * But if there is rich content, then the content must be uploaded
     * and then we can trigger a "parts:send" event indicating that
     * the part is ready to send.
     *
     * @method _send
     * @protected
     * @param  {layer.Client} client
     * @fires parts:send
     */

  }, {
    key: '_send',
    value: function _send(client) {
      // There is already a Content object, presumably the developer
      // already took care of this step for us.
      if (this._content) {
        this._sendWithContent();
      }

      // If the size is large, Create and upload the Content
      if (this.size > 2048) {
        this._generateContentAndSend(client);
      }

      // If the body is a blob either base64 encode it
      else if (typeof Blob !== 'undefined' && this.body instanceof Blob) {
          this._sendBlob(client);
        }

        // Else the message part can be sent as is.
        else {
            this._sendBody();
          }
    }
  }, {
    key: '_sendBody',
    value: function _sendBody() {
      var obj = {
        mime_type: this.mimeType,
        body: this.body
      };
      if (this.encoding) obj.encoding = this.encoding;
      this.trigger('parts:send', obj);
    }
  }, {
    key: '_sendWithContent',
    value: function _sendWithContent() {
      this.trigger('parts:send', {
        mime_type: this.mimeType,
        content: {
          size: this.size,
          id: this._content.id
        }
      });
    }
  }, {
    key: '_sendBlob',
    value: function _sendBlob(client) {
      var _this5 = this;

      /* istanbul ignore else */
      var reader = new LocalFileReader();
      reader.onloadend = function () {
        var base64data = reader.result;
        if (base64data.length < 2048) {
          _this5.body = base64data;
          _this5.body = _this5.body.substring(_this5.body.indexOf(',') + 1);
          _this5.encoding = 'base64';
          _this5._sendBody(client);
        } else {
          _this5._generateContentAndSend(client);
        }
      };
      reader.readAsDataURL(this.body); // encodes to base64
    }

    /**
     * Create an rich Content object on the server
     * and then call _processContentResponse
     *
     * @method _generateContentAndSend
     * @private
     * @param  {layer.Client} client
     */

  }, {
    key: '_generateContentAndSend',
    value: function _generateContentAndSend(client) {
      var _this6 = this;

      this.hasContent = true;
      client.xhr({
        url: '/content',
        method: 'POST',
        headers: {
          'Upload-Content-Type': this.mimeType,
          'Upload-Content-Length': this.size,
          'Upload-Origin': typeof location !== 'undefined' ? location.origin : ''
        },
        sync: {}
      }, function (result) {
        _this6._processContentResponse(result.data, client);
      });
    }

    /**
     * Creates a layer.Content object from the server's
     * Content object, and then uploads the data to google cloud storage.
     *
     * @method _processContentResponse
     * @private
     * @param  {Object} response
     * @param  {layer.Client} client
     */

  }, {
    key: '_processContentResponse',
    value: function _processContentResponse(response, client) {
      var _this7 = this;

      this._content = new Content(response.id);
      this.hasContent = true;
      xhr({
        url: response.upload_url,
        method: 'PUT',
        data: this.body,
        headers: {
          'Upload-Content-Length': this.size,
          'Upload-Content-Type': this.mimeType
        }
      }, function (result) {
        return _this7._processContentUploadResponse(result, response, client);
      });
    }
  }, {
    key: '_processContentUploadResponse',
    value: function _processContentUploadResponse(uploadResult, contentResponse, client) {
      if (!uploadResult.success) {
        if (!client.onlineManager.isOnline) {
          client.onlineManager.once('connected', this._processContentResponse.bind(this, contentResponse, client), this);
        } else {
          console.error('We don\'t yet handle this!');
        }
      } else {
        this.trigger('parts:send', {
          mime_type: this.mimeType,
          content: {
            size: this.size,
            id: this._content.id
          }
        });
      }
    }

    /**
     * Returns the text for any text/plain part.
     *
     * Returns '' if its not a text/plain part.
     *
     * @method getText
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      if (this.mimeType === 'text/plain') {
        return this.body;
      } else {
        return '';
      }
    }

    /**
     * Updates the MessagePart with new data from the server.
     *
     * Currently, MessagePart properties do not update... however,
     * the layer.Content object that Rich Content MessageParts contain
     * do get updated with refreshed expiring urls.
     *
     * @method _populateFromServer
     * @param  {Object} part - Server representation of a part
     * @private
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(part) {
      if (part.content && this._content) {
        this._content.downloadUrl = part.content.download_url;
        this._content.expiration = new Date(part.content.expiration);
      }
    }

    /**
     * Creates a MessagePart from a server representation of the part
     *
     * @method _createFromServer
     * @private
     * @static
     * @param  {Object} part - Server representation of a part
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(part) {
      var content = part.content ? Content._createFromServer(part.content) : null;

      return new MessagePart({
        id: part.id,
        mimeType: part.mime_type,
        body: part.body || '',
        _content: content,
        hasContent: Boolean(content),
        size: part.size || 0,
        encoding: part.encoding || ''
      });
    }
  }]);

  return MessagePart;
}(Root);

/**
 * layer.Client that the conversation belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */


MessagePart.prototype.clientId = '';

/**
 * Server generated identifier for the part
 * @type {string}
 */
MessagePart.prototype.id = '';

/**
 * Body of your message part.
 *
 * This is the core data of your part.
 * @type {string}
 */
MessagePart.prototype.body = null;

/**
 * Rich content object.
 *
 * This will be automatically created for you if your layer.MessagePart.body
 * is large.
 * @type {layer.Content}
 * @private
 */
MessagePart.prototype._content = null;

/**
 * The Part has rich content
 * @type {Boolean}
 */
MessagePart.prototype.hasContent = false;

/**
 * URL to rich content object.
 *
 * Parts with rich content will be initialized with this property set.  But its value will expire.
 *
 * Will contain an expiring url at initialization time and be refreshed with calls to `layer.MessagePart.fetchStream()`.
 * Will contain a non-expiring url to a local resource if `layer.MessagePart.fetchContent()` is called.
 *
 * @type {layer.Content}
 */
Object.defineProperty(MessagePart.prototype, 'url', {
  enumerable: true,
  get: function get() {
    // Its possible to have a url and no content if it has been instantiated but not yet sent.
    // If there is a __url then its a local url generated from the body property and does not expire.
    if (this.__url) return this.__url;
    if (this._content) return this._content.isExpired() ? '' : this._content.downloadUrl;
    return '';
  },
  set: function set(inValue) {
    this.__url = inValue;
  }
});

/**
 * Mime Type for the data in layer.MessagePart.body.
 *
 * @type {String}
 */
MessagePart.prototype.mimeType = 'text/plain';

/**
 * Encoding used for the body of this part.
 *
 * No value is the default encoding.  'base64' is also a common value.
 * @type {String}
 */
MessagePart.prototype.encoding = '';

/**
 * Size of the layer.MessagePart.body.
 *
 * Will be set for you if not provided.
 * Only needed for use with rich content.
 *
 * @type {number}
 */
MessagePart.prototype.size = 0;

MessagePart._supportedEvents = ['parts:send', 'content-loaded', 'url-loaded', 'content-loaded-error'].concat(Root._supportedEvents);
Root.initClass.apply(MessagePart, [MessagePart, 'MessagePart']);

module.exports = MessagePart;

},{"./client-registry":9,"./content":13,"./layer-error":16,"./root":24,"./xhr":36,"filereader":3}],20:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Message Class represents Messages sent amongst participants
 * of of a Conversation.
 *
 * The simplest way to create and send a message is:
 *
 *      var m = conversation.createMessage('Hello there').send();
 *
 * For conversations that involve notifications (primarily for Android and IOS), the more common pattern is:
 *
 *      var m = conversation.createMessage('Hello there').send({text: "Message from Fred: Hello there"});
 *
 * Typically, rendering would be done as follows:
 *
 *      // Create a layer.Query that loads Messages for the
 *      // specified Conversation.
 *      var query = client.createQuery({
 *        model: Query.Message,
 *        predicate: 'conversation = "' + conversation.id + '"'
 *      });
 *
 *      // Any time the Query's data changes the 'change'
 *      // event will fire.
 *      query.on('change', function(layerEvt) {
 *        renderNewMessages(query.data);
 *      });
 *
 *      // This will call will cause the above event handler to receive
 *      // a change event, and will update query.data.
 *      conversation.createMessage('Hello there').send();
 *
 * The above code will trigger the following events:
 *
 *  * Message Instance fires
 *    * messages:sending: An event that lets you modify the message prior to sending
 *    * messages:sent: The message was received by the server
 *  * Query Instance fires
 *    * change: The query has received a new Message
 *    * change:add: Same as the change event but more specific
 *
 * When creating a Message there are a number of ways to structure it.
 * All of these are valid and create the same exact Message:
 *
 *      // Full API style:
 *      var m = conversation.createMessage({
 *          parts: [new layer.MessagePart({
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          })]
 *      });
 *
 *      // Option 1: Pass in an Object instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: {
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }
 *      });
 *
 *      // Option 2: Pass in an array of Objects instead of an array of layer.MessageParts
 *      var m = conversation.createMessage({
 *          parts: [{
 *              body: 'Hello there',
 *              mimeType: 'text/plain'
 *          }]
 *      });
 *
 *      // Option 3: Pass in a string (automatically assumes mimeType is text/plain)
 *      // instead of an array of objects.
 *      var m = conversation.createMessage({
 *          parts: 'Hello'
 *      });
 *
 *      // Option 4: Pass in an array of strings (automatically assumes mimeType is text/plain)
 *      var m = conversation.createMessage({
 *          parts: ['Hello']
 *      });
 *
 *      // Option 5: Pass in just a string and nothing else
 *      var m = conversation.createMessage('Hello');
 *
 *      // Option 6: Use addPart.
 *      var m = converseation.createMessage();
 *      m.addPart({body: "hello", mimeType: "text/plain"});
 *
 * Key methods, events and properties for getting started:
 *
 * Properties:
 *
 * * layer.Message.id: this property is worth being familiar with; it identifies the
 *   Message and can be used in `client.getMessage(id)` to retrieve it
 *   at any time.
 * * layer.Message.internalId: This property makes for a handy unique ID for use in dom nodes.
 *   It is gaurenteed not to change during this session.
 * * layer.Message.isRead: Indicates if the Message has been read yet; set `m.isRead = true`
 *   to tell the client and server that the message has been read.
 * * layer.Message.parts: An array of layer.MessagePart classes representing the contents of the Message.
 * * layer.Message.sentAt: Date the message was sent
 * * layer.Message.sender's `userId` property: Conversation participant who sent the Message. You may
 *   need to do a lookup on this id in your own servers to find a
 *   displayable name for it.
 *
 * Methods:
 *
 * * layer.Message.send(): Sends the message to the server and the other participants.
 * * layer.Message.on() and layer.Message.off(); event listeners built on top of the `backbone-events-standalone` npm project
 *
 * Events:
 *
 * * `messages:sent`: The message has been received by the server. Can also subscribe to
 *   this event from the layer.Client which is usually simpler.
 *
 * @class  layer.Message
 * @extends layer.Syncable
 */

var Root = require('./root');
var Syncable = require('./syncable');
var MessagePart = require('./message-part');
var LayerError = require('./layer-error');
var Constants = require('./const');
var Util = require('./client-utils');
var ClientRegistry = require('./client-registry');

var Message = function (_Syncable) {
  _inherits(Message, _Syncable);

  /**
   * See layer.Conversation.createMessage()
   *
   * @method constructor
   * @return {layer.Message}
   */

  function Message() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Message);

    // Unless this is a server representation, this is a developer's shorthand;
    // fill in the missing properties around isRead/isUnread before initializing.
    if (!options.fromServer) {
      if ('isUnread' in options) {
        options.isRead = !options.isUnread && !options.is_unread;
      } else {
        options.isRead = true;
      }
    } else {
      options.id = options.fromServer.id;
    }

    if (options.client) options.clientId = options.client.appId;
    if (!options.clientId) throw new Error('clientId property required to create a Message');
    if (options.conversation) options.conversationId = options.conversation.id;

    // Insure __adjustParts is set AFTER clientId is set.
    var parts = options.parts;
    options.parts = null;

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Message).call(this, options));

    _this.parts = parts;

    var client = _this.getClient();
    _this.isInitializing = true;
    if (options && options.fromServer) {
      _this._populateFromServer(options.fromServer);
    } else {
      _this.sender = { userId: '', name: '' };
      _this.sentAt = new Date();
    }

    if (!_this.parts) _this.parts = [];
    _this.localCreatedAt = new Date();

    _this._disableEvents = true;
    if (!options.fromServer) _this.recipientStatus = {};else _this.__updateRecipientStatus(_this.recipientStatus);
    _this._disableEvents = false;

    _this.isInitializing = false;
    if (options && options.fromServer) {
      client._addMessage(_this);
      var status = _this.recipientStatus[client.userId];
      if (status !== Constants.RECEIPT_STATE.READ && status !== Constants.RECEIPT_STATE.DELIVERED) {
        _this._sendReceipt('delivery');
      }
    }
    return _this;
  }

  /**
   * Get the layer.Client associated with this layer.Message.
   *
   * Uses the layer.Message.clientId property.
   *
   * @method getClient
   * @return {layer.Client}
   */


  _createClass(Message, [{
    key: 'getClient',
    value: function getClient() {
      return ClientRegistry.get(this.clientId);
    }

    /**
     * Get the layer.Conversation associated with this layer.Message.
     *
     * Uses the layer.Message.conversationId.
     *
     * @method getConversation
     * @return {layer.Conversation}
     */

  }, {
    key: 'getConversation',
    value: function getConversation(load) {
      if (this.conversationId) {
        return ClientRegistry.get(this.clientId).getConversation(this.conversationId, load);
      }
    }

    /**
     * Turn input into valid layer.MessageParts.
     *
     * This method is automatically called any time the parts
     * property is set (including during intialization).  This
     * is where we convert strings into MessageParts, and instances
     * into arrays.
     *
     * @method __adjustParts
     * @private
     * @param  {Mixed} parts -- Could be a string, array, object or MessagePart instance
     * @return {layer.MessagePart[]}
     */

  }, {
    key: '__adjustParts',
    value: function __adjustParts(parts) {
      var _this2 = this;

      if (typeof parts === 'string') {
        return [new MessagePart({
          body: parts,
          mimeType: 'text/plain',
          clientId: this.clientId
        })];
      } else if (Array.isArray(parts)) {
        return parts.map(function (part) {
          var result = undefined;
          if (part instanceof MessagePart) {
            result = part;
          } else {
            result = new MessagePart(part);
          }
          result.clientId = _this2.clientId;
          return result;
        });
      } else if (parts && (typeof parts === 'undefined' ? 'undefined' : _typeof(parts)) === 'object') {
        parts.clientId = this.clientId;
        return [new MessagePart(parts)];
      }
    }

    /**
     * Add a layer.MessagePart to this Message.
     *
     * Should only be called on an unsent Message.
     *
     * @method addPart
     * @param  {layer.MessagePart/Object} part - A layer.MessagePart instance or a `{mimeType: 'text/plain', body: 'Hello'}` formatted Object.
     */

  }, {
    key: 'addPart',
    value: function addPart(part) {
      if (part) {
        part.clientId = this.clientId;
        if ((typeof part === 'undefined' ? 'undefined' : _typeof(part)) === 'object') {
          this.parts.push(new MessagePart(part));
        } else if (part instanceof MessagePart) {
          this.parts.push(part);
        }
      }
      return this;
    }

    /**
     * Accessor called whenever the app accesses `message.recipientStatus`.
     *
     * Insures that participants who haven't yet been sent the Message are marked as layer.Constants.RECEIPT_STATE.PENDING
     *
     * @method __getRecipientStatus
     * @param {string} pKey - The actual property key where the value is stored
     * @private
     * @return {Object}
     */

  }, {
    key: '__getRecipientStatus',
    value: function __getRecipientStatus(pKey) {
      var _this3 = this;

      var value = this[pKey] || {};
      var client = this.getClient();
      if (client) {
        (function () {
          var userId = client.userId;
          var conversation = _this3.getConversation(false);
          if (conversation) {
            conversation.participants.forEach(function (participant) {
              if (!value[participant]) {
                value[participant] = participant === userId ? Constants.RECEIPT_STATE.READ : Constants.RECEIPT_STATE.PENDING;
              }
            });
          }
        })();
      }
      return value;
    }

    /**
     * Handle changes to the recipientStatus property.
     *
     * Any time the recipientStatus property is set,
     * Recalculate all of the receipt related properties:
     *
     * 1. isRead
     * 2. readStatus
     * 3. deliveryStatus
     *
     * @method __updateRecipientStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     *
     */

  }, {
    key: '__updateRecipientStatus',
    value: function __updateRecipientStatus(status, oldStatus) {
      var conversation = this.getConversation(false);
      var client = this.getClient();

      if (!conversation || Util.doesObjectMatch(status, oldStatus)) return;

      var userId = client.userId;
      var isSender = this.sender.userId === userId;
      var userHasRead = status[userId] === Constants.RECEIPT_STATE.READ;

      try {
        // -1 so we don't count this user
        var userCount = conversation.participants.length - 1;

        // If sent by this user or read by this user, update isRead/unread
        if (!this.__isRead && (isSender || userHasRead)) {
          this.__isRead = true; // no __updateIsRead event fired
        }

        // Update the readStatus/deliveryStatus properties

        var _getReceiptStatus2 = this._getReceiptStatus(status, userId);

        var readCount = _getReceiptStatus2.readCount;
        var deliveredCount = _getReceiptStatus2.deliveredCount;

        this._setReceiptStatus(readCount, deliveredCount, userCount);
      } catch (error) {}
      // Do nothing


      // Only trigger an event
      // 1. we're not initializing a new Message
      // 2. the user's state has been updated to read; we don't care about updates from other users if we aren't the sender.
      //    We also don't care about state changes to delivered; these do not inform rendering as the fact we are processing it
      //    proves its delivered.
      // 3. The user is the sender; in that case we do care about rendering receipts from other users
      if (!this.isInitializing && oldStatus) {
        var usersStateUpdatedToRead = userHasRead && oldStatus[userId] !== Constants.RECEIPT_STATE.READ;
        if (usersStateUpdatedToRead || isSender) {
          this._triggerAsync('messages:change', {
            oldValue: oldStatus,
            newValue: status,
            property: 'recipientStatus'
          });
        }
      }
    }

    /**
     * Get the number of participants who have read and been delivered
     * this Message
     *
     * @method _getReceiptStatus
     * @private
     * @param  {Object} status - Object describing the delivered/read/sent value for each participant
     * @param  {string} userId - User ID for this user; not counted when reporting on how many people have read/received.
     * @return {Object} result
     * @return {number} result.readCount
     * @return {number} result.deliveredCount
     */

  }, {
    key: '_getReceiptStatus',
    value: function _getReceiptStatus(status, userId) {
      var readCount = 0,
          deliveredCount = 0;
      Object.keys(status).filter(function (participant) {
        return participant !== userId;
      }).forEach(function (participant) {
        if (status[participant] === Constants.RECEIPT_STATE.READ) {
          readCount++;
          deliveredCount++;
        } else if (status[participant] === Constants.RECEIPT_STATE.DELIVERED) {
          deliveredCount++;
        }
      });

      return {
        readCount: readCount,
        deliveredCount: deliveredCount
      };
    }

    /**
     * Sets the layer.Message.readStatus and layer.Message.deliveryStatus properties.
     *
     * @method _setReceiptStatus
     * @private
     * @param  {number} readCount
     * @param  {number} deliveredCount
     * @param  {number} userCount
     */

  }, {
    key: '_setReceiptStatus',
    value: function _setReceiptStatus(readCount, deliveredCount, userCount) {
      if (readCount === userCount) {
        this.readStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (readCount > 0) {
        this.readStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.readStatus = Constants.RECIPIENT_STATE.NONE;
      }
      if (deliveredCount === userCount) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.ALL;
      } else if (deliveredCount > 0) {
        this.deliveryStatus = Constants.RECIPIENT_STATE.SOME;
      } else {
        this.deliveryStatus = Constants.RECIPIENT_STATE.NONE;
      }
    }

    /**
     * Handle changes to the isRead property.
     *
     * If someone called m.isRead = true, AND
     * if it was previously false, AND
     * if the call didn't come from layer.Message.__updateRecipientStatus,
     * Then notify the server that the message has been read.
     *
     *
     * @method __updateIsRead
     * @private
     * @param  {boolean} value - True if isRead is true.
     */

  }, {
    key: '__updateIsRead',
    value: function __updateIsRead(value) {
      if (value) {
        this._sendReceipt(Constants.RECEIPT_STATE.READ);
        this._triggerAsync('messages:read');
        var conversation = this.getConversation(false);
        if (conversation) conversation.unreadCount--;
      }
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * @method sendReceipt
     * @param {string} [type=layer.Constants.RECEIPT_STATE.READ] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     * @return {layer.Message} this
     */

  }, {
    key: 'sendReceipt',
    value: function sendReceipt() {
      var type = arguments.length <= 0 || arguments[0] === undefined ? Constants.RECEIPT_STATE.READ : arguments[0];

      if (type === Constants.RECEIPT_STATE.READ) {
        if (this.isRead) {
          return this;
        } else {
          // Without triggering the event, clearObject isn't called,
          // which means those using the toObject() data will have an isRead that doesn't match
          // this instance.  Which typically leads to lots of extra attempts
          // to mark the message as read.
          this.__isRead = true;
          this._triggerAsync('messages:read');
          var conversation = this.getConversation(false);
          if (conversation) conversation.unreadCount--;
        }
      }
      this._sendReceipt(type);
      return this;
    }

    /**
     * Send a Read or Delivery Receipt to the server.
     *
     * This bypasses any validation and goes direct to sending to the server.
     *
     * NOTE: Server errors are not handled; the local receipt state is suitable even
     * if out of sync with the server.
     *
     * @method _sendReceipt
     * @private
     * @param {string} [type=read] - One of layer.Constants.RECEIPT_STATE.READ or layer.Constants.RECEIPT_STATE.DELIVERY
     */

  }, {
    key: '_sendReceipt',
    value: function _sendReceipt(type) {
      var _this4 = this;

      // This little test exists so that we don't send receipts on Conversations we are no longer
      // participants in (participants = [] if we are not a participant)
      var conversation = this.getConversation(false);
      if (conversation && conversation.participants.length === 0) return;

      this._setSyncing();
      this._xhr({
        url: '/receipts',
        method: 'POST',
        data: {
          type: type
        },
        sync: {
          // This should not be treated as a POST/CREATE request on the Message
          operation: 'RECEIPT'
        }
      }, function () {
        return _this4._setSynced();
      });
    }

    /**
     * Send the message to all participants of the Conversation.
     *
     * Message must have parts and a valid conversation to send successfully.
     *
     * @method send
     * @param {Object} [notification] - Parameters for controling how the phones manage notifications of the new Message.
     *                          See IOS and Android docs for details.
     * @param {string} [notification.text] - Text of your notification
     * @param {string} [notification.sound] - Name of an audio file or other sound-related hint
     * @return {layer.Message} this
     */

  }, {
    key: 'send',
    value: function send(notification) {
      var _this5 = this;

      var client = this.getClient();
      if (!client) {
        throw new Error(LayerError.dictionary.clientMissing);
      }

      var conversation = this.getConversation(true);

      if (!conversation) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      if (this.syncState !== Constants.SYNC_STATE.NEW) {
        throw new Error(LayerError.dictionary.alreadySent);
      }

      if (conversation.isLoading) {
        return conversation.once('conversations:loaded', function () {
          return _this5.send(notification);
        });
      }

      if (!this.parts || !this.parts.length) {
        throw new Error(LayerError.dictionary.partsMissing);
      }

      this.sender.userId = client.userId;
      this._setSyncing();
      client._addMessage(this);

      // Make sure that the Conversation has been created on the server
      // and update the lastMessage property
      conversation.send(this);

      // allow for modification of message before sending
      this.trigger('messages:sending');

      var data = {
        parts: new Array(this.parts.length),
        id: this.id
      };
      if (notification) data.notification = notification;

      this._preparePartsForSending(data);
      return this;
    }

    /**
     * Insures that each part is ready to send before actually sending the Message.
     *
     * @method _preparePartsForSending
     * @private
     * @param  {Object} structure to be sent to the server
     */

  }, {
    key: '_preparePartsForSending',
    value: function _preparePartsForSending(data) {
      var _this6 = this;

      var client = this.getClient();
      var count = 0;
      this.parts.forEach(function (part, index) {
        part.once('parts:send', function (evt) {
          data.parts[index] = {
            mime_type: evt.mime_type
          };
          if (evt.content) data.parts[index].content = evt.content;
          if (evt.body) data.parts[index].body = evt.body;
          if (evt.encoding) data.parts[index].encoding = evt.encoding;

          count++;
          if (count === _this6.parts.length) {
            _this6._send(data);
          }
        }, _this6);
        part._send(client);
      });
    }

    /**
     * Handle the actual sending.
     *
     * layer.Message.send has some potentially asynchronous
     * preprocessing to do before sending (Rich Content); actual sending
     * is done here.
     *
     * @method _send
     * @private
     */

  }, {
    key: '_send',
    value: function _send(data) {
      var _this7 = this;

      var client = this.getClient();
      var conversation = this.getConversation(false);

      this.sentAt = new Date();
      client.sendSocketRequest({
        method: 'POST',
        body: {
          method: 'Message.create',
          object_id: conversation.id,
          data: data
        },
        sync: {
          depends: [this.conversationId, this.id],
          target: this.id
        }
      }, function (success, socketData) {
        return _this7._sendResult(success, socketData);
      });
    }
  }, {
    key: '_getSendData',
    value: function _getSendData(data) {
      data.object_id = this.conversationId;
      return data;
    }

    /**
      * layer.Message.send() Success Callback.
      *
      * If successfully sending the message; triggers a 'sent' event,
      * and updates the message.id/url
      *
      * @method _sendResult
      * @private
      * @param {Object} messageData - Server description of the message
      */

  }, {
    key: '_sendResult',
    value: function _sendResult(_ref) {
      var success = _ref.success;
      var data = _ref.data;

      if (this.isDestroyed) return;

      if (success) {
        this._populateFromServer(data);
        this._triggerAsync('messages:sent');
      } else {
        this.trigger('messages:sent-error', { error: data });
        this.destroy();
      }
      this._setSynced();
    }

    /**
       * Standard `on()` provided by layer.Root.
       *
       * Adds some special handling of 'messages:loaded' so that calls such as
       *
       *      var m = client.getMessage('layer:///messages/123', true)
       *      .on('messages:loaded', function() {
       *          myrerender(m);
       *      });
       *      myrender(m); // render a placeholder for m until the details of m have loaded
       *
       * can fire their callback regardless of whether the client loads or has
       * already loaded the Message.
       *
       * @method on
       * @param  {string} eventName
       * @param  {Function} eventHandler
       * @param  {Object} context
       * @return {layer.Message} this
       */

  }, {
    key: 'on',
    value: function on(name, callback, context) {
      var hasLoadedEvt = name === 'messages:loaded' || name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object' && name['messages:loaded'];

      if (hasLoadedEvt && !this.isLoading) {
        (function () {
          var callNow = name === 'messages:loaded' ? callback : name['messages:loaded'];
          Util.defer(function () {
            return callNow.apply(context);
          });
        })();
      }
      _get(Object.getPrototypeOf(Message.prototype), 'on', this).call(this, name, callback, context);
      return this;
    }

    /**
     * Delete the Message from the server.
     *
     * This call will support various deletion modes.  Calling without a deletion mode is deprecated.
     *
     * Deletion Modes:
     *
     * * layer.Constants.DELETION_MODE.ALL: This deletes the local copy immediately, and attempts to also
     *   delete the server's copy.
     *
     * @method delete
     * @param {number} deletionMode - layer.Constants.DELETION_MODE.ALL is only supported mode at this time
     */

  }, {
    key: 'delete',
    value: function _delete(mode) {
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);

      var queryStr = undefined;
      switch (mode) {
        case Constants.DELETION_MODE.ALL:
        case true:
          queryStr = 'mode=all_participants';
          break;
        case Constants.DELETION_MODE.MY_DEVICES:
          queryStr = 'mode=my_devices';
          break;
        default:
          throw new Error(LayerError.dictionary.deletionModeUnsupported);
      }

      var id = this.id;
      var client = this.getClient();
      this._xhr({
        url: '?' + queryStr,
        method: 'DELETE'
      }, function (result) {
        if (!result.success && (!result.data || result.data.id !== 'not_found')) Message.load(id, client);
      });

      this._deleted();
      this.destroy();
    }

    /**
     * The Message has been deleted.
     *
     * Called from layer.Websockets.ChangeManager and from layer.Message.delete();
     *
     * Destroy must be called separately, and handles most cleanup.
     *
     * @method _deleted
     * @protected
     */

  }, {
    key: '_deleted',
    value: function _deleted() {
      this.trigger('messages:delete');
    }

    /**
     * Remove this Message from the system.
     *
     * This will deregister the Message, remove all events
     * and allow garbage collection.
     *
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var client = this.getClient();
      if (client) client._removeMessage(this);
      this.parts.forEach(function (part) {
        return part.destroy();
      });
      this.__parts = null;

      _get(Object.getPrototypeOf(Message.prototype), 'destroy', this).call(this);
    }

    /**
     * Populates this instance with the description from the server.
     *
     * Can be used for creating or for updating the instance.
     *
     * @method _populateFromServer
     * @protected
     * @param  {Object} m - Server description of the message
     */

  }, {
    key: '_populateFromServer',
    value: function _populateFromServer(message) {
      var _this8 = this;

      this.id = message.id;
      this.url = message.url;
      var oldPosition = this.position;
      this.position = message.position;

      // Assign IDs to preexisting Parts so that we can call getPartById()
      if (this.parts) {
        this.parts.forEach(function (part, index) {
          if (!part.id) part.id = _this8.id + '/parts/' + index;
        });
      }

      this.parts = message.parts.map(function (part) {
        var existingPart = _this8.getPartById(part.id);
        if (existingPart) {
          existingPart._populateFromServer(part);
          return existingPart;
        } else {
          return MessagePart._createFromServer(part);
        }
      });

      this.recipientStatus = message.recipient_status || {};

      this.isRead = !message.is_unread;

      this.sentAt = new Date(message.sent_at);
      this.receivedAt = message.received_at ? new Date(message.received_at) : undefined;

      this.sender = {
        userId: message.sender.user_id || '',
        name: message.sender.name || ''
      };

      this._setSynced();

      if (oldPosition && oldPosition !== this.position) {
        this._triggerAsync('messages:change', {
          oldValue: oldPosition,
          newValue: this.position,
          property: 'position'
        });
      }
    }

    /**
     * Returns the Message's layer.MessagePart with the specified the part ID.
     *
     * @method getPartById
     * @param {string} partId
     * @return {layer.MessagePart}
     */

  }, {
    key: 'getPartById',
    value: function getPartById(partId) {
      return this.parts ? this.parts.filter(function (part) {
        return part.id === partId;
      })[0] : null;
    }

    /**
     * Accepts json-patch operations for modifying recipientStatus.
     *
     * @method _handlePatchEvent
     * @private
     * @param  {Object[]} data - Array of operations
     */

  }, {
    key: '_handlePatchEvent',
    value: function _handlePatchEvent(newValue, oldValue, paths) {
      this._inLayerParser = false;
      if (paths[0].indexOf('recipient_status') === 0) {
        this.__updateRecipientStatus(this.recipientStatus, oldValue);
      }
      this._inLayerParser = true;
    }

    /**
     * Any xhr method called on this message uses the message's url.
     *
     * For more info on xhr method parameters see {@link layer.ClientAuthenticator#xhr}
     *
     * @method _xhr
     * @protected
     * @return {layer.Message} this
     */

  }, {
    key: '_xhr',
    value: function _xhr(options, callback) {
      // initialize
      var inUrl = options.url;
      var client = this.getClient();

      // Validatation
      if (this.isDestroyed) throw new Error(LayerError.dictionary.isDestroyed);
      if (!('url' in options)) throw new Error(LayerError.dictionary.urlRequired);

      if (inUrl && !inUrl.match(/^(\/|\?)/)) options.url = inUrl = '/' + options.url;
      if (!options.sync) options.url = this.url + options.url;

      // Setup sync structure
      options.sync = this._setupSyncObject(options.sync);

      client.xhr(options, callback);
      return this;
    }
  }, {
    key: '_getUrl',
    value: function _getUrl(url) {
      return this.url + (url || '');
    }
  }, {
    key: '_setupSyncObject',
    value: function _setupSyncObject(sync) {
      if (sync !== false) {
        if (!sync) sync = {};
        if (!sync.target) sync.target = this.id;
        if (!sync.depends) {
          sync.depends = [this.conversationId];
        } else if (sync.depends.indexOf(this.id) === -1) {
          sync.depends.push(this.conversationId);
        }
      }
      return sync;
    }

    /**
     * Get all text parts of the Message.
     *
     * Utility method for extracting all of the text/plain parts
     * and concatenating all of their bodys together into a single string.
     *
     * @method getText
     * @param {string} [joinStr='.  '] If multiple message parts of type text/plain, how do you want them joined together?
     * @return {string}
     */

  }, {
    key: 'getText',
    value: function getText() {
      var joinStr = arguments.length <= 0 || arguments[0] === undefined ? '. ' : arguments[0];

      var textArray = this.parts.filter(function (part) {
        return part.mimeType === 'text/plain';
      }).map(function (part) {
        return part.body;
      });
      textArray = textArray.filter(function (data) {
        return data;
      });
      return textArray.join(joinStr);
    }

    /**
     * Returns a plain object.
     *
     * Object will have all the same public properties as this
     * Message instance.  New object is returned any time
     * any of this object's properties change.
     *
     * @method toObject
     * @return {Object} POJO version of this object.
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      if (!this._toObject) {
        this._toObject = _get(Object.getPrototypeOf(Message.prototype), 'toObject', this).call(this);
        this._toObject.recipientStatus = Util.clone(this.recipientStatus);
        this._toObject.isNew = this.isNew();
        this._toObject.isSaving = this.isSaving();
        this._toObject.isSaved = this.isSaved();
        this._toObject.isSynced = this.isSynced();
      }
      return this._toObject;
    }
  }, {
    key: '_triggerAsync',
    value: function _triggerAsync(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), '_triggerAsync', this).call(this, evtName, args);
    }
  }, {
    key: 'trigger',
    value: function trigger(evtName, args) {
      this._clearObject();
      _get(Object.getPrototypeOf(Message.prototype), 'trigger', this).call(this, evtName, args);
    }

    /**
     * Creates a message from the server's representation of a message.
     *
     * Similar to _populateFromServer, however, this method takes a
     * message description and returns a new message instance using _populateFromServer
     * to setup the values.
     *
     * @method _createFromServer
     * @protected
     * @static
     * @param  {Object} message - Server's representation of the message
     * @param  {string} conversationId - Conversation for the message
     * @param  {layer.Client} client
     * @return {layer.Message}
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {
      this.conversationId = data.conversation.id;
      this.getClient()._addMessage(this);
    }

    /**
     * Identifies whether a Message receiving the specified patch data should be loaded from the server.
     *
     * Applies only to Messages that aren't already loaded; used to indicate if a change event is
     * significant enough to load the Message and trigger change events on that Message.
     *
     * At this time there are no properties that are patched on Messages via websockets
     * that would justify loading the Message from the server so as to notify the app.
     *
     * Only recipient status changes and maybe is_unread changes are sent;
     * neither of which are relevant to an app that isn't rendering that message.
     *
     * @method _loadResourceForPatch
     * @static
     * @private
     */

  }], [{
    key: '_createFromServer',
    value: function _createFromServer(message, client) {
      var fromWebsocket = message.fromWebsocket;
      return new Message({
        conversationId: message.conversation.id,
        fromServer: message,
        clientId: client.appId,
        _fromDB: message._fromDB,
        _notify: fromWebsocket && message.is_unread && message.sender.user_id !== client.userId
      });
    }
  }, {
    key: '_loadResourceForPatch',
    value: function _loadResourceForPatch(patchData) {
      return false;
    }
  }]);

  return Message;
}(Syncable);

/**
 * Client that the Message belongs to.
 *
 * Actual value of this string matches the appId.
 * @type {string}
 */


Message.prototype.clientId = '';

/**
 * Conversation that this Message belongs to.
 *
 * Actual value is the ID of the Conversation's ID.
 *
 * @type {string}
 */
Message.prototype.conversationId = '';

/**
 * Array of layer.MessagePart objects
 *
 * @type {layer.MessagePart[]}
 */
Message.prototype.parts = null;

/**
 * Message Identifier.
 *
 * This value is shared by all participants and devices.
 *
 * @type {String}
 */
Message.prototype.id = '';

/**
 * URL to the server endpoint for operating on the message.
 * @type {String}
 */
Message.prototype.url = '';

/**
 * Time that the message was sent.
 * @type {Date}
 */
Message.prototype.sentAt = null;

/**
 * Time that the first delivery receipt was sent by your
 * user acknowledging receipt of the message.
 * @type {Date}
 */
Message.prototype.receivedAt = null;

/**
 * Object representing the sender of the Message.
 *
 * Contains `userId` property which is
 * populated when the message was sent by a participant (or former participant)
 * in the Conversation.  Contains a `name` property which is
 * used when the Message is sent via a Named Platform API sender
 * such as "Admin", "Moderator", "Robot Jerking you Around".
 *
 *      <span class='sent-by'>
 *        {message.sender.name || getDisplayNameForId(message.sender.userId)}
 *      </span>
 *
 * @type {Object}
 */
Message.prototype.sender = null;

/**
 * Position of this message within the conversation.
 *
 * NOTES:
 *
 * 1. Deleting a message does not affect position of other Messages.
 * 2. A position is not gaurenteed to be unique (multiple messages sent at the same time could
 * all claim the same position)
 * 3. Each successive message within a conversation should expect a higher position.
 *
 * @type {Number}
 */
Message.prototype.position = 0;

/**
 * Hint used by layer.Client on whether to trigger a messages:notify event.
 *
 * @type {boolean}
 * @private
 */
Message.prototype._notify = false;

/* Recipient Status */

/**
 * Read/delivery State of all participants.
 *
 * This is an object containing keys for each participant,
 * and a value of:
 * * layer.RECEIPT_STATE.SENT
 * * layer.RECEIPT_STATE.DELIVERED
 * * layer.RECEIPT_STATE.READ
 * * layer.RECEIPT_STATE.PENDING
 *
 * @type {Object}
 */
Message.prototype.recipientStatus = null;

/**
 * True if this Message has been read by this user.
 *
 * You can change isRead programatically
 *
 *      m.isRead = true;
 *
 * This will automatically notify the server that the message was read by your user.
 * @type {Boolean}
 */
Message.prototype.isRead = false;

/**
 * This property is here for convenience only; it will always be the opposite of isRead.
 * @type {Boolean}
 * @readonly
 */
Object.defineProperty(Message.prototype, 'isUnread', {
  enumerable: true,
  get: function get() {
    return !this.isRead;
  }
});

/**
 * Have the other participants read this Message yet.
 *
 * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 * @type {String}
 */
Message.prototype.readStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * Have the other participants received this Message yet.
 *
  * This value is one of:
 *
 *  * layer.Constants.RECIPIENT_STATE.ALL
 *  * layer.Constants.RECIPIENT_STATE.SOME
 *  * layer.Constants.RECIPIENT_STATE.NONE
 *
 *  This value is updated any time recipientStatus changes.
 *
 *
 * @type {String}
 */
Message.prototype.deliveryStatus = Constants.RECIPIENT_STATE.NONE;

/**
 * The time that this client created this instance.
 * @type {Date}
 */
Message.prototype.localCreatedAt = null;

Message.prototype._toObject = null;

Message.prototype._fromDB = false;

Message.eventPrefix = 'messages';

Message.prefixUUID = 'layer:///messages/';

Message.inObjectIgnore = Syncable.inObjectIgnore;

Message.bubbleEventParent = 'getClient';

Message.imageTypes = ['image/gif', 'image/png', 'image/jpeg', 'image/jpg'];

Message._supportedEvents = [

/**
 * Message has been loaded from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded',

/**
 * The load method failed to load the message from the server.
 *
 * Note that this is only used in response to the layer.Message.load() method.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:loaded-error',

/**
 * Message deleted from the server.
 *
 * Caused by a call to layer.Message.delete() or a websocket event.
 * @param {layer.LayerEvent} evt
 * @event
 */
'messages:delete',

/**
 * Message is about to be sent.
 *
 * Last chance to modify or validate the message prior to sending.
 *
 *     message.on('messages:sending', function(evt) {
 *        message.addPart({mimeType: 'application/location', body: JSON.stringify(getGPSLocation())});
 *     });
 *
 * Typically, you would listen to this event more broadly using `client.on('messages:sending')`
 * which would trigger before sending ANY Messages.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sending',

/**
 * Message has been received by the server.
 *
 * It does NOT indicate delivery to other users.
 *
 * It does NOT indicate messages sent by other users.
 *
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:sent',

/**
 * Server failed to receive the Message.
 *
 * Message will be deleted immediately after firing this event.
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.LayerError} evt.error
 */
'messages:sent-error',

/**
 * Fired when message.isRead is set to true.
 *
 * Sometimes this event is triggered by marking the Message as read locally; sometimes its triggered
 * by your user on a separate device/browser marking the Message as read remotely.
 *
 * Useful if you style unread messages in bold, and need an event to tell you when
 * to unbold the message.
 *
 * @event
 * @param {layer.LayerEvent} evt
 * @param {layer.Message[]} evt.messages - Array of messages that have just been marked as read
 */
'messages:read',

/**
 * The recipientStatus property has changed.
 *
 * This happens in response to an update
 * from the server... but is also caused by marking the current user has having read
 * or received the message.
 * @event
 * @param {layer.LayerEvent} evt
 */
'messages:change'].concat(Syncable._supportedEvents);

Root.initClass.apply(Message, [Message, 'Message']);
Syncable.subclasses.push(Message);
module.exports = Message;

},{"./client-registry":9,"./client-utils":10,"./const":12,"./layer-error":16,"./message-part":19,"./root":24,"./syncable":27}],21:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This class manages a state variable for whether we are online/offline, triggers events
 * when the state changes, and determines when to perform tests to validate our online status.
 *
 * It performs the following tasks:
 *
 * 1. Any time we go more than this.pingFrequency (100 seconds) without any data from the server, flag us as being offline.
 *    Rationale: The websocket manager is calling `getCounter` every 30 seconds; so it would have had to fail to get any response
 *    3 times before we give up.
 * 2. While we are offline, ping the server until we determine we are in fact able to connect to the server
 * 3. Trigger events `connected` and `disconnected` to let the rest of the system know when we are/are not connected.
 *    NOTE: The Websocket manager will use that to reconnect its websocket, and resume its `getCounter` call every 30 seconds.
 *
 * NOTE: Apps that want to be notified of changes to online/offline state should see layer.Client's `online` event.
 *
 * NOTE: One iteration of this class treated navigator.onLine = false as fact.  If onLine is false, then we don't need to test
 * anything.  If its true, then this class verifies it can reach layer's servers.  However, https://code.google.com/p/chromium/issues/detail?id=277372 has replicated multiple times in chrome; this bug causes one tab of chrome to have navigator.onLine=false while all other tabs
 * correctly report navigator.onLine=true.  As a result, we can't rely on this value and this class must continue to poll the server while
 * offline and to ignore values from navigator.onLine.  Future Work: Allow non-chrome browsers to use navigator.onLine.
 *
 * @class  layer.OnlineStateManager
 * @private
 * @extends layer.Root
 *
 */
var Root = require('./root');
var xhr = require('./xhr');
var logger = require('./logger');
var Utils = require('./client-utils');

var OnlineStateManager = function (_Root) {
  _inherits(OnlineStateManager, _Root);

  /**
   * Creates a new OnlineStateManager.
   *
   * An Application is expected to only have one of these.
   *
   *      var onlineStateManager = new layer.OnlineStateManager({
   *          socketManager: socketManager,
   *          testUrl: 'https://api.layer.com/nonces'
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param  {layer.Websockets.SocketManager} options.socketManager - A websocket manager to monitor for messages
   * @param  {string} options.testUrl - A url to send requests to when testing if we are online
   */

  function OnlineStateManager(options) {
    _classCallCheck(this, OnlineStateManager);

    // Listen to all xhr events and websocket messages for online-status info

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OnlineStateManager).call(this, options));

    xhr.addConnectionListener(function (evt) {
      return _this._connectionListener(evt);
    });
    _this.socketManager.on('message', function () {
      return _this._connectionListener({ status: 'connection:success' });
    }, _this);

    // Any change in online status reported by the browser should result in
    // an immediate update to our online/offline state
    /* istanbul ignore else */
    if (typeof window !== 'undefined') {
      window.addEventListener('online', _this._handleOnlineEvent.bind(_this));
      window.addEventListener('offline', _this._handleOnlineEvent.bind(_this));
    }
    return _this;
  }

  /**
   * We don't actually start managing our online state until after the client has authenticated.
   * Call start() when we are ready for the client to start managing our state.
   *
   * The client won't call start() without first validating that we have a valid session, so by definition,
   * calling start means we are online.
   *
   * @method start
   */


  _createClass(OnlineStateManager, [{
    key: 'start',
    value: function start() {
      logger.info('OnlineStateManager: start');
      this.isClientReady = true;
      this.isOnline = true;
      if (!this._firstStart) {
        this.trigger('connected', { offlineDuration: 0 });
      }
      this._firstStart = false;
      this._scheduleNextOnlineCheck();
    }

    /**
     * If the client becomes unauthenticated, stop checking if we are online, and announce that we are offline.
     *
     * @method stop
     */

  }, {
    key: 'stop',
    value: function stop() {
      logger.info('OnlineStateManager: stop');
      this.isClientReady = false;
      this._clearCheck();
      this._changeToOffline();
    }

    /**
     * Schedules our next call to _onlineExpired if online or checkOnlineStatus if offline.
     *
     * @method _scheduleNextOnlineCheck
     * @private
     */

  }, {
    key: '_scheduleNextOnlineCheck',
    value: function _scheduleNextOnlineCheck() {
      logger.debug('OnlineStateManager: skip schedule');
      if (this.isDestroyed || !this.isClientReady) return;

      // Replace any scheduled calls with the newly scheduled call:
      this._clearCheck();

      // If this is called while we are online, then we are using this to detect when we've gone without data for more than pingFrequency.
      // Call this._onlineExpired after pingFrequency of no server responses.
      if (this.isOnline) {
        logger.debug('OnlineStateManager: Scheduled onlineExpired');
        this.onlineCheckId = setTimeout(this._onlineExpired.bind(this), this.pingFrequency);
      }

      // If this is called while we are offline, we're doing exponential backoff pinging the server to see if we've come back online.
      else {
          logger.info('OnlineStateManager: Scheduled checkOnlineStatus');
          var duration = Utils.getExponentialBackoffSeconds(this.maxOfflineWait, Math.min(10, this.offlineCounter++));
          this.onlineCheckId = setTimeout(this.checkOnlineStatus.bind(this), Math.floor(duration * 1000));
        }
    }

    /**
     * Cancels any upcoming calls to checkOnlineStatus
     *
     * @method _clearCheck
     * @private
     */

  }, {
    key: '_clearCheck',
    value: function _clearCheck() {
      if (this.onlineCheckId) {
        clearTimeout(this.onlineCheckId);
        this.onlineCheckId = 0;
      }
    }

    /**
     * Respond to the browser's online/offline events.
     *
     * Our response is not to trust them, but to use them as
     * a trigger to indicate we should immediately do our own
     * validation.
     *
     * @method _handleOnlineEvent
     * @private
     * @param  {Event} evt - Browser online/offline event object
     */

  }, {
    key: '_handleOnlineEvent',
    value: function _handleOnlineEvent(evt) {
      // Reset the counter because our first request may fail as they may not be
      // fully connected yet
      this.offlineCounter = 0;
      this.checkOnlineStatus();
    }

    /**
     * Our online state has expired; we are now offline.
     *
     * If this method gets called, it means that our connection has gone too long without any data
     * and is now considered to be disconnected.  Start scheduling tests to see when we are back online.
     *
     * @method _onlineExpired
     * @private
     */

  }, {
    key: '_onlineExpired',
    value: function _onlineExpired() {
      this._clearCheck();
      this._changeToOffline();
      this._scheduleNextOnlineCheck();
    }

    /**
     * Get a nonce to see if we can reach the server.
     *
     * We don't care about the result,
     * we just care about triggering a 'connection:success' or 'connection:error' event
     * which connectionListener will respond to.
     *
     *      client.onlineManager.checkOnlineStatus(function(result) {
     *          alert(result ? 'We're online!' : 'Doh!');
     *      });
     *
     * @method checkOnlineStatus
     * @param {Function} callback
     * @param {boolean} callback.isOnline - Callback is called with true if online, false if not
     */

  }, {
    key: 'checkOnlineStatus',
    value: function checkOnlineStatus(callback) {
      var _this2 = this;

      this._clearCheck();

      logger.info('OnlineStateManager: Firing XHR for online check');
      this._lastCheckOnlineStatus = new Date();
      // Ping the server and see if we're connected.
      xhr({
        url: this.testUrl,
        method: 'POST',
        headers: {
          accept: 'application/vnd.layer+json; version=1.0'
        }
      }, function () {
        // this.isOnline will be updated via _connectionListener prior to this line executing
        if (callback) callback(_this2.isOnline);
      });
    }

    /**
     * On determining that we are offline, handles the state transition and logging.
     *
     * @method _changeToOffline
     * @private
     */

  }, {
    key: '_changeToOffline',
    value: function _changeToOffline() {
      if (this.isOnline) {
        this.isOnline = false;
        this.trigger('disconnected');
        logger.info('OnlineStateManager: Connection lost');
      }
    }

    /**
     * Called whenever a websocket event arrives, or an xhr call completes; updates our isOnline state.
     *
     * Any call to this method will reschedule our next is-online test
     *
     * @method _connectionListener
     * @private
     * @param  {string} evt - Name of the event; either 'connection:success' or 'connection:error'
     */

  }, {
    key: '_connectionListener',
    value: function _connectionListener(evt) {
      // If event is a success, change us to online
      if (evt.status === 'connection:success') {
        var lastTime = this.lastMessageTime;
        this.lastMessageTime = new Date();
        if (!this.isOnline) {
          this.isOnline = true;
          this.offlineCounter = 0;
          this.trigger('connected', { offlineDuration: lastTime ? Date.now() - lastTime : 0 });
          if (this.connectedCounter === undefined) this.connectedCounter = 0;
          this.connectedCounter++;
          logger.info('OnlineStateManager: Connected restored');
        }
      }

      // If event is NOT success, change us to offline.
      else {
          this._changeToOffline();
        }

      this._scheduleNextOnlineCheck();
    }

    /**
     * Cleanup/shutdown
     *
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this._clearCheck();
      this.socketManager = null;
      _get(Object.getPrototypeOf(OnlineStateManager.prototype), 'destroy', this).call(this);
    }
  }]);

  return OnlineStateManager;
}(Root);

OnlineStateManager.prototype.isClientReady = false;

/**
 * URL To fire when testing to see if we are online.
 * @type {String}
 */
OnlineStateManager.prototype.testUrl = '';

/**
 * A Websocket manager whose 'message' event we will listen to
 * in order to know that we are still online.
 * @type {layer.Websockets.SocketManager}
 */
OnlineStateManager.prototype.socketManager = null;

/**
 * Number of testUrl requests we've been offline for.
 *
 * Will stop growing once the number is suitably large (10-20).
 * @type {Number}
 */
OnlineStateManager.prototype.offlineCounter = 0;

/**
 * Maximum wait during exponential backoff while offline.
 *
 * While offline, exponential backoff is used to calculate how long to wait between checking with the server
 * to see if we are online again. This value determines the maximum wait; any higher value returned by exponential backoff
 * are ignored and this value used instead.
 * Value is measured in seconds.
 * @type {Number}
 */
OnlineStateManager.prototype.maxOfflineWait = 5 * 60;

/**
 * Minimum wait between tries in ms.
 * @type {Number}
 */
OnlineStateManager.prototype.minBackoffWait = 100;

/**
 * Time that the last successful message was observed.
 * @type {Date}
 */
OnlineStateManager.prototype.lastMessageTime = null;

/**
 * For debugging, tracks the last time we checked if we are online.
 * @type {Date}
 */
OnlineStateManager.prototype._lastCheckOnlineStatus = null;

/**
 * Are we currently online?
 * @type {Boolean}
 */
OnlineStateManager.prototype.isOnline = false;

/**
 * setTimeoutId for the next checkOnlineStatus() call.
 * @type {Number}
 */
OnlineStateManager.prototype.onlineCheckId = 0;

/**
 * True until the first time start() is called.
 * @type {boolean}
 */
OnlineStateManager.prototype._firstStart = true;

/**
 * If we are online, how often do we need to ping to verify we are still online.
 *
 * Value is reset any time we observe any messages from the server.
 * Measured in miliseconds. NOTE: Websocket has a separate ping which mostly makes
 * this one unnecessary.  May end up removing this one... though we'd keep the
 * ping for when our state is offline.
 * @type {Number}
 */
OnlineStateManager.prototype.pingFrequency = 100 * 1000;

OnlineStateManager._supportedEvents = [
/**
 * We appear to be online and able to send and receive
 * @event connected
 * @param {number} onlineDuration - Number of miliseconds since we were last known to be online
 */
'connected',

/**
 * We appear to be offline and unable to send or receive
 * @event disconnected
 */
'disconnected'].concat(Root._supportedEvents);
Root.initClass.apply(OnlineStateManager, [OnlineStateManager, 'OnlineStateManager']);
module.exports = OnlineStateManager;

},{"./client-utils":10,"./logger":18,"./root":24,"./xhr":36}],22:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Query = require('./query');
var LayerError = require('./layer-error');

/**
 * Query builder class generating queries for a set of messages.
 * Used in Creating and Updating layer.Query instances.
 *
 * Using the Query Builder, we should be able to instantiate a Query
 *
 *      var qBuilder = QueryBuilder
 *       .messages()
 *       .forConversation('layer:///conversations/ffffffff-ffff-ffff-ffff-ffffffffffff')
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .messages()
 *       .forConversation('layer:///conversations/bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb')
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.MessagesQuery
 */

var MessagesQuery = function () {

  /**
   * Creates a new query builder for a set of messages.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */

  function MessagesQuery(query) {
    _classCallCheck(this, MessagesQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow
      };
    } else {
      this._query = {
        model: Query.Message,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow
      };
    }

    // TODO remove when messages can be fetched via query API rather than `GET /messages`
    this._conversationIdSet = false;
  }

  /**
   * Query for messages in this Conversation.
   *
   * @method forConversation
   * @param  {String} conversationId
   */


  _createClass(MessagesQuery, [{
    key: 'forConversation',
    value: function forConversation(conversationId) {
      if (conversationId) {
        this._query.predicate = 'conversation.id = \'' + conversationId + '\'';
        this._conversationIdSet = true;
      } else {
        delete this._query.predicate;
        this._conversationIdSet = false;
      }
      return this;
    }

    /**
     * Sets the pagination window/number of messages to fetch from the local cache or server.
     *
     * Currently only positive integers are supported.
     *
     * @method paginationWindow
     * @param  {number} win
     */

  }, {
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      if (!this._conversationIdSet) {
        throw new Error(LayerError.dictionary.conversationMissing);
      }

      return this._query;
    }
  }]);

  return MessagesQuery;
}();

var AnnouncementQuery = function (_MessagesQuery) {
  _inherits(AnnouncementQuery, _MessagesQuery);

  function AnnouncementQuery() {
    _classCallCheck(this, AnnouncementQuery);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(AnnouncementQuery).apply(this, arguments));
  }

  _createClass(AnnouncementQuery, [{
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return AnnouncementQuery;
}(MessagesQuery);

/**
 * Query builder class generating queries for a set of Conversations.
 *
 * Used in Creating and Updating layer.Query instances.
 * Note that at this time, the only thing we can query for is
 * ALL Conversations; primary use for this is to page through the Conversations.
 *
 * To get started:
 *
 *      var qBuilder = QueryBuilder
 *       .conversations()
 *       .paginationWindow(100);
 *      var query = client.createQuery(qBuilder);
 *
 * You can then create additional builders and update the query:
 *
 *      var qBuilder2 = QueryBuilder
 *       .conversations()
 *       .paginationWindow(200);
 *      query.update(qBuilder);
 *
 * @class layer.QueryBuilder.ConversationsQuery
 */


var ConversationsQuery = function () {

  /**
   * Creates a new query builder for a set of conversations.
   *
   * Standard use is without any arguments.
   *
   * @method constructor
   * @param  {Object} [query=null]
   */

  function ConversationsQuery(query) {
    _classCallCheck(this, ConversationsQuery);

    if (query) {
      this._query = {
        model: query.model,
        returnType: query.returnType,
        dataType: query.dataType,
        paginationWindow: query.paginationWindow,
        sortBy: query.sortBy
      };
    } else {
      this._query = {
        model: Query.Conversation,
        returnType: 'object',
        dataType: 'object',
        paginationWindow: Query.prototype.paginationWindow,
        sortBy: null
      };
    }
  }

  /**
   * Sets the pagination window/number of messages to fetch from the local cache or server.
   *
   * Currently only positive integers are supported.
   *
   * @method paginationWindow
   * @param  {number} win
   * @return {layer.QueryBuilder} this
   */


  _createClass(ConversationsQuery, [{
    key: 'paginationWindow',
    value: function paginationWindow(win) {
      this._query.paginationWindow = win;
      return this;
    }

    /**
     * Sets the sorting options for the Conversation.
     *
     * Currently only supports descending order
     * Currently only supports fieldNames of "createdAt" and "lastMessage.sentAt"
     *
     * @method sortBy
     * @param  {string} fieldName  - field to sort by
     * @param  {boolean} asc - Is an ascending sort?
     * @return {layer.QueryBuilder} this
     */

  }, {
    key: 'sortBy',
    value: function sortBy(fieldName) {
      var asc = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

      this._query.sortBy = [_defineProperty({}, fieldName, asc ? 'asc' : 'desc')];
      return this;
    }

    /**
     * Returns the built query object to send to the server.
     *
     * Called by layer.QueryBuilder. You should not need to call this.
     *
     * @method build
     */

  }, {
    key: 'build',
    value: function build() {
      return this._query;
    }
  }]);

  return ConversationsQuery;
}();

/**
 * Query builder class. Used with layer.Query to specify what local/remote
 * data changes to subscribe to.  For examples, see layer.QueryBuilder.MessagesQuery
 * and layer.QueryBuilder.ConversationsQuery.  This static class is used to instantiate
 * MessagesQuery and ConversationsQuery Builder instances:
 *
 *      var conversationsQueryBuilder = QueryBuilder.conversations();
 *      var messagesQueryBuidler = QueryBuilder.messages();
 *
 * Should you use these instead of directly using the layer.Query class?
 * That is a matter of programming style and preference, there is no
 * correct answer.
 *
 * @class layer.QueryBuilder
 */


var QueryBuilder = {

  /**
   * Create a new layer.MessagesQuery instance.
   *
   * @method messages
   * @static
   * @returns {layer.QueryBuilder.MessagesQuery}
   */

  messages: function messages() {
    return new MessagesQuery();
  },
  announcements: function announcements() {
    return new AnnouncementQuery();
  },


  /**
   * Create a new layer.ConversationsQuery instance.
   *
   * @method conversations
   * @static
   * @returns {layer.QueryBuilder.ConversationsQuery}
   */
  conversations: function conversations() {
    return new ConversationsQuery();
  },


  /**
   * Takes the return value of QueryBuilder.prototype.build and creates a
   * new QueryBuilder.
   *
   * Used within layer.Query.prototype.toBuilder.
   *
   * @method fromQueryObject
   * @private
   * @param {Object} obj
   * @static
   */
  fromQueryObject: function fromQueryObject(obj) {
    switch (obj.model) {
      case Query.Message:
        return new MessagesQuery(obj);
      case Query.Announcement:
        return new AnnouncementQuery(obj);
      case Query.Conversation:
        return new ConversationsQuery(obj);
      default:
        return null;
    }
  }
};

module.exports = QueryBuilder;

},{"./layer-error":16,"./query":23}],23:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * There are two ways to instantiate this class:
 *
 *      // 1. Using a Query Builder
 *      var queryBuilder = QueryBuilder.conversations().sortBy('lastMessage');
 *      var query = client.createQuery(client, queryBuilder);
 *
 *      // 2. Passing properties directly
 *      var query = client.createQuery({
 *        client: client,
 *        model: layer.Query.Conversation,
 *        sortBy: [{'createdAt': 'desc'}]
 *      });
 *
 * You can change the data selected by your query any time you want using:
 *
 *      query.update({
 *        paginationWindow: 200
 *      });
 *
 *      query.update({
 *        predicate: 'conversation.id = "' + conv.id + "'"
 *      });
 *
 *     // Or use the Query Builder:
 *     queryBuilder.paginationWindow(200);
 *     query.update(queryBuilder);
 *
 * You can release Conversations and Messages held in memory by your queries when done with them:
 *
 *      query.destroy();
 *
 * #### sortBy
 *
 * Note that the sortBy property is only supported for Conversations at this time and only
 * supports "createdAt" and "lastMessage.sentAt" as sort fields.
 *
 * #### dataType
 *
 * The layer.Query.dataType property lets you specify what type of data shows up in your results:
 *
 * ```javascript
 * var query = client.createQuery({
 *     model: layer.Query.Message,
 *     predicate: "conversation.id = 'layer:///conversations/uuid'",
 *     dataType: layer.Query.InstanceDataType
 * })
 *
 * var query = client.createQuery({
 *     model: layer.Query.Message,
 *     predicate: "conversation.id = 'layer:///conversations/uuid'",
 *     dataType: layer.Query.ObjectDataType
 * })
 * ```
 *
 * The property defaults to layer.Query.InstanceDataType.  Instances support methods and let you subscribe to events for direct notification
 * of changes to any of the results of your query:
 *
 * ```javascript
 * query.data[0].on('messages:read', function() {
 *     alert('The first message has been read!');
 * });
 * ```
 *
 * A value of layer.Query.ObjectDataType will cause the data to be an array of immutable objects rather than instances.  One can still get an instance from the POJO:
 *
 * ```javascript
 * var m = client.getMessage(query.data[0].id);
 * m.on('messages:read', function() {
 *     alert('The first message has been read!');
 * });
 * ```
 *
 * ## Query Events
 *
 * Queries fire events whenever their data changes.  There are 5 types of events;
 * all events are received by subscribing to the `change` event.
 *
 * ### 1. Data Events
 *
 * The Data event is fired whenever a request is sent to the server for new query results.  This could happen when first creating the query, when paging for more data, or when changing the query's properties, resulting in a new request to the server.
 *
 * The Event object will have an `evt.data` array of all newly added results.  But frequently you may just want to use the `query.data` array and get ALL results.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'data') {
 *      var newData = evt.data;
 *      var allData = query.data;
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:data', function(evt) {}` is also supported.
 *
 * ### 2. Insert Events
 *
 * A new Conversation or Message was created. It may have been created locally by your user, or it may have been remotely created, received via websocket, and added to the Query's results.
 *
 * The layer.LayerEvent.target property contains the newly inserted object.
 *
 * ```javascript
 *  query.on('change', function(evt) {
 *    if (evt.type === 'insert') {
 *       var newItem = evt.target;
 *       var allData = query.data;
 *    }
 *  });
 * ```
 *
 * Note that `query.on('change:insert', function(evt) {}` is also supported.
 *
 * ### 3. Remove Events
 *
 * A Conversation or Message was deleted. This may have been deleted locally by your user, or it may have been remotely deleted, a notification received via websocket, and removed from the Query results.
 *
 * The layer.LayerEvent.target property contains the removed object.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'remove') {
 *       var removedItem = evt.target;
 *       var allData = query.data;
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:remove', function(evt) {}` is also supported.
 *
 * ### 4. Reset Events
 *
 * Any time your query's model or predicate properties have been changed
 * the query is reset, and a new request is sent to the server.  The reset event informs your UI that the current result set is empty, and that the reason its empty is that it was `reset`.  This helps differentiate it from a `data` event that returns an empty array.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'reset') {
 *       var allData = query.data; // []
 *   }
 * });
 * ```
 *
 * Note that `query.on('change:reset', function(evt) {}` is also supported.
 *
 * ### 5. Property Events
 *
 * If any properties change in any of the objects listed in your layer.Query.data property, a `property` event will be fired.
 *
 * The layer.LayerEvent.target property contains object that was modified.
 *
 * See layer.LayerEvent.changes for details on how changes are reported.
 *
 * ```javascript
 * query.on('change', function(evt) {
 *   if (evt.type === 'property') {
 *       var changedItem = evt.target;
 *       var isReadChanges = evt.getChangesFor('isRead');
 *       var recipientStatusChanges = evt.getChangesFor('recipientStatus');
 *       if (isReadChanges.length) {
 *           ...
 *       }
 *
 *       if (recipientStatusChanges.length) {
 *           ...
 *       }
 *   }
 * });
 *```
 * Note that `query.on('change:property', function(evt) {}` is also supported.
 *
 * @class  layer.Query
 * @extends layer.Root
 *
 */
var Root = require('./root');
var LayerError = require('./layer-error');
var Util = require('./client-utils');
var Logger = require('./logger');

var CONVERSATION = 'Conversation';
var MESSAGE = 'Message';
var ANNOUNCEMENT = 'Announcement';
var findConvIdRegex = new RegExp(/^conversation.id\s*=\s*['"](layer:\/\/\/conversations\/.{8}-.{4}-.{4}-.{4}-.{12})['"]$/);

var Query = function (_Root) {
  _inherits(Query, _Root);

  function Query() {
    _classCallCheck(this, Query);

    var options = undefined;
    if (arguments.length === 2) {
      options = (arguments.length <= 1 ? undefined : arguments[1]).build();
      options.client = arguments.length <= 0 ? undefined : arguments[0];
    } else {
      options = arguments.length <= 0 ? undefined : arguments[0];
    }
    if ('paginationWindow' in options) {
      var paginationWindow = options.paginationWindow;
      options.paginationWindow = Math.min(Query.MaxPageSize, options.paginationWindow);
      if (options.paginationWindow !== paginationWindow) {
        Logger.warn('paginationWindow value ' + paginationWindow + ' in Query constructor ' + ('excedes Query.MaxPageSize of ' + Query.MaxPageSize));
      }
    }

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Query).call(this, options));

    _this.data = [];
    _this._initialPaginationWindow = _this.paginationWindow;
    if (!_this.client) throw new Error(LayerError.dictionary.clientMissing);
    _this.client.on('all', _this._handleChangeEvents, _this);

    if (!_this.client.isReady) {
      _this.client.once('ready', function () {
        return _this._run();
      }, _this);
    } else {
      _this._run();
    }
    return _this;
  }

  /**
   * Cleanup and remove this Query, its subscriptions and data.
   *
   * @method destroy
   */


  _createClass(Query, [{
    key: 'destroy',
    value: function destroy() {
      this.client.off(null, null, this);
      this.client._removeQuery(this);
      this.data = null;
      _get(Object.getPrototypeOf(Query.prototype), 'destroy', this).call(this);
    }

    /**
     * Updates properties of the Query.
     *
     * Currently supports updating:
     *
     * * paginationWindow
     * * predicate
     * * model
     *
     * Any change to predicate or model results in clearing all data from the
     * query's results and triggering a change event with [] as the new data.
     *
     * @method update
     * @param  {Object} options
     * @param {string} [options.predicate] - A new predicate for the query
     * @param {string} [options.model] - A new model for the Query
     * @param {number} [paginationWindow] - Increase/decrease our result size to match this pagination window.
     * @return {layer.Query} this
     */

  }, {
    key: 'update',
    value: function update() {
      var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var needsRefresh = undefined,
          needsRecreate = undefined;

      var optionsBuilt = typeof options.build === 'function' ? options.build() : options;

      if ('paginationWindow' in optionsBuilt && this.paginationWindow !== optionsBuilt.paginationWindow) {
        this.paginationWindow = Math.min(Query.MaxPageSize + this.size, optionsBuilt.paginationWindow);
        if (this.paginationWindow < optionsBuilt.paginationWindow) {
          Logger.warn('paginationWindow value ' + optionsBuilt.paginationWindow + ' in Query.update() ' + ('increases size greater than Query.MaxPageSize of ' + Query.MaxPageSize));
        }
        needsRefresh = true;
      }
      if ('predicate' in optionsBuilt && this.predicate !== optionsBuilt.predicate) {
        this.predicate = optionsBuilt.predicate || '';
        needsRecreate = true;
      }
      if ('model' in optionsBuilt && this.model !== optionsBuilt.model) {
        this.model = optionsBuilt.model;
        needsRecreate = true;
      }
      if ('sortBy' in optionsBuilt && JSON.stringify(this.sortBy) !== JSON.stringify(optionsBuilt.sortBy)) {
        this.sortBy = optionsBuilt.sortBy;
        needsRecreate = true;
      }
      if (needsRecreate) {
        this._reset();
      }
      if (needsRecreate || needsRefresh) this._run();
      return this;
    }

    /**
     * After redefining the query, reset it: remove all data/reset all state.
     *
     * @method _reset
     * @private
     */

  }, {
    key: '_reset',
    value: function _reset() {
      this.totalSize = 0;
      var data = this.data;
      this.data = [];
      this.client._checkAndPurgeCache(data);
      this.isFiring = false;
      this._predicate = null;
      this.paginationWindow = this._initialPaginationWindow;
      this.isReset = true;
      this._triggerChange({
        data: [],
        type: 'reset'
      });
    }

    /**
     * Reset your query to its initial state and then rerun it.
     *
     * @method reset
     */

  }, {
    key: 'reset',
    value: function reset() {
      this._reset();
      this._run();
    }

    /**
     * Execute the query.
     *
     * No, don't murder it, just fire it.  No, don't make it unemployed,
     * just connect to the server and get the results.
     *
     * @method _run
     * @private
     */

  }, {
    key: '_run',
    value: function _run() {
      // Find the number of items we need to request.
      var pageSize = Math.min(this.paginationWindow - this.size, Query.MaxPageSize);

      // If there is a reduction in pagination window, then this variable will be negative, and we can shrink
      // the data.
      if (pageSize < 0) {
        var removedData = this.data.slice(this.paginationWindow);
        this.data = this.data.slice(0, this.paginationWindow);
        this.client._checkAndPurgeCache(removedData);
        this._triggerAsync('change', { data: [] });
      } else if (pageSize === 0) {
        // No need to load 0 results.
      } else if (this.model === CONVERSATION) {
          this._runConversation(pageSize);
        } else if (this.model === MESSAGE && this.predicate) {
          this._runMessage(pageSize);
        } else if (this.model === ANNOUNCEMENT) {
          this._runAnnouncement(pageSize);
        }
    }

    /**
     * Get Conversations from the server.
     *
     * @method _runConversation
     * @private
     * @param  {number} pageSize - Number of new results to request
     */

  }, {
    key: '_runConversation',
    value: function _runConversation(pageSize) {
      var _this2 = this;

      // If no data, retrieve data from db cache in parallel with loading data from server
      if (this.isReset) {
        this.client.dbManager.loadConversations(function (conversations) {
          return _this2._appendResults({ data: conversations });
        });
      }
      this.isReset = false;

      // This is a pagination rather than an initial request if there is already data; get the fromId
      // which is the id of the last result.
      var lastConversation = this.data[this.data.length - 1];
      var lastConversationInstance = !lastConversation ? null : this._getInstance(lastConversation);
      var fromId = lastConversationInstance && lastConversationInstance.isSaved() ? '&from_id=' + lastConversationInstance.id : '';
      var sortBy = this._getSortField();

      this.isFiring = true;
      var firingRequest = this._firingRequest = 'conversations?sort_by=' + sortBy + '&page_size=' + pageSize + fromId;
      this.client.xhr({
        url: firingRequest,
        method: 'GET',
        sync: false
      }, function (results) {
        return _this2._processRunResults(results, firingRequest);
      });
    }

    /**
     * Returns the sort field for the query.
     *
     * Returns One of:
     *
     * * 'position' (Messages only)
     * * 'last_message' (Conversations only)
     * * 'created_at' (Conversations only)
     * @method _getSortField
     * @private
     */

  }, {
    key: '_getSortField',
    value: function _getSortField() {
      if (this.model === MESSAGE || this.model === ANNOUNCEMENT) return 'position';
      if (this.sortBy && this.sortBy[0] && this.sortBy[0]['lastMessage.sentAt']) return 'last_message';
      return 'created_at';
    }

    /**
     * Get the Conversation UUID from the predicate property.
     *
     * Extract the Conversation's UUID from the predicate... or returned the cached value.
     *
     * @method _getConversationUUID
     * @private
     */

  }, {
    key: '_getConversationPredicateIds',
    value: function _getConversationPredicateIds() {
      if (this.predicate.match(findConvIdRegex)) {
        var conversationId = this.predicate.replace(findConvIdRegex, '$1');

        // We will already have a this._predicate if we are paging; else we need to extract the UUID from
        // the conversationId.
        var uuid = (this._predicate || conversationId).replace(/^layer\:\/\/\/conversations\//, '');
        if (uuid) {
          return {
            uuid: uuid,
            id: conversationId
          };
        }
      }
    }

    /**
     * Get Messages from the server.
     *
     * @method _runMessage
     * @private
     * @param  {number} pageSize - Number of new results to request
     */

  }, {
    key: '_runMessage',
    value: function _runMessage(pageSize) {
      var _this3 = this;

      // This is a pagination rather than an initial request if there is already data; get the fromId
      // which is the id of the last result.
      var lastMessage = this.data[this.data.length - 1];
      var lastMessageInstance = !lastMessage ? null : this._getInstance(lastMessage);
      var fromId = lastMessageInstance && lastMessageInstance.isSaved() ? '&from_id=' + lastMessageInstance.id : '';
      var predicateIds = this._getConversationPredicateIds();

      // Do nothing if we don't have a conversation to query on
      if (predicateIds) {
        (function () {
          var conversationId = 'layer:///conversations/' + predicateIds.uuid;
          if (!_this3._predicate) _this3._predicate = predicateIds.id;
          var conversation = _this3.client.getConversation(conversationId);

          // If no data, retrieve data from db cache in parallel with loading data from server
          if (_this3.isReset) {
            _this3.client.dbManager.loadMessages(conversationId, function (messages) {
              return _this3._appendResults({ data: messages });
            });
          }
          _this3.isReset = false;

          // If the only Message is the Conversation's lastMessage, then we probably got this
          // result from `GET /conversations`, and not from `GET /messages`.  Get ALL Messages,
          // not just messages after the `lastMessage` if we've never received any messages from
          // `GET /messages` (safety code, not required code).  This also means that the first
          // Query gets MAX_PAGE_SIZE results instead of MAX_PAGE_SIZE + 1 results.
          if (conversation && conversation.lastMessage && lastMessage && lastMessage.id === conversation.lastMessage.id) {
            fromId = '';
          }

          // If the last message we have loaded is already the Conversation's lastMessage, then just request data without paging,
          // common occurence when query is populated with only a single result: conversation.lastMessage.
          // if (conversation && conversation.lastMessage && lastMessage && lastMessage.id === conversation.lastMessage.id) fromId = '';
          var newRequest = 'conversations/' + predicateIds.uuid + '/messages?page_size=' + pageSize + fromId;

          // Don't query on unsaved conversations, nor repeat still firing queries
          if ((!conversation || conversation.isSaved()) && newRequest !== _this3._firingRequest) {
            _this3.isFiring = true;
            _this3._firingRequest = newRequest;
            _this3.client.xhr({
              url: newRequest,
              method: 'GET',
              sync: false
            }, function (results) {
              return _this3._processRunResults(results, newRequest);
            });
          }

          // If there are no results, then its a new query; automatically populate it with the Conversation's lastMessage.
          if (_this3.data.length === 0) {
            if (conversation && conversation.lastMessage) {
              _this3.data = [_this3._getData(conversation.lastMessage)];
              // Trigger the change event
              _this3._triggerChange({
                type: 'data',
                data: _this3._getData(conversation.lastMessage),
                query: _this3,
                target: _this3.client
              });
            }
          }
        })();
      } else if (!this.predicate.match(/['"]/)) {
        Logger.error('This query may need to quote its value');
      }
    }

    /**
     * Get Messages from the server.
     *
     * @method _runMessage
     * @private
     * @param  {number} pageSize - Number of new results to request
     */

  }, {
    key: '_runAnnouncement',
    value: function _runAnnouncement(pageSize) {
      var _this4 = this;

      // If no data, retrieve data from db cache in parallel with loading data from server
      if (this.isReset) {
        this.client.dbManager.loadAnnouncements(function (messages) {
          return _this4._appendResults({ data: messages });
        });
      }
      this.isReset = false;

      // This is a pagination rather than an initial request if there is already data; get the fromId
      // which is the id of the last result.
      var lastMessage = this.data[this.data.length - 1];
      var lastMessageInstance = !lastMessage ? null : this._getInstance(lastMessage);
      var fromId = lastMessageInstance && lastMessageInstance.isSaved() ? '&from_id=' + lastMessageInstance.id : '';

      // If the last message we have loaded is already the Conversation's lastMessage, then just request data without paging,
      // common occurence when query is populated with only a single result: conversation.lastMessage.
      // if (conversation && conversation.lastMessage && lastMessage && lastMessage.id === conversation.lastMessage.id) fromId = '';
      var newRequest = 'announcements?page_size=' + pageSize + fromId;

      // Don't repeat still firing queries
      if (newRequest !== this._firingRequest) {
        this.isFiring = true;
        this._firingRequest = newRequest;
        this.client.xhr({
          url: newRequest,
          method: 'GET',
          sync: false
        }, function (results) {
          return _this4._processRunResults(results, newRequest);
        });
      }
    }

    /**
     * Process the results of the `_run` method; calls __appendResults.
     *
     * @method _processRunResults
     * @private
     * @param  {Object} results - Full xhr response object with server results
     */

  }, {
    key: '_processRunResults',
    value: function _processRunResults(results, requestUrl) {
      if (requestUrl !== this._firingRequest || this.isDestroyed) return;

      this.isFiring = false;
      this._firingRequest = '';
      if (results.success) {
        this._appendResults(results);
        this.totalSize = results.xhr.getResponseHeader('Layer-Count');
      } else {
        this.trigger('error', { error: results.data });
      }
    }

    /**
     * Appends arrays of data to the Query results.
     *
     * @method  _appendResults
     * @private
     */

  }, {
    key: '_appendResults',
    value: function _appendResults(results) {
      var _this5 = this;

      // For all results, register them with the client
      // If already registered with the client, properties will be updated as needed
      results.data.forEach(function (item) {
        if (item instanceof Root) return item;
        return _this5.client._createObject(item);
      });

      // Filter results to just the new results
      var newResults = results.data.filter(function (item) {
        return _this5._getIndex(item.id) === -1;
      });

      // Update this.data
      if (this.dataType === Query.ObjectDataType) {
        this.data = [].concat(this.data);
      }
      var data = this.data;
      newResults.forEach(function (itemIn) {
        var index = undefined;
        var item = _this5.client._getObject(itemIn.id);
        if (_this5.model === MESSAGE || _this5.model === ANNOUNCEMENT) {
          index = _this5._getInsertMessageIndex(item, data);
        } else {
          index = _this5._getInsertConversationIndex(item, data);
        }
        data.splice(index, 0, _this5._getData(item));
      });

      // Trigger the change event
      this._triggerChange({
        type: 'data',
        data: newResults.map(function (item) {
          return _this5._getData(_this5.client._getObject(item.id));
        }),
        query: this,
        target: this.client
      });
    }

    /**
     * Returns a correctly formatted object representing a result.
     *
     * Format is specified by the `dataType` property.
     *
     * @method _getData
     * @private
     * @param  {layer.Root} item - Conversation or Message instance
     * @return {Object} - Conversation or Message instance or Object
     */

  }, {
    key: '_getData',
    value: function _getData(item) {
      if (this.dataType === Query.ObjectDataType) {
        return item.toObject();
      }
      return item;
    }

    /**
     * Returns an instance regardless of whether the input is instance or object
     * @method
     * @private
     * @param {layer.Root|Object} item - Conversation or Message object/instance
     * @return {layer.Root}
     */

  }, {
    key: '_getInstance',
    value: function _getInstance(item) {
      if (item instanceof Root) return item;
      return this.client._getObject(item.id);
    }

    /**
     * Ask the query for the item matching the ID.
     *
     * Returns undefined if the ID is not found.
     *
     * @method _getItem
     * @private
     * @param  {string} id
     * @return {Object} Conversation or Message object or instance
     */

  }, {
    key: '_getItem',
    value: function _getItem(id) {
      switch (Util.typeFromID(id)) {
        case 'announcements':
          if (this.model === ANNOUNCEMENT) {
            var index = this._getIndex(id);
            return index === -1 ? null : this.data[index];
          }
          break;
        case 'messages':
          if (this.model === MESSAGE) {
            var index = this._getIndex(id);
            return index === -1 ? null : this.data[index];
          } else if (this.model === CONVERSATION) {
            for (var index = 0; index < this.data.length; index++) {
              var conversation = this.data[index];
              if (conversation.lastMessage && conversation.lastMessage.id === id) return conversation.lastMessage;
            }
            return null;
          }
          break;
        case 'conversations':
          if (this.model === CONVERSATION) {
            var index = this._getIndex(id);
            return index === -1 ? null : this.data[index];
          }
          break;
      }
    }

    /**
     * Get the index of the item represented by the specified ID; or return -1.
     *
     * @method _getIndex
     * @private
     * @param  {string} id
     * @return {number}
     */

  }, {
    key: '_getIndex',
    value: function _getIndex(id) {
      for (var index = 0; index < this.data.length; index++) {
        if (this.data[index].id === id) return index;
      }
      return -1;
    }

    /**
     * Handle any change event received from the layer.Client.
     *
     * These can be caused by websocket events, as well as local
     * requests to create/delete/modify Conversations and Messages.
     *
     * The event does not necessarily apply to this Query, but the Query
     * must examine it to determine if it applies.
     *
     * @method _handleChangeEvents
     * @private
     * @param {string} eventName - "messages:add", "conversations:change"
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_handleChangeEvents',
    value: function _handleChangeEvents(eventName, evt) {
      if (this.model === CONVERSATION) {
        this._handleConversationEvents(evt);
      } else if (this.model === MESSAGE || this.model === ANNOUNCEMENT) {
        this._handleMessageEvents(evt);
      }
    }
  }, {
    key: '_handleConversationEvents',
    value: function _handleConversationEvents(evt) {
      switch (evt.eventName) {

        // If a Conversation's property has changed, and the Conversation is in this
        // Query's data, then update it.
        case 'conversations:change':
          this._handleConversationChangeEvent(evt);
          break;

        // If a Conversation is added, and it isn't already in the Query,
        // add it and trigger an event
        case 'conversations:add':
          this._handleConversationAddEvent(evt);
          break;

        // If a Conversation is deleted, and its still in our data,
        // remove it and trigger an event.
        case 'conversations:remove':
          this._handleConversationRemoveEvent(evt);
          break;
      }
    }

    // TODO WEB-968: Refactor this into functions for instance, object, sortBy createdAt, sortBy lastMessage

  }, {
    key: '_handleConversationChangeEvent',
    value: function _handleConversationChangeEvent(evt) {
      var index = this._getIndex(evt.target.id);

      // If its an ID change (matching Distinct Conversation returned by server) make sure to update our data.
      // If dataType is an instance, its been updated for us.
      if (this.dataType === Query.ObjectDataType) {
        var idChanges = evt.getChangesFor('id');
        if (idChanges.length) {
          index = this._getIndex(idChanges[0].oldValue);
        }
      }

      // If dataType is "object" then update the object and our array;
      // else the object is already updated.
      // Ignore results that aren't already in our data; Results are added via
      // conversations:add events.  Websocket Manager automatically loads anything that receives an event
      // for which we have no object, so we'll get the add event at that time.
      if (index !== -1) {
        var sortField = this._getSortField();
        var reorder = evt.hasProperty('lastMessage') && sortField === 'last_message';

        if (this.dataType === Query.ObjectDataType) {
          if (!reorder) {
            // Replace the changed Conversation with a new immutable object
            this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
          } else {
            var newIndex = this._getInsertConversationIndex(evt.target, this.data);
            this.data.splice(index, 1);
            this.data.splice(newIndex, 0, this._getData(evt.target));
            this.data = this.data.concat([]);
          }
        }

        // Else dataType is instance not object
        else {
            if (reorder) {
              var newIndex = this._getInsertConversationIndex(evt.target, this.data);
              if (newIndex !== index) {
                this.data.splice(index, 1);
                this.data.splice(newIndex, 0, evt.target);
              }
            }
          }

        // Trigger a 'property' event
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
      }
    }
  }, {
    key: '_getInsertConversationIndex',
    value: function _getInsertConversationIndex(conversation, data) {
      var sortField = this._getSortField();
      var index = undefined;
      if (sortField === 'created_at') {
        for (index = 0; index < data.length; index++) {
          if (conversation.createdAt >= data[index].createdAt) break;
        }
        return index;
      } else {
        var d1 = conversation.lastMessage ? conversation.lastMessage.sentAt : conversation.createdAt;
        for (index = 0; index < data.length; index++) {
          var d2 = data[index].lastMessage ? data[index].lastMessage.sentAt : data[index].createdAt;
          if (d1 >= d2) break;
        }
        return index;
      }
    }
  }, {
    key: '_getInsertMessageIndex',
    value: function _getInsertMessageIndex(message, data) {
      var index = undefined;
      for (index = 0; index < data.length; index++) {
        if (message.position > data[index].position) {
          break;
        }
      }
      return index;
    }
  }, {
    key: '_handleConversationAddEvent',
    value: function _handleConversationAddEvent(evt) {
      var _this6 = this;

      // Filter out any Conversations already in our data
      var list = evt.conversations.filter(function (conversation) {
        return _this6._getIndex(conversation.id) === -1;
      });

      if (list.length) {
        (function () {
          var data = _this6.data;
          list.forEach(function (conversation) {
            var newIndex = _this6._getInsertConversationIndex(conversation, data);
            data.splice(newIndex, 0, _this6._getData(conversation));
          });

          // Whether sorting by last_message or created_at, new results go at the top of the list
          if (_this6.dataType === Query.ObjectDataType) {
            _this6.data = [].concat(data);
          }
          _this6.totalSize += list.length;

          // Trigger an 'insert' event for each item added;
          // typically bulk inserts happen via _appendResults().
          list.forEach(function (conversation) {
            var item = _this6._getData(conversation);
            _this6._triggerChange({
              type: 'insert',
              index: _this6.data.indexOf(item),
              target: item,
              query: _this6
            });
          });
        })();
      }
    }
  }, {
    key: '_handleConversationRemoveEvent',
    value: function _handleConversationRemoveEvent(evt) {
      var _this7 = this;

      var removed = [];
      evt.conversations.forEach(function (conversation) {
        var index = _this7._getIndex(conversation.id);
        if (index !== -1) {
          removed.push({
            data: conversation,
            index: index
          });
          if (_this7.dataType === Query.ObjectDataType) {
            _this7.data = [].concat(_toConsumableArray(_this7.data.slice(0, index)), _toConsumableArray(_this7.data.slice(index + 1)));
          } else {
            _this7.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this7._triggerChange({
          type: 'remove',
          index: removedObj.index,
          target: _this7._getData(removedObj.data),
          query: _this7
        });
      });
    }
  }, {
    key: '_handleMessageEvents',
    value: function _handleMessageEvents(evt) {
      switch (evt.eventName) {

        // If a Conversation's ID has changed, check our predicate, and update it automatically if needed.
        case 'conversations:change':
          if (this.model === MESSAGE) this._handleMessageConvIdChangeEvent(evt);
          break;

        // If a Message has changed and its in our result set, replace
        // it with a new immutable object
        case 'messages:change':
        case 'messages:read':
          this._handleMessageChangeEvent(evt);
          break;

        // If Messages are added, and they aren't already in our result set
        // add them.
        case 'messages:add':
          this._handleMessageAddEvent(evt);
          break;

        // If a Message is deleted and its in our result set, remove it
        // and trigger an event
        case 'messages:remove':
          this._handleMessageRemoveEvent(evt);
          break;
      }
    }

    /**
     * A Conversation ID changes if a matching Distinct Conversation was found on the server.
     *
     * If this Query's Conversation's ID has changed, update the predicate.
     *
     * @method _handleMessageConvIdChangeEvent
     * @param {layer.LayerEvent} evt - A Message Change Event
     * @private
     */

  }, {
    key: '_handleMessageConvIdChangeEvent',
    value: function _handleMessageConvIdChangeEvent(evt) {
      var cidChanges = evt.getChangesFor('id');
      if (cidChanges.length) {
        if (this._predicate === cidChanges[0].oldValue) {
          this._predicate = cidChanges[0].newValue;
          this.predicate = "conversation.id = '" + this._predicate + "'";
          this._run();
        }
      }
    }

    /**
     * If the ID of the message has changed, then the position property has likely changed as well.
     *
     * This method tests to see if changes to the position property have impacted the message's position in the
     * data array... and updates the array if it has.
     *
     * @method _handleMessagePositionChange
     * @private
     * @param {layer.LayerEvent} evt  A Message Change event
     * @param {number} index  Index of the message in the current data array
     * @return {boolean} True if a data was changed and a change event was emitted
     */

  }, {
    key: '_handleMessagePositionChange',
    value: function _handleMessagePositionChange(evt, index) {
      // If the message is not in the current data, then there is no change to our query results.
      if (index === -1) return false;

      // Create an array without our data item and then find out where the data item Should be inserted.
      // Note: we could just lookup the position in our current data array, but its too easy to introduce
      // errors where comparing this message to itself may yield index or index + 1.
      var newData = [].concat(_toConsumableArray(this.data.slice(0, index)), _toConsumableArray(this.data.slice(index + 1)));
      var newIndex = this._getInsertMessageIndex(evt.target, newData);

      // If the data item goes in the same index as before, then there is no change to be handled here;
      // else insert the item at the right index, update this.data and fire a change event
      if (newIndex !== index) {
        newData.splice(newIndex, 0, this._getData(evt.target));
        this.data = newData;
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
        return true;
      }
    }
  }, {
    key: '_handleMessageChangeEvent',
    value: function _handleMessageChangeEvent(evt) {
      var index = this._getIndex(evt.target.id);
      var positionChanges = evt.getChangesFor('position');

      // If there are position changes, handle them.  If all the changes are position changes,
      // exit when done.
      if (positionChanges.length) {
        if (this._handleMessagePositionChange(evt, index)) {
          if (positionChanges.length === evt.changes.length) return;
          index = this._getIndex(evt.target.id); // Get the updated position
        }
      }

      if (index !== -1) {
        if (this.dataType === Query.ObjectDataType) {
          this.data = [].concat(_toConsumableArray(this.data.slice(0, index)), [evt.target.toObject()], _toConsumableArray(this.data.slice(index + 1)));
        }
        this._triggerChange({
          type: 'property',
          target: this._getData(evt.target),
          query: this,
          isChange: true,
          changes: evt.changes
        });
      }
    }
  }, {
    key: '_handleMessageAddEvent',
    value: function _handleMessageAddEvent(evt) {
      var _this8 = this;

      // Only use added messages that are part of this Conversation
      // and not already in our result set
      var list = evt.messages.filter(function (message) {
        var type = Util.typeFromID(message.id);
        return type === 'messages' && _this8.model === MESSAGE || type === 'announcements' && _this8.model === ANNOUNCEMENT;
      }).filter(function (message) {
        var type = Util.typeFromID(message.id);
        return type === 'announcements' || message.conversationId === _this8._predicate;
      }).filter(function (message) {
        return _this8._getIndex(message.id) === -1;
      }).map(function (message) {
        return _this8._getData(message);
      });

      // Add them to our result set and trigger an event for each one
      if (list.length) {
        (function () {
          var data = _this8.data = _this8.dataType === Query.ObjectDataType ? [].concat(_this8.data) : _this8.data;
          list.forEach(function (item) {
            var index = _this8._getInsertMessageIndex(item, data);
            data.splice(index, 0, item);
          });

          _this8.totalSize += list.length;

          // Index calculated above may shift after additional insertions.  This has
          // to be done after the above insertions have completed.
          list.forEach(function (item) {
            _this8._triggerChange({
              type: 'insert',
              index: _this8.data.indexOf(item),
              target: item,
              query: _this8
            });
          });
        })();
      }
    }
  }, {
    key: '_handleMessageRemoveEvent',
    value: function _handleMessageRemoveEvent(evt) {
      var _this9 = this;

      var removed = [];
      evt.messages.forEach(function (message) {
        var index = _this9._getIndex(message.id);
        if (index !== -1) {
          removed.push({
            data: message,
            index: index
          });
          if (_this9.dataType === Query.ObjectDataType) {
            _this9.data = [].concat(_toConsumableArray(_this9.data.slice(0, index)), _toConsumableArray(_this9.data.slice(index + 1)));
          } else {
            _this9.data.splice(index, 1);
          }
        }
      });

      this.totalSize -= removed.length;
      removed.forEach(function (removedObj) {
        _this9._triggerChange({
          type: 'remove',
          target: _this9._getData(removedObj.data),
          index: removedObj.index,
          query: _this9
        });
      });
    }
  }, {
    key: '_triggerChange',
    value: function _triggerChange(evt) {
      this.trigger('change', evt);
      this.trigger('change:' + evt.type, evt);
    }
  }]);

  return Query;
}(Root);

Query.prefixUUID = 'layer:///queries/';

/**
 * Query for Conversations.
 *
 * Use this value in the model property.
 * @type {string}
 * @static
 */
Query.Conversation = CONVERSATION;

/**
 * Query for Messages.
 *
 * Use this value in the model property.
 * @type {string}
 * @static
 */
Query.Message = MESSAGE;

/**
 * Query for Announcements.
 *
 * Use this value in the model property.
 * @type {string}
 * @static
 */
Query.Announcement = ANNOUNCEMENT;

/**
 * Get data as POJOs/immutable objects.
 *
 * Your Query data and events will provide Messages/Conversations as objects.
 * @type {string}
 * @static
 */
Query.ObjectDataType = 'object';

/**
 * Get data as instances of layer.Message and layer.Conversation.
 *
 * Your Query data and events will provide Messages/Conversations as instances.
 * @type {string}
 * @static
 */
Query.InstanceDataType = 'instance';

/**
 * Set the maximum page size for queries.
 *
 * @type {number}
 * @static
 */
Query.MaxPageSize = 100;

/**
 * Access the number of results currently loaded.
 *
 * @type {Number}
 */
Object.defineProperty(Query.prototype, 'size', {
  enumerable: true,
  get: function get() {
    return !this.data ? 0 : this.data.length;
  }
});

/** Access the total number of results on the server.
 *
 * Will be 0 until the first query has successfully loaded results.
 *
 * @type {Number}
 */
Query.prototype.totalSize = 0;

/**
 * Access to the client so it can listen to websocket and local events.
 *
 * @type {layer.Client}
 * @protected
 */
Query.prototype.client = null;

/**
 * Query results.
 *
 * Array of data resulting from the Query; either a layer.Root subclass.
 *
 * or plain Objects
 * @type {Object[]}
 */
Query.prototype.data = null;

/**
 * Specifies the type of data being queried for.
 *
 * Model is one of
 * * layer.Query.Conversation
 * * layer.Query.Message
 *
 * @type {String}
 */
Query.prototype.model = CONVERSATION;

/**
 * What type of results to request of the server.
 *
 * Not yet supported; returnType is one of
 *
 * * object
 * * id
 * * count
 *
 * This Query API is designed only for use with 'object'.
 * @type {String}
 */
Query.prototype.returnType = 'object';

/**
 * Specify what kind of data array your application requires.
 *
 * Used to specify query dataType.  One of
 * * Query.ObjectDataType
 * * Query.InstanceDataType
 *
 * @type {String}
 */
Query.prototype.dataType = Query.InstanceDataType;

/**
 * Number of results from the server to request/cache.
 *
 * The pagination window can be increased to download additional items, or decreased to purge results
 * from the data property.
 *
 *     query.update({
 *       paginationWindow: 150
 *     })
 *
 * This call will load 150 results.  If it previously had 100,
 * then it will load 50 more. If it previously had 200, it will drop 50.
 *
 * Note that the server will only permit 100 at a time, so
 * setting a large pagination window may result in many
 * requests to the server to reach the specified page value.
 * @type {Number}
 */
Query.prototype.paginationWindow = 100;

/**
 * Sorting criteria for Conversation Queries.
 *
 * Only supports an array of one field/element.
 * Only supports the following options:
 *
 *     [{'createdAt': 'desc'}]
 *     [{'lastMessage.sentAt': 'desc'}]
 *
 * Why such limitations? Why this structure?  The server will be exposing a Query API at which point the
 * above sort options will make a lot more sense, and full sorting will be provided.
 *
 * @type {String}
 */
Query.prototype.sortBy = null;

/**
 * This value tells us what to reset the paginationWindow to when the query is redefined.
 *
 * @type {Number}
 * @private
 */
Query.prototype._initialPaginationWindow = 100;

/**
 * Your Query's WHERE clause.
 *
 * Currently, the only query supported is "conversation.id = 'layer:///conversations/uuid'"
 * Note that both ' and " are supported.
 * @type {string}
 */
Query.prototype.predicate = null;

Query.prototype.isReset = true;

/**
 * True if the Query is connecting to the server.
 *
 * It is not gaurenteed that every update(); for example, updating a paginationWindow to be smaller,
 * Or changing a value to the existing value would cause the request not to fire.
 * R ecommended pattern is:
 *
 *      query.update({paginationWindow: 50});
 *      if (!query.isFiring) {
 *        alert("Done");
 *      } else {
 *          query.on("change", function(evt) {
 *            if (evt.type == "data") alert("Done");
 *          });
 *      }
 *
 * @type {Boolean}
 */
Query.prototype.isFiring = false;

/**
 * The last request fired.
 *
 * If multiple requests are inflight, the response
 * matching this request is the ONLY response we will process.
 * @type {String}
 * @private
 */
Query.prototype._firingRequest = '';

Query._supportedEvents = [
/**
 * The query data has changed; any change event will cause this event to trigger.
 * @event change
 */
'change',

/**
 * A new page of data has been loaded from the server
 * @event 'change:data'
 */
'change:data',

/**
 * All data for this query has been reset due to a change in the Query predicate.
 * @event 'change:reset'
 */
'change:reset',

/**
 * An item of data within this Query has had a property change its value.
 * @event 'change:property'
 */
'change:property',

/**
 * A new item of data has been inserted into the Query. Not triggered by loading
 * a new page of data from the server, but is triggered by locally creating a matching
 * item of data, or receiving a new item of data via websocket.
 * @event 'change:insert'
 */
'change:insert',

/**
 * An item of data has been removed from the Query. Not triggered for every removal, but
 * is triggered by locally deleting a result, or receiving a report of deletion via websocket.
 * @event 'change:remove'
 */
'change:remove',

/**
 * The query data failed to load from the server.
 * @event error
 */
'error'].concat(Root._supportedEvents);

Root.initClass.apply(Query, [Query, 'Query']);

module.exports = Query;

},{"./client-utils":10,"./layer-error":16,"./logger":18,"./root":24}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Utils = require('./client-utils');
var LayerEvent = require('./layer-event');
var LayerError = require('./layer-error');
var Events = require('backbone-events-standalone/backbone-events-standalone');
var Logger = require('./logger');

/*
 * Provides a system bus that can be accessed by all components of the system.
 * Currently used to listen to messages sent via postMessage, but envisioned to
 * do far more.
 */
function EventClass() {}
EventClass.prototype = Events;

var SystemBus = new EventClass();
if (typeof postMessage === 'function') {
  addEventListener('message', function (event) {
    if (event.data.type === 'layer-delayed-event') {
      SystemBus.trigger(event.data.internalId + '-delayed-event');
    }
  });
}

// Used to generate a unique internalId for every Root instance
var uniqueIds = {};

// Regex for splitting an event string such as obj.on('evtName1 evtName2 evtName3')
var eventSplitter = /\s+/;

/**
 * The root class of all layer objects. Provides the following utilities
 *
 * 1. Mixes in the Backbone event model
 *
 *        var person = new Person();
 *        person.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        });
 *
 *        // Fire the console log handler:
 *        person.trigger('destroy');
 *
 *        // Unsubscribe
 *        person.off('destroy');
 *
 * 2. Adds a subscriptions object so that any event handlers on an object can be quickly found and removed
 *
 *        var person1 = new Person();
 *        var person2 = new Person();
 *        person2.on('destroy', function() {
 *            console.log('I have been destroyed!');
 *        }, person1);
 *
 *        // Pointers to person1 held onto by person2 are removed
 *        person1.destroy();
 *
 * 3. Adds support for event listeners in the constructor
 *    Any event handler can be passed into the constructor
 *    just as though it were a property.
 *
 *        var person = new Person({
 *            age: 150,
 *            destroy: function() {
 *                console.log('I have been destroyed!');
 *            }
 *        });
 *
 * 4. A _disableEvents property
 *
 *        myMethod() {
 *          if (this.isInitializing) {
 *              this._disableEvents = true;
 *
 *              // Event only received if _disableEvents = false
 *              this.trigger('destroy');
 *              this._disableEvents = false;
 *          }
 *        }
 *
 * 5. A _supportedEvents static property for each class
 *
 *     This property defines which events can be triggered.
 *
 *     * Any attempt to trigger
 *       an event not in _supportedEvents will log an error.
 *     * Any attempt to register a listener for an event not in _supportedEvents will
 *     *throw* an error.
 *
 *     This allows us to insure developers only subscribe to valid events.
 *
 *     This allows us to control what events can be fired and which ones blocked.
 *
 * 6. Adds an internalId property
 *
 *        var person = new Person();
 *        console.log(person.internalId); // -> 'Person1'
 *
 * 7. Adds a toObject method to create a simplified Plain Old Javacript Object from your object
 *
 *        var person = new Person();
 *        var simplePerson = person.toObject();
 *
 * 8. Provides __adjustProperty method support
 *
 *     For any property of a class, an `__adjustProperty` method can be defined.  If its defined,
 *     it will be called prior to setting that property, allowing:
 *
 *     A. Modification of the value that is actually set
 *     B. Validation of the value; throwing errors if invalid.
 *
 * 9. Provides __udpateProperty method support
 *
 *     After setting any property for which there is an `__updateProperty` method defined,
 *     the method will be called, allowing the new property to be applied.
 *
 *     Typically used for
 *
 *     A. Triggering events
 *     B. Firing XHR requests
 *     C. Updating the UI to match the new property value
 *
 *
 * @class layer.Root
 * @abstract
 * @author Michael Kantor
 */

var Root = function (_EventClass) {
  _inherits(Root, _EventClass);

  /**
   * Superclass constructor handles copying in properties and registering event handlers.
   *
   * @method constructor
   * @param  {Object} options - a hash of properties and event handlers
   * @return {layer.Root}
   */

  function Root() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Root);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Root).call(this));

    _this._subscriptions = [];
    _this._delayedTriggers = [];
    _this._lastDelayedTrigger = Date.now();
    _this._events = {};

    // Generate an internalId
    var name = _this.constructor.name;
    if (!uniqueIds[name]) uniqueIds[name] = 0;
    _this.internalId = name + uniqueIds[name]++;

    // Every component listens to the SystemBus for postMessage (triggerAsync) events
    SystemBus.on(_this.internalId + '-delayed-event', _this._processDelayedTriggers, _this);

    // Generate a temporary id if there isn't an id
    if (!_this.id && !options.id && _this.constructor.prefixUUID) {
      _this.id = _this.constructor.prefixUUID + Utils.generateUUID();
    }

    // Copy in all properties; setup all event handlers
    var key = undefined;
    for (key in options) {
      if (_this.constructor._supportedEvents.indexOf(key) !== -1) {
        _this.on(key, options[key]);
      } else if (key in _this && typeof _this[key] !== 'function') {
        _this[key] = options[key];
      }
    }
    _this.isInitializing = false;
    return _this;
  }

  /**
   * Destroys the object.
   *
   * Cleans up all events / subscriptions
   * and marks the object as isDestroyed.
   *
   * @method destroy
   */


  _createClass(Root, [{
    key: 'destroy',
    value: function destroy() {
      var _this2 = this;

      if (this.isDestroyed) throw new Error(LayerError.dictionary.alreadyDestroyed);

      // If anyone is listening, notify them
      this.trigger('destroy');

      // Cleanup pointers to SystemBus. Failure to call destroy
      // will have very serious consequences...
      SystemBus.off(this.internalId + '-delayed-event', null, this);

      // Remove all events, and all pointers passed to this object by other objects
      this.off();

      // Find all of the objects that this object has passed itself to in the form
      // of event handlers and remove all references to itself.
      this._subscriptions.forEach(function (item) {
        return item.off(null, null, _this2);
      });

      this._subscriptions = null;
      this._delayedTriggers = null;
      this.isDestroyed = true;
    }

    /**
     * Convert class instance to Plain Javascript Object.
     *
     * Strips out all private members, and insures no datastructure loops.
     * Recursively converting all subobjects using calls to toObject.
     *
     *      console.dir(myobj.toObject());
     *
     * Note: While it would be tempting to have noChildren default to true,
     * this would result in Message.toObject() not outputing its MessageParts.
     *
     * Private data (_ prefixed properties) will not be output.
     *
     * @method toObject
     * @param  {boolean} [noChildren=false] Don't output sub-components
     * @return {Object}
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      var _this3 = this;

      var noChildren = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

      this.__inToObject = true;
      var obj = {};

      // Iterate over all formally defined properties
      try {
        var keys = [];
        for (var key in this.constructor.prototype) {
          if (!(key in layer.Root.prototype)) keys.push(key);
        }keys.forEach(function (key) {
          var v = _this3[key];

          // Ignore private/protected properties and functions
          if (key.indexOf('_') === 0) return;
          if (typeof v === 'function') return;

          // Generate arrays...
          if (Array.isArray(v)) {
            obj[key] = [];
            v.forEach(function (item) {
              if (item instanceof Root) {
                if (noChildren) {
                  delete obj[key];
                } else if (!item.__inToObject) {
                  obj[key].push(item.toObject());
                }
              } else {
                obj[key].push(item);
              }
            });
          }

          // Generate subcomponents
          else if (v instanceof Root) {
              if (!v.__inToObject && !noChildren) {
                obj[key] = v.toObject();
              }
            }

            // Generate dates (creates a copy to separate it from the source object)
            else if (v instanceof Date) {
                obj[key] = new Date(v);
              }

              // Generate simple properties
              else {
                  obj[key] = v;
                }
        });
      } catch (e) {
        // no-op
      }
      this.__inToObject = false;
      return obj;
    }

    /**
     * Log a warning for attempts to subscribe to unsupported events.
     *
     * @method _warnForEvent
     * @private
     */

  }, {
    key: '_warnForEvent',
    value: function _warnForEvent(eventName) {
      if (!Utils.includes(this.constructor._supportedEvents, eventName)) {
        throw new Error('Event ' + eventName + ' not defined for ' + this.toString());
      }
    }

    /**
     * Prepare for processing an event subscription call.
     *
     * If context is a Root class, add this object to the context's subscriptions.
     *
     * @method _prepareOn
     * @private
     */

  }, {
    key: '_prepareOn',
    value: function _prepareOn(name, handler, context) {
      var _this4 = this;

      if (context instanceof Root) {
        if (context.isDestroyed) {
          throw new Error(LayerError.dictionary.isDestroyed);
        }
        context._subscriptions.push(this);
      }
      if (typeof name === 'string' && name !== 'all') {
        if (eventSplitter.test(name)) {
          var names = name.split(eventSplitter);
          names.forEach(function (n) {
            return _this4._warnForEvent(n);
          });
        } else {
          this._warnForEvent(name);
        }
      } else if (name && (typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
        Object.keys(name).forEach(function (keyName) {
          return _this4._warnForEvent(keyName);
        });
      }
    }

    /**
     * Subscribe to events.
     *
     * Note that the context parameter serves double importance here:
     *
     * 1. It determines the context in which to execute the event handler
     * 2. Create a backlink so that if either subscriber or subscribee is destroyed,
     *    all pointers between them can be found and removed.
     *
     *      obj.on('someEventName someOtherEventName', mycallback, mycontext);
     *
     *      obj.on({
     *          eventName1: callback1,
     *          eventName2: callback2
     *      }, mycontext);
     *
     * @method on
     * @param  {String} name - Name of the event
     * @param  {Function} handler - Event handler
     * @param  {layer.LayerEvent} handler.event - Event object delivered to the handler
     * @param  {Object} context - This pointer AND link to help with cleanup
     * @return {layer.Root} this
     */

  }, {
    key: 'on',
    value: function on(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.on.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Subscribe to the first occurance of the specified event.
     *
     * @method once
     */

  }, {
    key: 'once',
    value: function once(name, handler, context) {
      this._prepareOn(name, handler, context);
      Events.once.apply(this, [name, handler, context]);
      return this;
    }

    /**
     * Unsubscribe from events.
     *
     *      // Removes all event handlers for this event:
     *      obj.off('someEventName');
     *
     *      // Removes all event handlers using this function pointer as callback
     *      obj.off(null, f, null);
     *
     *      // Removes all event handlers that `this` has subscribed to; requires
     *      // obj.on to be called with `this` as its `context` parameter.
     *      obj.off(null, null, this);
     *
     * @method off
     * @param  {String} name - Name of the event; null for all event names
     * @param  {Function} handler - Event handler; null for all functions
     * @param  {Object} context - The context from the `on()` call to search for; null for all contexts
     */

    /**
     * Trigger an event for any event listeners.
     *
     * Events triggered this way will be blocked if _disableEvents = true
     *
     * @method trigger
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: 'trigger',
    value: function trigger() {
      if (this._disableEvents) return this;
      return this._trigger.apply(this, arguments);
    }

    /**
     * Triggers an event.
     *
     * @method trigger
     * @private
     * @param {string} eventName - Name of the event
     * @return {Object} Return *this* for chaining
     */

  }, {
    key: '_trigger',
    value: function _trigger() {
      if (!Utils.includes(this.constructor._supportedEvents, arguments.length <= 0 ? undefined : arguments[0])) {
        if (!Utils.includes(this.constructor._ignoredEvents, arguments.length <= 0 ? undefined : arguments[0])) {
          Logger.error(this.toString() + ' ignored ' + (arguments.length <= 0 ? undefined : arguments[0]));
        }
        return;
      }

      var computedArgs = this._getTriggerArgs.apply(this, arguments);

      Events.trigger.apply(this, computedArgs);

      var parentProp = this.constructor.bubbleEventParent;
      if (parentProp) {
        var _parentValue;

        var parentValue = this[parentProp];
        parentValue = typeof parentValue === 'function' ? parentValue.apply(this) : parentValue;
        if (parentValue) (_parentValue = parentValue).trigger.apply(_parentValue, _toConsumableArray(computedArgs));
      }
    }

    /**
     * Generates a layer.LayerEvent from a trigger call's arguments.
     *
     * * If parameter is already a layer.LayerEvent, we're done.
     * * If parameter is an object, a `target` property is added to that object and its delivered to all subscribers
     * * If the parameter is non-object value, it is added to an object with a `target` property, and the value is put in
     *   the `data` property.
     *
     * @method _getTriggerArgs
     * @private
     * @return {Mixed[]} - First element of array is eventName, second element is layer.LayerEvent.
     */

  }, {
    key: '_getTriggerArgs',
    value: function _getTriggerArgs() {
      var _this5 = this;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var computedArgs = Array.prototype.slice.call(args);

      if (args[1]) {
        (function () {
          var newArg = { target: _this5 };

          if (computedArgs[1] instanceof LayerEvent) {
            // A LayerEvent will be an argument when bubbling events up; these args can be used as-is
          } else {
              if (_typeof(computedArgs[1]) === 'object') {
                Object.keys(computedArgs[1]).forEach(function (name) {
                  newArg[name] = computedArgs[1][name];
                });
              } else {
                newArg.data = computedArgs[1];
              }
              computedArgs[1] = new LayerEvent(newArg, computedArgs[0]);
            }
        })();
      } else {
        computedArgs[1] = new LayerEvent({ target: this }, computedArgs[0]);
      }

      return computedArgs;
    }

    /**
     * Same as _trigger() method, but delays briefly before firing.
     *
     * When would you want to delay an event?
     *
     * 1. There is an event rollup that may be needed for the event;
     *    this requires the framework to be able to see ALL events that have been
     *    generated, roll them up, and THEN fire them.
     * 2. The event is intended for UI rendering... which should not hold up the rest of
     *    this framework's execution.
     *
     * When NOT to delay an event?
     *
     * 1. Lifecycle events frequently require response at the time the event has fired
     *
     * @method _triggerAsync
     * @private
     * @param {string} eventName    Name of the event that one should subscribe to in order to receive this event
     * @param {Mixed} arg           Values that will be placed within a layer.LayerEvent
     * @return {layer.Root} this
     */

  }, {
    key: '_triggerAsync',
    value: function _triggerAsync() {
      var _this6 = this;

      var computedArgs = this._getTriggerArgs.apply(this, arguments);
      this._delayedTriggers.push(computedArgs);

      // NOTE: It is unclear at this time how it happens, but on very rare occasions, we see processDelayedTriggers
      // fail to get called when length = 1, and after that length just continuously grows.  So we add
      // the _lastDelayedTrigger test to insure that it will still run.
      var shouldScheduleTrigger = this._delayedTriggers.length === 1 || this._delayedTriggers.length && this._lastDelayedTrigger + 500 < Date.now();
      if (shouldScheduleTrigger) {
        this._lastDelayedTrigger = Date.now();
        if (typeof postMessage === 'function' && typeof jasmine === 'undefined') {
          window.postMessage({
            type: 'layer-delayed-event',
            internalId: this.internalId
          }, '*');
        } else {
          setTimeout(function () {
            return _this6._processDelayedTriggers();
          }, 0);
        }
      }
    }

    /**
     * Combines a set of events into a single event.
     *
     * Given an event structure of
     *
     *      {
     *          customName: [value1]
     *      }
     *      {
     *          customName: [value2]
     *      }
     *      {
     *          customName: [value3]
     *      }
     *
     * Merge them into
     *
     *      {
     *          customName: [value1, value2, value3]
     *      }
     *
     * @method _foldEvents
     * @private
     * @param  {layer.LayerEvent[]} events
     * @param  {string} name      Name of the property (i.e. 'customName')
     * @param  {layer.Root}    newTarget Value of the target for the folded resulting event
     */

  }, {
    key: '_foldEvents',
    value: function _foldEvents(events, name, newTarget) {
      var firstEvt = events.length ? events[0][1] : null;
      var firstEvtProp = firstEvt ? firstEvt[name] : null;
      events.forEach(function (evt, i) {
        if (i > 0) {
          firstEvtProp.push(evt[1][name][0]);
          this._delayedTriggers.splice(this._delayedTriggers.indexOf(evt), 1);
        }
      }, this);
      if (events.length && newTarget) events[0][1].target = newTarget;
    }

    /**
     * Fold a set of Change events into a single Change event.
     *
     * Given a set change events on this component,
     * fold all change events into a single event via
     * the layer.LayerEvent's changes array.
     *
     * @method _foldChangeEvents
     * @private
     */

  }, {
    key: '_foldChangeEvents',
    value: function _foldChangeEvents() {
      var _this7 = this;

      var events = this._delayedTriggers.filter(function (evt) {
        return evt[1].isChange;
      });
      events.forEach(function (evt, i) {
        if (i > 0) {
          events[0][1]._mergeChanges(evt[1]);
          _this7._delayedTriggers.splice(_this7._delayedTriggers.indexOf(evt), 1);
        }
      });
    }

    /**
     * Execute all delayed events for this compoennt.
     *
     * @method _processDelayedTriggers
     * @private
     */

  }, {
    key: '_processDelayedTriggers',
    value: function _processDelayedTriggers() {
      if (this.isDestroyed) return;
      this._foldChangeEvents();

      this._delayedTriggers.forEach(function (evt) {
        this.trigger.apply(this, _toConsumableArray(evt));
      }, this);
      this._delayedTriggers = [];
    }

    /**
     * Returns a string representation of the class that is nicer than [Object].
     *
     * @method toString
     * @return {String}
     */

  }, {
    key: 'toString',
    value: function toString() {
      return this.internalId;
    }
  }]);

  return Root;
}(EventClass);

function defineProperty(newClass, propertyName) {
  var pKey = '__' + propertyName;
  var camel = propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);

  var hasDefinitions = newClass.prototype['__adjust' + camel] || newClass.prototype['__update' + camel] || newClass.prototype['__get' + camel];
  if (hasDefinitions) {
    // set default value
    newClass.prototype[pKey] = newClass.prototype[propertyName];

    Object.defineProperty(newClass.prototype, propertyName, {
      enumerable: true,
      get: function get() {
        return this['__get' + camel] ? this['__get' + camel](pKey) : this[pKey];
      },
      set: function set(inValue) {
        if (this.isDestroyed) return;
        var initial = this[pKey];
        if (inValue !== initial) {
          if (this['__adjust' + camel]) {
            var result = this['__adjust' + camel](inValue);
            if (result !== undefined) inValue = result;
          }
          this[pKey] = inValue;
        }
        if (inValue !== initial) {
          if (!this.isInitializing && this['__update' + camel]) {
            this['__update' + camel](inValue, initial);
          }
        }
      }
    });
  }
}

function initClass(newClass, className) {
  // Make sure our new class has a name property
  if (!newClass.name) newClass.name = className;

  // Make sure our new class has a _supportedEvents, _ignoredEvents, _inObjectIgnore and EVENTS properties
  if (!newClass._supportedEvents) newClass._supportedEvents = Root._supportedEvents;
  if (!newClass._ignoredEvents) newClass._ignoredEvents = Root._ignoredEvents;

  // Generate a list of properties for this class; we don't include any
  // properties from layer.Root
  var keys = Object.keys(newClass.prototype).filter(function (key) {
    return newClass.prototype.hasOwnProperty(key) && !Root.prototype.hasOwnProperty(key) && typeof newClass.prototype[key] !== 'function';
  });

  // Define getters/setters for any property that has __adjust or __update methods defined
  keys.forEach(function (name) {
    return defineProperty(newClass, name);
  });
}

/**
 * Set to true once destroy() has been called.
 *
 * A destroyed object will likely cause errors in any attempt
 * to call methods on it, and will no longer trigger events.
 *
 * @type {boolean}
 */
Root.prototype.isDestroyed = false;

/**
 * Every instance has its own internal ID.
 *
 * This ID is distinct from any IDs assigned by the server.
 * The internal ID is gaurenteed not to change within the lifetime of the Object/session;
 * it is possible, on creating a new object, for its `id` property to change.
 *
 * @type {string}
 */
Root.prototype.internalId = '';

/**
 * True while we are in the constructor.
 *
 * @type {boolean}
 */
Root.prototype.isInitializing = true;

/**
 * Objects that this object is listening for events from.
 *
 * @type {layer.Root[]}
 */
Root.prototype._subscriptions = null;

/**
 * Disable all events triggered on this object.
 * @type {boolean}
 */
Root.prototype._disableEvents = false;

Root._supportedEvents = ['destroy', 'all'];
Root._ignoredEvents = [];
module.exports = Root;
module.exports.initClass = initClass;

},{"./client-utils":10,"./layer-error":16,"./layer-event":17,"./logger":18,"backbone-events-standalone/backbone-events-standalone":2}],25:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A Sync Event represents a request to the server.
 * A Sync Event may fire immediately, or may wait in the layer.SyncManager's
 * queue for a long duration before firing.
 *
 * DO NOT confuse this with layer.LayerEvent which represents a change notification
 * to your application.  layer.SyncEvent represents a request to the server that
 * is either in progress or in queue.
 *
 * GET requests are typically NOT done via a SyncEvent as these are typically
 * needed to render a UI and should either fail or succeed promptly.
 *
 * Applications typically do not interact with these objects.
 *
 * @class  layer.SyncEvent
 * @extends layer.Root
 */
var Utils = require('./client-utils');

var SyncEvent = function () {
  /**
   * Create a layer.SyncEvent.  See layer.ClientAuthenticator for examples of usage.
   *
   * @method  constructor
   * @private
   * @return {layer.SyncEvent}
   */

  function SyncEvent(options) {
    _classCallCheck(this, SyncEvent);

    var key = undefined;
    for (key in options) {
      if (key in this) {
        this[key] = options[key];
      }
    }
    if (!this.depends) this.depends = [];
    if (!this.id) this.id = 'layer:///syncevents/' + Utils.generateUUID();
    if (!this.createdAt) this.createdAt = Date.now();
  }

  /**
   * Not strictly required, but nice to clean things up.
   *
   * @method destroy
   */


  _createClass(SyncEvent, [{
    key: 'destroy',
    value: function destroy() {
      this.target = null;
      this.depends = null;
      this.callback = null;
      this.data = null;
    }

    /**
     * Get the Real parameters for the request.
     *
     * @method _updateData
     * @private
     */

  }, {
    key: '_updateData',
    value: function _updateData(client) {
      if (!this.target) return;
      var target = client._getObject(this.target);
      if (target && this.operation === 'POST' && target._getSendData) {
        this.data = target._getSendData(this.data);
      }
    }

    /**
     * Returns a POJO version of this object suitable for serializing for the network
     * @method toObject
     * @returns {Object}
     */

  }, {
    key: 'toObject',
    value: function toObject() {
      return { data: this.data };
    }
  }]);

  return SyncEvent;
}();

/**
 * The type of operation being performed.
 *
 * Either GET, PATCH, DELETE, POST or PUT
 *
 * @property {String}
 */


SyncEvent.prototype.operation = '';

SyncEvent.prototype.fromDB = false;

SyncEvent.prototype.createdAt = 0;

/**
 * Indicates whether this request currently in-flight.
 *
 * * Set to true by _xhr() method,
 * * set to false on completion by layer.SyncManager.
 * * set to false automatically after 2 minutes
 *
 * @property {Boolean}
 */
Object.defineProperty(SyncEvent.prototype, 'isFiring', {
  enumerable: true,
  set: function set(value) {
    this.__isFiring = value;
    if (value) this.__firedAt = Date.now();
  },
  get: function get() {
    return Boolean(this.__isFiring && Date.now() - this.__firedAt < SyncEvent.FIRING_EXPIRIATION);
  }
});

SyncEvent.prototype.id = '';

/**
 * Indicates whether the request completed successfully.
 *
 * Set by layer.SyncManager.
 * @type {Boolean}
 */
SyncEvent.prototype.success = null;

/**
 * Callback to fire on completing this sync event.
 *
 * WARNING: The nature of this callback may change;
 * a persistence layer that persists the SyncManager's queue
 * must have serializable callbacks (object id + method name; not a function)
 * or must accept that callbacks are not always fired.
 * @type {Function}
 */
SyncEvent.prototype.callback = null;

/**
 * Number of retries on this request.
 *
 * Retries are only counted if its a 502 or 503
 * error.  Set and managed by layer.SyncManager.
 * @type {Number}
 */
SyncEvent.prototype.retryCount = 0;

/**
 * The target of the request.
 *
 * Any Component; typically a Conversation or Message.
 * @type {layer.Root}
 */
SyncEvent.prototype.target = null;

/**
 * Components that this request depends upon.
 *
 * A message cannot be sent if its
 * Conversation fails to get created.
 *
 * NOTE: May prove redundant with the target property and needs further review.
 * @type {layer.Root[]}
 */
SyncEvent.prototype.depends = null;

/**
 * Data field of the xhr call; can be an Object or string (including JSON string)
 * @type {Object}
 */
SyncEvent.prototype.data = null;

/**
 * After firing a request, if that firing state fails to clear after this number of miliseconds,
 * consider it to no longer be firing.  Under normal conditions, firing will be set to false explicitly.
 * This check insures that any failure of that process does not leave us stuck with a firing request
 * blocking the queue.
 * @type {number}
 * @static
 */
SyncEvent.FIRING_EXPIRIATION = 1000 * 60 * 2;

/**
 * A layer.SyncEvent intended to be fired as an XHR request.
 *
 * @class layer.SyncEvent.XHRSyncEvent
 * @extends layer.SyncEvent
 */

var XHRSyncEvent = function (_SyncEvent) {
  _inherits(XHRSyncEvent, _SyncEvent);

  function XHRSyncEvent() {
    _classCallCheck(this, XHRSyncEvent);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(XHRSyncEvent).apply(this, arguments));
  }

  _createClass(XHRSyncEvent, [{
    key: '_getRequestData',


    /**
     * Fire the request associated with this instance.
     *
     * Actually it just returns the parameters needed to make the xhr call:
     *
     *      var xhr = require('./xhr');
     *      xhr(event._getRequestData(client));
     *
     * @method _getRequestData
     * @param {layer.Client} client
     * @protected
     * @returns {Object}
     */
    value: function _getRequestData(client) {
      this._updateUrl(client);
      this._updateData(client);
      return {
        url: this.url,
        method: this.method,
        headers: this.headers,
        data: this.data
      };
    }

    /**
     * Get the Real URL.
     *
     * If the url property is a function, call it to set the actual url.
     * Used when the URL is unknown until a prior SyncEvent has completed.
     *
     * @method _updateUrl
     * @private
     */

  }, {
    key: '_updateUrl',
    value: function _updateUrl(client) {
      if (!this.target) return;
      var target = client._getObject(this.target);
      if (target && !this.url.match(/^http(s)\:\/\//)) {
        this.url = target._getUrl(this.url);
      }
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      return {
        data: this.data,
        url: this.url,
        method: this.method
      };
    }
  }, {
    key: '_getCreateId',
    value: function _getCreateId() {
      return this.operation === 'POST' && this.data ? this.data.id : '';
    }
  }]);

  return XHRSyncEvent;
}(SyncEvent);

/**
 * How long before the request times out?
 * @type {Number} [timeout=15000]
 */


XHRSyncEvent.prototype.timeout = 15000;

/**
 * URL to send the request to
 */
XHRSyncEvent.prototype.url = '';

/**
 * Counts number of online state changes.
 *
 * If this number becomes high in a short time period, its probably
 * failing due to a CORS error.
 */
XHRSyncEvent.prototype.returnToOnlineCount = 0;

/**
 * Headers for the request
 */
XHRSyncEvent.prototype.headers = null;

/**
 * Request method.
 */
XHRSyncEvent.prototype.method = 'GET';

/**
 * A layer.SyncEvent intended to be fired as a websocket request.
 *
 * @class layer.SyncEvent.WebsocketSyncEvent
 * @extends layer.SyncEvent
 */

var WebsocketSyncEvent = function (_SyncEvent2) {
  _inherits(WebsocketSyncEvent, _SyncEvent2);

  function WebsocketSyncEvent() {
    _classCallCheck(this, WebsocketSyncEvent);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(WebsocketSyncEvent).apply(this, arguments));
  }

  _createClass(WebsocketSyncEvent, [{
    key: '_getRequestData',


    /**
     * Get the websocket request object.
     *
     * @method _getRequestData
     * @private
     * @param {layer.Client} client
     * @return {Object}
     */
    value: function _getRequestData(client) {
      this._updateData(client);
      return this.data;
    }
  }, {
    key: 'toObject',
    value: function toObject() {
      return this.data;
    }
  }, {
    key: '_getCreateId',
    value: function _getCreateId() {
      return this.operation === 'POST' && this.data.data ? this.data.data.id : '';
    }
  }]);

  return WebsocketSyncEvent;
}(SyncEvent);

module.exports = { SyncEvent: SyncEvent, XHRSyncEvent: XHRSyncEvent, WebsocketSyncEvent: WebsocketSyncEvent };

},{"./client-utils":10}],26:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @class  layer.SyncManager
 * @extends layer.Root
 * @protected
 *
 * This class manages
 *
 * 1. a queue of requests that need to be made
 * 2. when a request should be fired, based on authentication state, online state, websocket connection state, and position in the queue
 * 3. when a request should be aborted
 * 4. triggering any request callbacks
 *
 * TODO WEB-850: Currently the sync queue is managed solely in runtime memory.  But the queue should be stored
 * in persistent memory so that a tab-reload can restore the queue without losing commands that the user has
 * been told have been accepted.
 *
 * TODO: In the event of a DNS error, we may have a valid websocket receiving events and telling us we are online,
 * and be unable to create a REST call.  This will be handled wrong because evidence will suggest that we are online.
 * This issue goes away when we use bidirectional websockets for all requests.
 *
 * Applications do not typically interact with this class, but may subscribe to its events
 * to get richer detailed information than is available from the layer.Client instance.
 */
var Root = require('./root');

var _require = require('./sync-event');

var WebsocketSyncEvent = _require.WebsocketSyncEvent;

var xhr = require('./xhr');
var logger = require('./logger');
var Utils = require('./client-utils');

var SyncManager = function (_Root) {
  _inherits(SyncManager, _Root);

  /**
   * Creates a new SyncManager.
   *
   * An Application is expected to only have one SyncManager.
   *
   *      var socketManager = new layer.Websockets.SocketManager({client: client});
   *      var requestManager = new layer.Websockets.RequestManager({client: client, socketManager: socketManager});
   *
   *      var onlineManager = new layer.OnlineManager({
   *          socketManager: socketManager
   *      });
   *
   *      // Now we can instantiate this thing...
   *      var SyncManager = new layer.SyncManager({
   *          client: client,
   *          onlineManager: onlineManager,
   *          socketManager: socketManager,
   *          requestManager: requestManager
   *      });
   *
   * @method constructor
   * @param  {Object} options
   * @param {layer.OnlineStateManager} options.onlineManager
   * @param {layer.Websockets.RequestManager} options.requestManager
   * @param {layer.Client} options.client
   */

  function SyncManager(options) {
    _classCallCheck(this, SyncManager);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SyncManager).call(this, options));

    _this.client = options.client;

    // Note we do not store a pointer to client... it is not needed.
    if (_this.client) {
      _this.client.on('ready', function () {
        _this._processNextRequest();
        _this._loadPersistedQueue();
      }, _this);
    }
    _this.queue = [];

    _this.onlineManager.on('disconnected', _this._onlineStateChange, _this);
    _this.socketManager.on('connected disconnected', _this._onlineStateChange, _this);
    return _this;
  }

  _createClass(SyncManager, [{
    key: 'isOnline',
    value: function isOnline() {
      return this.onlineManager.isOnline;
    }

    /**
     * Process sync request when connection is restored.
     *
     * Any time we go back online (as signaled by the onlineStateManager),
     * Process the next Sync Event (will do nothing if one is already firing)
     *
     * @method _onlineStateChange
     * @private
     * @param  {string} evtName - 'connected' or 'disconnected'
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_onlineStateChange',
    value: function _onlineStateChange(evt) {
      var _this2 = this;

      if (evt.eventName === 'connected') {
        if (this.queue.length) this.queue[0].returnToOnlineCount++;
        setTimeout(function () {
          return _this2._processNextRequest();
        }, 100);
      } else if (evt.eventName === 'disconnected') {
        if (this.queue.length) {
          this.queue[0].isFiring = false;
        }
      }
    }

    /**
     * Adds a new xhr request to the queue.
     *
     * If the queue is empty, this will be fired immediately.
     * If the queue is non-empty, this will wait until all other requests in the queue have been fired.
     *
     * @method request
     * @param  {layer.SyncEvent} requestEvt - A SyncEvent specifying the request to be made
     */

  }, {
    key: 'request',
    value: function request(requestEvt) {
      // If its a PATCH request on an object that isn't yet created,
      // do not add it to the queue.
      if (requestEvt.operation !== 'PATCH' || !this._findUnfiredCreate(requestEvt)) {
        logger.info('Sync Manager Request ' + requestEvt.operation + ' on target ' + requestEvt.target);
        logger.debug(requestEvt.toObject());
        this.queue.push(requestEvt);
        this.trigger('sync:add', {
          request: requestEvt,
          target: requestEvt.target
        });
      } else {
        logger.info('Sync Manager Request PATCH ' + requestEvt.target + ' request ignored; create request still enqueued');
        logger.debug(requestEvt.toObject());
      }

      // If its a DELETE request, purge all other requests on that target.
      if (requestEvt.operation === 'DELETE') {
        this._purgeOnDelete(requestEvt);
      }

      // Fire the request if there aren't any existing requests already being processed.
      // If this isn't the first item, assume that all necessary logic exists to fire the
      // existing requests and then it will move onto this request.
      if (this.queue.length === 1 || !this.queue[0].isFiring) {
        this._processNextRequest();
      }
    }

    /**
     * Find create request for this resource.
     *
     * Determine if the given target has a POST request waiting to create
     * the resource, and return any matching requests. Used
     * for folding PATCH requests into an unfired CREATE/POST request.
     *
     * @method _findUnfiredCreate
     * @private
     * @param  {layer.SyncEvent} requestEvt
     * @return {Boolean}
     */

  }, {
    key: '_findUnfiredCreate',
    value: function _findUnfiredCreate(requestEvt) {
      return Boolean(this.queue.filter(function (evt) {
        return evt.target === requestEvt.target && evt.operation === 'POST' && !evt.isFiring;
      }).length);
    }

    /**
     * Process the next request in the queue.
     *
     * Request is dequeued on completing the process.
     * If the first request in the queue is firing, do nothing.
     *
     * @method _processNextRequest
     * @private
     */

  }, {
    key: '_processNextRequest',
    value: function _processNextRequest() {
      var _this3 = this;

      if (this.isDestroyed) return;
      var requestEvt = this.queue[0];
      if (this.isOnline() && requestEvt && !requestEvt.isFiring) {
        this._validateRequest(requestEvt, function (isValid) {
          if (!isValid) {
            _this3._removeRequest(requestEvt);
            return _this3._processNextRequest();
          }
          if (requestEvt instanceof WebsocketSyncEvent) {
            if (_this3.socketManager && _this3.socketManager._isOpen()) {
              logger.debug('Sync Manager Websocket Request Firing ' + requestEvt.operation + ' on target ' + requestEvt.target, requestEvt.toObject());
              _this3.requestManager.sendRequest(requestEvt._getRequestData(_this3.client), function (result) {
                return _this3._xhrResult(result, requestEvt);
              });
              requestEvt.isFiring = true;
            } else {
              logger.debug('Sync Manager Websocket Request skipped; socket closed');
            }
          } else {
            logger.debug('Sync Manager XHR Request Firing ' + requestEvt.operation + ' ' + requestEvt.target, requestEvt.toObject());
            xhr(requestEvt._getRequestData(_this3.client), function (result) {
              return _this3._xhrResult(result, requestEvt);
            });
            requestEvt.isFiring = true;
          }
        });
      } else if (requestEvt && requestEvt.isFiring) {
        logger.debug('Sync Manager processNext skipped; request still firing ' + requestEvt.operation + ' ' + ('on target ' + requestEvt.target), requestEvt.toObject());
      }
    }

    /**
     * Is the syncEvent still valid?
     *
     * This method specifically tests to see if some other tab has already sent this request.
     * If persistence of the syncQueue is not enabled, then the callback is immediately called with true.
     * If another tab has already sent the request, then the entry will no longer be in indexedDB and the callback
     * will call false.
     *
     * @method _validateRequest
     * @param {layer.SyncEvent} syncEvent
     * @param {Function} callback
     * @param {Function} callback.isValid - The request is still valid
     * @private
     */

  }, {
    key: '_validateRequest',
    value: function _validateRequest(syncEvent, callback) {
      this.client.dbManager.claimSyncEvent(syncEvent, function (isFound) {
        return callback(isFound);
      });
    }

    /**
     * Turn deduplication errors into success messages.
     *
     * If this request has already been made but we failed to get a response the first time and we retried the request,
     * we will reissue the request.  If the prior request was successful we'll get back a deduplication error
     * with the created object. As far as the WebSDK is concerned, this is a success.
     *
     * @method _handleDeduplicationErrors
     * @private
     */

  }, {
    key: '_handleDeduplicationErrors',
    value: function _handleDeduplicationErrors(result) {
      if (result.data && result.data.id === 'id_in_use' && result.data.data && result.data.data.id === result.request._getCreateId()) {
        result.success = true;
        result.data = result.data.data;
      }
    }

    /**
     * Process the result of an xhr call, routing it to the appropriate handler.
     *
     * @method _xhrResult
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrResult',
    value: function _xhrResult(result, requestEvt) {
      if (this.isDestroyed) return;
      result.request = requestEvt;
      requestEvt.isFiring = false;
      this._handleDeduplicationErrors(result);
      if (!result.success) {
        this._xhrError(result);
      } else {
        this._xhrSuccess(result);
      }
    }

    /**
     * Categorize the error for handling.
     *
     * @method _getErrorState
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     * @param  {boolean} isOnline - Is our app state set to online
     */

  }, {
    key: '_getErrorState',
    value: function _getErrorState(result, requestEvt, isOnline) {
      var errId = result.data ? result.data.id : '';
      if (!isOnline) {
        // CORS errors look identical to offline; but if our online state has transitioned from false to true repeatedly while processing this request,
        // thats a hint that that its a CORS error
        if (requestEvt.returnToOnlineCount >= SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR) {
          return 'CORS';
        } else {
          return 'offline';
        }
      } else if (errId === 'not_found') {
        return 'notFound';
      } else if (errId === 'id_in_use') {
        return 'invalidId'; // This only fires if we get `id_in_use` but no Resource, which means the UUID was used by another user/app.
      } else if (result.status === 408 || errId === 'request_timeout') {
          if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
            return 'tooManyFailuresWhileOnline';
          } else {
            return 'validateOnlineAndRetry';
          }
        } else if ([502, 503, 504].indexOf(result.status) !== -1) {
          if (requestEvt.retryCount >= SyncManager.MAX_RETRIES) {
            return 'tooManyFailuresWhileOnline';
          } else {
            return 'serverUnavailable';
          }
        } else if (errId === 'authentication_required' && result.data.data && result.data.data.nonce) {
          return 'reauthorize';
        } else {
          return 'serverRejectedRequest';
        }
    }

    /**
     * Handle failed requests.
     *
     * 1. If there was an error from the server, then the request has problems
     * 2. If we determine we are not in fact online, call the connectionError handler
     * 3. If we think we are online, verify we are online and then determine how to handle it.
     *
     * @method _xhrError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrError',
    value: function _xhrError(result) {
      var requestEvt = result.request;

      logger.warn('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Failed'), requestEvt.toObject());

      var errState = this._getErrorState(result, requestEvt, this.isOnline());
      logger.warn('Sync Manager Error State: ' + errState);
      switch (errState) {
        case 'tooManyFailuresWhileOnline':
          this._xhrHandleServerError(result, 'Sync Manager Server Unavailable Too Long; removing request');
          break;
        case 'notFound':
          this._xhrHandleServerError(result, 'Resource not found; presumably deleted');
          break;
        case 'invalidId':
          this._xhrHandleServerError(result, 'ID was not unique; request failed');
          break;
        case 'validateOnlineAndRetry':
          // Server appears to be hung but will eventually recover.
          // Retry a few times and then error out.
          this._xhrValidateIsOnline();
          break;
        case 'serverUnavailable':
          // Server is in a bad state but will eventually recover;
          // keep retrying.
          this._xhrHandleServerUnavailableError(requestEvt);
          break;
        case 'reauthorize':
          // sessionToken appears to no longer be valid; forward response
          // on to client-authenticator to process.
          // Do not retry nor advance to next request.
          if (requestEvt.callback) requestEvt.callback(result);

          break;
        case 'serverRejectedRequest':
          // Server presumably did not like the arguments to this call
          // or the url was invalid.  Do not retry; trigger the callback
          // and let the caller handle it.
          this._xhrHandleServerError(result, 'Sync Manager Server Rejects Request; removing request');
          break;
        case 'CORS':
          // A pattern of offline-like failures that suggests its actually a CORs error
          this._xhrHandleServerError(result, 'Sync Manager Server detects CORS-like errors; removing request');
          break;
        case 'offline':
          this._xhrHandleConnectionError();
          break;
      }

      // Write the sync event back to the database if we haven't completed processing it
      if (this.queue.indexOf(requestEvt) !== -1) {
        this.client.dbManager.writeSyncEvents([requestEvt], false);
      }
    }

    /**
     * Handle a server unavailable error.
     *
     * In the event of a 502 (Bad Gateway), 503 (service unavailable)
     * or 504 (gateway timeout) error from the server
     * assume we have an error that is self correcting on the server.
     * Use exponential backoff to retry the request.
     *
     * Note that each call will increment retryCount; there is a maximum
     * of MAX_RETRIES before it is treated as an error
     *
     * @method  _xhrHandleServerUnavailableError
     * @private
     * @param {layer.SyncEvent} request
     */

  }, {
    key: '_xhrHandleServerUnavailableError',
    value: function _xhrHandleServerUnavailableError(request) {
      var maxDelay = SyncManager.MAX_UNAVAILABLE_RETRY_WAIT;
      var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, request.retryCount++));
      logger.warn('Sync Manager Server Unavailable; retry count ' + request.retryCount + '; retrying in ' + delay + ' seconds');
      setTimeout(this._processNextRequest.bind(this), delay * 1000);
    }

    /**
     * Handle a server error in response to firing sync event.
     *
     * If there is a server error, its presumably non-recoverable/non-retryable error, so
     * we're going to abort this request.
     *
     * 1. If a callback was provided, call it to handle the error
     * 2. If a rollback call is provided, call it to undo any patch/delete/etc... changes
     * 3. If the request was to create a resource, remove from the queue all requests
     *    that depended upon that resource.
     * 4. Advance to next request
     *
     * @method _xhrHandleServerError
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     *
     */

  }, {
    key: '_xhrHandleServerError',
    value: function _xhrHandleServerError(result, logMsg) {
      // Execute all callbacks provided by the request
      if (result.request.callback) result.request.callback(result);
      logger.error(logMsg, result.request);
      this.trigger('sync:error', {
        target: result.request.target,
        request: result.request,
        error: result.data
      });

      result.request.success = false;

      // If a POST request fails, all requests that depend upon this object
      // must be purged
      if (result.request.operation === 'POST') {
        this._purgeDependentRequests(result.request);
      }

      // Remove this request as well (side-effect: rolls back the operation)
      this._removeRequest(result.request);

      // And finally, we are ready to try the next request
      this._processNextRequest();
    }

    /**
     * If there is a connection error, wait for retry.
     *
     * In the event of what appears to be a connection error,
     * Wait until a 'connected' event before processing the next request (actually reprocessing the current event)
     *
     * @method _xhrHandleConnectionError
     * @private
     */

  }, {
    key: '_xhrHandleConnectionError',
    value: function _xhrHandleConnectionError() {}
    // Nothing to be done; we already have the below event handler setup
    // this.onlineManager.once('connected', () => this._processNextRequest());


    /**
     * Verify that we are online and retry request.
     *
     * This method is called when we think we're online, but
     * have determined we need to validate that assumption.
     *
     * Test that we have a connection; if we do,
     * retry the request once, and if it fails again,
     * _xhrError() will determine it to have failed and remove it from the queue.
     *
     * If we are offline, then let _xhrHandleConnectionError handle it.
     *
     * @method _xhrValidateIsOnline
     * @private
     */

  }, {
    key: '_xhrValidateIsOnline',
    value: function _xhrValidateIsOnline() {
      var _this4 = this;

      logger.debug('Sync Manager verifying online state');
      this.onlineManager.checkOnlineStatus(function (isOnline) {
        return _this4._xhrValidateIsOnlineCallback(isOnline);
      });
    }

    /**
     * If we have verified we are online, retry request.
     *
     * We should have received a response to our /nonces call
     * which assuming the server is actually alive,
     * will tell us if the connection is working.
     *
     * If we are offline, flag us as offline and let the ConnectionError handler handle this
     * If we are online, give the request a single retry (there is never more than one retry)
     *
     * @method _xhrValidateIsOnlineCallback
     * @private
     * @param  {boolean} isOnline  - Response object returned by xhr call
     */

  }, {
    key: '_xhrValidateIsOnlineCallback',
    value: function _xhrValidateIsOnlineCallback(isOnline) {
      logger.debug('Sync Manager online check result is ' + isOnline);
      if (!isOnline) {
        // Treat this as a Connection Error
        this._xhrHandleConnectionError();
      } else {
        // Retry the request in case we were offline, but are now online.
        // Of course, if this fails, give it up entirely.
        this.queue[0].retryCount++;
        this._processNextRequest();
      }
    }

    /**
     * The XHR request was successful.
     *
     * Any xhr request that actually succedes:
     *
     * 1. Remove it from the queue
     * 2. Call any callbacks
     * 3. Advance to next request
     *
     * @method _xhrSuccess
     * @private
     * @param  {Object} result  - Response object returned by xhr call
     * @param  {layer.SyncEvent} requestEvt - Request object
     */

  }, {
    key: '_xhrSuccess',
    value: function _xhrSuccess(result) {
      var requestEvt = result.request;
      logger.debug('Sync Manager ' + (requestEvt instanceof WebsocketSyncEvent ? 'Websocket' : 'XHR') + ' ' + (requestEvt.operation + ' Request on target ' + requestEvt.target + ' has Succeeded'), requestEvt.toObject());
      if (result.data) logger.debug(result.data);
      requestEvt.success = true;
      this._removeRequest(requestEvt);
      if (requestEvt.callback) requestEvt.callback(result);
      this._processNextRequest();

      this.trigger('sync:success', {
        target: requestEvt.target,
        request: requestEvt,
        response: result.data
      });
    }

    /**
     * Remove the SyncEvent request from the queue.
     *
     * @method _removeRequest
     * @private
     * @param  {layer.SyncEvent} requestEvt - SyncEvent Request to remove
     */

  }, {
    key: '_removeRequest',
    value: function _removeRequest(requestEvt) {
      var index = this.queue.indexOf(requestEvt);
      if (index !== -1) this.queue.splice(index, 1);
    }

    /**
     * Remove requests from queue that depend on specified resource.
     *
     * If there is a POST request to create a new resource, and there are PATCH, DELETE, etc...
     * requests on that resource, if the POST request fails, then all PATCH, DELETE, etc
     * requests must be removed from the queue.
     *
     * Note that we do not call the rollback on these dependent requests because the expected
     * rollback is to destroy the thing that was created, which means any other rollback has no effect.
     *
     * @method _purgeDependentRequests
     * @private
     * @param  {layer.SyncEvent} request - Request whose target is no longer valid
     */

  }, {
    key: '_purgeDependentRequests',
    value: function _purgeDependentRequests(request) {
      this.queue = this.queue.filter(function (evt) {
        return evt.depends.indexOf(request.target) === -1 || evt === request;
      });
    }

    /**
     * Remove from queue all events that operate upon the deleted object.
     *
     * @method _purgeOnDelete
     * @private
     * @param  {layer.SyncEvent} evt - Delete event that requires removal of other events
     */

  }, {
    key: '_purgeOnDelete',
    value: function _purgeOnDelete(evt) {
      var _this5 = this;

      this.queue.filter(function (request) {
        return request.depends.indexOf(evt.target) !== -1 && evt !== request;
      }).forEach(function (requestEvt) {
        _this5.trigger('sync:abort', {
          target: requestEvt.target,
          request: requestEvt
        });
        _this5._removeRequest(requestEvt);
      });
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.queue.forEach(function (evt) {
        return evt.destroy();
      });
      this.queue = null;
      _get(Object.getPrototypeOf(SyncManager.prototype), 'destroy', this).call(this);
    }

    /**
     * Load any unsent requests from indexedDB.
     *
     * If persistence is disabled, nothing will happen;
     * else all requests found in the database will be added to the queue.
     * @method _loadPersistedQueue
     * @private
     */

  }, {
    key: '_loadPersistedQueue',
    value: function _loadPersistedQueue() {
      var _this6 = this;

      this.client.dbManager.loadSyncQueue(function (data) {
        if (data.length) {
          _this6.queue = _this6.queue.concat(data);
          _this6._processNextRequest();
        }
      });
    }
  }]);

  return SyncManager;
}(Root);

/**
 * Websocket Manager for getting socket state.
 * @type {layer.Websockets.SocketManager}
 */


SyncManager.prototype.socketManager = null;

/**
 * Websocket Request Manager for sending requests.
 * @type {layer.Websockets.RequestManager}
 */
SyncManager.prototype.requestManager = null;

/**
 * Reference to the Online State Manager.
 *
 * Sync Manager uses online status to determine if it can fire sync-requests.
 * @private
 * @type {layer.OnlineStateManager}
 */
SyncManager.prototype.onlineManager = null;

/**
 * The array of layer.SyncEvent instances awaiting to be fired.
 * @type {layer.SyncEvent[]}
 */
SyncManager.prototype.queue = null;

/**
 * Reference to the Client so that we can pass it to SyncEvents  which may need to lookup their targets
 */
SyncManager.prototype.client = null;

/**
 * Maximum exponential backoff wait.
 *
 * If the server is returning 502, 503 or 504 errors, exponential backoff
 * should never wait longer than this number of seconds (15 minutes)
 * @type {Number}
 * @static
 */
SyncManager.MAX_UNAVAILABLE_RETRY_WAIT = 60 * 15;

/**
 * Retries before suspect CORS error.
 *
 * How many times can we transition from offline to online state
 * with this request at the front of the queue before we conclude
 * that the reason we keep thinking we're going offline is
 * a CORS error returning a status of 0.  If that pattern
 * shows 3 times in a row, there is likely a CORS error.
 * Note that CORS errors appear to javascript as a status=0 error,
 * which is the same as if the client were offline.
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES_BEFORE_CORS_ERROR = 3;

/**
 * Abort request after this number of retries.
 *
 * @type {number}
 * @static
 */
SyncManager.MAX_RETRIES = 20;

SyncManager._supportedEvents = [
/**
 * A sync request has failed.
 *
 * @event
 * @param {layer.SyncEvent} evt - The request object
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 * @param {Object} result.error - The error object {id, code, message, url}
 */
'sync:error',

/**
 * A sync layer request has completed successfully.
 *
 * @event
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 * @param {Object} result.data - null or any data returned by the call
 */
'sync:success',

/**
 * A new sync request has been added.
 *
 * @event
 * @param {layer.SyncEvent} evt - The request object
 */
'sync:add',

/**
 * A sync request has been canceled.
 *
 * Typically caused by a new SyncEvent that deletes the target of this SyncEvent
 *
 * @event
 * @param {layer.SyncEvent} evt - The request object
 * @param {Object} result
 * @param {string} result.target - ID of the message/conversation/etc. being operated upon
 * @param {layer.SyncEvent} result.request - The original request
 */
'sync:abort'].concat(Root._supportedEvents);

Root.initClass(SyncManager);
module.exports = SyncManager;

},{"./client-utils":10,"./logger":18,"./root":24,"./sync-event":25,"./xhr":36}],27:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Syncable abstract clas represents resources that are syncable with the server.
 * This is currently used for Messages and Conversations.
 * It represents the state of the object's sync, as one of:
 *
 *  * layer.Constants.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * NOTE: There is a special case for Messages where isSending is true and syncState !== layer.Constants.SYNC_STATE.SAVING,
 * which occurs after `send()` has been called, but while waiting for Rich Content to upload prior to actually
 * sending this to the server.
 *
 * @class layer.Syncable
 * @extends layer.Root
 * @abstract
 */

var Root = require('./root');

var _require = require('./const');

var SYNC_STATE = _require.SYNC_STATE;

var LayerError = require('./layer-error');

var Syncable = function (_Root) {
  _inherits(Syncable, _Root);

  function Syncable() {
    _classCallCheck(this, Syncable);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Syncable).apply(this, arguments));
  }

  _createClass(Syncable, [{
    key: '_load',


    /**
     * Load this conversation from the server.
     *
     * Called from the static layer.Conversation.load() method
     *
     * @method _load
     * @private
     */
    value: function _load() {
      var _this2 = this;

      this.syncState = SYNC_STATE.LOADING;
      this._xhr({
        url: '',
        method: 'GET',
        sync: false
      }, function (result) {
        return _this2._loadResult(result);
      });
    }
  }, {
    key: '_loadResult',
    value: function _loadResult(result) {
      var _this3 = this;

      var prefix = this.constructor.eventPrefix;
      if (!result.success) {
        this.syncState = SYNC_STATE.NEW;
        this._triggerAsync(prefix + ':loaded-error', { error: result.data });
        setTimeout(function () {
          return _this3.destroy();
        }, 100); // Insure destroyed AFTER loaded-error event has triggered
      } else {
          this._populateFromServer(result.data);
          this._loaded(result.data);
          this.trigger(prefix + ':loaded');
        }
    }

    /**
     * Processing the result of a _load() call.
     *
     * Typically used to register the object and cleanup any properties not handled by _populateFromServer.
     *
     * @method _loaded
     * @private
     * @param  {Object} data - Response data from server
     */

  }, {
    key: '_loaded',
    value: function _loaded(data) {}

    /**
     * Object is queued for syncing with the server.
     *
     * That means it is currently out of sync with the server.
     *
     * @method _setSyncing
     * @private
     */

  }, {
    key: '_setSyncing',
    value: function _setSyncing() {
      this._clearObject();
      switch (this.syncState) {
        case SYNC_STATE.SYNCED:
          this.syncState = SYNC_STATE.SYNCING;
          break;
        case SYNC_STATE.NEW:
          this.syncState = SYNC_STATE.SAVING;
          break;
      }
      this._syncCounter++;
    }

    /**
     * Object is synced with the server and up to date.
     *
     * @method _setSynced
     * @private
     */

  }, {
    key: '_setSynced',
    value: function _setSynced() {
      this._clearObject();
      if (this._syncCounter > 0) this._syncCounter--;

      this.syncState = this._syncCounter === 0 ? SYNC_STATE.SYNCED : SYNC_STATE.SYNCING;
      this.isSending = false;
    }

    /**
     * Any time the instance changes, we should clear the cached toObject value
     *
     * @method _clearObject
     * @private
     */

  }, {
    key: '_clearObject',
    value: function _clearObject() {
      this._toObject = null;
    }

    /**
     * Object is new, and is not yet queued for syncing
     *
     * @method isNew
     * @returns {boolean}
     */

  }, {
    key: 'isNew',
    value: function isNew() {
      return this.syncState === SYNC_STATE.NEW;
    }

    /**
     * Object is new, and is queued for syncing
     *
     * @method isSaving
     * @returns {boolean}
     */

  }, {
    key: 'isSaving',
    value: function isSaving() {
      return this.syncState === SYNC_STATE.SAVING;
    }

    /**
     * Object does not yet exist on server.
     *
     * @method isSaved
     * @returns {boolean}
     */

  }, {
    key: 'isSaved',
    value: function isSaved() {
      return !(this.isNew() || this.isSaving());
    }

    /**
     * Object is fully synced.
     *
     * As best we know, server and client have the same values.
     *
     * @method isSynced
     * @returns {boolean}
     */

  }, {
    key: 'isSynced',
    value: function isSynced() {
      return this.syncState === SYNC_STATE.SYNCED;
    }
  }], [{
    key: 'load',
    value: function load(id, client) {
      if (!client || !(client instanceof Root)) throw new Error(LayerError.dictionary.clientMissing);

      var obj = {
        id: id,
        url: client.url + id.substring(8),
        clientId: client.appId
      };

      var ConstructorClass = Syncable.subclasses.filter(function (aClass) {
        return obj.id.indexOf(aClass.prefixUUID) === 0;
      })[0];
      var syncItem = new ConstructorClass(obj);

      syncItem._load();
      return syncItem;
    }
  }]);

  return Syncable;
}(Root);

/**
 * The current sync state of this object.
 *
 * Possible values are:
 *
 *  * layer.SYNC_STATE.NEW: Newly created; local only.
 *  * layer.Constants.SYNC_STATE.SAVING: Newly created; being sent to the server
 *  * layer.Constants.SYNC_STATE.SYNCING: Exists on both client and server, but changes are being sent to server.
 *  * layer.Constants.SYNC_STATE.SYNCED: Exists on both client and server and is synced.
 *  * layer.Constants.SYNC_STATE.LOADING: Exists on server; loading it into client.
 *
 * NOTE: There is a special case for Messages where isSending is true and syncState !== layer.Constants.SYNC_STATE.SAVING,
 * which occurs after `send()` has been called, but while waiting for Rich Content to upload prior to actually
 * sending this to the server.
 *
 * @type {string}
 */


Syncable.prototype.syncState = SYNC_STATE.NEW;

/**
 * Number of sync requests that have been requested.
 *
 * Counts down to zero; once it reaches zero, all sync
 * requests have been completed.
 *
 * @type {Number}
 * @private
 */
Syncable.prototype._syncCounter = 0;

/**
 * Prefix to use when triggering events
 */
Syncable.eventPrefix = '';

/**
 * Is the object loading from the server?
 *
 * @type {boolean}
 */
Object.defineProperty(Syncable.prototype, 'isLoading', {
  enumerable: true,
  get: function get() {
    return this.syncState === SYNC_STATE.LOADING;
  }
});

/**
 * Array of classes that are subclasses of Syncable.
 *
 * Used by Factory function.
 * @private
 */
Syncable.subclasses = [];

Syncable._supportedEvents = [].concat(Root._supportedEvents);
Syncable.inObjectIgnore = Root.inObjectIgnore;
module.exports = Syncable;

},{"./const":12,"./layer-error":16,"./root":24}],28:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The TypingIndicatorListener receives Typing Indicator state
 * for other users via a websocket, and notifies
 * the client of the updated state.  Typical applications
 * do not access this component directly, but DO subscribe
 * to events produced by this component:
 *
 *      client.on('typing-indicator-change', function(evt) {
 *        if (evt.conversationId == conversationICareAbout) {
 *          console.log('The following users are typing: ' + evt.typing.join(', '));
 *          console.log('The following users are paused: ' + evt.paused.join(', '));
 *        }
 *      });
 *
 * @class layer.TypingIndicators.TypingIndicatorListener
 * @extends {layer.Root}
 */

var Root = require('../root');
var ClientRegistry = require('../client-registry');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

var TypingIndicatorListener = function (_Root) {
  _inherits(TypingIndicatorListener, _Root);

  /**
   * Creates a Typing Indicator Listener for this Client.
   *
   * @method constructor
   * @protected
   * @param  {Object} args
   * @param {string} args.clientId - ID of the client this belongs to
   */

  function TypingIndicatorListener(args) {
    _classCallCheck(this, TypingIndicatorListener);

    /**
     * Stores the state of all Conversations, indicating who is typing and who is paused.
     *
     * People who are stopped are removed from this state.
     * @property {Object} state
     */

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TypingIndicatorListener).call(this, args));

    _this.state = {};
    _this._pollId = 0;
    var client = _this._getClient();
    client.on('ready', function () {
      return _this._clientReady();
    });
    return _this;
  }

  /**
   * Called when the client is ready
   *
   * @method _clientReady
   * @private
   */


  _createClass(TypingIndicatorListener, [{
    key: '_clientReady',
    value: function _clientReady() {
      var client = this._getClient();
      this.userId = client.userId;
      var ws = client.socketManager;
      ws.on('message', this._handleSocketEvent, this);
      this._startPolling();
    }

    /**
     * Determines if this event is relevant to report on.
     * Must be a typing indicator signal that is reporting on
     * someone other than this user.
     *
     * @method _isRelevantEvent
     * @private
     * @param  {Object}  Websocket event data
     * @return {Boolean}
     */

  }, {
    key: '_isRelevantEvent',
    value: function _isRelevantEvent(evt) {
      return evt.type === 'signal' && evt.body.type === 'typing_indicator' && evt.body.data.user_id !== this.userId;
    }

    /**
     * This method receives websocket events and
     * if they are typing indicator events, updates its state.
     *
     * @method _handleSocketEvent
     * @private
     * @param {layer.LayerEvent} evtIn - All websocket events
     */

  }, {
    key: '_handleSocketEvent',
    value: function _handleSocketEvent(evtIn) {
      var evt = evtIn.data;

      if (this._isRelevantEvent(evt)) {
        var userId = evt.body.data.user_id;
        var state = evt.body.data.action;
        var conversationId = evt.body.object.id;
        var stateEntry = this.state[conversationId];
        if (!stateEntry) {
          stateEntry = this.state[conversationId] = {
            users: {},
            typing: [],
            paused: []
          };
        }
        stateEntry.users[userId] = {
          startTime: Date.now(),
          state: state
        };
        if (stateEntry.users[userId].state === FINISHED) {
          delete stateEntry.users[userId];
        }

        this._updateState(stateEntry, state, userId);

        this.trigger('typing-indicator-change', {
          conversationId: conversationId,
          typing: stateEntry.typing,
          paused: stateEntry.paused
        });
      }
    }

    /**
     * Updates the state of a single stateEntry; a stateEntry
     * represents a single Conversation's typing indicator data.
     *
     * Updates typing and paused arrays following immutable strategies
     * in hope that this will help Flex based architectures.
     *
     * @method _updateState
     * @private
     * @param  {Object} stateEntry - A Conversation's typing indicator state
     * @param  {string} newState   - started, paused or finished
     * @param  {string} userId     - ID of the user whose state has changed
     */

  }, {
    key: '_updateState',
    value: function _updateState(stateEntry, newState, userId) {
      var typingIndex = stateEntry.typing.indexOf(userId);
      if (newState !== STARTED && typingIndex !== -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing.slice(0, typingIndex)), _toConsumableArray(stateEntry.typing.slice(typingIndex + 1)));
      }
      var pausedIndex = stateEntry.paused.indexOf(userId);
      if (newState !== PAUSED && pausedIndex !== -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused.slice(0, pausedIndex)), _toConsumableArray(stateEntry.paused.slice(pausedIndex + 1)));
      }

      if (newState === STARTED && typingIndex === -1) {
        stateEntry.typing = [].concat(_toConsumableArray(stateEntry.typing), [userId]);
      } else if (newState === PAUSED && pausedIndex === -1) {
        stateEntry.paused = [].concat(_toConsumableArray(stateEntry.paused), [userId]);
      }
    }

    /**
     * Any time a state change becomes more than 6 seconds stale,
     * assume that the user is 'finished'.
     *
     * In theory, we should
     * receive a new event every 2.5 seconds.  If the current user
     * has gone offline, lack of this code would cause the people
     * currently flagged as typing as still typing hours from now.
     *
     * For this first pass, we just mark the user as 'finished'
     * but a future pass may move from 'started' to 'paused'
     * and 'paused to 'finished'
     *
     * @method _startPolling
     * @private
     */

  }, {
    key: '_startPolling',
    value: function _startPolling() {
      var _this2 = this;

      if (this._pollId) return;
      this._pollId = setInterval(function () {
        return _this2._poll();
      }, 5000);
    }
  }, {
    key: '_poll',
    value: function _poll() {
      var _this3 = this;

      var conversationIds = Object.keys(this.state);

      conversationIds.forEach(function (id) {
        var state = _this3.state[id];
        Object.keys(_this3.state[id].users).forEach(function (userId) {
          if (Date.now() >= state.users[userId].startTime + 6000) {
            _this3._updateState(state, FINISHED, userId);
            delete state.users[userId];
            _this3.trigger('typing-indicator-change', {
              conversationId: id,
              typing: state.typing,
              paused: state.paused
            });
          }
        });
      });
    }

    /**
     * Get the Client associated with this class.  Uses the clientId
     * property.
     *
     * @method _getClient
     * @protected
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }
  }]);

  return TypingIndicatorListener;
}(Root);

/**
 * setTimeout ID for polling for states to transition
 * @type {Number}
 * @private
 */


TypingIndicatorListener.prototype._pollId = 0;

/**
 * ID of the client this instance is associated with
 * @type {String}
 */
TypingIndicatorListener.prototype.clientId = '';

TypingIndicatorListener.bubbleEventParent = '_getClient';

TypingIndicatorListener._supportedEvents = [
/**
 * There has been a change in typing indicator state of other users.
 * @event change
 * @param {layer.LayerEvent} evt
 * @param {string[]} evt.typing - Array of userIds of people who are typing
 * @param {string[]} evt.paused - Array of userIds of people who are paused
 * @param {string} evt.conversationId - ID of the Converation that has changed typing indicator state
 */
'typing-indicator-change'].concat(Root._supportedEvents);

Root.initClass.apply(TypingIndicatorListener, [TypingIndicatorListener, 'TypingIndicatorListener']);
module.exports = TypingIndicatorListener;

},{"../client-registry":9,"../root":24,"./typing-indicators":29}],29:[function(require,module,exports){
'use strict';

/**
 * Static properties here only needed if your directly using
 * the layer.TypingIndicators.TypingPublisher (not needed if
 * you are using the layer.TypingIndicators.TypingListener).
 *
 *      typingPublisher.setState(layer.TypingIndicators.STARTED);
 *
 * @class  layer.TypingIndicators
 * @static
 */
module.exports = {
  /**
   * Typing has started/resumed
   * @type {String}
   * @static
   */
  STARTED: 'started',

  /**
   * Typing has paused
   * @type {String}
   * @static
   */
  PAUSED: 'paused',

  /**
   * Typing has finished
   * @type {String}
   * @static
   */
  FINISHED: 'finished'
};

},{}],30:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TypingPublisher = require('./typing-publisher');

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

/**
 * The Typing Listener Class listens to keyboard events on
 * your text field, and uses the layer.TypingPublisher to
 * send state based on keyboard behavior.
 *
 *      var typingListener = client.createTypingListener(document.getElementById('mytextarea'));
 *
 *  You change what Conversation
 *  the typing indicator reports your user to be typing
 *  in by calling:
 *
 *      typingListener.setConversation(mySelectedConversation);
 *
 * There are two ways of cleaning up all pointers to your input so it can be garbage collected:
 *
 * 1. Destroy the listener:
 *
 *        typingListener.destroy();
 *
 * 2. Remove or replace the input:
 *
 *        typingListener.setInput(null);
 *        typingListener.setInput(newInput);
 *
 * @class  layer.TypingIndicators.TypingListener
 */

var TypingListener = function () {

  /**
   * Create a TypingListener that listens for the user's typing.
   *
   * The TypingListener needs
   * to know what Conversation the user is typing into... but it does not require that parameter during initialization.
   *
   * @method constructor
   * @param  {Object} args
   * @param {string} args.clientId - The ID of the client; used so that the TypingPublisher can access its websocket manager*
   * @param {HTMLElement} [args.input=null] - A Text editor dom node that will have typing indicators
   * @param {Object} [args.conversation=null] - The Conversation Object or Instance that the input will send messages to
   */

  function TypingListener(args) {
    _classCallCheck(this, TypingListener);

    this.clientId = args.clientId;
    this.conversation = args.conversation;
    this.publisher = new TypingPublisher({
      clientId: this.clientId,
      conversation: this.conversation
    });

    this.intervalId = 0;
    this.lastKeyId = 0;

    this._handleKeyPress = this._handleKeyPress.bind(this);
    this._handleKeyDown = this._handleKeyDown.bind(this);
    this.setInput(args.input);
  }

  _createClass(TypingListener, [{
    key: 'destroy',
    value: function destroy() {
      this._removeInput(this.input);
      this.publisher.destroy();
    }

    /**
     * Change the input being tracked by your TypingListener.
     *
     * If you are removing your input from the DOM, you can simply call
     *
     *     typingListener.setInput(null);
     *
     * And all event handlers will be removed, allowing for garbage collection
     * to cleanup your input.
     *
     * You can also call setInput with a newly created input:
     *
     *     var input = document.createElement('input');
     *     typingListener.setInput(input);
     *
     * @method setInput
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: 'setInput',
    value: function setInput(input) {
      if (input !== this.input) {
        this._removeInput(this.input);
        this.input = input;

        // Use keypress rather than keydown because the user hitting alt-tab to change
        // windows, and other meta keys should not result in typing indicators
        this.input.addEventListener('keypress', this._handleKeyPress);
        this.input.addEventListener('keydown', this._handleKeyDown);
      }
    }

    /**
     * Cleanup and remove all links and callbacks keeping input from being garbage collected.
     *
     * @method _removeInput
     * @private
     * @param {HTMLElement} input - Textarea or text input
     */

  }, {
    key: '_removeInput',
    value: function _removeInput(input) {
      if (input) {
        input.removeEventListener('keypress', this._handleKeyPress);
        input.removeEventListener('keydown', this._handleKeyDown);
        this.input = null;
      }
    }

    /**
     * Change the Conversation; this should set the state of the old Conversation to "finished".
     *
     * Use this when the user has changed Conversations and you want to report on typing to a new
     * Conversation.
     *
     * @method setConversation
     * @param  {Object} conv - The new Conversation Object or Instance
     */

  }, {
    key: 'setConversation',
    value: function setConversation(conv) {
      if (conv !== this.conversation) {
        this.conversation = conv;
        this.publisher.setConversation(conv);
      }
    }

    /**
     * Whenever the key is pressed, send a "started" or "finished" event.
     *
     * If its a "start" event, schedule a pause-test that will send
     * a "pause" event if typing stops.
     *
     * @method _handleKeyPress
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyPress',
    value: function _handleKeyPress(evt) {
      var _this = this;

      if (this.lastKeyId) window.clearTimeout(this.lastKeyId);
      this.lastKeyId = window.setTimeout(function () {
        _this.lastKeyId = 0;
        var isEmpty = !Boolean(_this.input.value);
        _this.send(isEmpty ? FINISHED : STARTED);
      }, 50);
    }

    /**
     * Handles keyboard keys not reported by on by keypress events.
     *
     * These keys can be detected with keyDown event handlers. The ones
     * currently handled here are backspace, delete and enter.
     * We may add more later.
     *
     * @method _handleKeyDown
     * @private
     * @param  {KeyboardEvent} evt
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(evt) {
      if ([8, 46, 13].indexOf(evt.keyCode) !== -1) this._handleKeyPress();
    }

    /**
     * Send the state to the publisher.
     *
     * If your application requires
     * you to directly control the state, you can call this method;
     * however, as long as you use this TypingListener, keyboard
     * events will overwrite any state changes you send.
     *
     * Common use case for this: After a message is sent, you want to clear any typing indicators:
     *
     *      function send() {
     *        message.send();
     *        typingIndicators.send(layer.TypingIndicators.FINISHED);
     *      }
     *
     * @method send
     * @param  {string} state - One of "started", "paused", "finished"
     */

  }, {
    key: 'send',
    value: function send(state) {
      this.publisher.setState(state);
    }
  }]);

  return TypingListener;
}();

module.exports = TypingListener;

},{"./typing-indicators":29,"./typing-publisher":31}],31:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * The TypingPublisher's job is:
 *
 *  1. Send state changes to the server
 *  2. Insure that the server is not flooded with repeated state changes of the same value
 *  3. Automatically transition states when no new states or old states are requested.
 *
 * Who is the Typing Publisher for?  Its used by the layer.TypingIndicators.TypingListener; if your using
 * the TypingListener, you don't need this.  If you want to provide your own logic for when to send typing
 * states, then you need the TypingPublisher.
 *
 * Create an instance using:
 *
 *        var publisher = client.createTypingPublisher();
 *
 * To tell the Publisher which Conversation its reporting activity on, use:
 *
 *        publisher.setConversation(mySelectedConversation);
 *
 * To then use the instance:
 *
 *        publisher.setState(layer.TypingIndicators.STARTED);
 *        publisher.setState(layer.TypingIndicators.PAUSED);
 *        publisher.setState(layer.TypingIndicators.FINISHED);
 *
 * Note that the `STARTED` state only lasts for 2.5 seconds, so you
 * must repeatedly call setState for as long as this state should continue.
 * This is typically done by simply calling `setState(STARTED)` every time a user hits
 * a key.
 *
 * A few rules for how the *publisher* works internally:
 *
 *  - it maintains an indicator state for the current conversation
 *  - if app calls  `setState(layer.TypingIndicators.STARTED);` publisher sends the event immediately
 *  - if app calls the same method under _2.5 seconds_ with the same typing indicator state (`started`), publisher waits
 *    for those 2.5 seconds to pass and then publishes the ephemeral event
 *  - if app calls the same methods multiple times within _2.5 seconds_ with the same value,
 *    publisher waits until end of 2.5 second period and sends the state only once.
 *  - if app calls the same method under _2.5 seconds_ with a different typing indicator state (say `paused`),
 *    publisher immediately sends the event
 *  - if 2.5 seconds passes without any events, state transitions from 'started' to 'paused'
 *  - if 2.5 seconds passes without any events, state transitions from 'paused' to 'finished'
 *
 * @class layer.TypingIndicators.TypingPublisher
 * @protected
 */

var INTERVAL = 2500;

var _require = require('./typing-indicators');

var STARTED = _require.STARTED;
var PAUSED = _require.PAUSED;
var FINISHED = _require.FINISHED;

var ClientRegistry = require('../client-registry');

var TypingPublisher = function () {

  /**
   * Create a Typing Publisher.  See layer.Client.createTypingPublisher.
   *
   * The TypingPublisher needs
   * to know what Conversation its publishing changes for...
   * but it does not require that parameter during initialization.
   *
   * @method constructor
   * @param {Object} args
   * @param {string} clientId - The ID for the client from which we will get access to the websocket
   * @param {Object} [conversation=null] - The Conversation Object or Instance that messages are being typed to.
   */

  function TypingPublisher(args) {
    _classCallCheck(this, TypingPublisher);

    this.clientId = args.clientId;
    if (args.conversation) this.conversation = this._getClient().getConversation(args.conversation.id);
    this.state = FINISHED;
    this._lastMessageTime = 0;
  }

  /**
   * Set which Conversation we are reporting on state changes for.
   *
   * If this instance managed a previous Conversation,
   * its state is immediately transitioned to "finished".
   *
   * @method setConversation
   * @param  {Object} conv - Conversation Object or Instance
   */


  _createClass(TypingPublisher, [{
    key: 'setConversation',
    value: function setConversation(conv) {
      this.setState(FINISHED);
      this.conversation = conv ? this._getClient().getConversation(conv.id) : null;
      this.state = FINISHED;
    }

    /**
     * Sets the state and either sends the state to the server or schedules it to be sent.
     *
     * @method setState
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: 'setState',
    value: function setState(state) {
      // We have a fresh state; whatever our pauseLoop was doing
      // can be canceled... and restarted later.
      if (this._pauseLoopId) {
        clearInterval(this._pauseLoopId);
        this._pauseLoopId = 0;
      }
      if (!this.conversation) return;

      // If its a new state, send it immediately.
      if (this.state !== state) {
        this.state = state;
        this._send(state);
      }

      // No need to resend 'finished' state
      else if (state === FINISHED) {
          return;
        }

        // If its an existing state that hasn't been sent in the
        // last 2.5 seconds, send it immediately.
        else if (Date.now() > this._lastMessageTime + INTERVAL) {
            this._send(state);
          }

          // Else schedule it to be sent.
          else {
              this._scheduleNextMessage(state);
            }

      // Start test to automatically transition if 2.5 seconds without any setState calls
      if (this.state !== FINISHED) this._startPauseLoop();
    }

    /**
     * Start loop to automatically change to next state.
     *
     * Any time we are set to 'started' or 'paused' we should transition
     * to the next state after 2.5 seconds of no setState calls.
     *
     * The 2.5 second setTimeout is canceled/restarted every call to setState()
     *
     * @method _startPauseLoop
     * @private
     */

  }, {
    key: '_startPauseLoop',
    value: function _startPauseLoop() {
      var _this = this;

      if (this._pauseLoopId) return;

      // Note that this interval is canceled every call to setState.
      this._pauseLoopId = window.setInterval(function () {
        if (_this.state === PAUSED) {
          _this.setState(FINISHED);
        } else if (_this.state === STARTED) {
          _this.setState(PAUSED);
        }
      }, INTERVAL);
    }

    /**
     * Schedule the next state refresh message.
     *
     * It should be at least INTERVAL ms after
     * the last state message of the same state
     *
     * @method _scheduleNextMessage
     * @private
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: '_scheduleNextMessage',
    value: function _scheduleNextMessage(state) {
      var _this2 = this;

      if (this._scheduleId) clearTimeout(this._scheduleId);
      var delay = INTERVAL - Math.min(Date.now() - this._lastMessageTime, INTERVAL);
      this._scheduleId = setTimeout(function () {
        _this2._scheduleId = 0;
        // If the state didn't change while waiting...
        if (_this2.state === state) _this2._send(state);
      }, delay);
    }

    /**
     * Send a state change to the server.
     *
     * @method send
     * @private
     * @param  {string} state - One of
     * * layer.TypingIndicators.STARTED
     * * layer.TypingIndicators.PAUSED
     * * layer.TypingIndicators.FINISHED
     */

  }, {
    key: '_send',
    value: function _send(state) {
      if (!this.conversation.isSaved()) return;
      this._lastMessageTime = Date.now();
      var ws = this._getClient().socketManager;
      ws.sendSignal({
        'type': 'typing_indicator',
        'object': {
          'id': this.conversation.id
        },
        'data': {
          'action': state
        }
      });
    }

    /**
     * Get the Client associated with this layer.Message.
     *
     * Uses the clientId property.
     *
     * @method getClient
     * @return {layer.Client}
     */

  }, {
    key: '_getClient',
    value: function _getClient() {
      return ClientRegistry.get(this.clientId);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      delete this.conversation;
      clearTimeout(this._scheduleId);
      clearInterval(this._pauseLoopId);
    }
  }]);

  return TypingPublisher;
}();

module.exports = TypingPublisher;

},{"../client-registry":9,"./typing-indicators":29}],32:[function(require,module,exports){
/**
 * Layer does not at this time have a concept of Users, so this class
 * is more of a convenience/utility than required use.
 *
 * The main conveniences provided by this class are that when
 * used in conjunction with the `client.users`  array,
 * and the `client.addUser(user)` method, each instance
 * will look for/monitor for Conversations that are direct
 * messages between the currently authenticated user and
 * the user represented by this User instance.
 *
 * This is useful if listing users and want to show their last
 * message or their unread message count.
 *
 *      client.addUser(new layer.User({
 *          displayName: 'Fred',
 *          id: 'fred1234',
 *          data: {
 *              a: 'a',
 *              b: 'b',
 *              lastName: 'Huh?'
 *          }
 *      }));
 *
 * The id will be what is used to find matching Conversations.
 *
 * displayName is not required, but is a convenient place
 * to store a displayable name.
 *
 * The data property contains an arbitrary javascript object
 * with any relevant details of your user.
 *
 * TODO: Replace client with clientId
 *
 * @class  layer.User
 * @extends layer.Root
 * @private // Make this public when Identities is released
 */
"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Root = require("./root");
var Util = require("./client-utils");

var User = function (_Root) {
    _inherits(User, _Root);

    function User(options) {
        _classCallCheck(this, User);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(User).call(this, options));

        _this.on("all", _this._clearObject, _this);
        return _this;
    }

    /**
     * Sets the Client property.
     *
     * This is called as a side-effect of `client.addUser(user)`
     *
     * If you directly manipulate `client.users`, instead of calling
     * addUser(), you may need to call this method and set the client property.
     *
     * @method setClient
     * @param  {layer.Client} client
     */


    _createClass(User, [{
        key: "setClient",
        value: function setClient(client) {
            if (client) {
                var conversations = Object.keys(client._conversationsHash).map(function (id) {
                    return client.getConversation(id);
                }).filter(function (c) {
                    return c.participants.length == 2 && c.participants.indexOf(this.id) != -1;
                }, this);

                Util.sortBy(conversations, function (conversation) {
                    return conversation.lastMessage ? conversation.lastMessage.sentAt : null;
                }, true);
                if (conversations.length) {
                    this.conversation = conversations[0];
                } else {
                    client.on("conversations:add", this._checkNewConversation, this);
                }
            }
        }

        /**
         * Searches all new Conversations for matching Conversation.
         *
         * A matching Conversation is a direct message conversation
         * between this user and the client's authenticated user.
         *
         * If its a match, updates this.conversation and stops
         * listening for new Conversations.
         *
         * @method _checkNewConversation
         * @private
         * @param  {layer.LayerEvent} evt
         */

    }, {
        key: "_checkNewConversation",
        value: function _checkNewConversation(evt) {
            var _this2 = this;

            var conversations = evt.conversations;
            conversations.forEach(function (conversation) {
                if (conversation.participants.length == 2 && conversation.participants.indexOf(_this2.id) != -1) {
                    _this2.conversation = conversation;
                    conversation.client.off(null, null, _this2);
                }
            });
        }

        /**
         * Handles new values for the Conversation property.
         *
         * Any time a new Conversation is assigned to this property,
         * subscribe to its "destroy" event and trigger a "conversations:change"
         * event on this user.
         *
         * @method __updateConversation
         * @private
         * @param  {layer.Conversation} conversation
         * @param  {layer.Conversation} oldConversation
         */

    }, {
        key: "__updateConversation",
        value: function __updateConversation(conversation, oldConversation) {
            if (oldConversation) oldConversation.off(null, null, this);
            if (conversation) conversation.on("destroy", this._destroyConversation, this);
            this.trigger("conversations:change");
        }

        /**
         * If the Conversation is destroyed, this user has no Conversation.
         *
         * @method _destroyConversation
         * @private
         * @param  {layer.LayerEvent} evt
         */

    }, {
        key: "_destroyConversation",
        value: function _destroyConversation(evt) {
            this.conversation = null;
        }
    }, {
        key: "toObject",
        value: function toObject() {
            if (!this._toObject) {
                this._toObject = _get(Object.getPrototypeOf(User.prototype), "toObject", this).call(this);
            }
            return this._toObject;
        }
    }, {
        key: "_clearObject",
        value: function _clearObject() {
            delete this._toObject;
        }
    }]);

    return User;
}(Root);

/**
 * Custom user data.
 *
 * This property has no built-in meaning; but is intended to let you store a custom data.
 * Initialize this via constructor:
 *
 *         new layer.User({
 *             data: {
 *                 age: 109,
 *                 nickName: "Freddy"
 *             },
 *             id: "fred"
 *         });
 *
 * @type {Object}
 */


User.prototype.data = null;

/**
 * Your User ID.
 *
 * This ID should match up with the IDs used in participants in Conversations;
 * such IDs are based on your own user IDs which are passed to the Layer services via Identity Tokens.
 * @type {String}
 */
User.prototype.id = "";

/**
 * Your user's displayable name.
 *
 * This property has no built-in meaning; but is intended to let you store a custom string
 * for how to render this user.  Initialize this via constructor:
 *
 *         new layer.User({
 *             displayName: "Freddy",
 *             id: "fred"
 *         });
 *
 * @type {String}
 */
User.prototype.displayName = "";

/**
 * CSS Class for user icon.
 *
 * This property has no built-in meaning; use this if your rendering engine needs this;
 * just pass it into the constructor;
 *
 *         new layer.User({
 *             iconClass: "unknown-face",
 *             id: "fred"
 *         });
 *
 * @type {String}
 */
User.prototype.iconClass = "";

/**
 * The User's Conversation.
 *
 * This property is managed by the user class and is set to always point to any matching Direct
 * Message conversation between this user and the currently authenticated user.  Useful
 * for rendering in a User List and showing unread counts, last message, etc...
 * Can also be used when selecting the user to quickly resume a Conversation.
 * @type {layer.Conversation}
 */
User.prototype.conversation = null;
User.prototype._toObject = null;

User._supportedEvents = ["conversations:change"].concat(Root._supportedEvents);
Root.initClass.apply(User, [User, "User"]);

module.exports = User;

},{"./client-utils":10,"./root":24}],33:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.ChangeManager
 * @private
 *
 * This class listens for `change` events from the websocket server,
 * and processes them.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var Message = require('../message');
var Conversation = require('../conversation');

var WebsocketChangeManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketChangeManager = new layer.Websockets.ChangeManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.ChangeManager}
   */

  function WebsocketChangeManager(options) {
    _classCallCheck(this, WebsocketChangeManager);

    this.client = options.client;
    options.socketManager.on('message', this._handleChange, this);
  }

  /**
   * Handles a Change packet from the server.
   *
   * @method _handleChange
   * @private
   * @param  {layer.LayerEvent} evt
   */


  _createClass(WebsocketChangeManager, [{
    key: '_handleChange',
    value: function _handleChange(evt) {
      if (evt.data.type === 'change') {
        var msg = evt.data.body;
        switch (msg.operation) {
          case 'create':
            logger.info('Websocket Change Event: Create ' + msg.object.type + ' ' + msg.object.id);
            logger.debug(msg.data);
            this._handleCreate(msg);
            break;
          case 'delete':
            logger.info('Websocket Change Event: Delete ' + msg.object.type + ' ' + msg.object.id);
            logger.debug(msg.data);
            this._handleDelete(msg);
            break;
          case 'patch':
            logger.info('Websocket Change Event: Patch ' + msg.object.type + ' ' + msg.object.id + ': ' + msg.data.map(function (op) {
              return op.property;
            }).join(', '));
            logger.debug(msg.data);
            this._handlePatch(msg);
            break;
        }
      }
    }

    /**
     * Process a create object message from the server
     *
     * @method _handleCreate
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleCreate',
    value: function _handleCreate(msg) {
      msg.data.fromWebsocket = true;
      this.client._createObject(msg.data);
    }

    /**
     * Handles delete object messages from the server.
     * All objects that can be deleted from the server should
     * provide a _deleted() method to be called prior to destroy().
     *
     * @method _handleDelete
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handleDelete',
    value: function _handleDelete(msg) {
      if (msg.data.mode === 'my_devices' && msg.data.from_position) {
        this.client._purgeMessagesByPosition(msg.object.id, msg.data.from_position);
      } else {
        var entity = this._getObject(msg);
        if (entity) {
          entity._deleted();
          entity.destroy();
        }
      }
    }

    /**
     * On receiving an update/patch message from the server
     * run the LayerParser on the data.
     *
     * @method _handlePatch
     * @private
     * @param  {Object} msg
     */

  }, {
    key: '_handlePatch',
    value: function _handlePatch(msg) {
      // Can only patch a cached object
      var entity = this._getObject(msg);
      if (entity) {
        try {
          entity._inLayerParser = true;
          Utils.layerParse({
            object: entity,
            type: msg.object.type,
            operations: msg.data,
            client: this.client
          });
          entity._inLayerParser = false;
        } catch (err) {
          logger.error('websocket-manager: Failed to handle event', msg.data);
        }
      } else {
        switch (Utils.typeFromID(msg.object.id)) {
          case 'conversations':
            if (Conversation._loadResourceForPatch(msg.data)) this.client.getConversation(msg.object.id, true);
            break;
          case 'messages':
            if (Message._loadResourceForPatch(msg.data)) this.client.getMessage(msg.object.id, true);
            break;
          case 'announcements':
            break;
        }
      }
    }

    /**
     * Get the object specified by the `object` property of the websocket packet.
     *
     * @method _getObject
     * @private
     * @param  {Object} msg
     * @return {layer.Root}
     */

  }, {
    key: '_getObject',
    value: function _getObject(msg) {
      return this.client._getObject(msg.object.id);
    }

    /**
     * Not required, but destroy is best practice
     * @method destroy
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      this.client = null;
    }
  }]);

  return WebsocketChangeManager;
}();

/**
 * The Client that owns this.
 * @type {layer.Client}
 */


WebsocketChangeManager.prototype.client = null;

module.exports = WebsocketChangeManager;

},{"../client-utils":10,"../conversation":14,"../logger":18,"../message":20}],34:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @class  layer.Websockets.RequestManager
 * @private
 *
 * This class allows one to send requests to the websocket server, and provide a callback,
 * And have that callback either called by the correct websocket server response, or
 * be called with a timeout.
 */
var Utils = require('../client-utils');
var logger = require('../logger');
var LayerError = require('../layer-error');

// Wait 15 seconds for a response and then give up
var DELAY_UNTIL_TIMEOUT = 15 * 1000;

var WebsocketRequestManager = function () {
  /**
   * Create a new websocket change manager
   *
   *      var websocketRequestManager = new layer.Websockets.RequestManager({
   *          client: client,
   *          socketManager: client.Websockets.SocketManager
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @param {layer.Websockets.SocketManager} socketManager
   * @returns {layer.Websockets.RequestManager}
   */

  function WebsocketRequestManager(options) {
    _classCallCheck(this, WebsocketRequestManager);

    this.client = options.client;
    this.socketManager = options.socketManager;
    this.socketManager.on({
      message: this._handleResponse,
      disconnected: this._reset
    }, this);

    this._requestCallbacks = {};
  }

  _createClass(WebsocketRequestManager, [{
    key: '_reset',
    value: function _reset() {
      this._requestCallbacks = {};
    }

    /**
     * Handle a response to a request.
     *
     * @method _handleResponse
     * @private
     * @param  {layer.LayerEvent} evt
     */

  }, {
    key: '_handleResponse',
    value: function _handleResponse(evt) {
      if (evt.data.type === 'response') {
        var msg = evt.data.body;
        var requestId = msg.request_id;
        var data = msg.success ? msg.data : new LayerError(msg.data);
        logger.debug('Websocket response ' + requestId + ' ' + (msg.success ? 'Successful' : 'Failed'));
        if (requestId && this._requestCallbacks[requestId]) {
          this._requestCallbacks[requestId].callback({
            success: msg.success,
            fullData: evt.data,
            data: data
          });
          delete this._requestCallbacks[requestId];
        }
      }
    }

    /**
     * Shortcut for sending a request; builds in handling for callbacks
     *
     *    manager.sendRequest({
     *      operation: "delete",
     *      object: {id: "layer:///conversations/uuid"},
     *      data: {deletion_mode: "all_participants"}
     *    }, function(result) {
     *        alert(result.success ? "Yay" : "Boo");
     *    });
     *
     * @method sendRequest
     * @param  {Object} data - Data to send to the server
     * @param  {Function} callback - Handler for success/failure callback
     */

  }, {
    key: 'sendRequest',
    value: function sendRequest(data, callback) {
      if (!this._isOpen()) {
        return !callback ? undefined : callback(new LayerError({
          success: false,
          data: { id: 'not_connected', code: 0, message: 'WebSocket not connected' }
        }));
      }
      var body = Utils.clone(data);
      body.request_id = 'r' + this._nextRequestId++;
      logger.debug('Request ' + body.request_id + ' is sending');
      if (callback) {
        this._requestCallbacks[body.request_id] = {
          date: Date.now(),
          callback: callback
        };
      }

      this.socketManager.send({
        type: 'request',
        body: body
      });
      this._scheduleCallbackCleanup();
    }

    /**
     * Flags a request as having failed if no response within 2 minutes
     *
     * @method _scheduleCallbackCleanup
     * @private
     */

  }, {
    key: '_scheduleCallbackCleanup',
    value: function _scheduleCallbackCleanup() {
      if (!this._callbackCleanupId) {
        this._callbackCleanupId = setTimeout(this._runCallbackCleanup.bind(this), DELAY_UNTIL_TIMEOUT + 50);
      }
    }

    /**
     * Calls callback with an error.
     *
     * NOTE: Because we call requests that expect responses serially instead of in parallel,
     * currently there should only ever be a single entry in _requestCallbacks.  This may change in the future.
     *
     * @method _runCallbackCleanup
     * @private
     */

  }, {
    key: '_runCallbackCleanup',
    value: function _runCallbackCleanup() {
      var _this = this;

      this._callbackCleanupId = 0;
      // If the websocket is closed, ignore all callbacks.  The Sync Manager will reissue these requests as soon as it gets
      // a 'connected' event... they have not failed.  May need to rethink this for cases where third parties are directly
      // calling the websocket manager bypassing the sync manager.
      if (this.isDestroyed || !this._isOpen()) return;
      var count = 0;
      var now = Date.now();
      Object.keys(this._requestCallbacks).forEach(function (requestId) {
        var callbackConfig = _this._requestCallbacks[requestId];
        // If the request hasn't expired, we'll need to reschedule callback cleanup; else if its expired...
        if (callbackConfig && now < callbackConfig.date + DELAY_UNTIL_TIMEOUT) {
          count++;
        } else {
          // If there has been no data from the server, there's probably a problem with the websocket; reconnect.
          if (now > _this.socketManager._lastDataFromServerTimestamp + DELAY_UNTIL_TIMEOUT) {
            _this.socketManager._reconnect(false);
            _this._scheduleCallbackCleanup();
            return;
          } else {
            // The request isn't responding and the socket is good; fail the request.
            _this._timeoutRequest(requestId);
          }
        }
      });
      if (count) this._scheduleCallbackCleanup();
    }
  }, {
    key: '_timeoutRequest',
    value: function _timeoutRequest(requestId) {
      try {
        logger.warn('Websocket request timeout');
        this._requestCallbacks[requestId].callback({
          success: false,
          data: new LayerError({
            id: 'request_timeout',
            message: 'The server is not responding. We know how much that sucks.',
            url: 'https:/developer.layer.com/docs/websdk',
            code: 0,
            status: 408,
            httpStatus: 408
          })
        });
      } catch (err) {
        // Do nothing
      }
      delete this._requestCallbacks[requestId];
    }
  }, {
    key: '_isOpen',
    value: function _isOpen() {
      return this.socketManager._isOpen();
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.isDestroyed = true;
      if (this._callbackCleanupId) clearTimeout(this._callbackCleanupId);
      this._requestCallbacks = null;
    }
  }]);

  return WebsocketRequestManager;
}();

WebsocketRequestManager.prototype._nextRequestId = 1;

/**
 * The Client that owns this.
 * @type {layer.Client}
 */
WebsocketRequestManager.prototype.client = null;

WebsocketRequestManager.prototype._requestCallbacks = null;

WebsocketRequestManager.prototype._callbackCleanupId = 0;

WebsocketRequestManager.prototype.socketManager = null;

module.exports = WebsocketRequestManager;

},{"../client-utils":10,"../layer-error":16,"../logger":18}],35:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This component manages
 *
 * 1. recieving websocket events
 * 2. Processing them
 * 3. Triggering events on completing them
 * 4. Sending them
 *
 * Applications typically do not interact with this component, but may subscribe
 * to the `message` event if they want richer event information than is available
 * through the layer.Client class.
 *
 * @class  layer.Websockets.SocketManager
 * @extends layer.Root
 * @private
 */
var Root = require('../root');
var Utils = require('../client-utils');
var logger = require('../logger');

var SocketManager = function (_Root) {
  _inherits(SocketManager, _Root);

  /**
   * Create a new websocket manager
   *
   *      var socketManager = new layer.Websockets.SocketManager({
   *          client: client,
   *      });
   *
   * @method
   * @param  {Object} options
   * @param {layer.Client} client
   * @return {layer.Websockets.SocketManager}
   */

  function SocketManager(options) {
    _classCallCheck(this, SocketManager);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(SocketManager).call(this, options));

    if (!_this.client) throw new Error('SocketManager requires a client');

    // Insure that on/off methods don't need to call bind, therefore making it easy
    // to add/remove functions as event listeners.
    _this._onMessage = _this._onMessage.bind(_this);
    _this._onOpen = _this._onOpen.bind(_this);
    _this._onSocketClose = _this._onSocketClose.bind(_this);
    _this._onError = _this._onError.bind(_this);

    // If the client is authenticated, start it up.
    if (_this.client.isAuthenticated && _this.client.onlineManager.isOnline) {
      _this.connect();
    }

    _this.client.on('online', _this._onlineStateChange, _this);

    // Any time the Client triggers a ready event we need to reconnect.
    _this.client.on('authenticated', _this.connect, _this);

    _this._lastTimestamp = Date.now();
    return _this;
  }

  /**
   * Call this when we want to reset all websocket state; this would be done after a lengthy period
   * of being disconnected.  This prevents Event.replay from being called on reconnecting.
   *
   * @method _reset
   * @private
   */


  _createClass(SocketManager, [{
    key: '_reset',
    value: function _reset() {
      this._lastTimestamp = 0;
      this._lastDataFromServerTimestamp = 0;
      this._lastCounter = null;
      this._hasCounter = false;

      this._inReplay = false;
      this._needsReplayFrom = null;
    }

    /**
     * Event handler is triggered any time the client's online state changes.
     * If going online we need to reconnect (i.e. will close any existing websocket connections and then open a new connection)
     * If going offline, close the websocket as its no longer useful/relevant.
     * @method _onlineStateChange
     * @private
     * @param {layer.LayerEvent} evt
     */

  }, {
    key: '_onlineStateChange',
    value: function _onlineStateChange(evt) {
      if (!this.client.isAuthenticated) return;
      if (evt.isOnline) {
        this._reconnect(evt.reset);
      } else {
        this.close();
      }
    }

    /**
     * Reconnect to the server, optionally resetting all data if needed.
     * @method _reconnect
     * @private
     * @param {boolean} reset
     */

  }, {
    key: '_reconnect',
    value: function _reconnect(reset) {
      // The sync manager will reissue any requests once it receives a 'connect' event from the websocket manager.
      // There is no need to have an error callback at this time.
      // Note that calls that come from sources other than the sync manager may suffer from this.
      // Once the websocket implements retry rather than the sync manager, we may need to enable it
      // to trigger a callback after sufficient time.  Just delete all callbacks.
      this.close();
      if (reset) this._reset();
      this.connect();
    }

    /**
     * Connect to the websocket server
     *
     * @method connect
     * @param  {layer.SyncEvent} evt - Ignored parameter
     */

  }, {
    key: 'connect',
    value: function connect(evt) {
      if (this.client.isDestroyed || !this.client.isOnline) return;

      this._closing = false;

      this._lastCounter = -1;

      // Load up our websocket component or shim
      /* istanbul ignore next */
      var WS = typeof WebSocket === 'undefined' ? require('websocket').w3cwebsocket : WebSocket;

      // Get the URL and connect to it
      var url = this.client.url.replace(/^http/, 'ws') + '/websocket?session_token=' + this.client.sessionToken;
      this._socket = new WS(url, 'layer-1.0');

      // If its the shim, set the event hanlers
      /* istanbul ignore if */
      if (typeof WebSocket === 'undefined') {
        this._socket.onmessage = this._onMessage;
        this._socket.onclose = this._onSocketClose;
        this._socket.onopen = this._onOpen;
        this._socket.onerror = this._onError;
      }

      // If its a real websocket, add the event handlers
      else {
          this._socket.addEventListener('message', this._onMessage);
          this._socket.addEventListener('close', this._onSocketClose);
          this._socket.addEventListener('open', this._onOpen);
          this._socket.addEventListener('error', this._onError);
        }

      // Trigger a failure if it takes >= 5 seconds to establish a connection
      this._connectionFailedId = setTimeout(this._connectionFailed.bind(this), 5000);
    }

    /**
     * Clears the scheduled call to _connectionFailed that is used to insure the websocket does not get stuck
     * in CONNECTING state. This call is used after the call has completed or failed.
     *
     * @method _clearConnectionFailed
     * @private
     */

  }, {
    key: '_clearConnectionFailed',
    value: function _clearConnectionFailed() {
      if (this._connectionFailedId) {
        clearTimeout(this._connectionFailedId);
        this._connectionFailedId = 0;
      }
    }

    /**
     * Called after 5 seconds of entering CONNECTING state without getting an error or a connection.
     * Calls _onError which will cause this attempt to be stopped and another connection attempt to be scheduled.
     *
     * @method _connectionFailed
     * @private
     */

  }, {
    key: '_connectionFailed',
    value: function _connectionFailed() {
      this._connectionFailedId = 0;
      var msg = 'Websocket failed to connect to server';
      logger.warn(msg);

      // TODO: At this time there is little information on what happens when closing a websocket connection that is stuck in
      // readyState=CONNECTING.  Does it throw an error?  Does it call the onClose or onError event handlers?
      // Remove all event handlers so that calling close won't trigger any calls.
      try {
        this.isOpen = false;
        this._removeSocketEvents();
        this._socket.close();
        this._socket = null;
      } catch (e) {}
      // No-op


      // Now we can call our error handler.
      this._onError(new Error(msg));
    }

    /**
     * The websocket connection is reporting that its now open.
     *
     * @method _onOpen
     * @private
     */

  }, {
    key: '_onOpen',
    value: function _onOpen() {
      this._clearConnectionFailed();
      if (this._isOpen()) {
        this._lostConnectionCount = 0;
        this.isOpen = true;
        this.trigger('connected');
        logger.debug('Websocket Connected');
        if (this._hasCounter) {
          this.replayEvents(this._lastTimestamp, true);
        } else {
          this._reschedulePing();
        }
      }
    }

    /**
     * Tests to see if the websocket connection is open.  Use the isOpen property
     * for external tests.
     * @method _isOpen
     * @private
     * @returns {Boolean}
     */

  }, {
    key: '_isOpen',
    value: function _isOpen() {
      if (!this._socket) return false;
      /* istanbul ignore if */
      if (typeof WebSocket === 'undefined') return true;
      return this._socket && this._socket.readyState === WebSocket.OPEN;
    }

    /**
     * If not isOpen, presumably failed to connect
     * Any other error can be ignored... if the connection has
     * failed, onClose will handle it.
     *
     * @method _onError
     * @private
     * @param  {Error} err - Websocket error
     */

  }, {
    key: '_onError',
    value: function _onError(err) {
      if (this._closing) return;
      this._clearConnectionFailed();
      logger.debug('Websocket Error causing websocket to close', err);
      if (!this.isOpen) {
        this._removeSocketEvents();
        this._lostConnectionCount++;
        this._scheduleReconnect();
      } else {
        this._onSocketClose();
        this._socket.close();
        this._socket = null;
      }
    }

    /**
     * Shortcut method for sending a signal
     *
     *    manager.sendSignal({
            'type': 'typing_indicator',
            'object': {
              'id': this.conversation.id
            },
            'data': {
              'action': state
            }
          });
     *
     * @method sendSignal
     * @param  {Object} body - Signal body
     */

  }, {
    key: 'sendSignal',
    value: function sendSignal(body) {
      if (this._isOpen()) {
        this._socket.send(JSON.stringify({
          type: 'signal',
          body: body
        }));
      }
    }

    /**
     * Shortcut to sending a Counter.read request
     *
     * @method getCounter
     * @param  {Function} callback
     * @param {boolean} callback.success
     * @param {number} callback.lastCounter
     * @param {number} callback.newCounter
     */

  }, {
    key: 'getCounter',
    value: function getCounter(callback) {
      logger.debug('Websocket request: getCounter');
      this.client.socketRequestManager.sendRequest({
        method: 'Counter.read'
      }, function (result) {
        logger.debug('Websocket response: getCounter ' + result.data.counter);
        if (callback) {
          if (result.success) {
            callback(true, result.data.counter, result.fullData.counter);
          } else {
            callback(false);
          }
        }
      });
    }

    /**
     * Replays all missed change packets since the specified timestamp
     *
     * @method replayEvents
     * @param  {string|number}   timestamp - Iso formatted date string; if number will be transformed into formatted date string.
     * @param  {boolean} [force=false] - if true, cancel any in progress replayEvents and start a new one
     * @param  {Function} [callback] - Optional callback for completion
     */

  }, {
    key: 'replayEvents',
    value: function replayEvents(timestamp, force, callback) {
      var _this2 = this;

      if (!timestamp) return;
      if (force) this._inReplay = false;
      if (typeof timestamp === 'number') timestamp = new Date(timestamp).toISOString();

      // If we are already waiting for a replay to complete, record the timestamp from which we
      // need to replay on our next replay request
      // If we are simply unable to replay because we're disconnected, capture the _needsReplayFrom
      if (this._inReplay || !this._isOpen()) {
        if (!this._needsReplayFrom) {
          logger.debug('Websocket request: replayEvents updating _needsReplayFrom');
          this._needsReplayFrom = timestamp;
        }
      } else {
        this._inReplay = true;
        logger.info('Websocket request: replayEvents');
        this.client.socketRequestManager.sendRequest({
          method: 'Event.replay',
          data: {
            from_timestamp: timestamp
          }
        }, function (result) {
          return _this2._replayEventsComplete(timestamp, callback, result.success);
        });
      }
    }

    /**
     * Callback for handling completion of replay.
     *
     * @method _replayEventsComplete
     * @private
     * @param  {Date}     timestamp
     * @param  {Function} callback
     * @param  {Boolean}   success
     */

  }, {
    key: '_replayEventsComplete',
    value: function _replayEventsComplete(timestamp, callback, success) {
      this._inReplay = false;

      // If replay was completed, and no other requests for replay, then trigger synced;
      // we're done.
      if (success && !this._needsReplayFrom) {
        logger.info('Websocket replay complete');
        this.trigger('synced');
        if (callback) callback();
      }

      // If replayEvents was called during a replay, then replay
      // from the given timestamp.  If request failed, then we need to retry from _lastTimestamp
      else if (success && this._needsReplayFrom) {
          logger.info('Websocket replay partially complete');
          var t = this._needsReplayFrom;
          this._needsReplayFrom = null;
          this.replayEvents(t);
        }

        // We never got a done event.  We also didn't miss any counters, so the last
        // message we received was valid; so lets just use that as our timestamp and
        // try again until we DO get a Event.Replay completion packet
        else {
            logger.info('Websocket replay retry');
            this.replayEvents(timestamp);
          }
    }

    /**
     * Handles a new websocket packet from the server
     *
     * @method _onMessage
     * @private
     * @param  {Object} evt - Message from the server
     */

  }, {
    key: '_onMessage',
    value: function _onMessage(evt) {
      this._lostConnectionCount = 0;
      try {
        var msg = JSON.parse(evt.data);
        var skippedCounter = this._lastCounter + 1 !== msg.counter;
        this._hasCounter = true;
        this._lastCounter = msg.counter;
        this._lastDataFromServerTimestamp = Date.now();

        // If we've missed a counter, replay to get; note that we had to update _lastCounter
        // for replayEvents to work correctly.
        if (skippedCounter) {
          this.replayEvents(this._lastTimestamp);
        } else {
          this._lastTimestamp = new Date(msg.timestamp).getTime();
        }

        this.trigger('message', {
          data: msg
        });

        this._reschedulePing();
      } catch (err) {
        logger.error('Layer-Websocket: Failed to handle websocket message: ' + err + '\n', evt.data);
      }
    }

    /**
     * Reschedule a ping request which helps us verify that the connection is still alive,
     * and that we haven't missed any events.
     *
     * @method _reschedulePing
     * @private
     */

  }, {
    key: '_reschedulePing',
    value: function _reschedulePing() {
      if (this._nextPingId) {
        clearTimeout(this._nextPingId);
      }
      this._nextPingId = setTimeout(this._ping.bind(this), this.pingFrequency);
    }

    /**
     * Send a counter request to the server to verify that we are still connected and
     * have not missed any events.
     *
     * @method _ping
     * @private
     */

  }, {
    key: '_ping',
    value: function _ping() {
      logger.debug('Websocket ping');
      this._nextPingId = 0;
      if (this._isOpen()) {
        // NOTE: onMessage will already have called reschedulePing, but if there was no response, then the error handler would NOT have called it.
        this.getCounter(this._reschedulePing.bind(this));
      }
    }

    /**
     * Close the websocket.
     *
     * @method close
     */

  }, {
    key: 'close',
    value: function close() {
      logger.debug('Websocket close requested');
      this._closing = true;
      this.isOpen = false;
      if (this._socket) {
        // Close all event handlers and set socket to null
        // without waiting for browser event to call
        // _onSocketClose as the next command after close
        // might require creating a new socket
        this._onSocketClose();
        this._socket.close();
        this._socket = null;
      }
    }

    /**
     * Send a packet across the websocket
     * @method send
     * @param {Object} obj
     */

  }, {
    key: 'send',
    value: function send(obj) {
      this._socket.send(JSON.stringify(obj));
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.close();
      if (this._nextPingId) clearTimeout(this._nextPingId);
      _get(Object.getPrototypeOf(SocketManager.prototype), 'destroy', this).call(this);
    }

    /**
     * If the socket has closed (or if the close method forces it closed)
     * Remove all event handlers and if appropriate, schedule a retry.
     *
     * @method _onSocketClose
     * @private
     */

  }, {
    key: '_onSocketClose',
    value: function _onSocketClose() {
      logger.debug('Websocket closed');
      this.isOpen = false;
      if (!this._closing) {
        this._scheduleReconnect();
      }

      this._removeSocketEvents();
      this.trigger('disconnected');
    }

    /**
     * Removes all event handlers on the current socket.
     *
     * @method _removeSocketEvents
     * @private
     */

  }, {
    key: '_removeSocketEvents',
    value: function _removeSocketEvents() {
      /* istanbul ignore if */
      if (typeof WebSocket !== 'undefined' && this._socket) {
        this._socket.removeEventListener('message', this._onMessage);
        this._socket.removeEventListener('close', this._onSocketClose);
        this._socket.removeEventListener('open', this._onOpen);
        this._socket.removeEventListener('error', this._onError);
      } else if (this._socket) {
        this._socket.onmessage = null;
        this._socket.onclose = null;
        this._socket.onopen = null;
        this._socket.onerror = null;
      }
    }

    /**
     * Schedule an attempt to reconnect to the server.  If the onlineManager
     * declares us to be offline, don't bother reconnecting.  A reconnect
     * attempt will be triggered as soon as the online manager reports we are online again.
     *
     * Note that the duration of our delay can not excede the onlineManager's ping frequency
     * or it will declare us to be offline while we attempt a reconnect.
     *
     * @method _scheduleReconnect
     * @private
     */

  }, {
    key: '_scheduleReconnect',
    value: function _scheduleReconnect() {
      if (this.isDestroyed || !this.client.isOnline) return;

      var maxDelay = (this.client.onlineManager.pingFrequency - 1000) / 1000;
      var delay = Utils.getExponentialBackoffSeconds(maxDelay, Math.min(15, this._lostConnectionCount));
      logger.debug('Websocket Reconnect in ' + delay + ' seconds');
      this._reconnectId = setTimeout(this.connect.bind(this), delay * 1000);
    }
  }]);

  return SocketManager;
}(Root);

/**
 * Is the websocket connection currently open?
 * @type {Boolean}
 */


SocketManager.prototype.isOpen = false;

/**
 * setTimeout ID for calling connect()
 * @private
 * @type {Number}
 */
SocketManager.prototype._reconnectId = 0;

/**
 * setTimeout ID for calling _connectionFailed()
 * @private
 * @type {Number}
 */
SocketManager.prototype._connectionFailedId = 0;

SocketManager.prototype._lastTimestamp = 0;
SocketManager.prototype._lastDataFromServerTimestamp = 0;
SocketManager.prototype._lastCounter = null;
SocketManager.prototype._hasCounter = false;

SocketManager.prototype._inReplay = false;
SocketManager.prototype._needsReplayFrom = null;

/**
 * Frequency with which the websocket checks to see if any websocket notifications
 * have been missed.
 * @type {Number}
 */
SocketManager.prototype.pingFrequency = 30000;

/**
 * The Client that owns this.
 * @type {layer.Client}
 */
SocketManager.prototype.client = null;

/**
 * The Socket Connection instance
 * @type {Websocket}
 */
SocketManager.prototype._socket = null;

/**
 * Is the websocket connection being closed by a call to close()?
 * If so, we can ignore any errors that signal the socket as closing.
 * @type {Boolean}
 */
SocketManager.prototype._closing = false;

/**
 * Number of failed attempts to reconnect.
 * @type {Number}
 */
SocketManager.prototype._lostConnectionCount = 0;

SocketManager._supportedEvents = [
/**
 * A data packet has been received from the server.
 * @event message
 * @param {layer.LayerEvent} layerEvent
 * @param {Object} layerEvent.data - The data that was received from the server
 */
'message',

/**
 * The websocket is now connected.
 * @event connected
 * @protected
 */
'connected',

/**
 * The websocket is no longer connected
 * @event disconnected
 * @protected
 */
'disconnected',

/**
 * Websocket events were missed; we are resyncing with the server
 * @event replay-begun
 */
'syncing',

/**
 * Websocket events were missed; we resynced with the server and are now done
 * @event replay-begun
 */
'synced'].concat(Root._supportedEvents);
Root.initClass.apply(SocketManager, [SocketManager, 'SocketManager']);
module.exports = SocketManager;

},{"../client-utils":10,"../logger":18,"../root":24,"websocket":3}],36:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

/**
 * Basic XHR Library with some notions hardcoded in
 * of what the Layer server expects/returns.
 *
    layer.xhr({
      url: 'http://my.com/mydata',
      data: {hey: 'ho', there: 'folk'},
      method: 'GET',
      format: 'json',
      headers: {'fred': 'Joe'},
      timeout: 50000
    }, function(result) {
      if (!result.success) {
        errorHandler(result.data, result.headers, result.status);
      } else {
        successHandler(result.data, result.headers, result.xhr);
      }
    });
 *
 * @class layer.xhr
 */

/**
 * Send a Request.
 *
 * @method  xhr
 * @param {Object} options
 * @param {string} options.url
 * @param {Mixed} [options.data=null]
 * @param {string} [options.format=''] - set to 'json' to get result parsed as json (in case there is no obvious Content-Type in the response)
 * @param {Object} [options.headers={}] - Name value pairs for  headers and their values
 * @param {number} [options.timeout=0] - When does the request expire/timeout in miliseconds.
 * @param {Function} callback
 * @param {Object} callback.result
 * @param {number} callback.result.status - http status code
 * @param {boolean} callback.result.success - true if it was a successful response
 * @param {XMLHttpRequest} callback.result.xhr - The XHR object used for the request
 * @param {Object} callback.result.data -  The parsed response body
 *
 * TODO:
 *
 * 1. Make this a subclass of Root and make it a singleton so it can inherit a proper event system
 * 2. Result should be a layer.ServerResponse instance
 * 3. Should only access link headers if requested; annoying having it throw errors every other time.
 */

// Don't set xhr to window.XMLHttpRequest as it will bypass jasmine's
// ajax library
var Xhr = typeof window === 'undefined' ? require('xhr2') : null;

function parseLinkHeaders(linkHeader) {
  if (!linkHeader) return {};

  // Split parts by comma
  var parts = linkHeader.split(',');
  var links = {};

  // Parse each part into a named link
  parts.forEach(function (part) {
    var section = part.split(';');
    if (section.length !== 2) return;
    var url = section[0].replace(/<(.*)>/, '$1').trim();
    var name = section[1].replace(/rel='?(.*)'?/, '$1').trim();
    links[name] = url;
  });

  return links;
}

module.exports = function (request, callback) {
  var req = Xhr ? new Xhr() : new XMLHttpRequest();
  var method = (request.method || 'GET').toUpperCase();

  var onload = function onload() {
    var headers = {
      'content-type': this.getResponseHeader('content-type')
    };

    var result = {
      status: this.status,
      success: this.status && this.status < 300,
      xhr: this
    };
    var isJSON = String(headers['content-type']).split(/;/)[0].match(/^application\/json/) || request.format === 'json';

    if (this.responseType === 'blob' || this.responseType === 'arraybuffer') {
      // Damnit, this.response is a function if using jasmine test framework.
      result.data = typeof this.response === 'function' ? this.responseText : this.response;
    } else {
      if (isJSON && this.responseText) {
        try {
          result.data = JSON.parse(this.responseText);
        } catch (err) {
          result.data = {
            code: 999,
            message: 'Invalid JSON from server',
            response: this.responseText
          };
          result.status = 999;
        }
      } else {
        result.data = this.responseText;
      }

      module.exports.trigger({
        target: this,
        status: !this.responseText && !this.status ? 'connection:error' : 'connection:success'
      });

      if (!this.responseText && !this.status) {
        result.status = 408;
        result.data = {
          id: 'request_timeout',
          message: 'The server is not responding please try again in a few minutes',
          url: 'https://developer.layer.com/docs/websdk',
          code: 0,
          status: 408,
          httpStatus: 408
        };
      } else if (this.status === 404 && _typeof(result.data) !== 'object') {
        result.data = {
          id: 'operation_not_found',
          message: 'Endpoint ' + (request.method || 'GET') + ' ' + request.url + ' does not exist',
          status: this.status,
          httpStatus: 404,
          code: 106,
          url: 'https://developer.layer.com/docs/websdk'
        };
      } else if (typeof result.data === 'string' && this.status >= 400) {
        result.data = {
          id: 'unknown_error',
          message: result.data,
          status: this.status,
          httpStatus: this.status,
          code: 0,
          url: 'https://developer.layer.com/docs/websdk'
        };
      }
    }

    if (request.headers && (request.headers.accept || '').match(/application\/vnd.layer\+json/)) {
      var links = this.getResponseHeader('link');
      if (links) result.Links = parseLinkHeaders(links);
    }
    result.xhr = this;

    if (callback) callback(result);
  };

  req.onload = onload;

  // UNTESTED!!!
  req.onerror = req.ontimeout = onload;

  // Replace all headers in arbitrary case with all lower case
  // for easy matching.
  var headersList = Object.keys(request.headers || {});
  var headers = {};
  headersList.forEach(function (header) {
    if (header.toLowerCase() === 'content-type') {
      headers['content-type'] = request.headers[header];
    } else {
      headers[header.toLowerCase()] = request.headers[header];
    }
  });
  request.headers = headers;

  var data = '';
  if (request.data) {
    if (typeof Blob !== 'undefined' && request.data instanceof Blob) {
      data = request.data;
    } else if (request.headers && (String(request.headers['content-type']).match(/^application\/json/) || String(request.headers['content-type']) === 'application/vnd.layer-patch+json')) {
      data = typeof request.data === 'string' ? request.data : JSON.stringify(request.data);
    } else if (request.data && _typeof(request.data) === 'object') {
      Object.keys(request.data).forEach(function (name) {
        if (data) data += '&';
        data += name + '=' + request.data[name];
      });
    } else {
      data = request.data; // Some form of raw string/data
    }
  }
  if (data) {
    if (method === 'GET') {
      request.url += '?' + data;
    }
  }

  req.open(method, request.url, true);
  if (request.timeout) req.timeout = request.timeout;
  if (request.withCredentials) req.withCredentials = true;
  if (request.responseType) req.responseType = request.responseType;

  if (request.headers) {
    Object.keys(request.headers).forEach(function (headerName) {
      return req.setRequestHeader(headerName, request.headers[headerName]);
    });
  }

  try {
    if (method === 'GET') {
      req.send();
    } else {
      req.send(data);
    }
  } catch (e) {
    // do nothing
  }
};

var listeners = [];
module.exports.addConnectionListener = function (func) {
  return listeners.push(func);
};

module.exports.trigger = function (evt) {
  listeners.forEach(function (func) {
    func(evt);
  });
};

},{"xhr2":3}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleC1lczYuanMiLCJub2RlX21vZHVsZXMvYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUvYmFja2JvbmUtZXZlbnRzLXN0YW5kYWxvbmUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2xheWVyLXBhdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvcm5nLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvdXVpZC91dWlkLmpzIiwic3JjL2Fubm91bmNlbWVudC5qcyIsInNyYy9jbGllbnQtYXV0aGVudGljYXRvci5qcyIsInNyYy9jbGllbnQtcmVnaXN0cnkuanMiLCJzcmMvY2xpZW50LXV0aWxzLmpzIiwic3JjL2NsaWVudC5qcyIsInNyYy9jb25zdC5qcyIsInNyYy9jb250ZW50LmpzIiwic3JjL2NvbnZlcnNhdGlvbi5qcyIsInNyYy9kYi1tYW5hZ2VyLmpzIiwic3JjL2xheWVyLWVycm9yLmpzIiwic3JjL2xheWVyLWV2ZW50LmpzIiwic3JjL2xvZ2dlci5qcyIsInNyYy9tZXNzYWdlLXBhcnQuanMiLCJzcmMvbWVzc2FnZS5qcyIsInNyYy9vbmxpbmUtc3RhdGUtbWFuYWdlci5qcyIsInNyYy9xdWVyeS1idWlsZGVyLmpzIiwic3JjL3F1ZXJ5LmpzIiwic3JjL3Jvb3QuanMiLCJzcmMvc3luYy1ldmVudC5qcyIsInNyYy9zeW5jLW1hbmFnZXIuanMiLCJzcmMvc3luY2FibGUuanMiLCJzcmMvdHlwaW5nLWluZGljYXRvcnMvdHlwaW5nLWluZGljYXRvci1saXN0ZW5lci5qcyIsInNyYy90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctaW5kaWNhdG9ycy5qcyIsInNyYy90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctbGlzdGVuZXIuanMiLCJzcmMvdHlwaW5nLWluZGljYXRvcnMvdHlwaW5nLXB1Ymxpc2hlci5qcyIsInNyYy91c2VyLmpzIiwic3JjL3dlYnNvY2tldHMvY2hhbmdlLW1hbmFnZXIuanMiLCJzcmMvd2Vic29ja2V0cy9yZXF1ZXN0LW1hbmFnZXIuanMiLCJzcmMvd2Vic29ja2V0cy9zb2NrZXQtbWFuYWdlci5qcyIsInNyYy94aHIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLE9BQU8sT0FBUCxHQUFpQjtBQUNmLFFBQU0sUUFBUSxZQUFSLENBQU47QUFDQSxVQUFRLFFBQVEsY0FBUixDQUFSO0FBQ0EsdUJBQXFCLFFBQVEsNEJBQVIsQ0FBckI7QUFDQSxZQUFVLFFBQVEsZ0JBQVIsQ0FBVjtBQUNBLGdCQUFjLFFBQVEsb0JBQVIsQ0FBZDtBQUNBLFdBQVMsUUFBUSxlQUFSLENBQVQ7QUFDQSxnQkFBYyxRQUFRLG9CQUFSLENBQWQ7QUFDQSxlQUFhLFFBQVEsb0JBQVIsQ0FBYjtBQUNBLFNBQU8sUUFBUSxhQUFSLENBQVA7QUFDQSxnQkFBYyxRQUFRLHFCQUFSLENBQWQ7QUFDQSxPQUFLLFFBQVEsV0FBUixDQUFMO0FBQ0EsUUFBTSxRQUFRLFlBQVIsQ0FBTjtBQUNBLGNBQVksUUFBUSxtQkFBUixDQUFaO0FBQ0EsY0FBWSxRQUFRLG1CQUFSLENBQVo7QUFDQSxXQUFTLFFBQVEsZUFBUixDQUFUO0FBQ0EsZUFBYSxRQUFRLG9CQUFSLENBQWI7QUFDQSxhQUFXLFFBQVEsa0JBQVIsRUFBNEIsU0FBNUI7QUFDWCxnQkFBYyxRQUFRLGtCQUFSLEVBQTRCLFlBQTVCO0FBQ2Qsc0JBQW9CLFFBQVEsa0JBQVIsRUFBNEIsa0JBQTVCO0FBQ3BCLGNBQVk7QUFDVixtQkFBZSxRQUFRLGlDQUFSLENBQWY7QUFDQSxvQkFBZ0IsUUFBUSxrQ0FBUixDQUFoQjtBQUNBLG1CQUFlLFFBQVEsaUNBQVIsQ0FBZjtHQUhGO0FBS0Esc0JBQW9CLFFBQVEsNEJBQVIsQ0FBcEI7QUFDQSxhQUFXLFFBQVEsa0JBQVIsQ0FBWDtBQUNBLGFBQVcsUUFBUSxhQUFSLENBQVg7QUFDQSxRQUFNLFFBQVEsb0JBQVIsQ0FBTjtBQUNBLG9CQUFrQixRQUFRLDJDQUFSLENBQWxCO0NBN0JGO0FBK0JBLE9BQU8sT0FBUCxDQUFlLGdCQUFmLENBQWdDLGNBQWhDLEdBQWlELFFBQVEseUNBQVIsQ0FBakQ7QUFDQSxPQUFPLE9BQVAsQ0FBZSxnQkFBZixDQUFnQyxlQUFoQyxHQUFrRCxRQUFRLDBDQUFSLENBQWxEOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFxQixVQUFyQixFQUFpQyxRQUFRLE9BQVIsQ0FBZ0IsVUFBaEIsQ0FBakM7S0FBZCxDQUFyQyxDQURtQjtHQUFyQjs7QUFJQSxNQUFJO0FBQ0YsUUFBSSxXQUFXLEtBQVgsRUFBa0I7QUFDcEIsVUFBSSxJQUFKLEdBRG9CO0tBQXRCLE1BRU87QUFDTCxVQUFJLElBQUosQ0FBUyxJQUFULEVBREs7S0FGUDtHQURGLENBTUUsT0FBTyxDQUFQLEVBQVU7O0dBQVY7Q0EzSWE7O0FBZ0pqQixJQUFNLFlBQVksRUFBWjtBQUNOLE9BQU8sT0FBUCxDQUFlLHFCQUFmLEdBQXVDO1NBQVEsVUFBVSxJQUFWLENBQWUsSUFBZjtDQUFSOztBQUV2QyxPQUFPLE9BQVAsQ0FBZSxPQUFmLEdBQXlCLFVBQUMsR0FBRCxFQUFTO0FBQ2hDLFlBQVUsT0FBVixDQUFrQixnQkFBUTtBQUN4QixTQUFLLEdBQUwsRUFEd0I7R0FBUixDQUFsQixDQURnQztDQUFUIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBSb290OiByZXF1aXJlKCcuL3NyYy9yb290JyksXG4gIENsaWVudDogcmVxdWlyZSgnLi9zcmMvY2xpZW50JyksXG4gIENsaWVudEF1dGhlbnRpY2F0b3I6IHJlcXVpcmUoJy4vc3JjL2NsaWVudC1hdXRoZW50aWNhdG9yJyksXG4gIFN5bmNhYmxlOiByZXF1aXJlKCcuL3NyYy9zeW5jYWJsZScpLFxuICBDb252ZXJzYXRpb246IHJlcXVpcmUoJy4vc3JjL2NvbnZlcnNhdGlvbicpLFxuICBNZXNzYWdlOiByZXF1aXJlKCcuL3NyYy9tZXNzYWdlJyksXG4gIEFubm91bmNlbWVudDogcmVxdWlyZSgnLi9zcmMvYW5ub3VuY2VtZW50JyksXG4gIE1lc3NhZ2VQYXJ0OiByZXF1aXJlKCcuL3NyYy9tZXNzYWdlLXBhcnQnKSxcbiAgUXVlcnk6IHJlcXVpcmUoJy4vc3JjL3F1ZXJ5JyksXG4gIFF1ZXJ5QnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvcXVlcnktYnVpbGRlcicpLFxuICB4aHI6IHJlcXVpcmUoJy4vc3JjL3hocicpLFxuICBVc2VyOiByZXF1aXJlKCcuL3NyYy91c2VyJyksXG4gIExheWVyRXJyb3I6IHJlcXVpcmUoJy4vc3JjL2xheWVyLWVycm9yJyksXG4gIExheWVyRXZlbnQ6IHJlcXVpcmUoJy4vc3JjL2xheWVyLWV2ZW50JyksXG4gIENvbnRlbnQ6IHJlcXVpcmUoJy4vc3JjL2NvbnRlbnQnKSxcbiAgU3luY01hbmFnZXI6IHJlcXVpcmUoJy4vc3JjL3N5bmMtbWFuYWdlcicpLFxuICBTeW5jRXZlbnQ6IHJlcXVpcmUoJy4vc3JjL3N5bmMtZXZlbnQnKS5TeW5jRXZlbnQsXG4gIFhIUlN5bmNFdmVudDogcmVxdWlyZSgnLi9zcmMvc3luYy1ldmVudCcpLlhIUlN5bmNFdmVudCxcbiAgV2Vic29ja2V0U3luY0V2ZW50OiByZXF1aXJlKCcuL3NyYy9zeW5jLWV2ZW50JykuV2Vic29ja2V0U3luY0V2ZW50LFxuICBXZWJzb2NrZXRzOiB7XG4gICAgU29ja2V0TWFuYWdlcjogcmVxdWlyZSgnLi9zcmMvd2Vic29ja2V0cy9zb2NrZXQtbWFuYWdlcicpLFxuICAgIFJlcXVlc3RNYW5hZ2VyOiByZXF1aXJlKCcuL3NyYy93ZWJzb2NrZXRzL3JlcXVlc3QtbWFuYWdlcicpLFxuICAgIENoYW5nZU1hbmFnZXI6IHJlcXVpcmUoJy4vc3JjL3dlYnNvY2tldHMvY2hhbmdlLW1hbmFnZXInKSxcbiAgfSxcbiAgT25saW5lU3RhdGVNYW5hZ2VyOiByZXF1aXJlKCcuL3NyYy9vbmxpbmUtc3RhdGUtbWFuYWdlcicpLFxuICBEYk1hbmFnZXI6IHJlcXVpcmUoJy4vc3JjL2RiLW1hbmFnZXInKSxcbiAgQ29uc3RhbnRzOiByZXF1aXJlKCcuL3NyYy9jb25zdCcpLFxuICBVdGlsOiByZXF1aXJlKCcuL3NyYy9jbGllbnQtdXRpbHMnKSxcbiAgVHlwaW5nSW5kaWNhdG9yczogcmVxdWlyZSgnLi9zcmMvdHlwaW5nLWluZGljYXRvcnMvdHlwaW5nLWluZGljYXRvcnMnKSxcbn07XG5tb2R1bGUuZXhwb3J0cy5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ0xpc3RlbmVyID0gcmVxdWlyZSgnLi9zcmMvdHlwaW5nLWluZGljYXRvcnMvdHlwaW5nLWxpc3RlbmVyJyk7XG5tb2R1bGUuZXhwb3J0cy5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ1B1Ymxpc2hlciA9IHJlcXVpcmUoJy4vc3JjL3R5cGluZy1pbmRpY2F0b3JzL3R5cGluZy1wdWJsaXNoZXInKTtcbiIsIi8qKlxuICogU3RhbmRhbG9uZSBleHRyYWN0aW9uIG9mIEJhY2tib25lLkV2ZW50cywgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSByZXF1aXJlZC5cbiAqIERlZ3JhZGVzIG5pY2VseSB3aGVuIEJhY2tvbmUvdW5kZXJzY29yZSBhcmUgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCBkb2NzIHN1Z2dlc3QgdG8gdXNlIHVuZGVyc2NvcmUncyBgXy5leHRlbmQoKWAgbWV0aG9kIHRvIGFkZCBFdmVudHNcbiAqIHN1cHBvcnQgdG8gc29tZSBnaXZlbiBvYmplY3QuIEEgYG1peGluKClgIG1ldGhvZCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRXZlbnRzXG4gKiBwcm90b3R5cGUgdG8gYXZvaWQgdXNpbmcgdW5kZXJzY29yZSBmb3IgdGhhdCBzb2xlIHB1cnBvc2U6XG4gKlxuICogICAgIHZhciBteUV2ZW50RW1pdHRlciA9IEJhY2tib25lRXZlbnRzLm1peGluKHt9KTtcbiAqXG4gKiBPciBmb3IgYSBmdW5jdGlvbiBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDb25zdHJ1Y3Rvcigpe31cbiAqICAgICBNeUNvbnN0cnVjdG9yLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbigpe31cbiAqICAgICBCYWNrYm9uZUV2ZW50cy5taXhpbihNeUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gKlxuICogKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogKGMpIDIwMTMgTmljb2xhcyBQZXJyaWF1bHRcbiAqL1xuLyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICBpZENvdW50ZXIgPSAwO1xuXG4gIC8vIFJldHVybnMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIG1hdGNoaW5nIHRoZSBtaW5pbWFsIEFQSSBzdWJzZXQgcmVxdWlyZWRcbiAgLy8gYnkgQmFja2JvbmUuRXZlbnRzXG4gIGZ1bmN0aW9uIG1pbmlzY29yZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMoKSBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LFxuXG4gICAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICAgICAgfSxcblxuICAgICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgICB9LFxuXG4gICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfID0gbWluaXNjb3JlKCksIEV2ZW50cztcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBNaXhpbiB1dGlsaXR5XG4gIEV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ3RyaWdnZXInLCAnc3RvcExpc3RlbmluZycsICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgJ2xpc3RlblRvT25jZScsICdiaW5kJywgJ3VuYmluZCddO1xuICAgIF8uZWFjaChleHBvcnRzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIC8vIEV4cG9ydCBFdmVudHMgYXMgQmFja2JvbmVFdmVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY29udGV4dFxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBFdmVudHM7XG4gICAgfVxuICAgIGV4cG9ydHMuQmFja2JvbmVFdmVudHMgPSBFdmVudHM7XG4gIH1lbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgICYmIHR5cGVvZiBkZWZpbmUuYW1kID09IFwib2JqZWN0XCIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXZlbnRzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuQmFja2JvbmVFdmVudHMgPSBFdmVudHM7XG4gIH1cbn0pKHRoaXMpO1xuIixudWxsLCIvKipcbiAqIFRoZSBsYXllci5qcy5MYXllclBhdGNoUGFyc2VyIG1ldGhvZCB3aWxsIHBhcnNlXG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtIHtCb29sZWFufSAgIFtjYW1lbENhc2U9ZmFsc2VdICAgICAgICAgICAgIFNldCB0aGUgY2FtZWwgY2FzZWQgdmVyc2lvbiBvZiB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gICAgW3Byb3BlcnR5TmFtZU1hcF0gICAgICAgICAgICAgTWFwcyBwcm9wZXJ0eSBuYW1lcyBpbiB0aGUgb3BlcmF0aW9uIHRvIHByb3BlcnR5IG5hbWVzIGluIHRoZSBsb2NhbCBvYmplY3Qgc2NoZW1hXG4gKiBAcGFyYW0ge09iamVjdH0gICAgW2NoYW5nZUNhbGxiYWNrc10gICAgICAgICAgICAgQ2FsbGJhY2sgbWFkZSBhbnkgdGltZSBhbiBvYmplY3QgaXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9ICAgIFthYm9ydENhbGxiYWNrc10gICAgICAgICAgICAgIENhbGxiYWNrIG1hZGUgdG8gdmVyaWZ5IGEgY2hhbmdlIGlzIHBlcm1pdHRlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gIFtkb2VzT2JqZWN0TWF0Y2hJZENhbGxiYWNrXSAgIENhbGxiYWNrIHJldHVybnMgYm9vbGVhbiB0byBpbmRpY2F0ZSBpZiBhIGdpdmVuIG9iamVjdCBtYXRjaGVzIGFuIElELlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJldHVybnMgdHJ1ZSBpZiBhbGwgb3BlcmF0aW9ucyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiBzb21lIHJldHVybmVkIGVycm9yc1xuICovXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIG9wSGFuZGxlcnMgPSB7XG4gICAgJ3NldCc6IHNldFByb3AsXG4gICAgJ2RlbGV0ZSc6IGRlbGV0ZVByb3AsXG4gICAgJ2FkZCc6IGFkZFByb3AsXG4gICAgJ3JlbW92ZSc6IHJlbW92ZVByb3BcbiAgfTtcblxuICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgIHRoaXMuY2FtZWxDYXNlID0gb3B0aW9ucy5jYW1lbENhc2U7XG4gICAgdGhpcy5wcm9wZXJ0eU5hbWVNYXAgPSBvcHRpb25zLnByb3BlcnR5TmFtZU1hcDtcbiAgICB0aGlzLmNoYW5nZUNhbGxiYWNrcyA9IG9wdGlvbnMuY2hhbmdlQ2FsbGJhY2tzO1xuICAgIHRoaXMuYWJvcnRDYWxsYmFja3MgPSBvcHRpb25zLmFib3J0Q2FsbGJhY2tzO1xuICAgIHRoaXMuZ2V0T2JqZWN0Q2FsbGJhY2sgPSBvcHRpb25zLmdldE9iamVjdENhbGxiYWNrO1xuICAgIHRoaXMuZG9lc09iamVjdE1hdGNoSWRDYWxsYmFjayA9IG9wdGlvbnMuZG9lc09iamVjdE1hdGNoSWRDYWxsYmFjayB8fCBmdW5jdGlvbihpZCwgb2JqKSB7XG4gICAgICByZXR1cm4gb2JqLmlkID09IGlkO1xuICAgIH07XG4gICAgdGhpcy5yZXR1cm5JZHMgPSBvcHRpb25zLnJldHVybklkcztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuTGF5ZXJQYXRjaFBhcnNlciA9IFBhcnNlcjtcbiAgfVxuXG4gIFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgICBvcHRpb25zLm9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgdmFyIHByb3BlcnR5RGVmID0gZ2V0UHJvcGVydHlEZWYuYXBwbHkodGhpcywgW29wLnByb3BlcnR5LCBvcHRpb25zLCBjaGFuZ2VzLCBvcF0pXG4gICAgICBvcEhhbmRsZXJzW29wLm9wZXJhdGlvbl0uY2FsbCh0aGlzLFxuICAgICAgICBwcm9wZXJ0eURlZixcbiAgICAgICAgZ2V0VmFsdWUuYXBwbHkodGhpcywgW29wLCBvcHRpb25zXSksXG4gICAgICAgIG9wLCBvcHRpb25zLCBjaGFuZ2VzKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJlcG9ydENoYW5nZXMuYXBwbHkodGhpcywgW2NoYW5nZXMsIG9wdGlvbnMub2JqZWN0LCBvcHRpb25zLnR5cGVdKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXBvcnRDaGFuZ2VzKGNoYW5nZXMsIHVwZGF0ZU9iamVjdCwgb2JqZWN0VHlwZSkge1xuICAgIGlmICh0aGlzLmNoYW5nZUNhbGxiYWNrcyAmJiBvYmplY3RUeXBlICYmIHRoaXMuY2hhbmdlQ2FsbGJhY2tzW29iamVjdFR5cGVdKSB7XG4gICAgICBPYmplY3Qua2V5cyhjaGFuZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAodGhpcy5jaGFuZ2VDYWxsYmFja3Nbb2JqZWN0VHlwZV0uYWxsKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VDYWxsYmFja3Nbb2JqZWN0VHlwZV0uYWxsKHVwZGF0ZU9iamVjdCwgdXBkYXRlT2JqZWN0W2tleV0sIGNoYW5nZXNba2V5XS5iZWZvcmUsIGNoYW5nZXNba2V5XS5wYXRocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaGFuZ2VDYWxsYmFja3Nbb2JqZWN0VHlwZV1ba2V5XSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlQ2FsbGJhY2tzW29iamVjdFR5cGVdW2tleV0odXBkYXRlT2JqZWN0LCB1cGRhdGVPYmplY3Rba2V5XSwgY2hhbmdlc1trZXldLmJlZm9yZSwgY2hhbmdlc1trZXldLnBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UHJvcGVydHlEZWYocHJvcGVydHksIG9wdGlvbnMsIGNoYW5nZXMsIG9wZXJhdGlvbikge1xuICAgIHZhciBvYmogPSBvcHRpb25zLm9iamVjdDtcbiAgICB2YXIgdGVtcG9yYXJ5U2VwYXJhdG9yID0gU3RyaW5nLmZyb21DaGFyQ29kZSgxNDUpO1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZSgvXFxcXFxcLi9nLCB0ZW1wb3JhcnlTZXBhcmF0b3IpO1xuICAgIHByb3BlcnR5ID0gcHJvcGVydHkucmVwbGFjZSgvXFxcXCguKS9nLCAnJDEnKTtcbiAgICB2YXIgcGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgvXFwuLyk7XG5cbiAgICB2YXIgciA9IG5ldyBSZWdFeHAodGVtcG9yYXJ5U2VwYXJhdG9yLCAnZycpXG4gICAgcGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24ocGFydCkge1xuICAgICAgcmV0dXJuIHBhcnQucmVwbGFjZShyLCAnLicpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2FtZWxDYXNlKSB7XG4gICAgICBwYXJ0c1swXSA9IHBhcnRzWzBdLnJlcGxhY2UoL1stX10uL2csIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wZXJ0eU5hbWVNYXApIHtcbiAgICAgIHZhciB0eXBlRGVmID0gdGhpcy5wcm9wZXJ0eU5hbWVNYXBbb3B0aW9ucy50eXBlXTtcbiAgICAgIHBhcnRzWzBdID0gKHR5cGVEZWYgJiYgdHlwZURlZltwYXJ0c1swXV0pIHx8IHBhcnRzWzBdO1xuICAgIH1cblxuICAgIHRyYWNrQ2hhbmdlcy5hcHBseSh0aGlzLCBbe1xuICAgICAgYmFzZU5hbWU6IHBhcnRzWzBdLFxuICAgICAgZnVsbFBhdGg6IHByb3BlcnR5LFxuICAgICAgb2JqZWN0OiBvcHRpb25zLm9iamVjdCxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICBjaGFuZ2VzOiBjaGFuZ2VzLFxuICAgICAgb3BlcmF0aW9uOiBvcGVyYXRpb25cbiAgICB9XSk7XG5cbiAgICB2YXIgY3VyT2JqID0gb2JqO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgdmFyIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0IGluIGN1ck9iaikge1xuICAgICAgICBjdXJPYmogPSBjdXJPYmpbcGFydF07XG4gICAgICAgIGlmIChjdXJPYmogPT09IG51bGwgfHwgdHlwZW9mIGN1ck9iaiAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBhY2Nlc3MgcHJvcGVydHkgXFwnJyArIHByb3BlcnR5ICsgJ1xcJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyT2JqW3BhcnRdID0ge307XG4gICAgICAgIGN1ck9iaiA9IGN1ck9ialtwYXJ0XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50ZXI6IGN1ck9iaixcbiAgICAgIGxhc3ROYW1lOiBwYXJ0c1twYXJ0cy5sZW5ndGgtMV0sXG4gICAgICBiYXNlTmFtZTogcGFydHNbMF0sXG4gICAgICBmdWxsUGF0aDogcHJvcGVydHksXG4gICAgICBhYm9ydEhhbmRsZXI6IHRoaXMuYWJvcnRDYWxsYmFja3MgJiYgdGhpcy5hYm9ydENhbGxiYWNrc1tvcHRpb25zLnR5cGVdICYmICh0aGlzLmFib3J0Q2FsbGJhY2tzW29wdGlvbnMudHlwZV0uYWxsIHx8IHRoaXMuYWJvcnRDYWxsYmFja3Nbb3B0aW9ucy50eXBlXVtwYXJ0c1swXV0pXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbHVlKG9wLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wLmlkKSB7XG4gICAgICBpZiAoIXRoaXMuZ2V0T2JqZWN0Q2FsbGJhY2spIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGdldE9iamVjdENhbGxiYWNrIGluIGNvbnN0cnVjdG9yIHRvIHVzZSBpZHMnKTtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldE9iamVjdENhbGxiYWNrKG9wLmlkKTtcbiAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICBpZiAodGhpcy5yZXR1cm5JZHMpIHJldHVybiBvcC5pZDtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3AudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJhY2tDaGFuZ2VzKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY2hhbmdlc1tvcHRpb25zLmJhc2VOYW1lXSkge1xuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IG9wdGlvbnMub2JqZWN0W29wdGlvbnMuYmFzZU5hbWVdO1xuICAgICAgaWYgKCdpZCcgaW4gb3B0aW9ucy5vcGVyYXRpb24gJiYgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGluaXRpYWxWYWx1ZS5pZDtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2UgPSBvcHRpb25zLmNoYW5nZXNbb3B0aW9ucy5iYXNlTmFtZV0gPSB7cGF0aHM6IFtdfTtcbiAgICAgIGNoYW5nZS5iZWZvcmUgPSAoaW5pdGlhbFZhbHVlICYmIHR5cGVvZiBpbml0aWFsVmFsdWUgPT09ICdvYmplY3QnKSA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5pdGlhbFZhbHVlKSkgOiBpbml0aWFsVmFsdWU7XG4gICAgfVxuICAgIHZhciBwYXRocyA9IG9wdGlvbnMuY2hhbmdlc1tvcHRpb25zLmJhc2VOYW1lXS5wYXRocztcbiAgICBpZiAocGF0aHMuaW5kZXhPZihvcHRpb25zLmZ1bGxQYXRoKSA9PT0gLTEpIHtcbiAgICAgIHBhdGhzLnB1c2gob3B0aW9ucy5mdWxsUGF0aCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJvcChwcm9wZXJ0eURlZiwgdmFsdWUsIG9wLCBvcHRpb25zLCBjaGFuZ2VzKSB7XG4gICAgaWYgKHByb3BlcnR5RGVmLmFib3J0SGFuZGxlcikge1xuICAgICAgaWYgKHByb3BlcnR5RGVmLmFib3J0SGFuZGxlcihwcm9wZXJ0eURlZi5mdWxsUGF0aCwgJ3NldCcsIHZhbHVlKSkgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9wZXJ0eURlZi5wb2ludGVyW3Byb3BlcnR5RGVmLmxhc3ROYW1lXSA9IHZhbHVlO1xuXG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVQcm9wKHByb3BlcnR5RGVmLCB2YWx1ZSwgb3AsIG9wdGlvbnMsIGNoYW5nZXMpIHtcbiAgICBpZiAocHJvcGVydHlEZWYuYWJvcnRIYW5kbGVyKSB7XG4gICAgICBpZiAocHJvcGVydHlEZWYuYWJvcnRIYW5kbGVyKHByb3BlcnR5RGVmLmZ1bGxQYXRoLCAnZGVsZXRlJywgdmFsdWUpKSByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9wZXJ0eURlZi5wb2ludGVyW3Byb3BlcnR5RGVmLmxhc3ROYW1lXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFByb3AocHJvcGVydHlEZWYsIHZhbHVlLCBvcCwgb3B0aW9ucywgY2hhbmdlcykge1xuICAgIGlmIChwcm9wZXJ0eURlZi5hYm9ydEhhbmRsZXIpIHtcbiAgICAgIGlmIChwcm9wZXJ0eURlZi5hYm9ydEhhbmRsZXIocHJvcGVydHlEZWYuZnVsbFBhdGgsICdhZGQnLCB2YWx1ZSkpIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9iajtcbiAgICBpZiAocHJvcGVydHlEZWYubGFzdE5hbWUgaW4gcHJvcGVydHlEZWYucG9pbnRlcikge1xuICAgICAgb2JqID0gcHJvcGVydHlEZWYucG9pbnRlcltwcm9wZXJ0eURlZi5sYXN0TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9iaiA9IHByb3BlcnR5RGVmLnBvaW50ZXJbcHJvcGVydHlEZWYubGFzdE5hbWVdID0gW107XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBhZGQgb3BlcmF0aW9uIHJlcXVpcmVzIGFuIGFycmF5IG9yIG5ldyBzdHJ1Y3R1cmUgdG8gYWRkIHRvLicpO1xuICAgIGlmICghb3AuaWQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWRkIG9wZXJhdGlvbiB3aWxsIG5vdCBhZGQgYXJyYXlzIHRvIHNldHMuJyk7XG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgdGhyb3cgbmV3IEVycm9yKCdUaGUgYWRkIG9wZXJhdGlvbiB3aWxsIG5vdCBhZGQgb2JqZWN0cyB0byBzZXRzLicpO1xuICAgIH1cbiAgICBpZiAob2JqLmluZGV4T2YodmFsdWUpID09PSAtMSkgb2JqLnB1c2godmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUHJvcChwcm9wZXJ0eURlZiwgdmFsdWUsIG9wLCBvcHRpb25zLCBjaGFuZ2VzKSB7XG4gICAgaWYgKHByb3BlcnR5RGVmLmFib3J0SGFuZGxlcikge1xuICAgICAgaWYgKHByb3BlcnR5RGVmLmFib3J0SGFuZGxlcihwcm9wZXJ0eURlZi5mdWxsUGF0aCwgJ3JlbW92ZScsIHZhbHVlKSkgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgb2JqO1xuICAgIGlmIChwcm9wZXJ0eURlZi5sYXN0TmFtZSBpbiBwcm9wZXJ0eURlZi5wb2ludGVyKSB7XG4gICAgICBvYmogPSBwcm9wZXJ0eURlZi5wb2ludGVyW3Byb3BlcnR5RGVmLmxhc3ROYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0gcHJvcGVydHlEZWYucG9pbnRlcltwcm9wZXJ0eURlZi5sYXN0TmFtZV0gPSBbXTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHRocm93IG5ldyBFcnJvcignVGhlIHJlbW92ZSBvcGVyYXRpb24gcmVxdWlyZXMgYW4gYXJyYXkgb3IgbmV3IHN0cnVjdHVyZSB0byByZW1vdmUgZnJvbS4nKTtcblxuICAgIGlmICghb3AuaWQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVtb3ZlIG9wZXJhdGlvbiB3aWxsIG5vdCByZW1vdmUgYXJyYXlzIGZyb20gc2V0cy4nKTtcbiAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZW1vdmUgb3BlcmF0aW9uIHdpbGwgbm90IHJlbW92ZSBvYmplY3RzIGZyb20gc2V0cy4nKTtcblxuICAgICAgdmFyIGluZGV4ID0gb2JqLmluZGV4T2YodmFsdWUpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkgb2JqLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmRvZXNPYmplY3RNYXRjaElkQ2FsbGJhY2sob3AuaWQsIG9ialtpXSkpIHtcbiAgICAgICAgICBvYmouc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSgpO1xuIiwiXG52YXIgcm5nO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAvLyBNb2RlcmF0ZWx5IGZhc3QsIGhpZ2ggcXVhbGl0eVxuICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICBybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kczgpO1xuICAgIHJldHVybiBfcm5kczg7XG4gIH07XG59XG5cbmlmICghcm5nKSB7XG4gIC8vIE1hdGgucmFuZG9tKCktYmFzZWQgKFJORylcbiAgLy9cbiAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHVzZSBNYXRoLnJhbmRvbSgpLiAgSXQncyBmYXN0LCBidXQgaXMgb2YgdW5zcGVjaWZpZWRcbiAgLy8gcXVhbGl0eS5cbiAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gIHJuZyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICB9XG5cbiAgICByZXR1cm4gX3JuZHM7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcm5nO1xuXG4iLCIvLyAgICAgdXVpZC5qc1xuLy9cbi8vICAgICBDb3B5cmlnaHQgKGMpIDIwMTAtMjAxMiBSb2JlcnQgS2llZmZlclxuLy8gICAgIE1JVCBMaWNlbnNlIC0gaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXG4vLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuLy8gZGV0ZWN0IHRvIGRldGVybWluZSB0aGUgYmVzdCBSTkcgc291cmNlLCBub3JtYWxpemluZyB0byBhIGZ1bmN0aW9uIHRoYXRcbi8vIHJldHVybnMgMTI4LWJpdHMgb2YgcmFuZG9tbmVzcywgc2luY2UgdGhhdCdzIHdoYXQncyB1c3VhbGx5IHJlcXVpcmVkXG52YXIgX3JuZyA9IHJlcXVpcmUoJy4vcm5nJyk7XG5cbi8vIE1hcHMgZm9yIG51bWJlciA8LT4gaGV4IHN0cmluZyBjb252ZXJzaW9uXG52YXIgX2J5dGVUb0hleCA9IFtdO1xudmFyIF9oZXhUb0J5dGUgPSB7fTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gIF9oZXhUb0J5dGVbX2J5dGVUb0hleFtpXV0gPSBpO1xufVxuXG4vLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbmZ1bmN0aW9uIHBhcnNlKHMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gKGJ1ZiAmJiBvZmZzZXQpIHx8IDAsIGlpID0gMDtcblxuICBidWYgPSBidWYgfHwgW107XG4gIHMudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bMC05YS1mXXsyfS9nLCBmdW5jdGlvbihvY3QpIHtcbiAgICBpZiAoaWkgPCAxNikgeyAvLyBEb24ndCBvdmVyZmxvdyFcbiAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgfVxuICB9KTtcblxuICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICB3aGlsZSAoaWkgPCAxNikge1xuICAgIGJ1ZltpICsgaWkrK10gPSAwO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG5mdW5jdGlvbiB1bnBhcnNlKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDAsIGJ0aCA9IF9ieXRlVG9IZXg7XG4gIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArICctJyArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dICsgJy0nICtcbiAgICAgICAgICBidGhbYnVmW2krK11dICsgYnRoW2J1ZltpKytdXSArXG4gICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgIGJ0aFtidWZbaSsrXV0gKyBidGhbYnVmW2krK11dO1xufVxuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbi8vIHJhbmRvbSAjJ3Mgd2UgbmVlZCB0byBpbml0IG5vZGUgYW5kIGNsb2Nrc2VxXG52YXIgX3NlZWRCeXRlcyA9IF9ybmcoKTtcblxuLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG52YXIgX25vZGVJZCA9IFtcbiAgX3NlZWRCeXRlc1swXSB8IDB4MDEsXG4gIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbl07XG5cbi8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG52YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4vLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcbnZhciBfbGFzdE1TZWNzID0gMCwgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgbisrKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IHVucGFyc2UoYik7XG59XG5cbi8vICoqYHY0KClgIC0gR2VuZXJhdGUgcmFuZG9tIFVVSUQqKlxuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWQgZm9yIEFQSSBkZXRhaWxzXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAvLyBEZXByZWNhdGVkIC0gJ2Zvcm1hdCcgYXJndW1lbnQsIGFzIHN1cHBvcnRlZCBpbiB2MS4yXG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09ICdiaW5hcnknID8gbmV3IEFycmF5KDE2KSA6IG51bGw7XG4gICAgb3B0aW9ucyA9IG51bGw7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgX3JuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyBpaSsrKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbn1cblxuLy8gRXhwb3J0IHB1YmxpYyBBUElcbnZhciB1dWlkID0gdjQ7XG51dWlkLnYxID0gdjE7XG51dWlkLnY0ID0gdjQ7XG51dWlkLnBhcnNlID0gcGFyc2U7XG51dWlkLnVucGFyc2UgPSB1bnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4iLCJjb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi9tZXNzYWdlJyk7XG5jb25zdCBTeW5jYWJsZSA9IHJlcXVpcmUoJy4vc3luY2FibGUnKTtcbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcblxuXG5jbGFzcyBBbm5vdW5jZW1lbnQgZXh0ZW5kcyBNZXNzYWdlIHtcbiAgc2VuZCgpIHt9XG4gIGdldENvbnZlcnNhdGlvbigpIHt9XG5cbiAgX2xvYWRlZChkYXRhKSB7XG4gICAgdGhpcy5nZXRDbGllbnQoKS5fYWRkTWVzc2FnZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXIncyByZXByZXNlbnRhdGlvbiBvZiBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIFNpbWlsYXIgdG8gX3BvcHVsYXRlRnJvbVNlcnZlciwgaG93ZXZlciwgdGhpcyBtZXRob2QgdGFrZXMgYVxuICAgKiBtZXNzYWdlIGRlc2NyaXB0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG1lc3NhZ2UgaW5zdGFuY2UgdXNpbmcgX3BvcHVsYXRlRnJvbVNlcnZlclxuICAgKiB0byBzZXR1cCB0aGUgdmFsdWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVGcm9tU2VydmVyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1lc3NhZ2UgLSBTZXJ2ZXIncyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKiBAcGFyYW0gIHtsYXllci5Db252ZXJzYXRpb259IGNvbnZlcnNhdGlvbiAtIENvbnZlcnNhdGlvbiBmb3IgdGhlIG1lc3NhZ2VcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIHN0YXRpYyBfY3JlYXRlRnJvbVNlcnZlcihtZXNzYWdlLCBjbGllbnQpIHtcbiAgICBjb25zdCBmcm9tV2Vic29ja2V0ID0gbWVzc2FnZS5mcm9tV2Vic29ja2V0O1xuICAgIHJldHVybiBuZXcgQW5ub3VuY2VtZW50KHtcbiAgICAgIGZyb21TZXJ2ZXI6IG1lc3NhZ2UsXG4gICAgICBjbGllbnRJZDogY2xpZW50LmFwcElkLFxuICAgICAgX25vdGlmeTogZnJvbVdlYnNvY2tldCAmJiBtZXNzYWdlLmlzX3VucmVhZCxcbiAgICB9KTtcbiAgfVxufVxuXG5Bbm5vdW5jZW1lbnQucHJlZml4VVVJRCA9ICdsYXllcjovLy9hbm5vdW5jZW1lbnRzLyc7XG5cbkFubm91bmNlbWVudC5pbk9iamVjdElnbm9yZSA9IE1lc3NhZ2UuaW5PYmplY3RJZ25vcmU7XG5cbkFubm91bmNlbWVudC5idWJibGVFdmVudFBhcmVudCA9ICdnZXRDbGllbnQnO1xuXG5Bbm5vdW5jZW1lbnQuX3N1cHBvcnRlZEV2ZW50cyA9IFtdLmNvbmNhdChNZXNzYWdlLl9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShBbm5vdW5jZW1lbnQsIFtBbm5vdW5jZW1lbnQsICdBbm5vdW5jZW1lbnQnXSk7XG5TeW5jYWJsZS5zdWJjbGFzc2VzLnB1c2goQW5ub3VuY2VtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gQW5ub3VuY2VtZW50O1xuIiwiLyoqXG4gKiBMYXllciBDbGllbnQuICBBY2Nlc3MgdGhlIGxheWVyIGJ5IGNhbGxpbmcgY3JlYXRlIGFuZCByZWNlaXZpbmcgaXRcbiAqIGZyb20gdGhlIFwicmVhZHlcIiBjYWxsYmFjay5cblxuICB2YXIgY2xpZW50ID0gbmV3IGxheWVyLkNsaWVudCh7XG4gICAgYXBwSWQ6IFwibGF5ZXI6Ly8vYXBwcy9zdGFnaW5nL2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZlwiLFxuICAgIGlzVHJ1c3RlZERldmljZTogZmFsc2UsXG4gICAgY2hhbGxlbmdlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIG15QXV0aGVudGljYXRvcih7XG4gICAgICAgIG5vbmNlOiBldnQubm9uY2UsXG4gICAgICAgIG9uU3VjY2VzczogZXZ0LmNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlYWR5OiBmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgIGFsZXJ0KFwiWWF5LCBJIGZpbmFsbHkgZ290IG15IGNsaWVudCFcIik7XG4gICAgfVxuICB9KS5jb25uZWN0KFwic2FtcGxldXNlcklkXCIpO1xuXG4gKiBUaGUgTGF5ZXIgQ2xpZW50L0NsaWVudEF1dGhlbnRpY2F0b3IgY2xhc3NlcyBoYXZlIGJlZW4gZGl2aWRlZCBpbnRvOlxuICpcbiAqIDEuIENsaWVudEF1dGhlbnRpY2F0b3I6IE1hbmFnZXMgYWxsIGF1dGhlbnRpY2F0aW9uIGFuZCBjb25uZWN0aXZpdHkgcmVsYXRlZCBpc3N1ZXNcbiAqIDIuIENsaWVudDogTWFuYWdlcyBhY2Nlc3MgdG8gQ29udmVyc2F0aW9ucywgUXVlcmllcywgTWVzc2FnZXMsIEV2ZW50cywgZXRjLi4uXG4gKlxuICogQGNsYXNzIGxheWVyLkNsaWVudEF1dGhlbnRpY2F0b3JcbiAqIEBwcml2YXRlXG4gKiBAZXh0ZW5kcyBsYXllci5Sb290XG4gKiBAYXV0aG9yIE1pY2hhZWwgS2FudG9yXG4gKlxuICovXG5cbmNvbnN0IHhociA9IHJlcXVpcmUoJy4veGhyJyk7XG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCBTb2NrZXRNYW5hZ2VyID0gcmVxdWlyZSgnLi93ZWJzb2NrZXRzL3NvY2tldC1tYW5hZ2VyJyk7XG5jb25zdCBXZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyID0gcmVxdWlyZSgnLi93ZWJzb2NrZXRzL2NoYW5nZS1tYW5hZ2VyJyk7XG5jb25zdCBXZWJzb2NrZXRSZXF1ZXN0TWFuYWdlciA9IHJlcXVpcmUoJy4vd2Vic29ja2V0cy9yZXF1ZXN0LW1hbmFnZXInKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuL2xheWVyLWVycm9yJyk7XG5jb25zdCBPbmxpbmVNYW5hZ2VyID0gcmVxdWlyZSgnLi9vbmxpbmUtc3RhdGUtbWFuYWdlcicpO1xuY29uc3QgU3luY01hbmFnZXIgPSByZXF1aXJlKCcuL3N5bmMtbWFuYWdlcicpO1xuY29uc3QgRGJNYW5hZ2VyID0gcmVxdWlyZSgnLi9kYi1tYW5hZ2VyJyk7XG5jb25zdCB7IFhIUlN5bmNFdmVudCwgV2Vic29ja2V0U3luY0V2ZW50IH0gPSByZXF1aXJlKCcuL3N5bmMtZXZlbnQnKTtcbmNvbnN0IHsgQUNDRVBULCBMT0NBTFNUT1JBR0VfS0VZUyB9ID0gcmVxdWlyZSgnLi9jb25zdCcpO1xuY29uc3QgYXRvYiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gcmVxdWlyZSgnYXRvYicpIDogd2luZG93LmF0b2I7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG5jb25zdCBNQVhfWEhSX1JFVFJJRVMgPSAzO1xuXG5jbGFzcyBDbGllbnRBdXRoZW50aWNhdG9yIGV4dGVuZHMgUm9vdCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBDbGllbnQuXG4gICAqXG4gICAqIFRoZSBhcHBJZCBpcyB0aGUgb25seSByZXF1aXJlZCBwYXJhbWV0ZXI6XG4gICAqXG4gICAqICAgICAgdmFyIGNsaWVudCA9IG5ldyBDbGllbnQoe1xuICAgKiAgICAgICAgICBhcHBJZDogXCJsYXllcjovLy9hcHBzL3N0YWdpbmcvdXVpZFwiXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEZvciB0cnVzdGVkIGRldmljZXMsIHlvdSBjYW4gZW5hYmxlIHN0b3JhZ2Ugb2YgZGF0YSB0byBpbmRleGVkREIgYW5kIGxvY2FsU3RvcmFnZSB3aXRoIHRoZSBgaXNUcnVzdGVkRGV2aWNlYCBwcm9wZXJ0eTpcbiAgICpcbiAgICogICAgICB2YXIgY2xpZW50ID0gbmV3IENsaWVudCh7XG4gICAqICAgICAgICAgIGFwcElkOiBcImxheWVyOi8vL2FwcHMvc3RhZ2luZy91dWlkXCIsXG4gICAqICAgICAgICAgIGlzVHJ1c3RlZERldmljZTogdHJ1ZVxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG9wdGlvbnMuYXBwSWQgICAgICAgICAgIC0gXCJsYXllcjovLy9hcHBzL3Byb2R1Y3Rpb24vdXVpZFwiOyBJZGVudGlmaWVzIHdoYXRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIHdlIGFyZSBjb25uZWN0aW5nIHRvLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHRpb25zLnVybD1odHRwczovL2FwaS5sYXllci5jb21dIC0gVVJMIHRvIGxvZyBpbnRvIGEgZGlmZmVyZW50IFJFU1Qgc2VydmVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb2dMZXZlbD1FUlJPUl0gLSBQcm92aWRlIGEgbG9nIGxldmVsIHRoYXQgaXMgb25lIG9mIGxheWVyLkNvbnN0YW50cy5MT0cuTk9ORSwgbGF5ZXIuQ29uc3RhbnRzLkxPRy5FUlJPUixcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLkNvbnN0YW50cy5MT0cuV0FSTiwgbGF5ZXIuQ29uc3RhbnRzLkxPRy5JTkZPLCBsYXllci5Db25zdGFudHMuTE9HLkRFQlVHXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNUcnVzdGVkRGV2aWNlPWZhbHNlXSAtIElmIHRoaXMgaXMgbm90IGEgdHJ1c3RlZCBkZXZpY2UsIG5vIGRhdGEgd2lsbCBiZSB3cml0dGVuIHRvIGluZGV4ZWREQiBub3IgbG9jYWxTdG9yYWdlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnYXJkbGVzcyBvZiBhbnkgdmFsdWVzIGluIGxheWVyLkNsaWVudC5wZXJzaXN0ZW5jZUZlYXR1cmVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucGVyc2lzdGVuY2VGZWF0dXJlcz1dIElmIGxheWVyLkNsaWVudC5pc1RydXN0ZWREZXZpY2UgaXMgdHJ1ZSwgdGhlbiB0aGlzIHNwZWNpZmllcyB3aGF0IHR5cGVzIG9mIGRhdGEgdG8gc3RvcmUuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXYW50IHRvIGluc3VyZSBjcmVkaXQgY2FyZCBkYXRhIGlzIG5vdCB3cml0dGVuPyBEaXNhYmxlIHdyaXRpbmcgb2YgTWVzc2FnZXMgdG8gaW5kZXhlZERCLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVmYXVsdCBpcyBmb3IgYWxsIGRhdGEgdG8gYmUgc3RvcmVkLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpZGVudGl0aWVzOiBXcml0ZSBpZGVudGl0aWVzIHRvIGluZGV4ZWREQj8gVGhpcyBhbGxvd3MgZm9yIGZhc3RlciBpbml0aWFsaXphdGlvbi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY29udmVyc2F0aW9uczogV3JpdGUgY29udmVyc2F0aW9ucyB0byBpbmRleGVkREI/IFRoaXMgYWxsb3dzIGZvciBmYXN0ZXIgcmVuZGVyaW5nXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIGEgQ29udmVyc2F0aW9uIExpc3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbWVzc2FnZXM6IFdyaXRlIG1lc3NhZ2VzIHRvIGluZGV4ZWREQj8gVGhpcyBhbGxvd3MgZm9yIGZ1bGwgb2ZmbGluZSBhY2Nlc3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3luY1F1ZXVlOiBXcml0ZSByZXF1ZXN0cyBtYWRlIHdoaWxlIG9mZmxpbmUgdG8gaW5kZXhlZERCPyAgVGhpcyBhbGxvd3MgdGhlIGFwcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGNvbXBsZXRlIHNlbmRpbmcgbWVzc2FnZXMgYWZ0ZXIgYmVpbmcgcmVsYXVuY2hlZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc2Vzc2lvblRva2VuOiBXcml0ZSB0aGUgc2Vzc2lvbiB0b2tlbiB0byBsb2NhbFN0b3JhZ2UgZm9yIHF1aWNrIHJlYXV0aGVudGljYXRpb24gb24gcmVsYXVuY2hpbmcgdGhlIGFwcC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgaWYgKCFvcHRpb25zLmFwcElkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmFwcElkTWlzc2luZyk7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzdWJjb21wb25lbnRzIG9mIHRoZSBDbGllbnRBdXRoZW50aWNhdG9yXG4gICAqXG4gICAqIEBtZXRob2QgX2luaXRDb21wb25lbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdENvbXBvbmVudHMoKSB7XG4gICAgLy8gU2V0dXAgdGhlIHdlYnNvY2tldCBtYW5hZ2VyOyB3b24ndCBjb25uZWN0IHVudGlsIHdlIHRyaWdnZXIgYW4gYXV0aGVudGljYXRlZCBldmVudFxuICAgIHRoaXMuc29ja2V0TWFuYWdlciA9IG5ldyBTb2NrZXRNYW5hZ2VyKHtcbiAgICAgIGNsaWVudDogdGhpcyxcbiAgICB9KTtcblxuICAgIHRoaXMuc29ja2V0Q2hhbmdlTWFuYWdlciA9IG5ldyBXZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyKHtcbiAgICAgIGNsaWVudDogdGhpcyxcbiAgICAgIHNvY2tldE1hbmFnZXI6IHRoaXMuc29ja2V0TWFuYWdlcixcbiAgICB9KTtcblxuICAgIHRoaXMuc29ja2V0UmVxdWVzdE1hbmFnZXIgPSBuZXcgV2Vic29ja2V0UmVxdWVzdE1hbmFnZXIoe1xuICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgc29ja2V0TWFuYWdlcjogdGhpcy5zb2NrZXRNYW5hZ2VyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5vbmxpbmVNYW5hZ2VyID0gbmV3IE9ubGluZU1hbmFnZXIoe1xuICAgICAgc29ja2V0TWFuYWdlcjogdGhpcy5zb2NrZXRNYW5hZ2VyLFxuICAgICAgdGVzdFVybDogdGhpcy51cmwgKyAnL25vbmNlcz9jb25uZWN0aW9uLXRlc3QnLFxuICAgICAgY29ubmVjdGVkOiB0aGlzLl9oYW5kbGVPbmxpbmVDaGFuZ2UuYmluZCh0aGlzKSxcbiAgICAgIGRpc2Nvbm5lY3RlZDogdGhpcy5faGFuZGxlT25saW5lQ2hhbmdlLmJpbmQodGhpcyksXG4gICAgfSk7XG5cbiAgICB0aGlzLnN5bmNNYW5hZ2VyID0gbmV3IFN5bmNNYW5hZ2VyKHtcbiAgICAgIG9ubGluZU1hbmFnZXI6IHRoaXMub25saW5lTWFuYWdlcixcbiAgICAgIHNvY2tldE1hbmFnZXI6IHRoaXMuc29ja2V0TWFuYWdlcixcbiAgICAgIHJlcXVlc3RNYW5hZ2VyOiB0aGlzLnNvY2tldFJlcXVlc3RNYW5hZ2VyLFxuICAgICAgY2xpZW50OiB0aGlzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3kgdGhlIHN1YmNvbXBvbmVudHMgb2YgdGhlIENsaWVudEF1dGhlbnRpY2F0b3JcbiAgICpcbiAgICogQG1ldGhvZCBfZGVzdHJveUNvbXBvbmVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZXN0cm95Q29tcG9uZW50cygpIHtcbiAgICB0aGlzLnN5bmNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLm9ubGluZU1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuc29ja2V0TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5zb2NrZXRDaGFuZ2VNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLnNvY2tldFJlcXVlc3RNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICBpZiAodGhpcy5kYk1hbmFnZXIpIHRoaXMuZGJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIElzIFBlcnNpc3RlZCBTZXNzaW9uIFRva2VucyBkaXNhYmxlZD9cbiAgICpcbiAgICogQG1ldGhvZCBfaXNQZXJzaXN0ZWRTZXNzaW9uc0Rpc2FibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lzUGVyc2lzdGVkU2Vzc2lvbnNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gIWdsb2JhbC5sb2NhbFN0b3JhZ2UgfHwgdGhpcy5wZXJzaXN0ZW5jZUZlYXR1cmVzICYmICF0aGlzLnBlcnNpc3RlbmNlRmVhdHVyZXMuc2Vzc2lvblRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3RvcmUgdGhlIHNlc3Npb25Ub2tlbiBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICpcbiAgICogVGhpcyBzZXRzIHRoZSBzZXNzaW9uVG9rZW4gcmF0aGVyIHRoYW4gcmV0dXJuaW5nIHRoZSB0b2tlbi5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVzdG9yZUxhc3RTZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzdG9yZUxhc3RTZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLl9pc1BlcnNpc3RlZFNlc3Npb25zRGlzYWJsZWQoKSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbTE9DQUxTVE9SQUdFX0tFWVMuU0VTU0lPTkRBVEEgKyB0aGlzLmFwcElkXTtcbiAgICAgIGlmICghc2Vzc2lvbkRhdGEpIHJldHVybjtcbiAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHNlc3Npb25EYXRhKTtcbiAgICAgIGlmIChwYXJzZWREYXRhLmV4cGlyZXMgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgIGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShMT0NBTFNUT1JBR0VfS0VZUy5TRVNTSU9OREFUQSArIHRoaXMuYXBwSWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSBwYXJzZWREYXRhLnNlc3Npb25Ub2tlbjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gTm8tb3BcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFzIHRoZSB1c2VySUQgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBsb2dpbj9cbiAgICpcbiAgICogQG1ldGhvZCBfaGFzVXNlcklkQ2hhbmdlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlcklkXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhc1VzZXJJZENoYW5nZWQodXNlcklkKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNlc3Npb25EYXRhID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtMT0NBTFNUT1JBR0VfS0VZUy5TRVNTSU9OREFUQSArIHRoaXMuYXBwSWRdO1xuICAgICAgaWYgKCFzZXNzaW9uRGF0YSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc2Vzc2lvbkRhdGEpLnVzZXJJZCAhPT0gdXNlcklkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGVzIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBDYWxsZWQgYnkgY29uc3RydWN0b3IoKS5cbiAgICpcbiAgICogV2lsbCBlaXRoZXIgYXR0ZW1wdCB0byB2YWxpZGF0ZSB0aGUgY2FjaGVkIHNlc3Npb25Ub2tlbiBieSBnZXR0aW5nIGNvbnZlcmF0aW9ucyxcbiAgICogb3IgaWYgbm8gc2Vzc2lvblRva2VuLCB3aWxsIGNhbGwgL25vbmNlcyB0byBzdGFydCBwcm9jZXNzIG9mIGdldHRpbmcgYSBuZXcgb25lLlxuICAgKlxuICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJZCAtIFVzZXIgSUQgb2YgdGhlIHVzZXIgeW91IGFyZSBsb2dnaW5nIGluIGFzXG4gICAqIEByZXR1cm5zIHtsYXllci5DbGllbnRBdXRoZW50aWNhdG9yfSB0aGlzXG4gICAqL1xuICBjb25uZWN0KHVzZXJJZCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuaXNUcnVzdGVkRGV2aWNlIHx8ICF1c2VySWQgfHwgdGhpcy5faXNQZXJzaXN0ZWRTZXNzaW9uc0Rpc2FibGVkKCkgfHwgdGhpcy5faGFzVXNlcklkQ2hhbmdlZCh1c2VySWQpKSB7XG4gICAgICB0aGlzLl9jbGVhclN0b3JlZERhdGEoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNUcnVzdGVkRGV2aWNlICYmIHVzZXJJZCkge1xuICAgICAgdGhpcy5fcmVzdG9yZUxhc3RTZXNzaW9uKHVzZXJJZCk7XG4gICAgfVxuICAgIHRoaXMudXNlcklkID0gdXNlcklkO1xuICAgIGlmICh0aGlzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5fc2Vzc2lvblRva2VuUmVzdG9yZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54aHIoe1xuICAgICAgICB1cmw6ICcvbm9uY2VzJyxcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIHN5bmM6IGZhbHNlLFxuICAgICAgfSwgKHJlc3VsdCkgPT4gdGhpcy5fY29ubmVjdGlvblJlc3BvbnNlKHJlc3VsdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgdGhlIGNvbm5lY3Rpb24gd2l0aCBhIHNlc3Npb24gdG9rZW4uXG4gICAqXG4gICAqIFRoaXMgY2FsbCBpcyBmb3IgdXNlIHdoZW4geW91IGhhdmUgcmVjZWl2ZWQgYSBTZXNzaW9uIFRva2VuIGZyb20gc29tZSBvdGhlciBzb3VyY2U7IHN1Y2ggYXMgeW91ciBzZXJ2ZXIsXG4gICAqIGFuZCB3aXNoIHRvIHVzZSB0aGF0IGluc3RlYWQgb2YgZG9pbmcgYSBmdWxsIGF1dGggcHJvY2Vzcy5cbiAgICpcbiAgICogVGhlIENsaWVudCB3aWxsIHByZXN1bWUgdGhlIHRva2VuIHRvIGJlIHZhbGlkLCBhbmQgd2lsbCBhc3luY2hyb25vdXNseSB0cmlnZ2VyIHRoZSBgcmVhZHlgIGV2ZW50LlxuICAgKiBJZiB0aGUgdG9rZW4gcHJvdmlkZWQgaXMgTk9UIHZhbGlkLCB0aGlzIHdvbid0IGJlIGRldGVjdGVkIHVudGlsIGEgcmVxdWVzdCBpcyBtYWRlIHVzaW5nIHRoaXMgdG9rZW4sXG4gICAqIGF0IHdoaWNoIHBvaW50IHRoZSBgY2hhbGxlbmdlYCBtZXRob2Qgd2lsbCB0cmlnZ2VyLlxuICAgKlxuICAgKiBOT1RFOiBUaGUgYGNvbm5lY3RlZGAgZXZlbnQgd2lsbCBub3QgYmUgdHJpZ2dlcmVkIG9uIHRoaXMgcGF0aC5cbiAgICpcbiAgICogQG1ldGhvZCBjb25uZWN0V2l0aFNlc3Npb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJJZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2Vzc2lvblRva2VuXG4gICAqIEByZXR1cm5zIHtsYXllci5DbGllbnRBdXRoZW50aWNhdG9yfSB0aGlzXG4gICAqL1xuICBjb25uZWN0V2l0aFNlc3Npb24odXNlcklkLCBzZXNzaW9uVG9rZW4pIHtcbiAgICBpZiAoIXVzZXJJZCB8fCAhc2Vzc2lvblRva2VuKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LnNlc3Npb25BbmRVc2VyUmVxdWlyZWQpO1xuICAgIGlmICghdGhpcy5pc1RydXN0ZWREZXZpY2UgfHwgdGhpcy5faXNQZXJzaXN0ZWRTZXNzaW9uc0Rpc2FibGVkKCkgfHwgdGhpcy5faGFzVXNlcklkQ2hhbmdlZCh1c2VySWQpKSB7XG4gICAgICB0aGlzLl9jbGVhclN0b3JlZERhdGEoKTtcbiAgICB9XG4gICAgdGhpcy5vbmxpbmVNYW5hZ2VyLnN0YXJ0KCk7XG5cbiAgICB0aGlzLnVzZXJJZCA9IHVzZXJJZDtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2F1dGhDb21wbGV0ZSh7IHNlc3Npb25fdG9rZW46IHNlc3Npb25Ub2tlbiB9KSwgMSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gb3VyIHJlcXVlc3QgZm9yIGEgbm9uY2UgZ2V0cyBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBJZiB0aGVyZSBpcyBhbiBlcnJvciwgY2FsbHMgX2Nvbm5lY3Rpb25FcnJvci5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgbm9uY2UsIGNhbGxzIF9jb25uZWN0aW9uQ29tcGxldGUuXG4gICAqXG4gICAqIEBtZXRob2QgX2Nvbm5lY3Rpb25SZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdFxuICAgKi9cbiAgX2Nvbm5lY3Rpb25SZXNwb25zZShyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uRXJyb3IocmVzdWx0LmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uQ29tcGxldGUocmVzdWx0LmRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBhcmUgbm93IGNvbm5lY3RlZCAod2UgaGF2ZSBhIG5vbmNlKS5cbiAgICpcbiAgICogSWYgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmV0cmlldmVkIGEgbm9uY2UsIHRoZW5cbiAgICogd2UgaGF2ZSBlbnRlcmVkIGEgXCJjb25uZWN0ZWRcIiBidXQgbm90IFwiYXV0aGVudGljYXRlZFwiIHN0YXRlLlxuICAgKiBTZXQgdGhlIHN0YXRlLCB0cmlnZ2VyIGFueSBldmVudHMsIGFuZCB0aGVuIHN0YXJ0IGF1dGhlbnRpY2F0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jb25uZWN0aW9uQ29tcGxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHRcbiAgICogQHBhcmFtICB7c3RyaW5nfSByZXN1bHQubm9uY2UgLSBUaGUgbm9uY2UgcHJvdmlkZWQgYnkgdGhlIHNlcnZlclxuICAgKlxuICAgKiBAZmlyZXMgY29ubmVjdGVkXG4gICAqL1xuICBfY29ubmVjdGlvbkNvbXBsZXRlKHJlc3VsdCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMudHJpZ2dlcignY29ubmVjdGVkJyk7XG4gICAgdGhpcy5fYXV0aGVudGljYXRlKHJlc3VsdC5ub25jZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gd2UgZmFpbCB0byBnZXQgYSBub25jZS5cbiAgICpcbiAgICogQG1ldGhvZCBfY29ubmVjdGlvbkVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLkxheWVyRXJyb3J9IGVyclxuICAgKlxuICAgKiBAZmlyZXMgY29ubmVjdGVkLWVycm9yXG4gICAqL1xuICBfY29ubmVjdGlvbkVycm9yKGVycm9yKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdjb25uZWN0ZWQtZXJyb3InLCB7IGVycm9yIH0pO1xuICB9XG5cblxuICAvKiBDT05ORUNUIE1FVEhPRFMgRU5EICovXG5cbiAgLyogQVVUSEVOVElDQVRFIE1FVEhPRFMgQkVHSU4gKi9cblxuICAvKipcbiAgICogU3RhcnQgdGhlIGF1dGhlbnRpY2F0aW9uIHN0ZXAuXG4gICAqXG4gICAqIFdlIHN0YXJ0IGF1dGhlbnRpY2F0aW9uIGJ5IHRyaWdnZXJpbmcgYSBcImNoYWxsZW5nZVwiIGV2ZW50IHRoYXRcbiAgICogdGVsbHMgdGhlIGFwcCB0byB1c2UgdGhlIG5vbmNlIHRvIG9idGFpbiBhbiBpZGVudGl0eV90b2tlbi5cbiAgICpcbiAgICogQG1ldGhvZCBfYXV0aGVudGljYXRlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbm9uY2UgLSBUaGUgbm9uY2UgdG8gcHJvdmlkZSB5b3VyIGlkZW50aXR5IHByb3ZpZGVyIHNlcnZpY2VcbiAgICpcbiAgICogQGZpcmVzIGNoYWxsZW5nZVxuICAgKi9cbiAgX2F1dGhlbnRpY2F0ZShub25jZSkge1xuICAgIGlmIChub25jZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFsbGVuZ2UnLCB7XG4gICAgICAgIG5vbmNlLFxuICAgICAgICBjYWxsYmFjazogdGhpcy5hbnN3ZXJBdXRoZW50aWNhdGlvbkNoYWxsZW5nZS5iaW5kKHRoaXMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBpZGVudGl0eVRva2VuIGFuZCB1c2UgaXQgdG8gY3JlYXRlIGEgc2Vzc2lvbi5cbiAgICpcbiAgICogVHlwaWNhbGx5LCB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgdXNpbmcgdGhlIGZ1bmN0aW9uIHBvaW50ZXIgcHJvdmlkZWQgYnlcbiAgICogdGhlIGNoYWxsZW5nZSBldmVudCwgYnV0IGl0IGNhbiBhbHNvIGJlIGNhbGxlZCBkaXJlY3RseS5cbiAgICpcbiAgICogICAgICBnZXRJZGVudGl0eVRva2VuKG5vbmNlLCBmdW5jdGlvbihpZGVudGl0eVRva2VuKSB7XG4gICAqICAgICAgICAgIGNsaWVudC5hbnN3ZXJBdXRoZW50aWNhdGlvbkNoYWxsZW5nZShpZGVudGl0eVRva2VuKTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBhbnN3ZXJBdXRoZW50aWNhdGlvbkNoYWxsZW5nZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkZW50aXR5VG9rZW4gLSBJZGVudGl0eSB0b2tlbiBwcm92aWRlZCBieSB5b3VyIGlkZW50aXR5IHByb3ZpZGVyIHNlcnZpY2VcbiAgICovXG4gIGFuc3dlckF1dGhlbnRpY2F0aW9uQ2hhbGxlbmdlKGlkZW50aXR5VG9rZW4pIHtcbiAgICAvLyBSZXBvcnQgYW4gZXJyb3IgaWYgbm8gaWRlbnRpdHlUb2tlbiBwcm92aWRlZFxuICAgIGlmICghaWRlbnRpdHlUb2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pZGVudGl0eVRva2VuTWlzc2luZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBVc2VySWQgYW5kIGdldCBhIHNlc3Npb25Ub2tlbjsgYnlwYXNzIHRoZSBfX2FkanVzdFVzZXJJZCBjb25uZWN0ZWQgdGVzdFxuICAgICAgdGhpcy51c2VySWQgPSBKU09OLnBhcnNlKGF0b2IoaWRlbnRpdHlUb2tlbi5zcGxpdCgnLicpWzFdKSkucHJuO1xuICAgICAgdGhpcy54aHIoe1xuICAgICAgICB1cmw6ICcvc2Vzc2lvbnMnLFxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgc3luYzogZmFsc2UsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGl0eV90b2tlbjogaWRlbnRpdHlUb2tlbixcbiAgICAgICAgICBhcHBfaWQ6IHRoaXMuYXBwSWQsXG4gICAgICAgIH0sXG4gICAgICB9LCAocmVzdWx0KSA9PiB0aGlzLl9hdXRoUmVzcG9uc2UocmVzdWx0LCBpZGVudGl0eVRva2VuKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIG91ciByZXF1ZXN0IGZvciBhIHNlc3Npb25Ub2tlbiByZWNlaXZlcyBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWV0aG9kIF9hdXRoUmVzcG9uc2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZGVudGl0eVRva2VuXG4gICAqL1xuICBfYXV0aFJlc3BvbnNlKHJlc3VsdCwgaWRlbnRpdHlUb2tlbikge1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX2F1dGhFcnJvcihyZXN1bHQuZGF0YSwgaWRlbnRpdHlUb2tlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dGhDb21wbGV0ZShyZXN1bHQuZGF0YSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQXV0aGVudGljYXRpb24gaXMgY29tcGxldGVkLCB1cGRhdGUgc3RhdGUgYW5kIHRyaWdnZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9hdXRoQ29tcGxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHRcbiAgICogQHBhcmFtICB7c3RyaW5nfSByZXN1bHQuc2Vzc2lvbl90b2tlbiAtIFNlc3Npb24gdG9rZW4gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqXG4gICAqIEBmaXJlcyBhdXRoZW50aWNhdGVkXG4gICAqL1xuICBfYXV0aENvbXBsZXRlKHJlc3VsdCkge1xuICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQuc2Vzc2lvbl90b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5zZXNzaW9uVG9rZW5NaXNzaW5nKTtcbiAgICB9XG4gICAgdGhpcy5zZXNzaW9uVG9rZW4gPSByZXN1bHQuc2Vzc2lvbl90b2tlbjtcblxuICAgIC8vIE5PVEU6IFdlIHN0b3JlIGJvdGggaXRlbXMgb2YgZGF0YSBpbiBhIHNpbmdsZSBrZXkgYmVjYXVzZSBzb21lb25lIGxpc3RlbmluZyBmb3Igc3RvcmFnZVxuICAgIC8vIGV2ZW50cyBpcyBsaXN0ZW5pbmcgZm9yIGFuIGFzeW5jaHJvbm91cyBjaGFuZ2UsIGFuZCB3ZSBuZWVkIHRvIGdhdXJlbnRlZSB0aGF0IGJvdGhcbiAgICAvLyB1c2VySWQgYW5kIHNlc3Npb24gYXJlIGF2YWlsYWJsZS5cbiAgICBpZiAoIXRoaXMuX2lzUGVyc2lzdGVkU2Vzc2lvbnNEaXNhYmxlZCgpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBnbG9iYWwubG9jYWxTdG9yYWdlW0xPQ0FMU1RPUkFHRV9LRVlTLlNFU1NJT05EQVRBICsgdGhpcy5hcHBJZF0gPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgc2Vzc2lvblRva2VuOiB0aGlzLnNlc3Npb25Ub2tlbiB8fCAnJyxcbiAgICAgICAgICB1c2VySWQ6IHRoaXMudXNlcklkIHx8ICcnLFxuICAgICAgICAgIGV4cGlyZXM6IERhdGUubm93KCkgKyAzMCAqIDYwICogNjAgKiAyNCxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzQXV0aGVudGljYXRlZCA9IHRydWU7XG4gICAgdGhpcy50cmlnZ2VyKCdhdXRoZW50aWNhdGVkJyk7XG4gICAgdGhpcy5fY2xpZW50UmVhZHkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGlvbiBoYXMgZmFpbGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9hdXRoRXJyb3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuTGF5ZXJFcnJvcn0gcmVzdWx0XG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWRlbnRpdHlUb2tlbiBOb3QgY3VycmVudGx5IHVzZWRcbiAgICpcbiAgICogQGZpcmVzIGF1dGhlbnRpY2F0ZWQtZXJyb3JcbiAgICovXG4gIF9hdXRoRXJyb3IoZXJyb3IsIGlkZW50aXR5VG9rZW4pIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2F1dGhlbnRpY2F0ZWQtZXJyb3InLCB7IGVycm9yIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgc3RhdGUgYW5kIHRyaWdnZXJzIGV2ZW50cyBmb3IgYm90aCBjb25uZWN0ZWQgYW5kIGF1dGhlbnRpY2F0ZWQuXG4gICAqXG4gICAqIElmIHJldXNpbmcgYSBzZXNzaW9uVG9rZW4gY2FjaGVkIGluIGxvY2FsU3RvcmFnZSxcbiAgICogdXNlIHRoaXMgbWV0aG9kIHJhdGhlciB0aGFuIF9hdXRoQ29tcGxldGUuXG4gICAqXG4gICAqIEBtZXRob2QgX3Nlc3Npb25Ub2tlblJlc3RvcmVkXG4gICAqIEBwcml2YXRlXG4gICAqXG4gICAqIEBmaXJlcyBjb25uZWN0ZWQsIGF1dGhlbnRpY2F0ZWRcbiAgICovXG4gIF9zZXNzaW9uVG9rZW5SZXN0b3JlZCgpIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyaWdnZXIoJ2Nvbm5lY3RlZCcpO1xuICAgIHRoaXMub25saW5lTWFuYWdlci5zdGFydCgpO1xuICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyaWdnZXIoJ2F1dGhlbnRpY2F0ZWQnKTtcbiAgICB0aGlzLl9jbGllbnRSZWFkeSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBmbGFnIHRoZSBjbGllbnQgYXMgcmVhZHkgZm9yIGFjdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGFmdGVyIGF1dGhlbmljYXRpb24gQU5EXG4gICAqIGFmdGVyIGluaXRpYWwgY29udmVyc2F0aW9ucyBoYXZlIGJlZW4gbG9hZGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jbGllbnRSZWFkeVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZmlyZXMgcmVhZHlcbiAgICovXG4gIF9jbGllbnRSZWFkeSgpIHtcbiAgICBpZiAoIXRoaXMucGVyc2lzdGVuY2VGZWF0dXJlcyB8fCAhdGhpcy5pc1RydXN0ZWREZXZpY2UpIHtcbiAgICAgIHRoaXMucGVyc2lzdGVuY2VGZWF0dXJlcyA9IHtcbiAgICAgICAgaWRlbnRpdHk6IHRoaXMuaXNUcnVzdGVkRGV2aWNlLFxuICAgICAgICBjb252ZXJzYXRpb25zOiB0aGlzLmlzVHJ1c3RlZERldmljZSxcbiAgICAgICAgbWVzc2FnZXM6IHRoaXMuaXNUcnVzdGVkRGV2aWNlLFxuICAgICAgICBzeW5jUXVldWU6IHRoaXMuaXNUcnVzdGVkRGV2aWNlLFxuICAgICAgICBzZXNzaW9uVG9rZW46IHRoaXMuaXNUcnVzdGVkRGV2aWNlLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRiTWFuYWdlcikge1xuICAgICAgdGhpcy5kYk1hbmFnZXIgPSBuZXcgRGJNYW5hZ2VyKHtcbiAgICAgICAgY2xpZW50OiB0aGlzLFxuICAgICAgICB0YWJsZXM6IHRoaXMucGVyc2lzdGVuY2VGZWF0dXJlcyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc1JlYWR5KSB7XG4gICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScpO1xuICAgICAgdGhpcy5vbmxpbmVNYW5hZ2VyLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cblxuICAvKiBDT05ORUNUIE1FVEhPRFMgRU5EICovXG5cblxuICAvKiBTVEFSVCBTRVNTSU9OIE1BTkFHRU1FTlQgTUVUSE9EUyAqL1xuXG4gIC8qKlxuICAgKiBEZWxldGVzIHlvdXIgc2Vzc2lvblRva2VuIGZyb20gdGhlIHNlcnZlciwgYW5kIHJlbW92ZXMgYWxsIHVzZXIgZGF0YSBmcm9tIHRoZSBDbGllbnQuXG4gICAqIENhbGwgYGNsaWVudC5sb2dpbigpYCB0byByZXN0YXJ0IHRoZSBhdXRoZW50aWNhdGlvbiBwcm9jZXNzLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvZ291dFxuICAgKiBAcmV0dXJuIHtsYXllci5DbGllbnRBdXRoZW50aWNhdG9yfSB0aGlzXG4gICAqL1xuICBsb2dvdXQoKSB7XG4gICAgaWYgKHRoaXMuaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICB0aGlzLnhocih7XG4gICAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgIHVybDogJy9zZXNzaW9ucy8nICsgZXNjYXBlKHRoaXMuc2Vzc2lvblRva2VuKSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIENsZWFyIGRhdGEgZXZlbiBpZiBpc0F1dGhlbnRpY2F0ZWQgaXMgZmFsc2VcbiAgICAvLyBTZXNzaW9uIG1heSBoYXZlIGV4cGlyZWQsIGJ1dCBkYXRhIHN0aWxsIGNhY2hlZC5cbiAgICB0aGlzLl9yZXNldFNlc3Npb24oKTtcbiAgICB0aGlzLl9jbGVhclN0b3JlZERhdGEoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9jbGVhclN0b3JlZERhdGEoKSB7XG4gICAgaWYgKHRoaXMuZGJNYW5hZ2VyKSB0aGlzLmRiTWFuYWdlci5kZWxldGVUYWJsZXMoKTtcbiAgICBpZiAoZ2xvYmFsLmxvY2FsU3RvcmFnZSkgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oTE9DQUxTVE9SQUdFX0tFWVMuU0VTU0lPTkRBVEEgKyB0aGlzLmFwcElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgb3V0L2NsZWFyIHNlc3Npb24gaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIFVzZSB0aGlzIHRvIGNsZWFyIHRoZSBzZXNzaW9uVG9rZW4gYW5kIGFsbCBpbmZvcm1hdGlvbiBmcm9tIHRoaXMgc2Vzc2lvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVzZXRTZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtsYXllci5DbGllbnRBdXRoZW50aWNhdG9yfSB0aGlzXG4gICAqL1xuICBfcmVzZXRTZXNzaW9uKCkge1xuICAgIHRoaXMuaXNSZWFkeSA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnNlc3Npb25Ub2tlbikge1xuICAgICAgdGhpcy5zZXNzaW9uVG9rZW4gPSAnJztcbiAgICAgIGlmIChnbG9iYWwubG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKExPQ0FMU1RPUkFHRV9LRVlTLlNFU1NJT05EQVRBICsgdGhpcy5hcHBJZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RlYXV0aGVudGljYXRlZCcpO1xuICAgIHRoaXMub25saW5lTWFuYWdlci5zdG9wKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB5b3VyIElPUyBkZXZpY2UgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zLlxuICAgKiBGb3IgdXNlIHdpdGggbmF0aXZlIGNvZGUgb25seSAoQ29yZG92YSwgUmVhY3QgTmF0aXZlLCBUaXRhbml1bSwgZXRjLi4uKVxuICAgKlxuICAgKiBAbWV0aG9kIHJlZ2lzdGVySU9TUHVzaFRva2VuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRldmljZUlkIC0gWW91ciBJT1MgZGV2aWNlJ3MgZGV2aWNlIElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmlvc1ZlcnNpb24gLSBZb3VyIElPUyBkZXZpY2UncyB2ZXJzaW9uIG51bWJlclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b2tlbiAtIFlvdXIgQXBwbGUgQVBOUyBUb2tlblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYnVuZGxlSWRdIC0gWW91ciBBcHBsZSBBUE5TIEJ1bmRsZSBJRCAoXCJjb20ubGF5ZXIuYnVuZGxlaWRcIilcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPW51bGxdIC0gT3B0aW9uYWwgY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBjYWxsYmFjay5lcnJvciAtIExheWVyRXJyb3IgaWYgdGhlcmUgd2FzIGFuIGVycm9yOyBudWxsIGlmIHN1Y2Nlc3NmdWxcbiAgICovXG4gIHJlZ2lzdGVySU9TUHVzaFRva2VuKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy54aHIoe1xuICAgICAgdXJsOiAncHVzaF90b2tlbnMnLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBzeW5jOiBmYWxzZSxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdG9rZW46IG9wdGlvbnMudG9rZW4sXG4gICAgICAgIHR5cGU6ICdhcG5zJyxcbiAgICAgICAgZGV2aWNlX2lkOiBvcHRpb25zLmRldmljZUlkLFxuICAgICAgICBpb3NfdmVyc2lvbjogb3B0aW9ucy5pb3NWZXJzaW9uLFxuICAgICAgICBhcG5zX2J1bmRsZV9pZDogb3B0aW9ucy5idW5kbGVJZCxcbiAgICAgIH0sXG4gICAgfSwgKHJlc3VsdCkgPT4gY2FsbGJhY2socmVzdWx0LmRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB5b3VyIEFuZHJvaWQgZGV2aWNlIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucy5cbiAgICogRm9yIHVzZSB3aXRoIG5hdGl2ZSBjb2RlIG9ubHkgKENvcmRvdmEsIFJlYWN0IE5hdGl2ZSwgVGl0YW5pdW0sIGV0Yy4uLilcbiAgICpcbiAgICogQG1ldGhvZCByZWdpc3RlckFuZHJvaWRQdXNoVG9rZW5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGV2aWNlSWQgLSBZb3VyIElPUyBkZXZpY2UncyBkZXZpY2UgSURcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG9rZW4gLSBZb3VyIEdDTSBwdXNoIFRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnNlbmRlcklkIC0gWW91ciBHQ00gU2VuZGVyIElEL1Byb2plY3QgTnVtYmVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1udWxsXSAtIE9wdGlvbmFsIGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gY2FsbGJhY2suZXJyb3IgLSBMYXllckVycm9yIGlmIHRoZXJlIHdhcyBhbiBlcnJvcjsgbnVsbCBpZiBzdWNjZXNzZnVsXG4gICAqL1xuICByZWdpc3RlckFuZHJvaWRQdXNoVG9rZW4ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB0aGlzLnhocih7XG4gICAgICB1cmw6ICdwdXNoX3Rva2VucycsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHN5bmM6IGZhbHNlLFxuICAgICAgZGF0YToge1xuICAgICAgICB0b2tlbjogb3B0aW9ucy50b2tlbixcbiAgICAgICAgdHlwZTogJ2djbScsXG4gICAgICAgIGRldmljZV9pZDogb3B0aW9ucy5kZXZpY2VJZCxcbiAgICAgICAgZ2NtX3NlbmRlcl9pZDogb3B0aW9ucy5zZW5kZXJJZCxcbiAgICAgIH0sXG4gICAgfSwgKHJlc3VsdCkgPT4gY2FsbGJhY2socmVzdWx0LmRhdGEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciB5b3VyIEFuZHJvaWQgZGV2aWNlIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucy5cbiAgICogRm9yIHVzZSB3aXRoIG5hdGl2ZSBjb2RlIG9ubHkgKENvcmRvdmEsIFJlYWN0IE5hdGl2ZSwgVGl0YW5pdW0sIGV0Yy4uLilcbiAgICpcbiAgICogQG1ldGhvZCB1bnJlZ2lzdGVyUHVzaFRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkZXZpY2VJZCAtIFlvdXIgSU9TIGRldmljZSdzIGRldmljZSBJRFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9bnVsbF0gLSBPcHRpb25hbCBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXJyb3J9IGNhbGxiYWNrLmVycm9yIC0gTGF5ZXJFcnJvciBpZiB0aGVyZSB3YXMgYW4gZXJyb3I7IG51bGwgaWYgc3VjY2Vzc2Z1bFxuICAgKi9cbiAgdW5yZWdpc3RlclB1c2hUb2tlbihkZXZpY2VJZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnhocih7XG4gICAgICB1cmw6ICdwdXNoX3Rva2Vucy8nICsgZGV2aWNlSWQsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0sIChyZXN1bHQpID0+IGNhbGxiYWNrKHJlc3VsdC5kYXRhKSk7XG4gIH1cblxuICAvKiBTRVNTSU9OIE1BTkFHRU1FTlQgTUVUSE9EUyBFTkQgKi9cblxuXG4gIC8qIEFDQ0VTU09SIE1FVEhPRFMgQkVHSU4gKi9cblxuICAvKipcbiAgICogX18gTWV0aG9kcyBhcmUgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgcHJvcGVydHkgc2V0dGVycy5cbiAgICpcbiAgICogQW55IGF0dGVtcHQgdG8gZXhlY3V0ZSBgdGhpcy51c2VyQXBwSWQgPSAneHh4J2Agd2lsbCBjYXVzZSBhbiBlcnJvciB0byBiZSB0aHJvd25cbiAgICogaWYgdGhlIGNsaWVudCBpcyBhbHJlYWR5IGNvbm5lY3RlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfX2FkanVzdEFwcElkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIE5ldyBhcHBJZCB2YWx1ZVxuICAgKi9cbiAgX19hZGp1c3RBcHBJZCgpIHtcbiAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jYW50Q2hhbmdlSWZDb25uZWN0ZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIF9fIE1ldGhvZHMgYXJlIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHByb3BlcnR5IHNldHRlcnMuXG4gICAqXG4gICAqIEFueSBhdHRlbXB0IHRvIGV4ZWN1dGUgYHRoaXMudXNlcklkID0gJ3h4eCdgIHdpbGwgY2F1c2UgYW4gZXJyb3IgdG8gYmUgdGhyb3duXG4gICAqIGlmIHRoZSBjbGllbnQgaXMgYWxyZWFkeSBjb25uZWN0ZWQuLi4gdW5sZXNzIHNldHRpbmcgaXQgZnJvbSBzY3JhdGNoLCBvciB0byB0aGUgc2FtZSB2YWx1ZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQG1ldGhvZCBfX2FkanVzdFVzZXJJZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBOZXcgYXBwSWQgdmFsdWVcbiAgICovXG4gIF9fYWRqdXN0VXNlcklkKHVzZXJJZCkge1xuICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkICYmIHRoaXMudXNlcklkICYmIHRoaXMudXNlcklkICE9PSB1c2VySWQgfHwgdGhpcy5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2FudENoYW5nZUlmQ29ubmVjdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKiBBQ0NFU1NPUiBNRVRIT0RTIEVORCAqL1xuXG5cbiAgLyogQ09NTVVOSUNBVElPTlMgTUVUSE9EUyBCRUdJTiAqL1xuICBzZW5kU29ja2V0UmVxdWVzdChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHBhcmFtcy5zeW5jKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBwYXJhbXMuc3luYy50YXJnZXQ7XG4gICAgICBsZXQgZGVwZW5kcyA9IHBhcmFtcy5zeW5jLmRlcGVuZHM7XG4gICAgICBpZiAodGFyZ2V0ICYmICFkZXBlbmRzKSBkZXBlbmRzID0gW3RhcmdldF07XG5cbiAgICAgIHRoaXMuc3luY01hbmFnZXIucmVxdWVzdChuZXcgV2Vic29ja2V0U3luY0V2ZW50KHtcbiAgICAgICAgZGF0YTogcGFyYW1zLmJvZHksXG4gICAgICAgIG9wZXJhdGlvbjogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBkZXBlbmRzLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMuZGF0YSA9PT0gJ2Z1bmN0aW9uJykgcGFyYW1zLmRhdGEgPSBwYXJhbXMuZGF0YSgpO1xuICAgICAgdGhpcy5zb2NrZXRSZXF1ZXN0TWFuYWdlci5zZW5kUmVxdWVzdChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBldmVudCBoYW5kbGVyIHJlY2VpdmVzIGV2ZW50cyBmcm9tIHRoZSBPbmxpbmUgU3RhdGUgTWFuYWdlciBhbmQgZ2VuZXJhdGVzIGFuIGV2ZW50IGZvciB0aG9zZSBzdWJzY3JpYmVkXG4gICAqIHRvIGNsaWVudC5vbignb25saW5lJylcbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlT25saW5lQ2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICBfaGFuZGxlT25saW5lQ2hhbmdlKGV2dCkge1xuICAgIGlmICghdGhpcy5pc0F1dGhlbnRpY2F0ZWQpIHJldHVybjtcbiAgICBjb25zdCBkdXJhdGlvbiA9IGV2dC5vZmZsaW5lRHVyYXRpb247XG4gICAgY29uc3QgaXNPbmxpbmUgPSBldnQuZXZlbnROYW1lID09PSAnY29ubmVjdGVkJztcbiAgICBjb25zdCBvYmogPSB7IGlzT25saW5lIH07XG4gICAgaWYgKGlzT25saW5lKSB7XG4gICAgICBvYmoucmVzZXQgPSBkdXJhdGlvbiA+IENsaWVudEF1dGhlbnRpY2F0b3IuUmVzZXRBZnRlck9mZmxpbmVEdXJhdGlvbjtcbiAgICB9XG4gICAgdGhpcy50cmlnZ2VyKCdvbmxpbmUnLCBvYmopO1xuICB9XG5cbiAgLyoqXG4gICAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHNlbmRpbmcgeGhyIHJlcXVlc3RzIG9yIGZvciBxdWVpbmcgdGhlbSBpbiB0aGUgc3luY01hbmFnZXIuXG4gICAqXG4gICAqIFRoaXMgY2FsbCBhZGp1c3QgYXJndW1lbnRzIGZvciBvdXIgUkVTVCBzZXJ2ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgeGhyXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIG9wdGlvbnNcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG9wdGlvbnMudXJsIC0gVVJMIHJlbGF0aXZlIGNsaWVudCdzIHVybDogXCIvY29udmVyc2F0aW9uc1wiXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgY2FsbGJhY2sucmVzdWx0XG4gICAqIEBwYXJhbSAge01peGVkfSAgICBjYWxsYmFjay5yZXN1bHQuZGF0YSAtIElmIGFuIGVycm9yIG9jY3VycmVkLCB0aGlzIGlzIGEgbGF5ZXIuTGF5ZXJFcnJvcjtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGUgcmVzcG9uc2Ugd2FzIGFwcGxpY2F0aW9uL2pzb24sIHRoaXMgd2lsbCBiZSBhbiBvYmplY3RcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0aGUgcmVzcG9uc2Ugd2FzIHRleHQvZW1wdHksIHRoaXMgd2lsbCBiZSB0ZXh0L2VtcHR5XG4gICAqIEBwYXJhbSAge1hNTEh0dHBSZXF1ZXN0fSBjYWxsYmFjay5yZXN1bHQueGhyIC0gTmF0aXZlIHhociByZXF1ZXN0IG9iamVjdCBmb3IgZGV0YWlsZWQgYW5hbHlzaXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgIGNhbGxiYWNrLnJlc3VsdC5MaW5rcyAtIEhhc2ggb2YgTGluayBoZWFkZXJzXG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudEF1dGhlbnRpY2F0b3J9IHRoaXNcbiAgICovXG4gIHhocihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0aW9ucy5zeW5jIHx8ICFvcHRpb25zLnN5bmMudGFyZ2V0KSB7XG4gICAgICBvcHRpb25zLnVybCA9IHRoaXMuX3hockZpeFJlbGF0aXZlVXJscyhvcHRpb25zLnVybCB8fCAnJyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIGlmICghb3B0aW9ucy5tZXRob2QpIG9wdGlvbnMubWV0aG9kID0gJ0dFVCc7XG4gICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIG9wdGlvbnMuaGVhZGVycyA9IHt9O1xuICAgIHRoaXMuX3hockZpeEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLl94aHJGaXhBdXRoKG9wdGlvbnMuaGVhZGVycyk7XG5cblxuICAgIC8vIE5vdGU6IHRoaXMgaXMgbm90IHN5bmMgdnMgYXN5bmM7IHRoaXMgaXMgc3luY01hbmFnZXIgdnMgZmlyZSBpdCBub3dcbiAgICBpZiAob3B0aW9ucy5zeW5jID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fbm9uc3luY1hocihvcHRpb25zLCBjYWxsYmFjaywgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N5bmNYaHIob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9zeW5jWGhyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRpb25zLnN5bmMpIG9wdGlvbnMuc3luYyA9IHt9O1xuICAgIGNvbnN0IGlubmVyQ2FsbGJhY2sgPSAocmVzdWx0KSA9PiB7XG4gICAgICB0aGlzLl94aHJSZXN1bHQocmVzdWx0LCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnN5bmMudGFyZ2V0O1xuICAgIGxldCBkZXBlbmRzID0gb3B0aW9ucy5zeW5jLmRlcGVuZHM7XG4gICAgaWYgKHRhcmdldCAmJiAhZGVwZW5kcykgZGVwZW5kcyA9IFt0YXJnZXRdO1xuXG4gICAgdGhpcy5zeW5jTWFuYWdlci5yZXF1ZXN0KG5ldyBYSFJTeW5jRXZlbnQoe1xuICAgICAgdXJsOiBvcHRpb25zLnVybCxcbiAgICAgIGRhdGE6IG9wdGlvbnMuZGF0YSxcbiAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICBvcGVyYXRpb246IG9wdGlvbnMuc3luYy5vcGVyYXRpb24gfHwgb3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICBjYWxsYmFjazogaW5uZXJDYWxsYmFjayxcbiAgICAgIHRhcmdldCxcbiAgICAgIGRlcGVuZHMsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciB4aHIgY2FsbHMgdGhhdCBkb24ndCBnbyB0aHJvdWdoIHRoZSBzeW5jIG1hbmFnZXIsXG4gICAqIGZpcmUgdGhlIHJlcXVlc3QsIGFuZCBpZiBpdCBmYWlscywgcmVmaXJlIGl0IHVwIHRvIDMgdHJpZXNcbiAgICogYmVmb3JlIHJlcG9ydGluZyBhbiBlcnJvci4gIDEgc2Vjb25kIGRlbGF5IGJldHdlZW4gcmVxdWVzdHNcbiAgICogc28gd2hhdGV2ZXIgaXNzdWUgaXMgb2NjdXJpbmcgaXMgYSB0aW55IGJpdCBtb3JlIGxpa2VseSB0byByZXNvbHZlLFxuICAgKiBhbmQgc28gd2UgZG9uJ3QgaGFtbWVyIHRoZSBzZXJ2ZXIgZXZlcnkgdGltZSB0aGVyZSdzIGEgcHJvYmxlbS5cbiAgICpcbiAgICogQG1ldGhvZCBfbm9uc3luY1hoclxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtICB7bnVtYmVyfSAgIHJldHJ5Q291bnRcbiAgICovXG4gIF9ub25zeW5jWGhyKG9wdGlvbnMsIGNhbGxiYWNrLCByZXRyeUNvdW50KSB7XG4gICAgeGhyKG9wdGlvbnMsIHJlc3VsdCA9PiB7XG4gICAgICBpZiAoWzUwMiwgNTAzLCA1MDRdLmluZGV4T2YocmVzdWx0LnN0YXR1cykgIT09IC0xICYmIHJldHJ5Q291bnQgPCBNQVhfWEhSX1JFVFJJRVMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9ub25zeW5jWGhyKG9wdGlvbnMsIGNhbGxiYWNrLCByZXRyeUNvdW50ICsgMSksIDEwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feGhyUmVzdWx0KHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpeCBhdXRoZW50aWNhdGlvbiBoZWFkZXIgZm9yIGFuIHhociByZXF1ZXN0XG4gICAqXG4gICAqIEBtZXRob2QgX3hockZpeEF1dGhcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBoZWFkZXJzXG4gICAqL1xuICBfeGhyRml4QXV0aChoZWFkZXJzKSB7XG4gICAgaWYgKHRoaXMuc2Vzc2lvblRva2VuICYmICFoZWFkZXJzLkF1dGhvcml6YXRpb24pIHtcbiAgICAgIGhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdMYXllciBzZXNzaW9uLXRva2VuPVwiJyArICB0aGlzLnNlc3Npb25Ub2tlbiArICdcIic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRml4IHJlbGF0aXZlIFVSTHMgdG8gY3JlYXRlIGFic29sdXRlIFVSTHMgbmVlZGVkIGZvciBDT1JTIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJGaXhSZWxhdGl2ZVVybHNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSByZWxhdGl2ZSBvciBhYnNvbHV0ZSB1cmxcbiAgICogQHJldHVybiB7c3RyaW5nfSBhYnNvbHV0ZSB1cmxcbiAgICovXG4gIF94aHJGaXhSZWxhdGl2ZVVybHModXJsKSB7XG4gICAgbGV0IHJlc3VsdCA9IHVybDtcbiAgICBpZiAodXJsLmluZGV4T2YoJ2h0dHBzOi8vJykgPT09IC0xKSB7XG4gICAgICBpZiAodXJsWzBdID09PSAnLycpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy51cmwgKyB1cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnVybCArICcvJyArIHVybDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXh1cCBhbGwgaGVhZGVycyBpbiBwcmVwYXJhdGlvbiBmb3IgYW4geGhyIGNhbGwuXG4gICAqXG4gICAqIDEuIEFsbCBoZWFkZXJzIHVzZSBsb3dlciBjYXNlIG5hbWVzIGZvciBzdGFuZGFyZC9lYXN5IGxvb2t1cFxuICAgKiAyLiBTZXQgdGhlIGFjY2VwdCBoZWFkZXJcbiAgICogMy4gSWYgbmVlZGVkLCBzZXQgdGhlIGNvbnRlbnQtdHlwZSBoZWFkZXJcbiAgICpcbiAgICogQG1ldGhvZCBfeGhyRml4SGVhZGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGhlYWRlcnNcbiAgICovXG4gIF94aHJGaXhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAvLyBSZXBsYWNlIGFsbCBoZWFkZXJzIGluIGFyYml0cmFyeSBjYXNlIHdpdGggYWxsIGxvd2VyIGNhc2VcbiAgICAvLyBmb3IgZWFzeSBtYXRjaGluZy5cbiAgICBjb25zdCBoZWFkZXJOYW1lTGlzdCA9IE9iamVjdC5rZXlzKGhlYWRlcnMpO1xuICAgIGhlYWRlck5hbWVMaXN0LmZvckVhY2goaGVhZGVyTmFtZSA9PiB7XG4gICAgICBpZiAoaGVhZGVyTmFtZSAhPT0gaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGhlYWRlcnNbaGVhZGVyTmFtZS50b0xvd2VyQ2FzZSgpXSA9IGhlYWRlcnNbaGVhZGVyTmFtZV07XG4gICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCFoZWFkZXJzLmFjY2VwdCkgaGVhZGVycy5hY2NlcHQgPSBBQ0NFUFQ7XG5cbiAgICBpZiAoIWhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIHJlc3VsdCBvZiBhbiB4aHIgY2FsbFxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJSZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIHJlc3VsdCAgICAgU3RhbmRhcmQgeGhyIHJlc3BvbnNlIG9iamVjdCBmcm9tIHRoZSB4aHIgbGliXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIENhbGxiYWNrIG9uIGNvbXBsZXRpb25cbiAgICovXG4gIF94aHJSZXN1bHQocmVzdWx0LCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAvLyBSZXBsYWNlIHRoZSByZXNwb25zZSB3aXRoIGEgTGF5ZXJFcnJvciBpbnN0YW5jZVxuICAgICAgaWYgKHJlc3VsdC5kYXRhICYmIHR5cGVvZiByZXN1bHQuZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVFcnJvcihyZXN1bHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdHMgYW4gYXV0aGVudGljYXRpb24gZXJyb3IsIHJlYXV0aGVudGljYXRlXG4gICAgICAvLyBkb24ndCBjYWxsIF9yZXNldFNlc3Npb24gYXMgdGhhdCB3aXBlcyBhbGwgZGF0YSBhbmQgc2NyZXdzIHdpdGggVUlzLCBhbmQgdGhlIHVzZXJcbiAgICAgIC8vIGlzIHN0aWxsIGF1dGhlbnRpY2F0ZWQgb24gdGhlIGN1c3RvbWVyJ3MgYXBwIGV2ZW4gaWYgbm90IG9uIExheWVyLlxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IDQwMSAmJiB0aGlzLmlzQXV0aGVudGljYXRlZCkge1xuICAgICAgICBsb2dnZXIud2FybignU0VTU0lPTiBFWFBJUkVEIScpO1xuICAgICAgICB0aGlzLmlzQXV0aGVudGljYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RlYXV0aGVudGljYXRlZCcpO1xuICAgICAgICB0aGlzLl9hdXRoZW50aWNhdGUocmVzdWx0LmRhdGEuZ2V0Tm9uY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2socmVzdWx0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHhociBlcnJvciByZXNwb25zZSBpbnRvIGEgbGF5ZXIuTGF5ZXJFcnJvciBpbnN0YW5jZS5cbiAgICpcbiAgICogQWRkcyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHRvIHRoZSByZXN1bHQgb2JqZWN0IGluY2x1ZGluZ1xuICAgKlxuICAgKiAqIHVybFxuICAgKiAqIGRhdGFcbiAgICpcbiAgICogQG1ldGhvZCBfZ2VuZXJhdGVFcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAtIFJlc3VsdCBvZiB0aGUgeGhyIGNhbGxcbiAgICovXG4gIF9nZW5lcmF0ZUVycm9yKHJlc3VsdCkge1xuICAgIHJlc3VsdC5kYXRhID0gbmV3IExheWVyRXJyb3IocmVzdWx0LmRhdGEpO1xuICAgIGlmICghcmVzdWx0LmRhdGEuaHR0cFN0YXR1cykgcmVzdWx0LmRhdGEuaHR0cFN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gICAgcmVzdWx0LmRhdGEubG9nKCk7XG4gIH1cblxuICAvKiBFTkQgQ09NTVVOSUNBVElPTlMgTUVUSE9EUyAqL1xuXG59XG5cbi8qKlxuICogU3RhdGUgdmFyaWFibGU7IGluZGljYXRlcyB0aGF0IGNsaWVudCBpcyBjdXJyZW50bHkgYXV0aGVudGljYXRlZCBieSB0aGUgc2VydmVyLlxuICogU2hvdWxkIG5ldmVyIGJlIHRydWUgaWYgaXNDb25uZWN0ZWQgaXMgZmFsc2UuXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUuaXNBdXRoZW50aWNhdGVkID0gZmFsc2U7XG5cbi8qKlxuICogU3RhdGUgdmFyaWFibGU7IGluZGljYXRlcyB0aGF0IGNsaWVudCBpcyBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHNlcnZlclxuICogKG1heSBub3QgYmUgYXV0aGVudGljYXRlZCB5ZXQpXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmYWxzZTtcblxuLyoqXG4gKiBTdGF0ZSB2YXJpYWJsZTsgaW5kaWNhdGVzIHRoYXQgY2xpZW50IGlzIHJlYWR5IGZvciB0aGUgYXBwIHRvIHVzZS5cbiAqIFVzZSB0aGUgJ3JlYWR5JyBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoaXMgdmFsdWUgY2hhbmdlcyB0byB0cnVlLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5DbGllbnRBdXRoZW50aWNhdG9yLnByb3RvdHlwZS5pc1JlYWR5ID0gZmFsc2U7XG5cbi8qKlxuICogWW91ciBMYXllciBBcHBsaWNhdGlvbiBJRC4gVGhpcyB2YWx1ZSBjYW4gbm90IGJlIGNoYW5nZWQgb25jZSBjb25uZWN0ZWQuXG4gKiBUbyBmaW5kIHlvdXIgTGF5ZXIgQXBwbGljYXRpb24gSUQsIHNlZSB5b3VyIExheWVyIERldmVsb3BlciBEYXNoYm9hcmQuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5DbGllbnRBdXRoZW50aWNhdG9yLnByb3RvdHlwZS5hcHBJZCA9ICcnO1xuXG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoaXMgdG8gZmluZCB0aGUgdXNlcklkIHlvdSBhcmUgbG9nZ2VkIGluIGFzLlxuICogWW91IGNhbiBzZXQgdGhpcyBpbiB0aGUgY29uc3RydWN0b3IgdG8gdmVyaWZ5IHRoYXQgdGhlIGNsaWVudFxuICogd2lsbCBvbmx5IHJlc3RvcmUgYSBzZXNzaW9uIGlmIHRoYXQgc2Vzc2lvbiBiZWxvbmdlZCB0byB0aGF0IHNhbWUgdXNlcklkLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUudXNlcklkID0gJyc7XG5cbi8qKlxuICogWW91ciBjdXJyZW50IHNlc3Npb24gdG9rZW4gdGhhdCBhdXRoZW50aWNhdGVzIHlvdXIgcmVxdWVzdHMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5DbGllbnRBdXRoZW50aWNhdG9yLnByb3RvdHlwZS5zZXNzaW9uVG9rZW4gPSAnJztcblxuLyoqXG4gKiBVUkwgdG8gTGF5ZXIncyBXZWIgQVBJIHNlcnZlci5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IucHJvdG90eXBlLnVybCA9ICdodHRwczovL2FwaS5sYXllci5jb20nO1xuXG4vKipcbiAqIFdlYiBTb2NrZXQgTWFuYWdlclxuICogQHR5cGUge2xheWVyLldlYnNvY2tldHMuU29ja2V0TWFuYWdlcn1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUuc29ja2V0TWFuYWdlciA9IG51bGw7XG5cbi8qKlxuICogV2ViIFNvY2tldCBSZXF1ZXN0IE1hbmFnZXJcbiogQHR5cGUge2xheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXJ9XG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IucHJvdG90eXBlLnNvY2tldFJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBXZWIgU29ja2V0IE1hbmFnZXJcbiAqIEB0eXBlIHtsYXllci5XZWJzb2NrZXRzLkNoYW5nZU1hbmFnZXJ9XG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IucHJvdG90eXBlLnNvY2tldENoYW5nZU1hbmFnZXIgPSBudWxsO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIG1hbmFnaW5nIG9ubGluZSBhcyB3ZWxsIGFzIG9mZmxpbmUgc2VydmVyIHJlcXVlc3RzXG4gKiBAdHlwZSB7bGF5ZXIuU3luY01hbmFnZXJ9XG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IucHJvdG90eXBlLnN5bmNNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBTZXJ2aWNlIGZvciBtYW5hZ2luZyBvbmxpbmUvb2ZmbGluZSBzdGF0ZSBhbmQgZXZlbnRzXG4gKiBAdHlwZSB7bGF5ZXIuT25saW5lU3RhdGVNYW5hZ2VyfVxuICovXG5DbGllbnRBdXRoZW50aWNhdG9yLnByb3RvdHlwZS5vbmxpbmVNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBJZiB0aGlzIGlzIGEgdHJ1c3RlZCBkZXZpY2UsIHRoZW4gd2UgY2FuIHdyaXRlIHBlcnNvbmFsIGRhdGEgdG8gcGVyc2lzdGVudCBtZW1vcnkuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUuaXNUcnVzdGVkRGV2aWNlID0gZmFsc2U7XG5cbi8qKlxuICogSWYgdGhpcyBsYXllci5DbGllbnQuaXNUcnVzdGVkRGV2aWNlIGlzIHRydWUsIHRoZW4geW91IGNhbiBjb250cm9sIHdoaWNoIHR5cGVzIG9mIGRhdGEgYXJlIHBlcnNpc3RlZC5cbiAqXG4gKiBQcm9wZXJ0aWVzIG9mIHRoaXMgT2JqZWN0IGNhbiBiZTpcbiAqXG4gKiAqIGlkZW50aXRpZXM6IFdyaXRlIGlkZW50aXRpZXMgdG8gaW5kZXhlZERCPyBUaGlzIGFsbG93cyBmb3IgZmFzdGVyIGluaXRpYWxpemF0aW9uLlxuICogKiBjb252ZXJzYXRpb25zOiBXcml0ZSBjb252ZXJzYXRpb25zIHRvIGluZGV4ZWREQj8gVGhpcyBhbGxvd3MgZm9yIGZhc3RlciByZW5kZXJpbmdcbiAqICAgICAgICAgICAgICAgICAgb2YgYSBDb252ZXJzYXRpb24gTGlzdFxuICogKiBtZXNzYWdlczogV3JpdGUgbWVzc2FnZXMgdG8gaW5kZXhlZERCPyBUaGlzIGFsbG93cyBmb3IgZnVsbCBvZmZsaW5lIGFjY2Vzc1xuICogKiBzeW5jUXVldWU6IFdyaXRlIHJlcXVlc3RzIG1hZGUgd2hpbGUgb2ZmbGluZSB0byBpbmRleGVkREI/ICBUaGlzIGFsbG93cyB0aGUgYXBwXG4gKiAgICAgICAgICAgICAgdG8gY29tcGxldGUgc2VuZGluZyBtZXNzYWdlcyBhZnRlciBiZWluZyByZWxhdW5jaGVkLlxuICogKiBzZXNzaW9uVG9rZW46IFdyaXRlIHRoZSBzZXNzaW9uIHRva2VuIHRvIGxvY2FsU3RvcmFnZSBmb3IgcXVpY2sgcmVhdXRoZW50aWNhdGlvbiBvbiByZWxhdW5jaGluZyB0aGUgYXBwLlxuICpcbiAqICAgICAgbmV3IGxheWVyLkNsaWVudCh7XG4gKiAgICAgICAgaXNUcnVzdGVkRGV2aWNlOiB0cnVlLFxuICogICAgICAgIHBlcnNpc3RlbmNlRmVhdHVyZXM6IHtcbiAqICAgICAgICAgIGNvbnZlcnNhdGlvbnM6IHRydWUsXG4gKiAgICAgICAgICBpZGVudGl0aWVzOiB0cnVlLFxuICogICAgICAgICAgbWVzc2FnZXM6IGZhbHNlLFxuICogICAgICAgICAgc3luY1F1ZXVlOiBmYWxzZSxcbiAqICAgICAgICAgIHNlc3Npb25Ub2tlbjogdHJ1ZVxuICogICAgICAgIH1cbiAqICAgICAgfSk7XG4gKlxuICogQHR5cGUge29iamVjdH1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUucGVyc2lzdGVuY2VGZWF0dXJlcyA9IG51bGw7XG5cbi8qKlxuICogRGF0YWJhc2UgTWFuYWdlciBmb3IgcmVhZC93cml0ZSB0byBJbmRleGVkREJcbiAqIEB0eXBlIHtsYXllci5EYk1hbmFnZXJ9XG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IucHJvdG90eXBlLmRiTWFuYWdlciA9IG51bGw7XG5cbi8qKlxuICogVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBjbGllbnQuXG4gKlxuICogVGhpcyBJRCBpcyB1c2VkIHRvIGRpZmZlcmVudGlhdGUgdGhpcyBpbnN0YW5jZSB3aXRoIGluc3RhbmNlcyB0aGF0IG1heSBydW4gaW4gb3RoZXIgdGFicyBvZiB0aGUgYnJvd3Nlci5cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUuaWQgPSAnJztcblxuLyoqXG4gKiBJcyB0cnVlIGlmIHRoZSBjbGllbnQgaXMgYXV0aGVudGljYXRlZCBhbmQgY29ubmVjdGVkIHRvIHRoZSBzZXJ2ZXI7XG4gKlxuICogVHlwaWNhbGx5IHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZXJlIGlzIGEgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyLlxuICpcbiAqIFR5cGljYWxseSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGBvbmxpbmVgIGV2ZW50LlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUsICdpc09ubGluZScsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub25saW5lTWFuYWdlciAmJiB0aGlzLm9ubGluZU1hbmFnZXIuaXNPbmxpbmU7XG4gIH0sXG59KTtcblxuLyoqXG4gKiBMb2cgbGV2ZWxzOyBvbmUgb2Y6XG4gKlxuICogICAgKiBsYXllci5Db25zdGFudHMuTE9HLk5PTkVcbiAqICAgICogbGF5ZXIuQ29uc3RhbnRzLkxPRy5FUlJPUlxuICogICAgKiBsYXllci5Db25zdGFudHMuTE9HLldBUk5cbiAqICAgICogbGF5ZXIuQ29uc3RhbnRzLkxPRy5JTkZPXG4gKiAgICAqIGxheWVyLkNvbnN0YW50cy5MT0cuREVCVUdcbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xpZW50QXV0aGVudGljYXRvci5wcm90b3R5cGUsICdsb2dMZXZlbCcsIHtcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkgeyByZXR1cm4gbG9nZ2VyLmxldmVsOyB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkgeyBsb2dnZXIubGV2ZWwgPSB2YWx1ZTsgfSxcbn0pO1xuXG4vKipcbiAqIFRpbWUgdG8gYmUgb2ZmbGluZSBhZnRlciB3aGljaCB3ZSBkb24ndCBkbyBhIFdlYlNvY2tldCBFdmVudHMucmVwbGF5LFxuICogYnV0IGluc3RlYWQganVzdCByZWZyZXNoIGFsbCBvdXIgUXVlcnkgZGF0YS4gIERlZmF1bHRzIHRvIDMwIGhvdXJzLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAc3RhdGljXG4gKi9cbkNsaWVudEF1dGhlbnRpY2F0b3IuUmVzZXRBZnRlck9mZmxpbmVEdXJhdGlvbiA9IDEwMDAgKiA2MCAqIDYwICogMzA7XG5cbi8qKlxuICogTGlzdCBvZiBldmVudHMgc3VwcG9ydGVkIGJ5IHRoaXMgY2xhc3NcbiAqIEBzdGF0aWNcbiAqIEBwcm90ZWN0ZWRcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuQ2xpZW50QXV0aGVudGljYXRvci5fc3VwcG9ydGVkRXZlbnRzID0gW1xuICAvKipcbiAgICogVGhlIGNsaWVudCBpcyByZWFkeSBmb3IgYWN0aW9uXG4gICAqXG4gICAqICAgICAgY2xpZW50Lm9uKCdyZWFkeScsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgICByZW5kZXJNeVVJKCk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBldmVudFxuICAgKi9cbiAgJ3JlYWR5JyxcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBjb25uZWN0ZWQgdG8gdGhlIHNlcnZlci5cbiAgICogQ3VycmVudGx5IGp1c3QgbWVhbnMgd2UgaGF2ZSBhIG5vbmNlLlxuICAgKiBOb3QgcmVjb21tZW5kZWQgZm9yIHR5cGljYWwgYXBwbGljYXRpb25zLlxuICAgKiBAZXZlbnQgY29ubmVjdGVkXG4gICAqL1xuICAnY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiB1bnN1Y2Nlc3NmdWwgaW4gb2J0YWluaW5nIGEgbm9uY2VcbiAgICogTm90IHJlY29tbWVuZGVkIGZvciB0eXBpY2FsIGFwcGxpY2F0aW9ucy5cbiAgICogQGV2ZW50IGNvbm5lY3RlZC1lcnJvclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldmVudC5lcnJvclxuICAgKi9cbiAgJ2Nvbm5lY3RlZC1lcnJvcicsXG5cbiAgLyoqXG4gICAqIFdlIG5vdyBoYXZlIGEgc2Vzc2lvbiBhbmQgYW55IHJlcXVlc3RzIHdlIHNlbmQgYXVnaHQgdG8gd29yay5cbiAgICogVHlwaWNhbGx5IHlvdSBzaG91bGQgdXNlIHRoZSByZWFkeSBldmVudCBpbnN0ZWFkIG9mIHRoZSBhdXRoZW50aWNhdGVkIGV2ZW50LlxuICAgKiBAZXZlbnQgYXV0aGVudGljYXRlZFxuICAgKi9cbiAgJ2F1dGhlbnRpY2F0ZWQnLFxuXG4gIC8qKlxuICAgKiBGYWlsZWQgdG8gYXV0aGVudGljYXRlIHlvdXIgY2xpZW50LlxuICAgKlxuICAgKiBFaXRoZXIgeW91ciBpZGVudGl0eS10b2tlbiB3YXMgaW52YWxpZCwgb3Igc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICogdXNpbmcgeW91ciBpZGVudGl0eS10b2tlbi5cbiAgICpcbiAgICogQGV2ZW50IGF1dGhlbnRpY2F0ZWQtZXJyb3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gZXZlbnQuZXJyb3JcbiAgICovXG4gICdhdXRoZW50aWNhdGVkLWVycm9yJyxcblxuICAvKipcbiAgICogVGhpcyBldmVudCBmaXJlcyB3aGVuIGEgc2Vzc2lvbiBoYXMgZXhwaXJlZCBvciB3aGVuIGBsYXllci5DbGllbnQubG9nb3V0YCBpcyBjYWxsZWQuXG4gICAqIFR5cGljYWxseSwgaXQgaXMgZW5vdWdoIHRvIHN1YnNjcmliZSB0byB0aGUgY2hhbGxlbmdlIGV2ZW50XG4gICAqIHdoaWNoIHdpbGwgbGV0IHlvdSByZWF1dGhlbnRpY2F0ZTsgdHlwaWNhbCBhcHBsaWNhdGlvbnMgZG8gbm90IG5lZWRcbiAgICogdG8gc3Vic2NyaWJlIHRvIHRoaXMuXG4gICAqXG4gICAqIEBldmVudCBkZWF1dGhlbnRpY2F0ZWRcbiAgICovXG4gICdkZWF1dGhlbnRpY2F0ZWQnLFxuXG4gIC8qKlxuICAgKiBAZXZlbnQgY2hhbGxlbmdlXG4gICAqIFZlcmlmeSB0aGUgdXNlcidzIGlkZW50aXR5LlxuICAgKlxuICAgKiBUaGlzIGV2ZW50IGlzIHdoZXJlIHlvdSB2ZXJpZnkgdGhhdCB0aGUgdXNlciBpcyB3aG8gd2UgYWxsIHRoaW5rIHRoZSB1c2VyIGlzLFxuICAgKiBhbmQgcHJvdmlkZSBhbiBpZGVudGl0eSB0b2tlbiB0byB2YWxpZGF0ZSB0aGF0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5vbmNlIC0gQSBub25jZSBmb3IgeW91IHRvIHByb3ZpZGUgdG8geW91ciBpZGVudGl0eSBwcm92aWRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5jYWxsYmFjayAtIENhbGwgdGhpcyBvbmNlIHlvdSBoYXZlIGFuIGlkZW50aXR5LXRva2VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5jYWxsYmFjay5pZGVudGl0eVRva2VuIC0gSWRlbnRpdHkgdG9rZW4gcHJvdmlkZWQgYnkgeW91ciBpZGVudGl0eSBwcm92aWRlciBzZXJ2aWNlXG4gICAqL1xuICAnY2hhbGxlbmdlJyxcblxuICAvKipcbiAgICogQGV2ZW50IHNlc3Npb24tdGVybWluYXRlZFxuICAgKiBJZiB5b3VyIHNlc3Npb24gaGFzIGJlZW4gdGVybWluYXRlZCBpbiBzdWNoIGEgd2F5IGFzIHRvIHByZXZlbnQgYXV0b21hdGljIHJlY29ubmVjdCxcbiAgICpcbiAgICogdGhpcyBldmVudCB3aWxsIGZpcmUuICBDb21tb24gc2NlbmFyaW86IHVzZXIgaGFzIHR3byB0YWJzIG9wZW47XG4gICAqIG9uZSB0YWIgdGhlIHVzZXIgbG9ncyBvdXQgKG9yIHlvdSBjYWxsIGNsaWVudC5sb2dvdXQoKSkuXG4gICAqIFRoZSBvdGhlciB0YWIgd2lsbCBkZXRlY3QgdGhhdCB0aGUgc2Vzc2lvblRva2VuIGhhcyBiZWVuIHJlbW92ZWQsXG4gICAqIGFuZCB3aWxsIHRlcm1pbmF0ZSBpdHMgc2Vzc2lvbiBhcyB3ZWxsLiAgSW4gdGhpcyBzY2VuYXJpbyB3ZSBkbyBub3Qgd2FudFxuICAgKiB0byBhdXRvbWF0aWNhbGx5IHRyaWdnZXIgYSBjaGFsbGVuZ2UgYW5kIHJlc3RhcnQgdGhlIGxvZ2luIHByb2Nlc3MuXG4gICAqL1xuICAnc2Vzc2lvbi10ZXJtaW5hdGVkJyxcblxuICAvKipcbiAgICogQGV2ZW50IG9ubGluZVxuICAgKlxuICAgKiBUaGlzIGV2ZW50IGlzIHVzZWQgdG8gZGV0ZWN0IHdoZW4gdGhlIGNsaWVudCBpcyBvbmxpbmUgKGNvbm5lY3RlZCB0byB0aGUgc2VydmVyKVxuICAgKiBvciBvZmZsaW5lIChzdGlsbCBhYmxlIHRvIGFjY2VwdCBBUEkgY2FsbHMgYnV0IG5vIGxvbmdlciBhYmxlIHRvIHN5bmMgdG8gdGhlIHNlcnZlcikuXG4gICAqXG4gICAqICAgICAgY2xpZW50Lm9uKCdvbmxpbmUnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICBpZiAoZXZ0LmlzT25saW5lKSB7XG4gICAqICAgICAgICAgICAgIHN0YXR1c0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnZ3JlZW4nO1xuICAgKiAgICAgICAgIH0gZWxzZSB7XG4gICAqICAgICAgICAgICAgIHN0YXR1c0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmVkJztcbiAgICogICAgICAgICB9XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmlzT25saW5lXG4gICAqL1xuICAnb25saW5lJyxcbl0uY29uY2F0KFJvb3QuX3N1cHBvcnRlZEV2ZW50cyk7XG5cblJvb3QuaW5pdENsYXNzLmFwcGx5KENsaWVudEF1dGhlbnRpY2F0b3IsIFtDbGllbnRBdXRoZW50aWNhdG9yLCAnQ2xpZW50QXV0aGVudGljYXRvciddKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRBdXRoZW50aWNhdG9yO1xuIiwiLyoqXG4gKiBBbGxvd3MgYWxsIGNvbXBvbmVudHMgdG8gaGF2ZSBhIGNsaWVudElkIGluc3RlYWQgb2YgYSBjbGllbnQgcG9pbnRlci5cbiAqIEFsbG93cyBhbiBhcHAgdG8gaGF2ZSBtdWx0aXBsZSBDbGllbnRzLCBlYWNoIHdpdGggaXRzIG93biBhcHBJZC5cbiAqIFByb3ZpZGVzIGEgZ2xvYmFsIHV0aWxpdHkgdGhhdCBjYW4gYmUgcmVxdWlyZWQgYnkgYWxsIG1vZHVsZXMgZm9yIGFjY2Vzc2luZ1xuICogdGhlIGNsaWVudC5cbiAqXG4gKiBAY2xhc3MgIGxheWVyLkNsaWVudFJlZ2lzdHJ5XG4gKiBAcHJpdmF0ZVxuICovXG5cbmNvbnN0IHJlZ2lzdHJ5ID0ge307XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBuZXcgQ2xpZW50OyB3aWxsIGRlc3Ryb3kgYW55IHByZXZpb3VzIGNsaWVudCB3aXRoIHRoZSBzYW1lIGFwcElkLlxuICpcbiAqIEBtZXRob2QgcmVnaXN0ZXJcbiAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50XG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyKGNsaWVudCkge1xuICBjb25zdCBhcHBJZCA9IGNsaWVudC5hcHBJZDtcbiAgaWYgKHJlZ2lzdHJ5W2FwcElkXSAmJiAhcmVnaXN0cnlbYXBwSWRdLmlzRGVzdHJveWVkKSB7XG4gICAgcmVnaXN0cnlbYXBwSWRdLmRlc3Ryb3koKTtcbiAgfVxuICByZWdpc3RyeVthcHBJZF0gPSBjbGllbnQ7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhIENsaWVudC5cbiAqXG4gKiBAbWV0aG9kIHVucmVnaXN0ZXJcbiAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50XG4gKi9cbmZ1bmN0aW9uIHVucmVnaXN0ZXIoY2xpZW50KSB7XG4gIGlmIChyZWdpc3RyeVtjbGllbnQuYXBwSWRdKSBkZWxldGUgcmVnaXN0cnlbY2xpZW50LmFwcElkXTtcbn1cblxuLyoqXG4gKiBHZXQgYSBDbGllbnQgYnkgYXBwSWRcbiAqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7c3RyaW5nfSBhcHBJZFxuICogQHJldHVybiB7bGF5ZXIuQ2xpZW50fVxuICovXG5mdW5jdGlvbiBnZXQoYXBwSWQpIHtcbiAgcmV0dXJuIHJlZ2lzdHJ5W2FwcElkXTtcbn1cblxuZnVuY3Rpb24gZ2V0QWxsKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkpLm1hcChrZXkgPT4gcmVnaXN0cnlba2V5XSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXQsXG4gIGdldEFsbCxcbiAgcmVnaXN0ZXIsXG4gIHVucmVnaXN0ZXIsXG59O1xuIiwiLyoqXG4gKiBVdGlsaXR5IG1ldGhvZHNcbiAqXG4gKiBAY2xhc3MgbGF5ZXIuQ2xpZW50VXRpbHNcbiAqL1xuXG5jb25zdCBMYXllclBhcnNlciA9IHJlcXVpcmUoJ2xheWVyLXBhdGNoJyk7XG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xuXG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gVVVJRFxuICpcbiAqIEBtZXRob2RcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVVVSUQgPSB1dWlkLnY0O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgJ3R5cGUnIHBvcnRpb24gb2YgYSBMYXllciBJRC5cbiAqXG4gKiAgICAgICAgIHN3aXRjaChVdGlscy50eXBlRnJvbUlEKGlkKSkge1xuICogICAgICAgICAgICAgY2FzZSAnY29udmVyc2F0aW9ucyc6XG4gKiAgICAgICAgICAgICAgICAgLi4uXG4gKiAgICAgICAgICAgICBjYXNlICdtZXNzYWdlJzpcbiAqICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgICAgIGNhc2U6ICdxdWVyaWVzJzpcbiAqICAgICAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgfVxuICpcbiAqIERvZXMgbm90IGN1cnJlbnRseSBoYW5kbGUgTGF5ZXIgQXBwIElEcy5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudHlwZUZyb21JRCA9IChpZCkgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gaWQubWF0Y2goL2xheWVyXFw6XFwvXFwvXFwvKC4qPylcXC8vKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogJyc7XG59O1xuXG5leHBvcnRzLmlzRW1wdHkgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nICYmIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuXG4vKipcbiAqIFNpbXBsaWZpZWQgc29ydCBtZXRob2QuXG4gKlxuICogUHJvdmlkZXMgYSBmdW5jdGlvbiB0byByZXR1cm4gdGhlIHZhbHVlIHRvIGNvbXBhcmUgcmF0aGVyIHRoYW4gZG8gdGhlIGNvbXBhcmlzb24uXG4gKlxuICogICAgICBzb3J0QnkoW3t2OiAzfSwge3Y6IDF9LCB2OiAzM31dLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICAgICAgICAgcmV0dXJuIHZhbHVlLnY7XG4gKiAgICAgIH0sIGZhbHNlKTtcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0gIHtNaXhlZFtdfSAgIGluQXJyYXkgICAgICBBcnJheSB0byBzb3J0XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgICAgICAgICBGdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdG8gY29tcGFyZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGZuLnZhbHVlICAgICAgQ3VycmVudCB2YWx1ZSBmcm9tIGluQXJyYXkgd2UgYXJlIGNvbXBhcmluZywgYW5kIGZyb20gd2hpY2ggYSB2YWx1ZSBzaG91bGQgYmUgZXh0cmFjdGVkXG4gKiBAcGFyYW0gIHtib29sZWFufSAgW3JldmVyc2U9ZmFsc2VdIFNvcnQgYXNjZW5kaW5nIChmYWxzZSkgb3IgZGVzY2VuZGluZyAodHJ1ZSlcbiAqL1xuZXhwb3J0cy5zb3J0QnkgPSAoaW5BcnJheSwgZm4sIHJldmVyc2UpID0+IHtcbiAgcmV2ZXJzZSA9IHJldmVyc2UgPyAtMSA6IDE7XG4gIGluQXJyYXkuc29ydCgodmFsdWVBLCB2YWx1ZUIpID0+IHtcbiAgICBjb25zdCBhYSA9IGZuKHZhbHVlQSk7XG4gICAgY29uc3QgYmIgPSBmbih2YWx1ZUIpO1xuICAgIGlmIChhYSA9PT0gdW5kZWZpbmVkICYmIGJiID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgIGlmIChhYSA9PT0gdW5kZWZpbmVkICYmIGJiICE9PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChhYSAhPT0gdW5kZWZpbmVkICYmIGJiID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoYWEgPiBiYikgcmV0dXJuIDEgKiByZXZlcnNlO1xuICAgIGlmIChhYSA8IGJiKSByZXR1cm4gLTEgKiByZXZlcnNlO1xuICAgIHJldHVybiAwO1xuICB9KTtcbn07XG5cbi8qKlxuICogUXVpY2sgYW5kIGVhc3kgY2xvbmUgbWV0aG9kLlxuICpcbiAqIERvZXMgbm90IHdvcmsgb24gY2lyY3VsYXIgcmVmZXJlbmNlczsgc2hvdWxkIG5vdCBiZSB1c2VkXG4gKiBvbiBvYmplY3RzIHdpdGggZXZlbnQgbGlzdGVuZXJzLlxuICpcbiAqICAgICAgdmFyIG5ld09iaiA9IFV0aWxzLmNsb25lKG9sZE9iaik7XG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgT2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBOZXcgT2JqZWN0XG4gKi9cbmV4cG9ydHMuY2xvbmUgPSAob2JqKSA9PiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXG4vKipcbiAqIEV4ZWN1dGUgdGhpcyBmdW5jdGlvbiBhc3luY2hyb25vdXNseS5cbiAqXG4gKiBEZWZlciB3aWxsIHVzZSBTT01FIHRlY2huaXF1ZSB0byBkZWxheSBleGVjdXRpb24gb2YgeW91ciBmdW5jdGlvbi5cbiAqIERlZmVyKCkgaXMgaW50ZW5kZWQgZm9yIGFueXRoaW5nIHRoYXQgc2hvdWxkIGJlIHByb2Nlc3NlZCBhZnRlciBjdXJyZW50IGV4ZWN1dGlvbiBoYXNcbiAqIGNvbXBsZXRlZCwgZXZlbiBpZiB0aGF0IG1lYW5zIDBtcyBkZWxheS5cbiAqXG4gKiAgICAgIGRlZmVyKGZ1bmN0aW9uKCkge2FsZXJ0KCdUaGF0IHdhc24ndCB2ZXJ5IGxvbmcgbm93IHdhcyBpdCEnKTt9KTtcbiAqXG4gKiBUT0RPOiBXRUItODQyOiBBZGQgYSBwb3N0TWVzc2FnZSBoYW5kbGVyLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmXG4gKi9cbmV4cG9ydHMuZGVmZXIgPSAoZnVuYykgPT4gc2V0VGltZW91dChmdW5jLCAwKTtcblxuXG4vKipcbiAqIFJldHVybnMgYSBkZWxheSBpbiBzZWNvbmRzIG5lZWRlZCB0byBmb2xsb3cgYW4gZXhwb25lbnRpYWxcbiAqIGJhY2tvZmYgcGF0dGVybiBvZiBkZWxheXMgZm9yIHJldHJ5aW5nIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBBbGdvcml0aG0gaGFzIHR3byBtb3RpdmF0aW9uczpcbiAqXG4gKiAxLiBSZXRyeSB3aXRoIGluY3JlYXNpbmdseSBsb25nIGludGVydmFscyB1cCB0byBzb21lIG1heGltdW0gaW50ZXJ2YWxcbiAqIDIuIFJhbmRvbWl6ZSB0aGUgcmV0cnkgaW50ZXJ2YWwgZW5vdWdoIHNvIHRoYXQgYSB0aG91c2FuZCBjbGllbnRzXG4gKiBhbGwgZm9sbG93aW5nIHRoZSBzYW1lIGFsZ29yaXRobSBhdCB0aGUgc2FtZSB0aW1lIHdpbGwgbm90IGhpdCB0aGVcbiAqIHNlcnZlciBhdCB0aGUgZXhhY3Qgc2FtZSB0aW1lcy5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGFyZSByZXN1bHRzIGJlZm9yZSBqaXR0ZXIgZm9yIHNvbWUgdmFsdWVzIG9mIGNvdW50ZXI6XG5cbiAgICAgIDA6IDAuMVxuICAgICAgMTogMC4yXG4gICAgICAyOiAwLjRcbiAgICAgIDM6IDAuOFxuICAgICAgNDogMS42XG4gICAgICA1OiAzLjJcbiAgICAgIDY6IDYuNFxuICAgICAgNzogMTIuOFxuICAgICAgODogMjUuNlxuICAgICAgOTogNTEuMlxuICAgICAgMTA6IDEwMi40XG4gICAgICAxMS4gMjA0LjhcbiAgICAgIDEyLiA0MDkuNlxuICAgICAgMTMuIDgxOS4yXG4gICAgICAxNC4gMTYzOC40ICgyNyBtaW51dGVzKVxuXG4gKiBAbWV0aG9kIGdldEV4cG9uZW50aWFsQmFja29mZlNlY29uZHNcbiAqIEBwYXJhbSAge251bWJlcn0gbWF4U2Vjb25kcyAtIFRoaXMgaXMgbm90IHRoZSBtYXhpbXVtIHNlY29uZHMgZGVsYXksIGJ1dCByYXRoZXJcbiAqIHRoZSBtYXhpbXVtIHNlY29uZHMgZGVsYXkgQkVGT1JFIGFkZGluZyBhIHJhbmRvbWl6ZWQgdmFsdWUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGNvdW50ZXIgLSBDdXJyZW50IGNvdW50ZXIgdG8gdXNlIGZvciBjYWxjdWxhdGluZyB0aGUgZGVsYXk7IHNob3VsZCBiZSBpbmNyZW1lbnRlZCB1cCB0byBzb21lIHJlYXNvbmFibGUgbWF4aW11bSB2YWx1ZSBmb3IgZWFjaCB1c2UuXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICBEZWxheSBpbiBzZWNvbmRzL2ZyYWN0aW9ucyBvZiBhIHNlY29uZFxuICovXG5leHBvcnRzLmdldEV4cG9uZW50aWFsQmFja29mZlNlY29uZHMgPSBmdW5jdGlvbiBnZXRFeHBvbmVudGlhbEJhY2tvZmZTZWNvbmRzKG1heFNlY29uZHMsIGNvdW50ZXIpIHtcbiAgbGV0IHNlY29uZHNXYWl0VGltZSA9IE1hdGgucG93KDIsIGNvdW50ZXIpIC8gMTAsXG4gICAgc2Vjb25kc09mZnNldCA9IE1hdGgucmFuZG9tKCk7IC8vIHZhbHVlIGJldHdlZW4gMC0xIHNlY29uZHMuXG4gIGlmIChjb3VudGVyIDwgMikgc2Vjb25kc09mZnNldCA9IHNlY29uZHNPZmZzZXQgLyA0OyAvLyB2YWx1ZXMgbGVzcyB0aGFuIDAuMiBzaG91bGQgYmUgb2Zmc2V0IGJ5IDAtMC4yNSBzZWNvbmRzXG4gIGVsc2UgaWYgKGNvdW50ZXIgPCA2KSBzZWNvbmRzT2Zmc2V0ID0gc2Vjb25kc09mZnNldCAvIDI7IC8vIHZhbHVlcyBiZXR3ZWVuIDAuMiBhbmQgMS4wIHNob3VsZCBiZSBvZmZzZXQgYnkgMC0wLjUgc2Vjb25kc1xuXG4gIGlmIChzZWNvbmRzV2FpdFRpbWUgPj0gbWF4U2Vjb25kcykgc2Vjb25kc1dhaXRUaW1lID0gbWF4U2Vjb25kcztcblxuICByZXR1cm4gc2Vjb25kc1dhaXRUaW1lICsgc2Vjb25kc09mZnNldDtcbn07XG5cbmxldCBwYXJzZXI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIExheWVyUGFyc2VyXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IC0gc2VlIGxheWVyLkNsaWVudFV0aWxzLmxheWVyUGFyc2VcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFyc2VyKHJlcXVlc3QpIHtcbiAgcmVxdWVzdC5jbGllbnQub25jZSgnZGVzdHJveScsICgpID0+IChwYXJzZXIgPSBudWxsKSk7XG5cbiAgcGFyc2VyID0gbmV3IExheWVyUGFyc2VyKHtcbiAgICBjYW1lbENhc2U6IHRydWUsXG4gICAgZ2V0T2JqZWN0Q2FsbGJhY2s6IChpZCkgPT4gcmVxdWVzdC5jbGllbnQuX2dldE9iamVjdChpZCksXG4gICAgcHJvcGVydHlOYW1lTWFwOiB7XG4gICAgICBDb252ZXJzYXRpb246IHtcbiAgICAgICAgdW5yZWFkTWVzc2FnZUNvdW50OiAndW5yZWFkQ291bnQnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGNoYW5nZUNhbGxiYWNrczoge1xuICAgICAgTWVzc2FnZToge1xuICAgICAgICBhbGw6ICh1cGRhdGVPYmplY3QsIG5ld1ZhbHVlLCBvbGRWYWx1ZSwgcGF0aHMpID0+IHtcbiAgICAgICAgICB1cGRhdGVPYmplY3QuX2hhbmRsZVBhdGNoRXZlbnQobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocyk7XG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgQ29udmVyc2F0aW9uOiB7XG4gICAgICAgIGFsbDogKHVwZGF0ZU9iamVjdCwgbmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocykgPT4ge1xuICAgICAgICAgIHVwZGF0ZU9iamVjdC5faGFuZGxlUGF0Y2hFdmVudChuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGhzKTtcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogUnVuIHRoZSBMYXllciBQYXJzZXIgb24gdGhlIHJlcXVlc3QuXG4gKlxuICogUGFyYW1ldGVycyBoZXJlXG4gKiBhcmUgdGhlIHBhcmFtZXRlcnMgc3BlY2llZCBpbiBbTGF5ZXItUGF0Y2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9sYXllcmhxL25vZGUtbGF5ZXItcGF0Y2gpLCBwbHVzXG4gKiBhIGNsaWVudCBvYmplY3QuXG4gKlxuICogICAgICBVdGlsLmxheWVyUGFyc2Uoe1xuICogICAgICAgICAgb2JqZWN0OiBjb252ZXJzYXRpb24sXG4gKiAgICAgICAgICB0eXBlOiAnQ29udmVyc2F0aW9uJyxcbiAqICAgICAgICAgIG9wZXJhdGlvbnM6IGxheWVyUGF0Y2hPcGVyYXRpb25zLFxuICogICAgICAgICAgY2xpZW50OiBjbGllbnRcbiAqICAgICAgfSk7XG4gKlxuICogQG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgLSBsYXllci1wYXRjaCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdC5vYmplY3QgLSBPYmplY3QgYmVpbmcgdXBkYXRlZCAgYnkgdGhlIG9wZXJhdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXF1ZXN0LnR5cGUgLSBUeXBlIG9mIG9iamVjdCBiZWluZyB1cGRhdGVkXG4gKiBAcGFyYW0ge09iamVjdFtdfSByZXF1ZXN0Lm9wZXJhdGlvbnMgLSBBcnJheSBvZiBjaGFuZ2Ugb3BlcmF0aW9ucyB0byBwZXJmb3JtIHVwb24gdGhlIG9iamVjdFxuICogQHBhcmFtIHtsYXllci5DbGllbnR9IHJlcXVlc3QuY2xpZW50XG4gKi9cbmV4cG9ydHMubGF5ZXJQYXJzZSA9IChyZXF1ZXN0KSA9PiB7XG4gIGlmICghcGFyc2VyKSBjcmVhdGVQYXJzZXIocmVxdWVzdCk7XG4gIHBhcnNlci5wYXJzZShyZXF1ZXN0KTtcbn07XG5cbi8qKlxuICogT2JqZWN0IGNvbXBhcmlzb24uXG4gKlxuICogRG9lcyBhIHJlY3Vyc2l2ZSB0cmF2ZXJzYWwgb2YgdHdvIG9iamVjdHMgdmVyaWZ5aW5nIHRoYXQgdGhleSBhcmUgdGhlIHNhbWUuXG4gKiBJcyBhYmxlIHRvIG1ha2UgbWV0YWRhdGEtcmVzdHJpY3RlZCBhc3N1bXB0aW9ucyBzdWNoIGFzIHRoYXRcbiAqIGFsbCB2YWx1ZXMgYXJlIGVpdGhlciBwbGFpbiBPYmplY3RzIG9yIHN0cmluZ3MuXG4gKlxuICogICAgICBpZiAoVXRpbHMuZG9lc09iamVjdE1hdGNoKGNvbnYxLm1ldGFkYXRhLCBjb252Mi5tZXRhZGF0YSkpIHtcbiAqICAgICAgICAgIGFsZXJ0KCdUaGVzZSB0d28gbWV0YWRhdGEgb2JqZWN0cyBhcmUgdGhlIHNhbWUnKTtcbiAqICAgICAgfVxuICpcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSAge09iamVjdH0gcmVxdWVzdGVkRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBhY3R1YWxEYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnRzLmRvZXNPYmplY3RNYXRjaCA9IChyZXF1ZXN0ZWREYXRhLCBhY3R1YWxEYXRhKSA9PiB7XG4gIGlmICghcmVxdWVzdGVkRGF0YSAmJiBhY3R1YWxEYXRhIHx8IHJlcXVlc3RlZERhdGEgJiYgIWFjdHVhbERhdGEpIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcmVxdWVzdGVkS2V5cyA9IE9iamVjdC5rZXlzKHJlcXVlc3RlZERhdGEpLnNvcnQoKTtcbiAgY29uc3QgYWN0dWFsS2V5cyA9IE9iamVjdC5rZXlzKGFjdHVhbERhdGEpLnNvcnQoKTtcblxuICAvLyBJZiB0aGVyZSBhcmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGtleXMsIGZhaWwuXG4gIGlmIChyZXF1ZXN0ZWRLZXlzLmxlbmd0aCAhPT0gYWN0dWFsS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAvLyBDb21wYXJlIGtleSBuYW1lIGFuZCB2YWx1ZSBhdCBlYWNoIGluZGV4XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXF1ZXN0ZWRLZXlzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNvbnN0IGsxID0gcmVxdWVzdGVkS2V5c1tpbmRleF07XG4gICAgY29uc3QgazIgPSBhY3R1YWxLZXlzW2luZGV4XTtcbiAgICBjb25zdCB2MSA9IHJlcXVlc3RlZERhdGFbazFdO1xuICAgIGNvbnN0IHYyID0gYWN0dWFsRGF0YVtrMl07XG4gICAgaWYgKGsxICE9PSBrMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh2MSAmJiB0eXBlb2YgdjEgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBBcnJheSBjb21wYXJpc29uIGlzIG5vdCB1c2VkIGJ5IHRoZSBXZWIgU0RLIGF0IHRoaXMgdGltZS5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHYxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbXBhcmlzb24gbm90IGhhbmRsZWQgeWV0Jyk7XG4gICAgICB9IGVsc2UgaWYgKCFleHBvcnRzLmRvZXNPYmplY3RNYXRjaCh2MSwgdjIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHYxICE9PSB2Mikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogU2ltcGxlIGFycmF5IGluY2x1c2lvbiB0ZXN0XG4gKiBAbWV0aG9kIGluY2x1ZGVzXG4gKiBAcGFyYW0ge01peGVkW119IGl0ZW1zXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaW5jbHVkZXMgPSAoaXRlbXMsIHZhbHVlKSA9PiBpdGVtcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG5cbiIsIi8qKlxuICogVGhlIExheWVyIENsaWVudDsgdGhpcyBpcyB0aGUgdG9wIGxldmVsIGNvbXBvbmVudCBmb3IgYW55IExheWVyIGJhc2VkIGFwcGxpY2F0aW9uLlxuXG4gICAgdmFyIGNsaWVudCA9IG5ldyBsYXllci5DbGllbnQoe1xuICAgICAgYXBwSWQ6ICdsYXllcjovLy9hcHBzL3N0YWdpbmcvZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJyxcbiAgICAgIHVzZXJJZDogJ0ZyZWQnLFxuICAgICAgY2hhbGxlbmdlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgbXlBdXRoZW50aWNhdG9yKHtcbiAgICAgICAgICBub25jZTogZXZ0Lm5vbmNlLFxuICAgICAgICAgIG9uU3VjY2VzczogZXZ0LmNhbGxiYWNrXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHJlYWR5OiBmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgYWxlcnQoJ0kgYW0gQ2xpZW50OyBTZXJ2ZXI6IFNlcnZlIG1lIScpO1xuICAgICAgfVxuICAgIH0pO1xuICpcbiAqIFlvdSBjYW4gYWxzbyBpbml0aWFsaXplIHRoaXMgYXNcblxuICAgIHZhciBjbGllbnQgPSBuZXcgbGF5ZXIuQ2xpZW50KHtcbiAgICAgIGFwcElkOiAnbGF5ZXI6Ly8vYXBwcy9zdGFnaW5nL2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZicsXG4gICAgICB1c2VySWQ6ICdGcmVkJ1xuICAgIH0pO1xuXG4gICAgY2xpZW50Lm9uKCdjaGFsbGVuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIG15QXV0aGVudGljYXRvcih7XG4gICAgICAgIG5vbmNlOiBldnQubm9uY2UsXG4gICAgICAgIG9uU3VjY2VzczogZXZ0LmNhbGxiYWNrXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNsaWVudC5vbigncmVhZHknLCBmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgIGFsZXJ0KCdJIGFtIENsaWVudDsgU2VydmVyOiBTZXJ2ZSBtZSEnKTtcbiAgICB9KTtcbiAqXG4gKiAjIyBBUEkgU3lub3BzaXM6XG4gKlxuICogVGhlIGZvbGxvd2luZyBQcm9wZXJ0aWVzLCBNZXRob2RzIGFuZCBFdmVudHMgYXJlIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgb25lcy4gIFNlZSB0aGUgZnVsbCBBUEkgYmVsb3dcbiAqIGZvciB0aGUgcmVzdCBvZiB0aGUgQVBJLlxuICpcbiAqICMjIyBQcm9wZXJ0aWVzOlxuICpcbiAqICogbGF5ZXIuQ2xpZW50LnVzZXJJZDogVXNlciBJRCBvZiB0aGUgYXV0aGVudGljYXRlZCB1c2VyXG4gKiAqIGxheWVyLkNsaWVudC5hcHBJZDogVGhlIElEIGZvciB5b3VyIGFwcGxpY2F0aW9uXG4gKlxuICpcbiAqICMjIyBNZXRob2RzOlxuICpcbiAqICogbGF5ZXIuQ2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbigpOiBDcmVhdGUgYSBuZXcgbGF5ZXIuQ29udmVyc2F0aW9uLlxuICogKiBsYXllci5DbGllbnQuY3JlYXRlUXVlcnkoKTogQ3JlYXRlIGEgbmV3IGxheWVyLlF1ZXJ5LlxuICogKiBsYXllci5DbGllbnQuZ2V0TWVzc2FnZSgpOiBJbnB1dCBhIE1lc3NhZ2UgSUQsIGFuZCBvdXRwdXQgYSBNZXNzYWdlIGZyb20gY2FjaGUuXG4gKiAqIGxheWVyLkNsaWVudC5nZXRDb252ZXJzYXRpb24oKTogSW5wdXQgYSBDb252ZXJzYXRpb24gSUQsIGFuZCBvdXRwdXQgYSBDb252ZXJzYXRpb24gZnJvbSBjYWNoZS5cbiAqICogbGF5ZXIuQ2xpZW50Lm9uKCkgYW5kIGxheWVyLkNvbnZlcnNhdGlvbi5vZmYoKTogZXZlbnQgbGlzdGVuZXJzXG4gKiAqIGxheWVyLkNsaWVudC5kZXN0cm95KCk6IENsZWFudXAgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoaXMgY2xpZW50LCBpbmNsdWRpbmcgYWxsIE1lc3NhZ2VzIGFuZCBDb252ZXJzYXRpb25zLlxuICpcbiAqICMjIyBFdmVudHM6XG4gKlxuICogKiBgY2hhbGxlbmdlYDogUHJvdmlkZXMgYSBub25jZSBhbmQgYSBjYWxsYmFjazsgeW91IGNhbGwgdGhlIGNhbGxiYWNrIG9uY2UgeW91IGhhdmUgYW4gSWRlbnRpdHkgVG9rZW4uXG4gKiAqIGByZWFkeWA6IFlvdXIgYXBwbGljYXRpb24gY2FuIG5vdyBzdGFydCB1c2luZyB0aGUgTGF5ZXIgc2VydmljZXNcbiAqICogYG1lc3NhZ2VzOm5vdGlmeWA6IFVzZWQgdG8gbm90aWZ5IHlvdXIgYXBwbGljYXRpb24gb2YgbmV3IG1lc3NhZ2VzIGZvciB3aGljaCBhIGxvY2FsIG5vdGlmaWNhdGlvbiBtYXkgYmUgc3VpdGFibGUuXG4gKlxuICogIyMgTG9nZ2luZzpcbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gY2hhbmdlIHRoZSBsb2cgbGV2ZWwgZm9yIExheWVyJ3MgbG9nZ2VyOlxuICpcbiAqICAgICBsYXllci5DbGllbnQucHJvdG90eXBlLmxvZ0xldmVsID0gbGF5ZXIuQ29uc3RhbnRzLkxPRy5JTkZPO1xuICpcbiAqIG9yXG4gKlxuICogICAgIHZhciBjbGllbnQgPSBuZXcgbGF5ZXIuQ2xpZW50KHtcbiAqICAgICAgICBhcHBJZDogJ2xheWVyOi8vL2FwcHMvc3RhZ2luZy9mZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYnLFxuICogICAgICAgIHVzZXJJZDogJ0ZyZWQnLFxuICogICAgICAgIGxvZ0xldmVsOiBsYXllci5Db25zdGFudHMuTE9HLklORk9cbiAqICAgICB9KTtcbiAqXG4gKiBAY2xhc3MgIGxheWVyLkNsaWVudFxuICogQGV4dGVuZHMgbGF5ZXIuQ2xpZW50QXV0aGVudGljYXRvclxuICpcbiAqL1xuXG5jb25zdCBDbGllbnRBdXRoID0gcmVxdWlyZSgnLi9jbGllbnQtYXV0aGVudGljYXRvcicpO1xuY29uc3QgQ29udmVyc2F0aW9uID0gcmVxdWlyZSgnLi9jb252ZXJzYXRpb24nKTtcbmNvbnN0IFF1ZXJ5ID0gcmVxdWlyZSgnLi9xdWVyeScpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IFN5bmNhYmxlID0gcmVxdWlyZSgnLi9zeW5jYWJsZScpO1xuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4vbWVzc2FnZScpO1xuY29uc3QgQW5ub3VuY2VtZW50ID0gcmVxdWlyZSgnLi9hbm5vdW5jZW1lbnQnKTtcbmNvbnN0IFVzZXIgPSByZXF1aXJlKCcuL3VzZXInKTtcbmNvbnN0IFR5cGluZ0luZGljYXRvckxpc3RlbmVyID0gcmVxdWlyZSgnLi90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctaW5kaWNhdG9yLWxpc3RlbmVyJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IENsaWVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9jbGllbnQtcmVnaXN0cnknKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5cbmNsYXNzIENsaWVudCBleHRlbmRzIENsaWVudEF1dGgge1xuXG4gIC8qXG4gICAqIEFkZHMgY29udmVyc2F0aW9ucywgbWVzc2FnZXMgYW5kIHdlYnNvY2tldHMgb24gdG9wIG9mIHRoZSBhdXRoZW50aWNhdGlvbiBjbGllbnQuXG4gICAqIGpzZG9jcyBvbiBwYXJlbnQgY2xhc3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgQ2xpZW50UmVnaXN0cnkucmVnaXN0ZXIodGhpcyk7XG5cbiAgICAvLyBJbml0aWFsaXplIFByb3BlcnRpZXNcbiAgICB0aGlzLl9jb252ZXJzYXRpb25zSGFzaCA9IHt9O1xuICAgIHRoaXMuX21lc3NhZ2VzSGFzaCA9IHt9O1xuICAgIHRoaXMuX3F1ZXJpZXNIYXNoID0ge307XG4gICAgdGhpcy5fc2NoZWR1bGVDaGVja0FuZFB1cmdlQ2FjaGVJdGVtcyA9IFtdO1xuXG4gICAgaWYgKCFvcHRpb25zLnVzZXJzKSB7XG4gICAgICB0aGlzLnVzZXJzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX191cGRhdGVVc2Vycyh0aGlzLnVzZXJzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0Q29tcG9uZW50cygpO1xuXG4gICAgdGhpcy5vbignb25saW5lJywgdGhpcy5fY29ubmVjdGlvblJlc3RvcmVkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyogU2VlIHBhcmVudCBtZXRob2QgZG9jcyAqL1xuICBfaW5pdENvbXBvbmVudHMoKSB7XG4gICAgc3VwZXIuX2luaXRDb21wb25lbnRzKCk7XG5cbiAgICB0aGlzLl90eXBpbmdJbmRpY2F0b3JzID0gbmV3IFR5cGluZ0luZGljYXRvckxpc3RlbmVyKHtcbiAgICAgIGNsaWVudElkOiB0aGlzLmFwcElkLFxuICAgIH0pO1xuXG4gICAgLy8gSW5zdGFudGlhdGUgUGx1Z2luc1xuICAgIE9iamVjdC5rZXlzKENsaWVudC5wbHVnaW5zKS5mb3JFYWNoKHByb3BlcnR5TmFtZSA9PiB7XG4gICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBuZXcgQ2xpZW50LnBsdWdpbnNbcHJvcGVydHlOYW1lXSh0aGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnVwIGFsbCByZXNvdXJjZXMgKENvbnZlcnNhdGlvbnMsIE1lc3NhZ2VzLCBldGMuLi4pIHByaW9yIHRvIGRlc3Ryb3kgb3IgcmVhdXRoZW50aWNhdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBfY2xlYW51cFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICB0aGlzLl9pbkNsZWFudXAgPSB0cnVlO1xuXG4gICAgT2JqZWN0LmtleXModGhpcy5fY29udmVyc2F0aW9uc0hhc2gpLmZvckVhY2goaWQgPT4ge1xuICAgICAgY29uc3QgYyA9IHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoW2lkXTtcbiAgICAgIGlmIChjICYmICFjLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIGMuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoID0gbnVsbDtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX21lc3NhZ2VzSGFzaCkuZm9yRWFjaChpZCA9PiB7XG4gICAgICBjb25zdCBtID0gdGhpcy5fbWVzc2FnZXNIYXNoW2lkXTtcbiAgICAgIGlmIChtICYmICFtLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIG0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX21lc3NhZ2VzSGFzaCA9IG51bGw7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9xdWVyaWVzSGFzaCkuZm9yRWFjaChpZCA9PiB7XG4gICAgICB0aGlzLl9xdWVyaWVzSGFzaFtpZF0uZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3F1ZXJpZXNIYXNoID0gbnVsbDtcbiAgICBpZiAodGhpcy51c2VycykgW10uY29uY2F0KHRoaXMudXNlcnMpLmZvckVhY2godXNlciA9PiB1c2VyLmRlc3Ryb3kgPyB1c2VyLmRlc3Ryb3koKSA6IG51bGwpO1xuXG4gICAgLy8gSWRlYWxseSB3ZSdkIHNldCBpdCB0byBudWxsLCBidXQgX2FkanVzdFVzZXJzIHdvdWxkIG1ha2UgaXQgW11cbiAgICB0aGlzLnVzZXJzID0gW107XG5cbiAgICBpZiAodGhpcy5zb2NrZXRNYW5hZ2VyKSB0aGlzLnNvY2tldE1hbmFnZXIuY2xvc2UoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG5cbiAgICAvLyBDbGVhbnVwIGFsbCBwbHVnaW5zXG4gICAgT2JqZWN0LmtleXMoQ2xpZW50LnBsdWdpbnMpLmZvckVhY2gocHJvcGVydHlOYW1lID0+IHtcbiAgICAgIGlmICh0aGlzW3Byb3BlcnR5TmFtZV0pIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdLmRlc3Ryb3koKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbcHJvcGVydHlOYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFudXAgYWxsIHJlc291cmNlcyAoQ29udmVyc2F0aW9ucywgTWVzc2FnZXMsIGV0Yy4uLilcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgICB0aGlzLl9kZXN0cm95Q29tcG9uZW50cygpO1xuXG4gICAgQ2xpZW50UmVnaXN0cnkudW5yZWdpc3Rlcih0aGlzKTtcblxuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9pbkNsZWFudXAgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBhIGNvbnZlcnNhdGlvbiBieSBJZGVudGlmaWVyLlxuICAgKlxuICAgKiAgICAgIHZhciBjID0gY2xpZW50LmdldENvbnZlcnNhdGlvbignbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy91dWlkJyk7XG4gICAqXG4gICAqIElmIHRoZXJlIGlzIG5vdCBhIGNvbnZlcnNhdGlvbiB3aXRoIHRoYXQgaWQsIGl0IHdpbGwgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIElmIHlvdSB3YW50IGl0IHRvIGxvYWQgaXQgZnJvbSBjYWNoZSBhbmQgdGhlbiBmcm9tIHNlcnZlciBpZiBub3QgaW4gY2FjaGUsIHVzZSB0aGUgYGNhbkxvYWRgIHBhcmFtZXRlci5cbiAgICogSWYgbG9hZGluZyBmcm9tIHRoZSBzZXJ2ZXIsIHRoZSBtZXRob2Qgd2lsbCByZXR1cm5cbiAgICogYSBsYXllci5Db252ZXJzYXRpb24gaW5zdGFuY2UgdGhhdCBoYXMgbm8gZGF0YTsgdGhlIGNvbnZlcnNhdGlvbnM6bG9hZGVkL2NvbnZlcnNhdGlvbnM6bG9hZGVkLWVycm9yIGV2ZW50c1xuICAgKiB3aWxsIGxldCB5b3Uga25vdyB3aGVuIHRoZSBjb252ZXJzYXRpb24gaGFzIGZpbmlzaGVkL2ZhaWxlZCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogICAgICB2YXIgYyA9IGNsaWVudC5nZXRDb252ZXJzYXRpb24oJ2xheWVyOi8vL2NvbnZlcnNhdGlvbnMvMTIzJywgdHJ1ZSlcbiAgICogICAgICAub24oJ2NvbnZlcnNhdGlvbnM6bG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgIC8vIFJlbmRlciB0aGUgQ29udmVyc2F0aW9uIHdpdGggYWxsIG9mIGl0cyBkZXRhaWxzIGxvYWRlZFxuICAgKiAgICAgICAgICBteXJlcmVuZGVyKGMpO1xuICAgKiAgICAgIH0pO1xuICAgKiAgICAgIC8vIFJlbmRlciBhIHBsYWNlaG9sZGVyIGZvciBjIHVudGlsIHRoZSBkZXRhaWxzIG9mIGMgaGF2ZSBsb2FkZWRcbiAgICogICAgICBteXJlbmRlcihjKTtcbiAgICpcbiAgICogQG1ldGhvZCBnZXRDb252ZXJzYXRpb25cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbY2FuTG9hZD1mYWxzZV0gLSBQYXNzIHRydWUgdG8gYWxsb3cgbG9hZGluZyBhIGNvbnZlcnNhdGlvbiBmcm9tXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHNlcnZlciBpZiBub3QgZm91bmRcbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKi9cbiAgZ2V0Q29udmVyc2F0aW9uKGlkLCBjYW5Mb2FkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuaWRQYXJhbVJlcXVpcmVkKTtcbiAgICBpZiAodGhpcy5fY29udmVyc2F0aW9uc0hhc2hbaWRdKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udmVyc2F0aW9uc0hhc2hbaWRdO1xuICAgIH0gZWxzZSBpZiAoY2FuTG9hZCkge1xuICAgICAgcmV0dXJuIENvbnZlcnNhdGlvbi5sb2FkKGlkLCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGNvbnZlcnNhdGlvbiB0byB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBUeXBpY2FsbHksIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXM7IHRoZSBmb2xsb3dpbmcgY29kZVxuICAgKiBhdXRvbWF0aWNhbGx5IGNhbGxzIF9hZGRDb252ZXJzYXRpb24gZm9yIHlvdTpcbiAgICpcbiAgICogICAgICB2YXIgY29udiA9IG5ldyBsYXllci5Db252ZXJzYXRpb24oe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICAgICAgcGFydGljaXBhbnRzOiBbJ2EnLCAnYiddXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqICAgICAgLy8gT1I6XG4gICAqICAgICAgdmFyIGNvbnYgPSBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKFsnYScsICdiJ10pO1xuICAgKlxuICAgKiBAbWV0aG9kIF9hZGRDb252ZXJzYXRpb25cbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtsYXllci5Db252ZXJzYXRpb259IGNcbiAgICogQHJldHVybnMge2xheWVyLkNsaWVudH0gdGhpc1xuICAgKi9cbiAgX2FkZENvbnZlcnNhdGlvbihjb252ZXJzYXRpb24pIHtcbiAgICBjb25zdCBpZCA9IGNvbnZlcnNhdGlvbi5pZDtcbiAgICBpZiAoIXRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoW2lkXSkge1xuICAgICAgLy8gUmVnaXN0ZXIgdGhlIENvbnZlcnNhdGlvblxuICAgICAgdGhpcy5fY29udmVyc2F0aW9uc0hhc2hbaWRdID0gY29udmVyc2F0aW9uO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIGNsaWVudCBpcyBzZXQgc28gdGhhdCB0aGUgbmV4dCBldmVudCBidWJibGVzIHVwXG4gICAgICBpZiAoY29udmVyc2F0aW9uLmNsaWVudElkICE9PSB0aGlzLmFwcElkKSBjb252ZXJzYXRpb24uY2xpZW50SWQgPSB0aGlzLmFwcElkO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjb252ZXJzYXRpb25zOmFkZCcsIHsgY29udmVyc2F0aW9uczogW2NvbnZlcnNhdGlvbl0gfSk7XG5cbiAgICAgIHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlKGNvbnZlcnNhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb252ZXJzYXRpb24gZnJvbSB0aGUgY2xpZW50LlxuICAgKlxuICAgKiBUeXBpY2FsbHksIHlvdSBkbyBub3QgbmVlZCB0byBjYWxsIHRoaXM7IHRoZSBmb2xsb3dpbmcgY29kZVxuICAgKiBhdXRvbWF0aWNhbGx5IGNhbGxzIF9yZW1vdmVDb252ZXJzYXRpb24gZm9yIHlvdTpcbiAgICpcbiAgICogICAgICBjb252ZXJhdGlvbi5kZXN0cm95KCk7XG4gICAqXG4gICAqIEBtZXRob2QgX3JlbW92ZUNvbnZlcnNhdGlvblxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gY1xuICAgKiBAcmV0dXJucyB7bGF5ZXIuQ2xpZW50fSB0aGlzXG4gICAqL1xuICBfcmVtb3ZlQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbikge1xuICAgIC8vIEluc3VyZSB3ZSBkbyBub3QgZ2V0IGFueSBldmVudHMsIHN1Y2ggYXMgbWVzc2FnZTpyZW1vdmVcbiAgICBjb252ZXJzYXRpb24ub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoW2NvbnZlcnNhdGlvbi5pZF0pIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jb252ZXJzYXRpb25zSGFzaFtjb252ZXJzYXRpb24uaWRdO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjb252ZXJzYXRpb25zOnJlbW92ZScsIHsgY29udmVyc2F0aW9uczogW2NvbnZlcnNhdGlvbl0gfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBNZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIENvbnZlcnNhdGlvblxuICAgIE9iamVjdC5rZXlzKHRoaXMuX21lc3NhZ2VzSGFzaCkuZm9yRWFjaChpZCA9PiB7XG4gICAgICBpZiAodGhpcy5fbWVzc2FnZXNIYXNoW2lkXS5jb252ZXJzYXRpb25JZCA9PT0gY29udmVyc2F0aW9uLmlkKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzSGFzaFtpZF0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIENvbnZlcnNhdGlvbiBJRCBjaGFuZ2VzLCB3ZSBuZWVkIHRvIHJlcmVnaXN0ZXIgdGhlIENvbnZlcnNhdGlvblxuICAgKlxuICAgKiBAbWV0aG9kIF91cGRhdGVDb252ZXJzYXRpb25JZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gY29udmVyc2F0aW9uIC0gQ29udmVyc2F0aW9uIHdob3NlIElEIGhhcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gb2xkSWQgLSBQcmV2aW91cyBJRFxuICAgKi9cbiAgX3VwZGF0ZUNvbnZlcnNhdGlvbklkKGNvbnZlcnNhdGlvbiwgb2xkSWQpIHtcbiAgICBpZiAodGhpcy5fY29udmVyc2F0aW9uc0hhc2hbb2xkSWRdKSB7XG4gICAgICB0aGlzLl9jb252ZXJzYXRpb25zSGFzaFtjb252ZXJzYXRpb24uaWRdID0gY29udmVyc2F0aW9uO1xuICAgICAgZGVsZXRlIHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoW29sZElkXTtcblxuICAgICAgLy8gVGhpcyBpcyBhIG5hc3R5IHdheSB0byB3b3JrLi4uIGJ1dCBuZWVkIHRvIGZpbmQgYW5kIHVwZGF0ZSBhbGxcbiAgICAgIC8vIGNvbnZlcnNhdGlvbklkIHByb3BlcnRpZXMgb2YgYWxsIE1lc3NhZ2VzIG9yIHRoZSBRdWVyeSdzIHdvbid0XG4gICAgICAvLyBzZWUgdGhlc2UgYXMgbWF0Y2hpbmcgdGhlIHF1ZXJ5LlxuICAgICAgT2JqZWN0LmtleXModGhpcy5fbWVzc2FnZXNIYXNoKVxuICAgICAgICAgICAgLmZpbHRlcihpZCA9PiB0aGlzLl9tZXNzYWdlc0hhc2hbaWRdLmNvbnZlcnNhdGlvbklkID09PSBvbGRJZClcbiAgICAgICAgICAgIC5mb3JFYWNoKGlkID0+ICh0aGlzLl9tZXNzYWdlc0hhc2hbaWRdLmNvbnZlcnNhdGlvbklkID0gY29udmVyc2F0aW9uLmlkKSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIG1lc3NhZ2Ugb3IgYW5ub3VuY2VtZW50IGlkLlxuICAgKlxuICAgKiBVc2VmdWwgZm9yIGZpbmRpbmcgYSBtZXNzYWdlIHdoZW4geW91IGhhdmUgb25seSB0aGUgSUQuXG4gICAqXG4gICAqIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBmb3VuZCwgaXQgd2lsbCByZXR1cm4gbnVsbC5cbiAgICpcbiAgICogSWYgeW91IHdhbnQgaXQgdG8gbG9hZCBpdCBmcm9tIGNhY2hlIGFuZCB0aGVuIGZyb20gc2VydmVyIGlmIG5vdCBpbiBjYWNoZSwgdXNlIHRoZSBgY2FuTG9hZGAgcGFyYW1ldGVyLlxuICAgKiBJZiBsb2FkaW5nIGZyb20gdGhlIHNlcnZlciwgdGhlIG1ldGhvZCB3aWxsIHJldHVyblxuICAgKiBhIGxheWVyLk1lc3NhZ2UgaW5zdGFuY2UgdGhhdCBoYXMgbm8gZGF0YTsgdGhlIG1lc3NhZ2VzOmxvYWRlZC9tZXNzYWdlczpsb2FkZWQtZXJyb3IgZXZlbnRzXG4gICAqIHdpbGwgbGV0IHlvdSBrbm93IHdoZW4gdGhlIG1lc3NhZ2UgaGFzIGZpbmlzaGVkL2ZhaWxlZCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogICAgICB2YXIgbSA9IGNsaWVudC5nZXRNZXNzYWdlKCdsYXllcjovLy9tZXNzYWdlcy8xMjMnLCB0cnVlKVxuICAgKiAgICAgIC5vbignbWVzc2FnZXM6bG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgIC8vIFJlbmRlciB0aGUgTWVzc2FnZSB3aXRoIGFsbCBvZiBpdHMgZGV0YWlscyBsb2FkZWRcbiAgICogICAgICAgICAgbXlyZXJlbmRlcihtKTtcbiAgICogICAgICB9KTtcbiAgICogICAgICAvLyBSZW5kZXIgYSBwbGFjZWhvbGRlciBmb3IgbSB1bnRpbCB0aGUgZGV0YWlscyBvZiBtIGhhdmUgbG9hZGVkXG4gICAqICAgICAgbXlyZW5kZXIobSk7XG4gICAqXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0TWVzc2FnZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkICAgICAgICAgICAgICAtIGxheWVyOi8vL21lc3NhZ2VzL3V1aWRcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2NhbkxvYWQ9ZmFsc2VdIC0gUGFzcyB0cnVlIHRvIGFsbG93IGxvYWRpbmcgYSBtZXNzYWdlIGZyb20gdGhlIHNlcnZlciBpZiBub3QgZm91bmRcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIGdldE1lc3NhZ2UoaWQsIGNhbkxvYWQpIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pZFBhcmFtUmVxdWlyZWQpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2VzSGFzaFtpZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlc0hhc2hbaWRdO1xuICAgIH0gZWxzZSBpZiAoY2FuTG9hZCkge1xuICAgICAgcmV0dXJuIFN5bmNhYmxlLmxvYWQoaWQsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBNZXNzYWdlUGFydCBieSBJRFxuICAgKiBAbWV0aG9kIGdldE1lc3NhZ2VQYXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIElEIG9mIHRoZSBNZXNzYWdlIFBhcnQ7IGxheWVyOi8vL21lc3NhZ2VzL3V1aWQvcGFydHMvNVxuICAgKi9cbiAgZ2V0TWVzc2FnZVBhcnQoaWQpIHtcbiAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pZFBhcmFtUmVxdWlyZWQpO1xuXG4gICAgY29uc3QgbWVzc2FnZUlkID0gaWQucmVwbGFjZSgvXFwvcGFydHMuKiQvLCAnJyk7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0TWVzc2FnZShtZXNzYWdlSWQpO1xuICAgIGlmIChtZXNzYWdlKSByZXR1cm4gbWVzc2FnZS5nZXRQYXJ0QnlJZChpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbWVzc2FnZSBpbiBfbWVzc2FnZXNIYXNoIGFuZCB0cmlnZ2VycyBldmVudHMuXG4gICAqXG4gICAqIE1heSBhbHNvIHVwZGF0ZSBDb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UuXG4gICAqXG4gICAqIEBtZXRob2QgX2FkZE1lc3NhZ2VcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtsYXllci5NZXNzYWdlfSBtZXNzYWdlXG4gICAqL1xuICBfYWRkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKCF0aGlzLl9tZXNzYWdlc0hhc2hbbWVzc2FnZS5pZF0pIHtcbiAgICAgIHRoaXMuX21lc3NhZ2VzSGFzaFttZXNzYWdlLmlkXSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmFkZCcsIHsgbWVzc2FnZXM6IFttZXNzYWdlXSB9KTtcbiAgICAgIGlmIChtZXNzYWdlLl9ub3RpZnkpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlczpub3RpZnknLCB7IG1lc3NhZ2UgfSk7XG4gICAgICAgIG1lc3NhZ2UuX25vdGlmeSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb252ZXJzYXRpb24gPSBtZXNzYWdlLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgICBpZiAoY29udmVyc2F0aW9uICYmICghY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlIHx8IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5wb3NpdGlvbiA8IG1lc3NhZ2UucG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlV2FzID0gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlO1xuICAgICAgICBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAobGFzdE1lc3NhZ2VXYXMpIHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlKGxhc3RNZXNzYWdlV2FzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG1lc3NhZ2UgZnJvbSBfbWVzc2FnZXNIYXNoLlxuICAgKlxuICAgKiBBY2NlcHRzIElEcyBvciBNZXNzYWdlIGluc3RhbmNlc1xuICAgKlxuICAgKiBUT0RPOiBSZW1vdmUgc3VwcG9ydCBmb3IgcmVtb3ZlIGJ5IElEXG4gICAqXG4gICAqIEBtZXRob2QgX3JlbW92ZU1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuTWVzc2FnZXxzdHJpbmd9IG1lc3NhZ2Ugb3IgTWVzc2FnZSBJRFxuICAgKi9cbiAgX3JlbW92ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGNvbnN0IGlkID0gKHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykgPyBtZXNzYWdlIDogbWVzc2FnZS5pZDtcbiAgICBtZXNzYWdlID0gdGhpcy5fbWVzc2FnZXNIYXNoW2lkXTtcbiAgICBpZiAobWVzc2FnZSkge1xuICAgICAgZGVsZXRlIHRoaXMuX21lc3NhZ2VzSGFzaFtpZF07XG4gICAgICBpZiAoIXRoaXMuX2luQ2xlYW51cCkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOnJlbW92ZScsIHsgbWVzc2FnZXM6IFttZXNzYWdlXSB9KTtcbiAgICAgICAgY29uc3QgY29udiA9IG1lc3NhZ2UuZ2V0Q29udmVyc2F0aW9uKGZhbHNlKTtcbiAgICAgICAgaWYgKGNvbnYgJiYgY29udi5sYXN0TWVzc2FnZSA9PT0gbWVzc2FnZSkgY29udi5sYXN0TWVzc2FnZSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZGVsZXRlIGZyb20gcG9zaXRpb24gZXZlbnQgZnJvbSBXZWJzb2NrZXQuXG4gICAqXG4gICAqIEEgV2ViU29ja2V0IG1heSBkZWxpdmVyIGEgYGRlbGV0ZWAgQ29udmVyc2F0aW9uIGV2ZW50IHdpdGggYVxuICAgKiBmcm9tX3Bvc2l0aW9uIGZpZWxkIGluZGljYXRpbmcgdGhhdCBhbGwgTWVzc2FnZXMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgKiBhbmQgZWFybGllciBzaG91bGQgYmUgZGVsZXRlZC5cbiAgICpcbiAgICogQG1ldGhvZCBfcHVyZ2VNZXNzYWdlc0J5UG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnZlcnNhdGlvbklkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tUG9zaXRpb25cbiAgICovXG4gIF9wdXJnZU1lc3NhZ2VzQnlQb3NpdGlvbihjb252ZXJzYXRpb25JZCwgZnJvbVBvc2l0aW9uKSB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fbWVzc2FnZXNIYXNoKS5mb3JFYWNoKG1JZCA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fbWVzc2FnZXNIYXNoW21JZF07XG4gICAgICBpZiAobWVzc2FnZS5jb252ZXJzYXRpb25JZCA9PT0gY29udmVyc2F0aW9uSWQgJiYgbWVzc2FnZS5wb3NpdGlvbiA8PSBmcm9tUG9zaXRpb24pIHtcbiAgICAgICAgbWVzc2FnZS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYXMgaW5wdXQgYW4gb2JqZWN0IGlkLCBhbmQgZWl0aGVyIGNhbGxzIGdldENvbnZlcnNhdGlvbigpIG9yIGdldE1lc3NhZ2UoKSBhcyBuZWVkZWQuXG4gICAqXG4gICAqIFdpbGwgb25seSBnZXQgY2FjaGVkIG9iamVjdHMsIHdpbGwgbm90IGdldCBvYmplY3RzIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogVGhpcyBpcyBub3QgYSBwdWJsaWMgbWV0aG9kIG1vc3RseSBzbyB0aGVyZSdzIG5vIGFtYmlndWl0eSBvdmVyIHVzaW5nIGdldFhYWFxuICAgKiBvciBfZ2V0T2JqZWN0LiAgZ2V0WFhYIHR5cGljYWxseSBoYXMgYW4gb3B0aW9uIHRvIGxvYWQgdGhlIHJlc291cmNlLCB3aGljaCB0aGlzXG4gICAqIGRvZXMgbm90LlxuICAgKlxuICAgKiBAbWV0aG9kIF9nZXRPYmplY3RcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gTWVzc2FnZSwgQ29udmVyc2F0aW9uIG9yIFF1ZXJ5IGlkXG4gICAqIEByZXR1cm4ge2xheWVyLk1lc3NhZ2V8bGF5ZXIuQ29udmVyc2F0aW9ufGxheWVyLlF1ZXJ5fVxuICAgKi9cbiAgX2dldE9iamVjdChpZCkge1xuICAgIHN3aXRjaCAoVXRpbC50eXBlRnJvbUlEKGlkKSkge1xuICAgICAgY2FzZSAnbWVzc2FnZXMnOlxuICAgICAgY2FzZSAnYW5ub3VuY2VtZW50cyc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1lc3NhZ2UoaWQpO1xuICAgICAgY2FzZSAnY29udmVyc2F0aW9ucyc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbnZlcnNhdGlvbihpZCk7XG4gICAgICBjYXNlICdxdWVyaWVzJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UXVlcnkoaWQpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFRha2VzIGFuIG9iamVjdCBkZXNjcmlwdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGVpdGhlciB1cGRhdGVzIGl0IChpZiBjYWNoZWQpXG4gICAqIG9yIGNyZWF0ZXMgYW5kIGNhY2hlcyBpdCAuXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZU9iamVjdFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2JqIC0gUGxhaW4gamF2YXNjcmlwdCBvYmplY3QgcmVwcmVzZW50aW5nIGEgTWVzc2FnZSBvciBDb252ZXJzYXRpb25cbiAgICovXG4gIF9jcmVhdGVPYmplY3Qob2JqKSB7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2dldE9iamVjdChvYmouaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpdGVtLl9wb3B1bGF0ZUZyb21TZXJ2ZXIob2JqKTtcbiAgICAgIHJldHVybiBpdGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGYWN0b3J5IG1ldGhvZCBpbiBTeW5jYWJsZSBjbGFzcz9cbiAgICAgIHN3aXRjaCAoVXRpbC50eXBlRnJvbUlEKG9iai5pZCkpIHtcbiAgICAgICAgY2FzZSAnbWVzc2FnZXMnOlxuICAgICAgICAgIHJldHVybiBNZXNzYWdlLl9jcmVhdGVGcm9tU2VydmVyKG9iaiwgdGhpcyk7XG5cbiAgICAgICAgY2FzZSAnYW5ub3VuY2VtZW50cyc6XG4gICAgICAgICAgcmV0dXJuIEFubm91bmNlbWVudC5fY3JlYXRlRnJvbVNlcnZlcihvYmosIHRoaXMpO1xuXG4gICAgICAgIGNhc2UgJ2NvbnZlcnNhdGlvbnMnOlxuICAgICAgICAgIHJldHVybiBDb252ZXJzYXRpb24uX2NyZWF0ZUZyb21TZXJ2ZXIob2JqLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgZXZlbnRzIGludG8gc21hbGxlciBudW1iZXJzIG9mIG1vcmUgY29tcGxldGUgZXZlbnRzLlxuICAgKlxuICAgKiBCZWZvcmUgYW55IGRlbGF5ZWQgdHJpZ2dlcnMgYXJlIGZpcmVkLCBmb2xkIHRvZ2V0aGVyIGFsbCBvZiB0aGUgY29udmVyc2F0aW9uczphZGRcbiAgICogYW5kIGNvbnZlcnNhdGlvbnM6cmVtb3ZlIGV2ZW50cyBzbyB0aGF0IDEwMCBjb252ZXJzYXRpb25zOmFkZCBldmVudHMgY2FuIGJlIGZpcmVkIGFzXG4gICAqIGEgc2luZ2xlIGV2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIF9wcm9jZXNzRGVsYXllZFRyaWdnZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0RlbGF5ZWRUcmlnZ2VycygpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgY29uc3QgYWRkQ29udmVyc2F0aW9ucyA9IHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5maWx0ZXIoKGV2dCkgPT4gZXZ0WzBdID09PSAnY29udmVyc2F0aW9uczphZGQnKTtcbiAgICBjb25zdCByZW1vdmVDb252ZXJzYXRpb25zID0gdGhpcy5fZGVsYXllZFRyaWdnZXJzLmZpbHRlcigoZXZ0KSA9PiBldnRbMF0gPT09ICdjb252ZXJzYXRpb25zOnJlbW92ZScpO1xuICAgIHRoaXMuX2ZvbGRFdmVudHMoYWRkQ29udmVyc2F0aW9ucywgJ2NvbnZlcnNhdGlvbnMnLCB0aGlzKTtcbiAgICB0aGlzLl9mb2xkRXZlbnRzKHJlbW92ZUNvbnZlcnNhdGlvbnMsICdjb252ZXJzYXRpb25zJywgdGhpcyk7XG5cbiAgICBjb25zdCBhZGRNZXNzYWdlcyA9IHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5maWx0ZXIoKGV2dCkgPT4gZXZ0WzBdID09PSAnbWVzc2FnZXM6YWRkJyk7XG4gICAgY29uc3QgcmVtb3ZlTWVzc2FnZXMgPSB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuZmlsdGVyKChldnQpID0+IGV2dFswXSA9PT0gJ21lc3NhZ2VzOnJlbW92ZScpO1xuXG4gICAgdGhpcy5fZm9sZEV2ZW50cyhhZGRNZXNzYWdlcywgJ21lc3NhZ2VzJywgdGhpcyk7XG4gICAgdGhpcy5fZm9sZEV2ZW50cyhyZW1vdmVNZXNzYWdlcywgJ21lc3NhZ2VzJywgdGhpcyk7XG5cbiAgICBzdXBlci5fcHJvY2Vzc0RlbGF5ZWRUcmlnZ2VycygpO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudE5hbWUsIGV2dCkge1xuICAgIHRoaXMuX3RyaWdnZXJMb2dnZXIoZXZlbnROYW1lLCBldnQpO1xuICAgIHN1cGVyLnRyaWdnZXIoZXZlbnROYW1lLCBldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERvZXMgbG9nZ2luZyBvbiBhbGwgdHJpZ2dlcmVkIGV2ZW50cy5cbiAgICpcbiAgICogQWxsIGxvZ2dpbmcgaXMgZG9uZSBhdCBgZGVidWdgIG9yIGBpbmZvYCBsZXZlbHMuXG4gICAqXG4gICAqIEBtZXRob2QgX3RyaWdnZXJMb2dnZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cmlnZ2VyTG9nZ2VyKGV2ZW50TmFtZSwgZXZ0KSB7XG4gICAgY29uc3QgaW5mb0V2ZW50cyA9IFtcbiAgICAgICdjb252ZXJzYXRpb25zOmFkZCcsICdjb252ZXJzYXRpb25zOnJlbW92ZScsXG4gICAgICAnY29udmVyc2F0aW9uczpjaGFuZ2UnLCAnbWVzc2FnZXM6YWRkJyxcbiAgICAgICdtZXNzYWdlczpyZW1vdmUnLCAnbWVzc2FnZXM6Y2hhbmdlJyxcbiAgICAgICdjaGFsbGVuZ2UnLCAncmVhZHknLFxuICAgIF07XG4gICAgaWYgKGluZm9FdmVudHMuaW5kZXhPZihldmVudE5hbWUpICE9PSAtMSkge1xuICAgICAgaWYgKGV2dCAmJiBldnQuaXNDaGFuZ2UpIHtcbiAgICAgICAgbG9nZ2VyLmluZm8oYENsaWVudCBFdmVudDogJHtldmVudE5hbWV9ICR7ZXZ0LmNoYW5nZXMubWFwKGNoYW5nZSA9PiBjaGFuZ2UucHJvcGVydHkpLmpvaW4oJywgJyl9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBpZiAoZXZ0KSB7XG4gICAgICAgICAgaWYgKGV2dC5tZXNzYWdlKSB0ZXh0ID0gZXZ0Lm1lc3NhZ2UuaWQ7XG4gICAgICAgICAgaWYgKGV2dC5tZXNzYWdlcykgdGV4dCA9IGV2dC5tZXNzYWdlcy5sZW5ndGggKyAnIG1lc3NhZ2VzJztcbiAgICAgICAgICBpZiAoZXZ0LmNvbnZlcnNhdGlvbikgdGV4dCA9IGV2dC5jb252ZXJzYXRpb24uaWQ7XG4gICAgICAgICAgaWYgKGV2dC5jb252ZXJzYXRpb25zKSB0ZXh0ID0gZXZ0LmNvbnZlcnNhdGlvbnMubGVuZ3RoICsgJyBjb252ZXJzYXRpb25zJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuaW5mbyhgQ2xpZW50IEV2ZW50OiAke2V2ZW50TmFtZX0gJHt0ZXh0fWApO1xuICAgICAgfVxuICAgICAgaWYgKGV2dCkgbG9nZ2VyLmRlYnVnKGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhldmVudE5hbWUsIGV2dCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGxvY2FsbHkgY2FjaGVkIGNvbnZlcnNhdGlvbnMgZm9yIGEgbWF0Y2hpbmcgY29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBJdGVyYXRlcyBvdmVyIGNvbnZlcnNhdGlvbnMgY2FsbGluZyBhIG1hdGNoaW5nIGZ1bmN0aW9uIHVudGlsXG4gICAqIHRoZSBjb252ZXJzYXRpb24gaXMgZm91bmQgb3IgYWxsIGNvbnZlcnNhdGlvbnMgdGVzdGVkLlxuICAgKlxuICAgKiAgICAgIHZhciBjID0gY2xpZW50LmZpbmRDb252ZXJzYXRpb24oZnVuY3Rpb24oY29udmVyc2F0aW9uKSB7XG4gICAqICAgICAgICAgIGlmIChjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmluZGV4T2YoJ2EnKSAhPSAtMSkgcmV0dXJuIHRydWU7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2QgZmluZENhY2hlZENvbnZlcnNhdGlvblxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZiAtIEZ1bmN0aW9uIHRvIGNhbGwgdW50aWwgd2UgZmluZCBhIG1hdGNoXG4gICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gZi5jb252ZXJzYXRpb24gLSBBIGNvbnZlcnNhdGlvbiB0byB0ZXN0XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGYucmV0dXJuIC0gUmV0dXJuIHRydWUgaWYgdGhlIGNvbnZlcnNhdGlvbiBpcyBhIG1hdGNoXG4gICAqIEBwYXJhbSAge09iamVjdH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCBmb3IgdGhlICp0aGlzKiBvYmplY3RcbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBUaGlzIHNob3VsZCBiZSByZXBsYWNlZCBieSBpdGVyYXRpbmcgb3ZlciB5b3VyIGxheWVyLlF1ZXJ5IGRhdGEuXG4gICAqL1xuICBmaW5kQ2FjaGVkQ29udmVyc2F0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBjb25zdCB0ZXN0ID0gY29udGV4dCA/IGZ1bmMuYmluZChjb250ZXh0KSA6IGZ1bmM7XG4gICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoKTtcbiAgICBjb25zdCBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBsaXN0W2luZGV4XTtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoW2tleV07XG4gICAgICBpZiAodGVzdChjb252ZXJzYXRpb24sIGluZGV4KSkgcmV0dXJuIGNvbnZlcnNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIHNlc3Npb24gaGFzIGJlZW4gcmVzZXQsIGR1bXAgYWxsIGRhdGEuXG4gICAqXG4gICAqIEBtZXRob2QgX3Jlc2V0U2Vzc2lvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0U2Vzc2lvbigpIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgdGhpcy51c2VycyA9IFtdO1xuICAgIHRoaXMuX2NvbnZlcnNhdGlvbnNIYXNoID0ge307XG4gICAgdGhpcy5fbWVzc2FnZXNIYXNoID0ge307XG4gICAgdGhpcy5fcXVlcmllc0hhc2ggPSB7fTtcbiAgICByZXR1cm4gc3VwZXIuX3Jlc2V0U2Vzc2lvbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHVzZXIgdG8gdGhlIHVzZXJzIGFycmF5LlxuICAgKlxuICAgKiBCeSBkb2luZyB0aGlzIGluc3RlYWQgb2YganVzdCBkaXJlY3RseSBgdGhpcy5jbGllbnQudXNlcnMucHVzaCh1c2VyKWBcbiAgICogdGhlIHVzZXIgd2lsbCBnZXQgaXRzIGNvbnZlcnNhdGlvbnMgcHJvcGVydHkgc2V0dXAgY29ycmVjdGx5LlxuICAgKlxuICAgKiBAbWV0aG9kIGFkZFVzZXJcbiAgICogQHBhcmFtICB7bGF5ZXIuVXNlcn0gdXNlciBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm5zIHtsYXllci5DbGllbnR9IHRoaXNcbiAgICovXG4gIGFkZFVzZXIodXNlcikge1xuICAgIHRoaXMudXNlcnMucHVzaCh1c2VyKTtcbiAgICB1c2VyLnNldENsaWVudCh0aGlzKTtcbiAgICB0aGlzLnRyaWdnZXIoJ3VzZXJzOmNoYW5nZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGBjbGllbnQudXNlcnNgIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGlkLlxuICAgKlxuICAgKiBVc2Ugb2YgdGhlIGBjbGllbnQudXNlcnNgIGFycmF5IGlzIG9wdGlvbmFsLlxuICAgKlxuICAgKiAgICAgIGZ1bmN0aW9uIGdldFNlbmRlckRpc3BsYXlOYW1lKG1lc3NhZ2UpIHtcbiAgICogICAgICAgICAgdmFyIHVzZXIgPSBjbGllbnQuZmluZFVzZXIobWVzc2FnZS5zZW5kZXIudXNlcklkKTtcbiAgICogICAgICAgICAgcmV0dXJuIHVzZXIgPyB1c2VyLmRpc3BsYXlOYW1lIDogJ1Vua25vd24gVXNlcic7XG4gICAqICAgICAgfVxuICAgKlxuICAgKiBAbWV0aG9kIGZpbmRVc2VyXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWRcbiAgICogQHJldHVybiB7bGF5ZXIuVXNlcn1cbiAgICovXG4gIGZpbmRVc2VyKGlkKSB7XG4gICAgY29uc3QgbCA9IHRoaXMudXNlcnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCB1ID0gdGhpcy51c2Vyc1tpXTtcbiAgICAgIGlmICh1LmlkID09PSBpZCkgcmV0dXJuIHU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIF9fIE1ldGhvZHMgYXJlIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHByb3BlcnR5IHNldHRlcnMuXG4gICAqXG4gICAqIEluc3VyZSB0aGF0IGFueSBhdHRlbXB0IHRvIHNldCB0aGUgYHVzZXJzYCBwcm9wZXJ0eSBzZXRzIGl0IHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9fYWRqdXN0VXNlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fYWRqdXN0VXNlcnModXNlcnMpIHtcbiAgICBpZiAoIXVzZXJzKSByZXR1cm4gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVzZXJzKSkgcmV0dXJuIFt1c2Vyc107XG4gIH1cblxuICAvKipcbiAgICogX18gTWV0aG9kcyBhcmUgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgcHJvcGVydHkgc2V0dGVycy5cbiAgICpcbiAgICogSW5zdXJlIHRoYXQgZWFjaCB1c2VyIGluIHRoZSB1c2VycyBhcnJheSBnZXRzIGl0cyBjbGllbnQgcHJvcGVydHkgc2V0dXAuXG4gICAqXG4gICAqIEBtZXRob2QgX19hZGp1c3RVc2Vyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX191cGRhdGVVc2Vycyh1c2Vycykge1xuICAgIHVzZXJzLmZvckVhY2godSA9PiB7XG4gICAgICBpZiAodSBpbnN0YW5jZW9mIFVzZXIpIHUuc2V0Q2xpZW50KHRoaXMpO1xuICAgIH0pO1xuICAgIHRoaXMudHJpZ2dlcigndXNlcnM6Y2hhbmdlJyk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgcmVjb21tZW5kZWQgd2F5IHRvIGNyZWF0ZSBhIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogVGhlcmUgYXJlIGEgZmV3IHdheXMgdG8gaW52b2tlIGl0OyBub3RlIHRoYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gY3JlYXRlIGEgRGlzdGluY3QgQ29udmVyc2F0aW9uXG4gICAqIHVubGVzcyBvdGhlcndpc2Ugc3RhdGVkIHZpYSB0aGUgbGF5ZXIuQ29udmVyc2F0aW9uLmRpc3RpbmN0IHByb3BlcnR5LlxuICAgKlxuICAgKiAgICAgICAgIGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oWydhJywgJ2InXSk7XG4gICAqXG4gICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbih7cGFydGljaXBhbnRzOiBbJ2EnLCAnYiddfSk7XG4gICAqXG4gICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbih7XG4gICAqICAgICAgICAgICAgIHBhcnRpY2lwYW50czogWydhJywgJ2InXSxcbiAgICogICAgICAgICAgICAgZGlzdGluY3Q6IGZhbHNlXG4gICAqICAgICAgICAgfSk7XG4gICAqXG4gICAqICAgICAgICAgY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbih7XG4gICAqICAgICAgICAgICAgIHBhcnRpY2lwYW50czogWydhJywgJ2InXSxcbiAgICogICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICogICAgICAgICAgICAgICAgIHRpdGxlOiAnSSBhbSBhIHRpdGxlJ1xuICAgKiAgICAgICAgICAgICB9XG4gICAqICAgICAgICAgfSk7XG4gICAqXG4gICAqIElmIHlvdSB0cnkgdG8gY3JlYXRlIGEgRGlzdGluY3QgQ29udmVyc2F0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMsXG4gICAqIHlvdSB3aWxsIGdldCBiYWNrIGFuIGV4aXN0aW5nIENvbnZlcnNhdGlvbiwgYW5kIGFueSByZXF1ZXN0ZWQgbWV0YWRhdGFcbiAgICogd2lsbCBOT1QgYmUgc2V0OyB5b3Ugd2lsbCBnZXQgd2hhdGV2ZXIgbWV0YWRhdGEgdGhlIG1hdGNoaW5nIENvbnZlcnNhdGlvblxuICAgKiBhbHJlYWR5IGhhZC5cbiAgICpcbiAgICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIGRpc3RpbmN0IGlzIGB0cnVlYC5cbiAgICpcbiAgICogV2hldGhlciB0aGUgQ29udmVyc2F0aW9uIGFscmVhZHkgZXhpc3RzIG9yIG5vdCwgYSAnY29udmVyc2F0aW9uczpzZW50JyBldmVudFxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZCBhc3luY2hyb25vdXNseSBhbmQgdGhlIENvbnZlcnNhdGlvbiBvYmplY3Qgd2lsbCBiZSByZWFkeVxuICAgKiBhdCB0aGF0IHRpbWUuICBGdXJ0aGVyLCB0aGUgZXZlbnQgd2lsbCBwcm92aWRlIGRldGFpbHMgb24gdGhlIHJlc3VsdDpcbiAgICpcbiAgICogICAgICAgdmFyIGNvbnZlcnNhdGlvbiA9IGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oWydhJywgJ2InXSk7XG4gICAqICAgICAgIGNvbnZlcnNhdGlvbi5vbignY29udmVyc2F0aW9uczpzZW50JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAqICAgICAgICAgICBzd2l0Y2goZXZ0LnJlc3VsdCkge1xuICAgKiAgICAgICAgICAgICAgIGNhc2UgQ29udmVyc2F0aW9uLkNSRUFURUQ6XG4gICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNvbnZlcnNhdGlvbi5pZCArICcgd2FzIGNyZWF0ZWQnKTtcbiAgICogICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAqICAgICAgICAgICAgICAgY2FzZSBDb252ZXJzYXRpb24uRk9VTkQ6XG4gICAqICAgICAgICAgICAgICAgICAgIGFsZXJ0KGNvbnZlcnNhdGlvbi5pZCArICcgd2FzIGZvdW5kJyk7XG4gICAqICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgKiAgICAgICAgICAgICAgIGNhc2UgQ29udmVyc2F0aW9uLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBOlxuICAgKiAgICAgICAgICAgICAgICAgICBhbGVydChjb252ZXJzYXRpb24uaWQgKyAnIHdhcyBmb3VuZCBidXQgaXQgYWxyZWFkeSBoYXMgYSB0aXRsZSBzbyB5b3VyIHJlcXVlc3RlZCB0aXRsZSB3YXMgbm90IHNldCcpO1xuICAgKiAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICogICAgICAgICAgICB9XG4gICAqICAgICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZUNvbnZlcnNhdGlvblxuICAgKiBAcGFyYW0gIHtPYmplY3Qvc3RyaW5nW119IG9wdGlvbnMgRWl0aGVyIGFuIGFycmF5IG9mIHBhcnRpY2lwYW50cyxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyB0byBwYXNzIHRvXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbnZlcnNhdGlvbidzIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZGlzdGluY3Q9dHJ1ZV0gSXMgdGhpcyBhIGRpc3RpbmN0IENvbnZlcmF0aW9uP1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWV0YWRhdGE9e31dIE1ldGFkYXRhIGZvciB5b3VyIENvbnZlcnNhdGlvblxuICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259XG4gICAqL1xuICBjcmVhdGVDb252ZXJzYXRpb24ob3B0aW9ucykge1xuICAgIGxldCBvcHRzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBwYXJ0aWNpcGFudHM6IG9wdGlvbnMsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0gb3B0aW9ucztcbiAgICB9XG4gICAgaWYgKCEoJ2Rpc3RpbmN0JyBpbiBvcHRzKSkgb3B0cy5kaXN0aW5jdCA9IHRydWU7XG4gICAgb3B0cy5jbGllbnQgPSB0aGlzO1xuICAgIHJldHVybiBDb252ZXJzYXRpb24uY3JlYXRlKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBxdWVyeSBieSBxdWVyeSBpZC5cbiAgICpcbiAgICogVXNlZnVsIGZvciBmaW5kaW5nIGEgUXVlcnkgd2hlbiB5b3Ugb25seSBoYXZlIHRoZSBJRFxuICAgKlxuICAgKiBAbWV0aG9kIGdldFF1ZXJ5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gaWQgICAgICAgICAgICAgIC0gbGF5ZXI6Ly8vbWVzc2FnZXMvdXVpZFxuICAgKiBAcmV0dXJuIHtsYXllci5RdWVyeX1cbiAgICovXG4gIGdldFF1ZXJ5KGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuaWRQYXJhbVJlcXVpcmVkKTtcblxuICAgIGlmICh0aGlzLl9xdWVyaWVzSGFzaFtpZF0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzSGFzaFtpZF07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZXJlIGFyZSB0d28gb3B0aW9ucyB0byBjcmVhdGUgYSBuZXcgbGF5ZXIuUXVlcnkgaW5zdGFuY2UuXG4gICAqXG4gICAqIFRoZSBkaXJlY3Qgd2F5OlxuICAgKlxuICAgKiAgICAgdmFyIHF1ZXJ5ID0gY2xpZW50LmNyZWF0ZVF1ZXJ5KHtcbiAgICogICAgICAgICBtb2RlbDogbGF5ZXIuUXVlcnkuTWVzc2FnZSxcbiAgICogICAgICAgICBwcmVkaWNhdGU6ICdjb252ZXJzYXRpb24uaWQgPSAnJyArIGNvbnYuaWQgKyAnJycsXG4gICAqICAgICAgICAgcGFnaW5hdGlvbldpbmRvdzogNTBcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBBIEJ1aWxkZXIgYXBwcm9hY2ggdGhhdCBhbGxvd3MgZm9yIGEgc2ltcGxlciBzeW50YXg6XG4gICAqXG4gICAqICAgICB2YXIgcUJ1aWxkZXIgPSBRdWVyeUJ1aWxkZXJcbiAgICogICAgICAubWVzc2FnZXMoKVxuICAgKiAgICAgIC5mb3JDb252ZXJzYXRpb24oJ2xheWVyOi8vL2NvbnZlcnNhdGlvbnMvZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmJylcbiAgICogICAgICAucGFnaW5hdGlvbldpbmRvdygxMDApO1xuICAgKiAgICAgdmFyIHF1ZXJ5ID0gY2xpZW50LmNyZWF0ZVF1ZXJ5KHFCdWlsZGVyKTtcbiAgICpcbiAgICogQG1ldGhvZCBjcmVhdGVRdWVyeVxuICAgKiBAcGFyYW0gIHtsYXllci5RdWVyeUJ1aWxkZXJ8T2JqZWN0fSBvcHRpb25zIC0gRWl0aGVyIGEgbGF5ZXIuUXVlcnlCdWlsZGVyIGluc3RhbmNlLCBvciBwYXJhbWV0ZXJzIGZvciB0aGUgbGF5ZXIuUXVlcnkgY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7bGF5ZXIuUXVlcnl9XG4gICAqL1xuICBjcmVhdGVRdWVyeShvcHRpb25zKSB7XG4gICAgbGV0IHF1ZXJ5O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5idWlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuY2xpZW50ID0gdGhpcztcbiAgICAgIHF1ZXJ5ID0gbmV3IFF1ZXJ5KG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGlzLl9hZGRRdWVyeShxdWVyeSk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBsYXllci5RdWVyeS5cbiAgICpcbiAgICogQG1ldGhvZCBfYWRkUXVlcnlcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuUXVlcnl9IHF1ZXJ5XG4gICAqL1xuICBfYWRkUXVlcnkocXVlcnkpIHtcbiAgICB0aGlzLl9xdWVyaWVzSGFzaFtxdWVyeS5pZF0gPSBxdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIHRoZSBsYXllci5RdWVyeS5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVtb3ZlUXVlcnlcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuUXVlcnl9IHF1ZXJ5IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIF9yZW1vdmVRdWVyeShxdWVyeSkge1xuICAgIGlmIChxdWVyeSkge1xuICAgICAgZGVsZXRlIHRoaXMuX3F1ZXJpZXNIYXNoW3F1ZXJ5LmlkXTtcbiAgICAgIGlmICghdGhpcy5faW5DbGVhbnVwKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBxdWVyeS5kYXRhXG4gICAgICAgICAgLm1hcChvYmogPT4gdGhpcy5fZ2V0T2JqZWN0KG9iai5pZCkpXG4gICAgICAgICAgLmZpbHRlcihvYmogPT4gb2JqKTtcbiAgICAgICAgdGhpcy5fY2hlY2tBbmRQdXJnZUNhY2hlKGRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5vZmYobnVsbCwgbnVsbCwgcXVlcnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3RzIGNhbiBzYWZlbHkgYmUgcmVtb3ZlZCBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBSZW1vdmVzIGZyb20gY2FjaGUgaWYgYW4gb2JqZWN0IGlzIG5vdCBwYXJ0IG9mIGFueSBRdWVyeSdzIHJlc3VsdCBzZXQuXG4gICAqXG4gICAqIEBtZXRob2QgX2NoZWNrQW5kUHVyZ2VDYWNoZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5Sb290W119IG9iamVjdHMgLSBBcnJheSBvZiBNZXNzYWdlcyBvciBDb252ZXJzYXRpb25zXG4gICAqL1xuICBfY2hlY2tBbmRQdXJnZUNhY2hlKG9iamVjdHMpIHtcbiAgICBvYmplY3RzLmZvckVhY2gob2JqID0+IHtcbiAgICAgIGlmICghb2JqLmlzRGVzdHJveWVkICYmICF0aGlzLl9pc0NhY2hlZE9iamVjdChvYmopKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBSb290ID09PSBmYWxzZSkgb2JqID0gdGhpcy5fZ2V0T2JqZWN0KG9iai5pZCk7XG4gICAgICAgIG9iai5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIF9ydW5TY2hlZHVsZWRDaGVja0FuZFB1cmdlQ2FjaGUgaWYgbmVlZGVkLCBhbmQgYWRkcyB0aGlzIG9iamVjdFxuICAgKiB0byB0aGUgbGlzdCBvZiBvYmplY3RzIGl0IHdpbGwgdmFsaWRhdGUgZm9yIHVuY2FjaGluZy5cbiAgICpcbiAgICogTm90ZSB0aGF0IGFueSBvYmplY3QgdGhhdCBkb2VzIG5vdCBleGlzdCBvbiB0aGUgc2VydmVyICghaXNTYXZlZCgpKSBpcyBhbiBvYmplY3QgdGhhdCB0aGVcbiAgICogYXBwIGNyZWF0ZWQgYW5kIGNhbiBvbmx5IGJlIHB1cmdlZCBieSB0aGUgYXBwIGFuZCBub3QgYnkgdGhlIFNESy4gIE9uY2UgaXRzIGJlZW5cbiAgICogc2F2ZWQsIGFuZCBjYW4gYmUgcmVsb2FkZWQgZnJvbSB0aGUgc2VydmVyIHdoZW4gbmVlZGVkLCBpdHMgc3ViamVjdCB0byBzdGFuZGFyZCBjYWNoaW5nLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLlJvb3R9XG4gICAqL1xuICBfc2NoZWR1bGVDaGVja0FuZFB1cmdlQ2FjaGUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5pc1NhdmVkKCkpIHtcbiAgICAgIGlmICh0aGlzLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZUF0IDwgRGF0ZS5ub3coKSkge1xuICAgICAgICB0aGlzLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZUF0ID0gRGF0ZS5ub3coKSArIENsaWVudC5DQUNIRV9QVVJHRV9JTlRFUlZBTDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9ydW5TY2hlZHVsZWRDaGVja0FuZFB1cmdlQ2FjaGUoKSwgQ2xpZW50LkNBQ0hFX1BVUkdFX0lOVEVSVkFMKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlSXRlbXMucHVzaChvYmplY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBfY2hlY2tBbmRQdXJnZUNhY2hlIG9uIGFjY3VtdWxhdGVkIG9iamVjdHMgYW5kIHJlc2V0cyBpdHMgc3RhdGVcbiAgICovXG4gIF9ydW5TY2hlZHVsZWRDaGVja0FuZFB1cmdlQ2FjaGUoKSB7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuX3NjaGVkdWxlQ2hlY2tBbmRQdXJnZUNhY2hlSXRlbXM7XG4gICAgdGhpcy5fc2NoZWR1bGVDaGVja0FuZFB1cmdlQ2FjaGVJdGVtcyA9IFtdO1xuICAgIHRoaXMuX2NoZWNrQW5kUHVyZ2VDYWNoZShsaXN0KTtcbiAgICB0aGlzLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZUF0ID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3Qgc2hvdWxkIGNvbnRpbnVlIHRvIGJlIHBhcnQgb2YgdGhlIGNhY2hlLlxuICAgKlxuICAgKiBSZXN1bHQgaXMgYmFzZWQgb24gd2hldGhlciB0aGUgb2JqZWN0IGlzIHBhcnQgb2YgdGhlIGRhdGEgZm9yIGEgUXVlcnkuXG4gICAqXG4gICAqIEBtZXRob2QgX2lzQ2FjaGVkT2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLlJvb3R9IG9iaiAtIEEgTWVzc2FnZSBvciBDb252ZXJzYXRpb24gSW5zdGFuY2VcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc0NhY2hlZE9iamVjdChvYmopIHtcbiAgICBjb25zdCBsaXN0ID0gT2JqZWN0LmtleXModGhpcy5fcXVlcmllc0hhc2gpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLl9xdWVyaWVzSGFzaFtsaXN0W2ldXTtcbiAgICAgIGlmIChxdWVyeS5fZ2V0SXRlbShvYmouaWQpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gcmVzdG9yaW5nIGEgY29ubmVjdGlvbiwgZGV0ZXJtaW5lIHdoYXQgc3RlcHMgbmVlZCB0byBiZSB0YWtlbiB0byB1cGRhdGUgb3VyIGRhdGEuXG4gICAqXG4gICAqIEEgcmVzZXQgYm9vbGVhbiBwcm9wZXJ0eSBpcyBwYXNzZWQ7IHNldCBiYXNlZCBvbiAgbGF5ZXIuQ2xpZW50QXV0aGVudGljYXRvci5SZXNldEFmdGVyT2ZmbGluZUR1cmF0aW9uLlxuICAgKlxuICAgKiBOb3RlIGl0IGlzIHBvc3NpYmxlIGZvciBhbiBhcHBsaWNhdGlvbiB0byBoYXZlIGxvZ2ljIHRoYXQgY2F1c2VzIHF1ZXJpZXMgdG8gYmUgY3JlYXRlZC9kZXN0cm95ZWRcbiAgICogYXMgYSBzaWRlLWVmZmVjdCBvZiBsYXllci5RdWVyeS5yZXNldCBkZXN0cm95aW5nIGFsbCBkYXRhLiBTbyB3ZSBtdXN0IHRlc3QgdG8gc2VlIGlmIHF1ZXJpZXMgZXhpc3QuXG4gICAqXG4gICAqIEBtZXRob2QgX2Nvbm5lY3Rpb25SZXN0b3JlZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc2V0IC0gU2hvdWxkIHRoZSBzZXNzaW9uIHJlc2V0L3JlbG9hZCBhbGwgZGF0YSBvciBhdHRlbXB0IHRvIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZj9cbiAgICovXG4gIF9jb25uZWN0aW9uUmVzdG9yZWQoZXZ0KSB7XG4gICAgaWYgKGV2dC5yZXNldCkge1xuICAgICAgbG9nZ2VyLmRlYnVnKCdDbGllbnQgQ29ubmVjdGlvbiBSZXN0b3JlZDsgUmVzZXR0aW5nIGFsbCBRdWVyaWVzJyk7XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9xdWVyaWVzSGFzaCkuZm9yRWFjaChpZCA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fcXVlcmllc0hhc2hbaWRdO1xuICAgICAgICBpZiAocXVlcnkpIHF1ZXJ5LnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGZyb20gY2FjaGVcbiAgICpcbiAgICogQG1ldGhvZCBfcmVtb3ZlT2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLlJvb3R9ICBvYmogLSBBIE1lc3NhZ2Ugb3IgQ29udmVyc2F0aW9uIEluc3RhbmNlXG4gICAqL1xuICBfcmVtb3ZlT2JqZWN0KG9iaikge1xuICAgIGlmIChvYmopIG9iai5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxheWVyLlR5cGluZ0luZGljYXRvcnMuVHlwaW5nTGlzdGVuZXIgaW5zdGFuY2VcbiAgICogYm91bmQgdG8gdGhlIHNwZWNpZmllZCBkb20gbm9kZS5cbiAgICpcbiAgICogICAgICB2YXIgdHlwaW5nTGlzdGVuZXIgPSBjbGllbnQuY3JlYXRlVHlwaW5nTGlzdGVuZXIoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ215VGV4dEJveCcpKTtcbiAgICogICAgICB0eXBpbmdMaXN0ZW5lci5zZXRDb252ZXJzYXRpb24obXlTZWxlY3RlZENvbnZlcnNhdGlvbik7XG4gICAqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBpbnN0YW50aWF0ZSBhIGxpc3RlbmVyLCBhbmQgY2FsbFxuICAgKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ0xpc3RlbmVyLnNldENvbnZlcnNhdGlvbiBldmVyeSB0aW1lIHlvdSB3YW50IHRvIGNoYW5nZSB3aGljaCBDb252ZXJzYXRpb25cbiAgICogaXQgcmVwb3J0cyB5b3VyIHVzZXIgaXMgdHlwaW5nIGludG8uXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlVHlwaW5nTGlzdGVuZXJcbiAgICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGlucHV0Tm9kZSAtIFRleHQgaW5wdXQgdG8gd2F0Y2ggZm9yIGtleXN0cm9rZXNcbiAgICogQHJldHVybiB7bGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdMaXN0ZW5lcn1cbiAgICovXG4gIGNyZWF0ZVR5cGluZ0xpc3RlbmVyKGlucHV0Tm9kZSkge1xuICAgIGNvbnN0IFR5cGluZ0xpc3RlbmVyID0gcmVxdWlyZSgnLi90eXBpbmctaW5kaWNhdG9ycy90eXBpbmctbGlzdGVuZXInKTtcbiAgICByZXR1cm4gbmV3IFR5cGluZ0xpc3RlbmVyKHtcbiAgICAgIGNsaWVudElkOiB0aGlzLmFwcElkLFxuICAgICAgaW5wdXQ6IGlucHV0Tm9kZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdQdWJsaXNoZXIuXG4gICAqXG4gICAqIFRoZSBUeXBpbmdQdWJsaXNoZXIgbGV0cyB5b3UgbWFuYWdlIHlvdXIgVHlwaW5nIEluZGljYXRvcnMgd2l0aG91dCB1c2luZ1xuICAgKiB0aGUgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdMaXN0ZW5lci5cbiAgICpcbiAgICogICAgICB2YXIgdHlwaW5nUHVibGlzaGVyID0gY2xpZW50LmNyZWF0ZVR5cGluZ1B1Ymxpc2hlcigpO1xuICAgKiAgICAgIHR5cGluZ1B1Ymxpc2hlci5zZXRDb252ZXJzYXRpb24obXlTZWxlY3RlZENvbnZlcnNhdGlvbik7XG4gICAqICAgICAgdHlwaW5nUHVibGlzaGVyLnNldFN0YXRlKGxheWVyLlR5cGluZ0luZGljYXRvcnMuU1RBUlRFRCk7XG4gICAqXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB0byBpbnN0YW50aWF0ZSBhIGxpc3RlbmVyLCBhbmQgY2FsbFxuICAgKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ1B1Ymxpc2hlci5zZXRDb252ZXJzYXRpb24gZXZlcnkgdGltZSB5b3Ugd2FudCB0byBjaGFuZ2Ugd2hpY2ggQ29udmVyc2F0aW9uXG4gICAqIGl0IHJlcG9ydHMgeW91ciB1c2VyIGlzIHR5cGluZyBpbnRvLlxuICAgKlxuICAgKiBVc2UgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdQdWJsaXNoZXIuc2V0U3RhdGUgdG8gaW5mb3JtIG90aGVyIHVzZXJzIG9mIHlvdXIgY3VycmVudCBzdGF0ZS5cbiAgICogTm90ZSB0aGF0IHRoZSBgU1RBUlRFRGAgc3RhdGUgb25seSBsYXN0cyBmb3IgMi41IHNlY29uZHMsIHNvIHlvdVxuICAgKiBtdXN0IHJlcGVhdGVkbHkgY2FsbCBzZXRTdGF0ZSBmb3IgYXMgbG9uZyBhcyB0aGlzIHN0YXRlIHNob3VsZCBjb250aW51ZS5cbiAgICogVGhpcyBpcyB0eXBpY2FsbHkgZG9uZSBieSBzaW1wbHkgY2FsbGluZyBpdCBldmVyeSB0aW1lIGEgdXNlciBoaXRzXG4gICAqIGEga2V5LlxuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZVR5cGluZ1B1Ymxpc2hlclxuICAgKiBAcmV0dXJuIHtsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ1B1Ymxpc2hlcn1cbiAgICovXG4gIGNyZWF0ZVR5cGluZ1B1Ymxpc2hlcigpIHtcbiAgICBjb25zdCBUeXBpbmdQdWJsaXNoZXIgPSByZXF1aXJlKCcuL3R5cGluZy1pbmRpY2F0b3JzL3R5cGluZy1wdWJsaXNoZXInKTtcbiAgICByZXR1cm4gbmV3IFR5cGluZ1B1Ymxpc2hlcih7XG4gICAgICBjbGllbnRJZDogdGhpcy5hcHBJZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2Nlc3NvciBmb3IgZ2V0dGluZyBhIENsaWVudCBieSBhcHBJZC5cbiAgICpcbiAgICogTW9zdCBhcHBzIHdpbGwgb25seSBoYXZlIG9uZSBjbGllbnQsXG4gICAqIGFuZCB3aWxsIG5vdCBuZWVkIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldENsaWVudFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSAge3N0cmluZ30gYXBwSWRcbiAgICogQHJldHVybiB7bGF5ZXIuQ2xpZW50fVxuICAgKi9cbiAgc3RhdGljIGdldENsaWVudChhcHBJZCkge1xuICAgIHJldHVybiBDbGllbnRSZWdpc3RyeS5nZXQoYXBwSWQpO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3lBbGxDbGllbnRzKCkge1xuICAgIENsaWVudFJlZ2lzdHJ5LmdldEFsbCgpLmZvckVhY2goY2xpZW50ID0+IGNsaWVudC5kZXN0cm95KCkpO1xuICB9XG5cbiAgLypcbiAgICogUmVnaXN0ZXJzIGEgcGx1Z2luIHdoaWNoIGNhbiBhZGQgY2FwYWJpbGl0aWVzIHRvIHRoZSBDbGllbnQuXG4gICAqXG4gICAqIENhcGFiaWxpdGllcyBtdXN0IGJlIHRyaWdnZXJlZCBieSBFdmVudHMvRXZlbnQgTGlzdGVuZXJzLlxuICAgKlxuICAgKiBUaGlzIGNvbmNlcHQgaXMgYSBiaXQgcHJlbWF0dXJlIGFuZCB1bnVzZWQvdW50ZXN0ZWQuLi5cbiAgICogQXMgaW1wbGVtZW50ZWQsIGl0IHByb3ZpZGVzIGZvciBhIHBsdWdpbiB0aGF0IHdpbGwgYmVcbiAgICogaW5zdGFudGlhdGVkIGJ5IHRoZSBDbGllbnQgYW5kIHBhc3NlZCB0aGUgQ2xpZW50IGFzIGl0cyBwYXJhbWV0ZXIuXG4gICAqIFRoaXMgYWxsb3dzIGZvciBhIGxpYnJhcnkgb2YgcGx1Z2lucyB0aGF0IGNhbiBiZSBzaGFyZWQgYW1vbmdcbiAgICogZGlmZmVyZW50IGNvbXBhbmllcy9wcm9qZWN0cyBidXQgdGhhdCBhcmUgb3V0c2lkZSBvZiB0aGUgY29yZVxuICAgKiBhcHAgbG9naWMuXG4gICAqXG4gICAqICAgICAgLy8gRGVmaW5lIHRoZSBwbHVnaW5cbiAgICogICAgICBmdW5jdGlvbiBNeVBsdWdpbihjbGllbnQpIHtcbiAgICogICAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAqICAgICAgICAgIGNsaWVudC5vbignbWVzc2FnZXM6YWRkJywgdGhpcy5vbk1lc3NhZ2VzQWRkLCB0aGlzKTtcbiAgICogICAgICB9XG4gICAqXG4gICAqICAgICAgTXlQbHVnaW4ucHJvdG90eXBlLm9uTWVzc2FnZXNBZGQgPSBmdW5jdGlvbihldmVudCkge1xuICAgKiAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBldmVudC5tZXNzYWdlcztcbiAgICogICAgICAgICAgYWxlcnQoJ1lvdSBub3cgaGF2ZSAnICsgbWVzc2FnZXMubGVuZ3RoICArICcgbWVzc2FnZXMnKTtcbiAgICogICAgICB9XG4gICAqXG4gICAqICAgICAgLy8gUmVnaXN0ZXIgdGhlIFBsdWdpblxuICAgKiAgICAgIENsaWVudC5yZWdpc3RlclBsdWdpbignbXlQbHVnaW4zNCcsIE15UGx1Z2luKTtcbiAgICpcbiAgICogICAgICB2YXIgY2xpZW50ID0gbmV3IENsaWVudCh7YXBwSWQ6ICdsYXllcjovLy9hcHBzL3N0YWdpbmcvdXVpZCd9KTtcbiAgICpcbiAgICogICAgICAvLyBUcmlnZ2VyIHRoZSBwbHVnaW4ncyBiZWhhdmlvclxuICAgKiAgICAgIGNsaWVudC5teVBsdWdpbjM0LmFkZE1lc3NhZ2VzKHttZXNzYWdlczpbXX0pO1xuICAgKlxuICAgKiBAbWV0aG9kIHJlZ2lzdGVyUGx1Z2luXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjbGFzc0RlZiBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBzdGF0aWMgcmVnaXN0ZXJQbHVnaW4obmFtZSwgY2xhc3NEZWYpIHtcbiAgICBDbGllbnQucGx1Z2luc1tuYW1lXSA9IGNsYXNzRGVmO1xuICB9XG5cbn1cblxuLyoqXG4gKiBIYXNoIG9mIGxheWVyLkNvbnZlcnNhdGlvbiBvYmplY3RzIGZvciBxdWljayBsb29rdXAgYnkgaWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHByb3BlcnR5IHtPYmplY3R9XG4gKi9cbkNsaWVudC5wcm90b3R5cGUuX2NvbnZlcnNhdGlvbnNIYXNoID0gbnVsbDtcblxuLyoqXG4gKiBIYXNoIG9mIGxheWVyLk1lc3NhZ2Ugb2JqZWN0cyBmb3IgcXVpY2sgbG9va3VwIGJ5IGlkXG4gKlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNsaWVudC5wcm90b3R5cGUuX21lc3NhZ2VzSGFzaCA9IG51bGw7XG5cbi8qKlxuICogSGFzaCBvZiBsYXllci5RdWVyeSBvYmplY3RzIGZvciBxdWljayBsb29rdXAgYnkgaWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQ2xpZW50LnByb3RvdHlwZS5fcXVlcmllc0hhc2ggPSBudWxsO1xuXG4vKipcbiAqIEFycmF5IG9mIGl0ZW1zIHRvIGJlIGNoZWNrZWQgdG8gc2VlIGlmIHRoZXkgY2FuIGJlIHVuY2FjaGVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7bGF5ZXIuUm9vdFtdfVxuICovXG5DbGllbnQucHJvdG90eXBlLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZUl0ZW1zID0gbnVsbDtcblxuLyoqXG4gKiBUaW1lIHRoYXQgdGhlIG5leHQgY2FsbCB0byBfcnVuQ2hlY2tBbmRQdXJnZUNhY2hlKCkgaXMgc2NoZWR1bGVkIGZvciBpbiBtcyBzaW5jZSAxOTcwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5DbGllbnQucHJvdG90eXBlLl9zY2hlZHVsZUNoZWNrQW5kUHVyZ2VDYWNoZUF0ID0gMDtcblxuLyoqXG4gKiBBcnJheSBvZiBsYXllci5Vc2VyIG9iamVjdHMuXG4gKlxuICogVXNlIG9mIHRoaXMgcHJvcGVydHkgaXMgb3B0aW9uYWw7IGJ1dCBieSBzdG9yaW5nXG4gKiBhbiBhcnJheSBvZiBsYXllci5Vc2VyIG9iamVjdHMgaW4gdGhpcyBhcnJheSwgeW91IGNhblxuICogdGhlbiB1c2UgdGhlIGBjbGllbnQuZmluZFVzZXIodXNlcklkKWAgbWV0aG9kIHRvIGxvb2t1cFxuICogdXNlcnM7IGFuZCB5b3UgY2FuIHVzZSB0aGUgbGF5ZXIuVXNlciBvYmplY3RzIHRvIGZpbmRcbiAqIHN1aXRhYmxlIENvbnZlcnNhdGlvbnMgc28geW91IGNhbiBhc3NvY2lhdGUgYSBEaXJlY3RcbiAqIE1lc3NhZ2UgY29udmVyc2F0aW9uIHdpdGggZWFjaCB1c2VyLlxuICpcbiAqIEB0eXBlIHtsYXllci5Vc2VyW119XG4gKi9cbkNsaWVudC5wcm90b3R5cGUudXNlcnMgPSBudWxsO1xuXG5cbi8qKlxuICogQW55IENvbnZlcnNhdGlvbiBvciBNZXNzYWdlIHRoYXQgaXMgcGFydCBvZiBhIFF1ZXJ5J3MgcmVzdWx0cyBhcmUga2VwdCBpbiBtZW1vcnkgZm9yIGFzIGxvbmcgYXMgaXRcbiAqIHJlbWFpbnMgaW4gdGhhdCBRdWVyeS4gIEhvd2V2ZXIsIHdoZW4gYSB3ZWJzb2NrZXQgZXZlbnQgZGVsaXZlcnMgbmV3IE1lc3NhZ2VzIGFuZCBDb252ZXJzYXRpb25zIHRoYXRcbiAqIGFyZSBOT1QgcGFydCBvZiBhIFF1ZXJ5LCBob3cgbG9uZyBzaG91bGQgdGhleSBzdGljayBhcm91bmQgaW4gbWVtb3J5PyAgV2h5IGhhdmUgdGhlbSBzdGljayBhcm91bmQ/XG4gKiBQZXJoYXBzIGFuIGFwcCB3YW50cyB0byBwb3N0IGEgbm90aWZpY2F0aW9uIG9mIGEgbmV3IE1lc3NhZ2Ugb3IgQ29udmVyc2F0aW9uLi4uIGFuZCB3YW50cyB0byBrZWVwXG4gKiB0aGUgb2JqZWN0IGxvY2FsIGZvciBhIGxpdHRsZSB3aGlsZS4gIERlZmF1bHQgaXMgMTAgbWludXRlcyBiZWZvcmUgY2hlY2tpbmcgdG8gc2VlIGlmXG4gKiB0aGUgb2JqZWN0IGlzIHBhcnQgb2YgYSBRdWVyeSBvciBjYW4gYmUgdW5jYWNoZWQuICBWYWx1ZSBpcyBpbiBtaWxpc2Vjb25kcy5cbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkNsaWVudC5DQUNIRV9QVVJHRV9JTlRFUlZBTCA9IDEwICogNjAgKiAxMDAwO1xuXG5DbGllbnQuX2lnbm9yZWRFdmVudHMgPSBbXG4gICdjb252ZXJzYXRpb25zOmxvYWRlZCcsXG4gICdjb252ZXJzYXRpb25zOmxvYWRlZC1lcnJvcicsXG5dO1xuXG5DbGllbnQuX3N1cHBvcnRlZEV2ZW50cyA9IFtcblxuICAvKipcbiAgICogT25lIG9yIG1vcmUgbGF5ZXIuQ29udmVyc2F0aW9uIG9iamVjdHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBjbGllbnQuXG4gICAqXG4gICAqIFRoZXkgbWF5IGhhdmUgYmVlbiBhZGRlZCB2aWEgdGhlIHdlYnNvY2tldCwgb3IgdmlhIHRoZSB1c2VyIGNyZWF0aW5nXG4gICAqIGEgbmV3IENvbnZlcnNhdGlvbiBsb2NhbGx5LlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbignY29udmVyc2F0aW9uczphZGQnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgZXZ0LmNvbnZlcnNhdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjb252ZXJzYXRpb24pIHtcbiAgICogICAgICAgICAgICAgIG15Vmlldy5hZGRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKTtcbiAgICogICAgICAgICAgfSk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBldnQuY29udmVyc2F0aW9ucyAtIEFycmF5IG9mIGNvbnZlcnNhdGlvbnMgYWRkZWRcbiAgICovXG4gICdjb252ZXJzYXRpb25zOmFkZCcsXG5cbiAgLyoqXG4gICAqIE9uZSBvciBtb3JlIGxheWVyLkNvbnZlcnNhdGlvbiBvYmplY3RzIGhhdmUgYmVlbiByZW1vdmVkLlxuICAgKlxuICAgKiBBIHJlbW92ZWQgQ29udmVyc2F0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBkZWxldGVkLCBpdHMganVzdFxuICAgKiBubyBsb25nZXIgYmVpbmcgaGVsZCBpbiBsb2NhbCBtZW1vcnkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0eXBpY2FsbHkgeW91IHdpbGwgd2FudCB0aGUgY29udmVyc2F0aW9uczpkZWxldGUgZXZlbnRcbiAgICogcmF0aGVyIHRoYW4gY29udmVyc2F0aW9uczpyZW1vdmUuXG4gICAqXG4gICAqICAgICAgY2xpZW50Lm9uKCdjb252ZXJzYXRpb25zOnJlbW92ZScsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgICBldnQuY29udmVyc2F0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnZlcnNhdGlvbikge1xuICAgKiAgICAgICAgICAgICAgbXlWaWV3LnJlbW92ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb24pO1xuICAgKiAgICAgICAgICB9KTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9uW119IGV2dC5jb252ZXJzYXRpb25zIC0gQXJyYXkgb2YgY29udmVyc2F0aW9ucyByZW1vdmVkXG4gICAqL1xuICAnY29udmVyc2F0aW9uczpyZW1vdmUnLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udmVyc2F0aW9uIGlzIG5vdyBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBDYWxsZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIGNvbnZlcnNhdGlvblxuICAgKiBvbiB0aGUgc2VydmVyLiAgVGhlIFJlc3VsdCBwcm9wZXJ0eSBpcyBvbmUgb2Y6XG4gICAqXG4gICAqICogbGF5ZXIuQ29udmVyc2F0aW9uLkNSRUFURUQ6IEEgbmV3IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBjcmVhdGVkXG4gICAqICogbGF5ZXIuQ29udmVyc2F0aW9uLkZPVU5EOiBBIG1hdGNoaW5nIERpc3RpbmN0IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBmb3VuZFxuICAgKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5GT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQTogQSBtYXRjaGluZyBEaXN0aW5jdCBDb252ZXJzYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhlIG1ldGFkYXRhIGlzIE5PVCB3aGF0IHlvdSByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIEFsbCBvZiB0aGVzZSByZXN1bHRzIHdpbGwgYWxzbyBtZWFuIHRoYXQgdGhlIHVwZGF0ZWQgcHJvcGVydHkgdmFsdWVzIGhhdmUgYmVlblxuICAgKiBjb3BpZWQgaW50byB5b3VyIENvbnZlcnNhdGlvbiBvYmplY3QuICBUaGF0IG1lYW5zIHlvdXIgbWV0YWRhdGEgcHJvcGVydHkgbWF5IG5vXG4gICAqIGxvbmdlciBiZSBpdHMgaW5pdGlhbCB2YWx1ZTsgaXQgd2lsbCBiZSB0aGUgdmFsdWUgZm91bmQgb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogICAgICBjbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6c2VudCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgICBzd2l0Y2goZXZ0LnJlc3VsdCkge1xuICAgKiAgICAgICAgICAgICAgY2FzZSBDb252ZXJzYXRpb24uQ1JFQVRFRDpcbiAgICogICAgICAgICAgICAgICAgICBhbGVydChldnQudGFyZ2V0LmlkICsgJyBDcmVhdGVkIScpO1xuICAgKiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgKiAgICAgICAgICAgICAgY2FzZSBDb252ZXJzYXRpb24uRk9VTkQ6XG4gICAqICAgICAgICAgICAgICAgICAgYWxlcnQoZXZ0LnRhcmdldC5pZCArICcgRm91bmQhJyk7XG4gICAqICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAqICAgICAgICAgICAgICBjYXNlIENvbnZlcnNhdGlvbi5GT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQTpcbiAgICogICAgICAgICAgICAgICAgICBhbGVydChldnQudGFyZ2V0LmlkICsgJyBGb3VuZCwgYnV0IGRvZXMgbm90IGhhdmUgdGhlIHJlcXVlc3RlZCBtZXRhZGF0YSEnKTtcbiAgICogICAgICAgICAgICAgICAgICBicmVhaztcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQucmVzdWx0XG4gICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9ufSB0YXJnZXRcbiAgICovXG4gICdjb252ZXJzYXRpb25zOnNlbnQnLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlcnNhdGlvbiBmYWlsZWQgdG8gbG9hZCBvciBjcmVhdGUgb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogICAgICBjbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6c2VudC1lcnJvcicsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgICBhbGVydChldnQuZGF0YS5tZXNzYWdlKTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gZXZ0LmRhdGFcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb259IHRhcmdldFxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6c2VudC1lcnJvcicsXG5cbiAgLyoqXG4gICAqIEEgY29udmVyc2F0aW9uIGhhZCBhIGNoYW5nZSBpbiBpdHMgcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhpcyBjaGFuZ2UgbWF5IGhhdmUgYmVlbiBkZWxpdmVyZWQgZnJvbSBhIHJlbW90ZSB1c2VyXG4gICAqIG9yIGFzIGEgcmVzdWx0IG9mIGEgbG9jYWwgb3BlcmF0aW9uLlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbignY29udmVyc2F0aW9uczpjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgdmFyIG1ldGFkYXRhQ2hhbmdlcyA9IGV2dC5nZXRDaGFuZ2VzRm9yKCdtZXRhZGF0YScpO1xuICAgKiAgICAgICAgICB2YXIgcGFydGljaXBhbnRDaGFuZ2VzID0gZXZ0LmdldENoYW5nZXNGb3IoJ3BhcnRpY2lwYW50cycpO1xuICAgKiAgICAgICAgICBpZiAobWV0YWRhdGFDaGFuZ2VzLmxlbmd0aCkge1xuICAgKiAgICAgICAgICAgICAgbXlWaWV3LnJlbmRlclRpdGxlKGV2dC50YXJnZXQubWV0YWRhdGEudGl0bGUpO1xuICAgKiAgICAgICAgICB9XG4gICAqICAgICAgICAgIGlmIChwYXJ0aWNpcGFudENoYW5nZXMubGVuZ3RoKSB7XG4gICAqICAgICAgICAgICAgICBteVZpZXcucmVuZGVyUGFydGljaXBhbnRzKGV2dC50YXJnZXQucGFydGljaXBhbnRzKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb259IGV2dC50YXJnZXRcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gZXZ0LmNoYW5nZXNcbiAgICogQHBhcmFtIHtNaXhlZH0gZXZ0LmNoYW5nZXMubmV3VmFsdWVcbiAgICogQHBhcmFtIHtNaXhlZH0gZXZ0LmNoYW5nZXMub2xkVmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dC5jaGFuZ2VzLnByb3BlcnR5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdGhhdCBoYXMgY2hhbmdlZFxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJyxcblxuICAvKipcbiAgICogQSBjYWxsIHRvIGxheWVyLkNvbnZlcnNhdGlvbi5sb2FkIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbn0gZXZ0LnRhcmdldFxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6bG9hZGVkJyxcblxuICAvKipcbiAgICogQSBuZXcgbWVzc2FnZSBoYXMgYmVlbiByZWNlaXZlZCBmb3Igd2hpY2ggYSBub3RpZmljYXRpb24gbWF5IGJlIHN1aXRhYmxlLlxuICAgKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBmb3IgbWVzc2FnZXMgdGhhdCBhcmU6XG4gICAqXG4gICAqIDEuIEFkZGVkIHZpYSB3ZWJzb2NrZXQgcmF0aGVyIHRoYW4gb3RoZXIgSU9cbiAgICogMi4gTm90IHlldCBiZWVuIG1hcmtlZCBhcyByZWFkXG4gICAqIDMuIE5vdCBzZW50IGJ5IHRoaXMgdXNlclxuICAgKlxuICAgICAgICAgIGNsaWVudC5vbignbWVzc2FnZXM6bm90aWZ5JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICAgIG15Tm90aWZ5KGV2dC5tZXNzYWdlKTtcbiAgICAgICAgICB9KVxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQuTWVzc2FnZVxuICAgKi9cbiAgJ21lc3NhZ2VzOm5vdGlmeScsXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2VzIGhhdmUgYmVlbiBhZGRlZCB0byBhIGNvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogVGhpcyBldmVudCBpcyB0cmlnZ2VyZWQgb25cbiAgICpcbiAgICogKiBjcmVhdGluZy9zZW5kaW5nIGEgbmV3IG1lc3NhZ2VcbiAgICogKiBSZWNlaXZpbmcgYSBuZXcgTWVzc2FnZSB2aWEgd2Vic29ja2V0XG4gICAqICogUXVlcnlpbmcvZG93bmxvYWRpbmcgYSBzZXQgb2YgTWVzc2FnZXNcbiAgICpcbiAgICAgICAgICBjbGllbnQub24oJ21lc3NhZ2VzOmFkZCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICBldnQubWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICBteVZpZXcuYWRkTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2VbXX0gZXZ0Lm1lc3NhZ2VzXG4gICAqL1xuICAnbWVzc2FnZXM6YWRkJyxcblxuICAvKipcbiAgICogQSBtZXNzYWdlIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBhIGNvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogQSByZW1vdmVkIE1lc3NhZ2UgaXMgbm90IG5lY2Vzc2FyaWx5IGRlbGV0ZWQsXG4gICAqIGp1c3Qgbm8gbG9uZ2VyIGJlaW5nIGhlbGQgaW4gbWVtb3J5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdHlwaWNhbGx5IHlvdSB3aWxsIHdhbnQgdGhlIG1lc3NhZ2VzOmRlbGV0ZSBldmVudFxuICAgKiByYXRoZXIgdGhhbiBtZXNzYWdlczpyZW1vdmUuXG4gICAqXG4gICAqICAgICAgY2xpZW50Lm9uKCdtZXNzYWdlczpyZW1vdmUnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgZXZ0Lm1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24obWVzc2FnZSkge1xuICAgKiAgICAgICAgICAgICAgbXlWaWV3LnJlbW92ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAqICAgICAgICAgIH0pO1xuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQubWVzc2FnZVxuICAgKi9cbiAgJ21lc3NhZ2VzOnJlbW92ZScsXG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBoYXMgYmVlbiBzZW50LlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbignbWVzc2FnZXM6c2VudCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgICBhbGVydChldnQudGFyZ2V0LmdldFRleHQoKSArICcgaGFzIGJlZW4gc2VudCcpO1xuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQudGFyZ2V0XG4gICAqL1xuICAnbWVzc2FnZXM6c2VudCcsXG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBpcyBhYm91dCB0byBiZSBzZW50LlxuICAgKlxuICAgKiBVc2VmdWwgaWYgeW91IHdhbnQgdG9cbiAgICogYWRkIHBhcnRzIHRvIHRoZSBtZXNzYWdlIGJlZm9yZSBpdCBnb2VzIG91dC5cbiAgICpcbiAgICogICAgICBjbGllbnQub24oJ21lc3NhZ2VzOnNlbmRpbmcnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgZXZ0LnRhcmdldC5hZGRQYXJ0KHtcbiAgICogICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAqICAgICAgICAgICAgICBib2R5OiAndGhpcyBpcyBqdXN0IGEgdGVzdCdcbiAgICogICAgICAgICAgfSk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2V9IGV2dC50YXJnZXRcbiAgICovXG4gICdtZXNzYWdlczpzZW5kaW5nJyxcblxuICAvKipcbiAgICogU2VydmVyIGZhaWxlZCB0byByZWNlaXZlIGEgTWVzc2FnZS5cbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFcnJvcn0gZXZ0LmVycm9yXG4gICAqL1xuICAnbWVzc2FnZXM6c2VudC1lcnJvcicsXG5cbiAgLyoqXG4gICAqIEEgbWVzc2FnZSBoYXMgaGFkIGEgY2hhbmdlIGluIGl0cyBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIGNoYW5nZSBtYXkgaGF2ZSBiZWVuIGRlbGl2ZXJlZCBmcm9tIGEgcmVtb3RlIHVzZXJcbiAgICogb3IgYXMgYSByZXN1bHQgb2YgYSBsb2NhbCBvcGVyYXRpb24uXG4gICAqXG4gICAqICAgICAgY2xpZW50Lm9uKCdtZXNzYWdlczpjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgdmFyIHJlY3BpZW50U3RhdHVzQ2hhbmdlcyA9IGV2dC5nZXRDaGFuZ2VzRm9yKCdyZWNpcGllbnRTdGF0dXMnKTtcbiAgICogICAgICAgICAgaWYgKHJlY3BpZW50U3RhdHVzQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICogICAgICAgICAgICAgIG15Vmlldy5yZW5kZXJTdGF0dXMoZXZ0LnRhcmdldCk7XG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gZXZ0LnRhcmdldFxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBldnQuY2hhbmdlc1xuICAgKiBAcGFyYW0ge01peGVkfSBldnQuY2hhbmdlcy5uZXdWYWx1ZVxuICAgKiBAcGFyYW0ge01peGVkfSBldnQuY2hhbmdlcy5vbGRWYWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0LmNoYW5nZXMucHJvcGVydHkgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGhhcyBjaGFuZ2VkXG4gICAqL1xuICAnbWVzc2FnZXM6Y2hhbmdlJyxcblxuICAvKipcbiAgICogQSBtZXNzYWdlIGhhcyBiZWVuIG1hcmtlZCBhcyByZWFkLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbiBiZSB0cmlnZ2VyZWQgYnkgYSBsb2NhbCBldmVudCwgb3IgYnkgdGhpcyBzYW1lIHVzZXIgb24gYSBzZXBhcmF0ZSBkZXZpY2Ugb3IgYnJvd3Nlci5cbiAgICpcbiAgICogICAgICBjbGllbnQub24oJ21lc3NhZ2VzOnJlYWQnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgbXlWaWV3LnJlbmRlclVucmVhZFN0YXR1cyhldnQudGFyZ2V0KTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZX0gZXZ0LnRhcmdldFxuICAgKi9cbiAgJ21lc3NhZ2VzOnJlYWQnLFxuXG4gIC8qKlxuICAgKiBBIGNhbGwgdG8gbGF5ZXIuTWVzc2FnZS5sb2FkIGhhcyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2V9IGV2dC50YXJnZXRcbiAgICovXG4gICdtZXNzYWdlczpsb2FkZWQnLFxuXG4gIC8qKlxuICAgKiBBIENvbnZlcnNhdGlvbiBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2F1c2VkIGJ5IGVpdGhlciBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBsYXllci5Db252ZXJzYXRpb24uZGVsZXRlKCkgb24gdGhlIENvbnZlcnNhdGlvblxuICAgKiBvciBieSBhIHJlbW90ZSB1c2VyLlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbignY29udmVyc2F0aW9uczpkZWxldGUnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgbXlWaWV3LnJlbW92ZUNvbnZlcnNhdGlvbihldnQudGFyZ2V0KTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7bGF5ZXIuQ29udmVyc2F0aW9ufSBldnQudGFyZ2V0XG4gICAqL1xuICAnY29udmVyc2F0aW9uczpkZWxldGUnLFxuXG4gIC8qKlxuICAgKiBBIE1lc3NhZ2UgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIENhdXNlZCBieSBlaXRoZXIgYSBzdWNjZXNzZnVsIGNhbGwgdG8gbGF5ZXIuTWVzc2FnZS5kZWxldGUoKSBvbiB0aGUgTWVzc2FnZVxuICAgKiBvciBieSBhIHJlbW90ZSB1c2VyLlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbignbWVzc2FnZXM6ZGVsZXRlJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAqICAgICAgICAgIG15Vmlldy5yZW1vdmVNZXNzYWdlKGV2dC50YXJnZXQpO1xuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBldnQudGFyZ2V0XG4gICAqL1xuICAnbWVzc2FnZXM6ZGVsZXRlJyxcblxuICAvKipcbiAgICogQSBVc2VyIGhhcyBiZWVuIGFkZGVkIG9yIGNoYW5nZWQgaW4gdGhlIHVzZXJzIGFycmF5LlxuICAgKlxuICAgKiBUaGlzIGV2ZW50IGlzIG5vdCB5ZXQgd2VsbCBzdXBwb3J0ZWQuXG4gICAqIEBldmVudFxuICAgKi9cbiAgJ3VzZXJzOmNoYW5nZScsXG5cbiAgLyoqXG4gICAqIEEgVHlwaW5nIEluZGljYXRvciBzdGF0ZSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogRWl0aGVyIGEgY2hhbmdlIGhhcyBiZWVuIHJlY2VpdmVkXG4gICAqIGZyb20gdGhlIHNlcnZlciwgb3IgYSB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlIGhhcyBleHBpcmVkLlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5vbigndHlwaW5nLWluZGljYXRvci1jaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICogICAgICAgICAgaWYgKGV2dC5jb252ZXJzYXRpb25JZCA9PT0gbXlDb252ZXJzYXRpb25JZCkge1xuICAgKiAgICAgICAgICAgICAgYWxlcnQoZXZ0LnR5cGluZy5qb2luKCcsICcpICsgJyBhcmUgdHlwaW5nJyk7XG4gICAqICAgICAgICAgICAgICBhbGVydChldnQucGF1c2VkLmpvaW4oJywgJykgKyAnIGFyZSBwYXVzZWQnKTtcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnZlcnNhdGlvbklkIC0gSUQgb2YgdGhlIENvbnZlcnNhdGlvbiB1c2VycyBhcmUgdHlwaW5nIGludG9cbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gdHlwaW5nIC0gQXJyYXkgb2YgdXNlciBJRHMgd2hvIGFyZSBjdXJyZW50bHkgdHlwaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdXNlZCAtIEFycmF5IG9mIHVzZXIgSURzIHdobyBhcmUgY3VycmVudGx5IHBhdXNlZDtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBwYXVzZWQgdXNlciBzdGlsbCBoYXMgdGV4dCBpbiB0aGVpciB0ZXh0IGJveC5cbiAgICovXG4gICd0eXBpbmctaW5kaWNhdG9yLWNoYW5nZScsXG5cblxuXS5jb25jYXQoQ2xpZW50QXV0aC5fc3VwcG9ydGVkRXZlbnRzKTtcblxuQ2xpZW50LnBsdWdpbnMgPSB7fTtcblxuXG5Sb290LmluaXRDbGFzcy5hcHBseShDbGllbnQsIFtDbGllbnQsICdDbGllbnQnXSk7XG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudDtcbiIsIi8qKlxuICogTGF5ZXIgQ29uc3RhbnRzIGFyZSBzdG9yZWQgaW4gdHdvIHBsYWNlczpcbiAqXG4gKiAxLiBBcyBwYXJ0IG9mIHRoZSBsYXllci5Db25zdGFudHMgc2luZ2xldG9uXG4gKiAyLiBBcyBzdGF0aWMgcHJvcGVydGllcyBvbiBjbGFzc2VzLlxuICpcbiAqIFR5cGljYWxseSB0aGUgc3RhdGljIHByb3BlcnR5IGNvbnN0YW50cyBhcmUgZGVzaWduZWQgdG8gYmUgY2hhbmdlZCBieSBkZXZlbG9wZXJzIHRvIGN1c3RvbWl6ZSBiZWhhdmlvcnMsXG4gKiBhbmQgdGVuZCB0byBvbmx5IGJlIHVzZWQgYnkgdGhhdCBzaW5nbGUgY2xhc3MuXG4gKlxuICogQGNsYXNzIGxheWVyLkNvbnN0YW50c1xuICogQHNpbmdsZXRvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIElzIHRoZSBvYmplY3Qgc3luY2hyb25pemVkIHdpdGggdGhlIHNlcnZlcj9cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFtTWU5DX1NUQVRFPW51bGxdXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTWU5DX1NUQVRFLk5FVyAgICAgIC0gT2JqZWN0IGlzIG5ld2x5IGNyZWF0ZWQsIHdhcyBjcmVhdGVkIGxvY2FsbHksIG5vdCBmcm9tIHNlcnZlciBkYXRhLCBhbmQgaGFzIG5vdCB5ZXQgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTWU5DX1NUQVRFLlNBVklORyAgIC0gT2JqZWN0IGlzIG5ld2x5IGNyZWF0ZWQgYW5kIGlzIGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFNZTkNfU1RBVEUuU1lOQ0lORyAgLSBPYmplY3QgZXhpc3RzIGJvdGggbG9jYWxseSBhbmQgb24gc2VydmVyIGJ1dCBpcyBiZWluZyBzeW5jZWQgd2l0aCBjaGFuZ2VzLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gU1lOQ19TVEFURS5TWU5DRUQgICAtIE9iamVjdCBleGlzdHMgYm90aCBsb2NhbGx5IGFuZCBvbiBzZXJ2ZXIgYW5kIGF0IGxhc3QgY2hlY2sgd2FzIGluIHN5bmMuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBTWU5DX1NUQVRFLkxPQURJTkcgIC0gT2JqZWN0IGlzIGJlaW5nIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIgYW5kIG1heSBub3QgaGF2ZSBpdHMgcHJvcGVydGllcyBzZXQgeWV0LlxuICAgKi9cbiAgU1lOQ19TVEFURToge1xuICAgIE5FVzogJ05FVycsXG4gICAgU0FWSU5HOiAnU0FWSU5HJyxcbiAgICBTWU5DSU5HOiAnU1lOQ0lORycsXG4gICAgU1lOQ0VEOiAnU1lOQ0VEJyxcbiAgICBMT0FESU5HOiAnTE9BRElORycsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbHVlcyBmb3IgcmVhZFN0YXR1cy9kZWxpdmVyeVN0YXR1c1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gW1JFQ0lQSUVOVF9TVEFURT1dXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRUNJUElFTlRfU1RBVEUuTk9ORSAtIE5vIHVzZXJzIGhhdmUgcmVhZCAob3IgcmVjZWl2ZWQpIHRoaXMgTWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gUkVDSVBJRU5UX1NUQVRFLlNPTUUgLSBTb21lIHVzZXJzIGhhdmUgcmVhZCAob3IgcmVjZWl2ZWQpIHRoaXMgTWVzc2FnZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gUkVDSVBJRU5UX1NUQVRFLkFMTCAgLSBBbGwgdXNlcnMgaGF2ZSByZWFkIChvciByZWNlaXZlZCkgdGhpcyBNZXNzYWdlXG4gICAqL1xuICBSRUNJUElFTlRfU1RBVEU6IHtcbiAgICBOT05FOiAnTk9ORScsXG4gICAgU09NRTogJ1NPTUUnLFxuICAgIEFMTDogJ0FMTCcsXG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbHVlcyBmb3IgcmVjaXBpZW50U3RhdHVzXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbUkVDRUlQVF9TVEFURT1dXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRUNFSVBUX1NUQVRFLlNFTlQgICAgICAtIFRoZSBNZXNzYWdlIGhhcyBiZWVuIHNlbnQgdG8gdGhlIHNwZWNpZmllZCB1c2VyIGJ1dCBpdCBoYXMgbm90IHlldCBiZWVuIHJlY2VpdmVkIGJ5IHRoZWlyIGRldmljZS5cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IFJFQ0VJUFRfU1RBVEUuREVMSVZFUkVEIC0gVGhlIE1lc3NhZ2UgaGFzIGJlZW4gZGVsaXZlcmVkIHRvIHRoZSBzcGVjaWZpZWQgdXNlIGJ1dCBoYXMgbm90IHlldCBiZWVuIHJlYWQuXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBSRUNFSVBUX1NUQVRFLlJFQUQgICAgICAtIFRoZSBNZXNzYWdlIGhhcyBiZWVuIHJlYWQgYnkgdGhlIHNwZWNpZmllZCB1c2VyLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gUkVDRUlQVF9TVEFURS5QRU5ESU5HICAgLSBUaGUgcmVxdWVzdCB0byBzZW5kIHRoaXMgTWVzc2FnZSB0byB0aGUgc3BlY2lmaWVkIHVzZXIgaGFzIG5vdCB5ZXQgYmVlbiByZWNlaXZlZCBieSB0aGUgc2VydmVyLlxuICAgKi9cbiAgUkVDRUlQVF9TVEFURToge1xuICAgIFNFTlQ6ICdzZW50JyxcbiAgICBERUxJVkVSRUQ6ICdkZWxpdmVyZWQnLFxuICAgIFJFQUQ6ICdyZWFkJyxcbiAgICBQRU5ESU5HOiAncGVuZGluZycsXG4gIH0sXG4gIExPQ0FMU1RPUkFHRV9LRVlTOiB7XG4gICAgU0VTU0lPTkRBVEE6ICdsYXllci1zZXNzaW9uLWRhdGEtJyxcbiAgfSxcbiAgQUNDRVBUOiAnYXBwbGljYXRpb24vdm5kLmxheWVyK2pzb247IHZlcnNpb249MS4wJyxcblxuICAvKipcbiAgICogTG9nIGxldmVsc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gW0xPRz1dXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0cuREVCVUcgICAgIExvZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCByZXF1ZXN0cywgcmVzcG9uc2VzLCBldmVudHMsIHN0YXRlIGNoYW5nZXMsIGV0Yy4uLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gTE9HLklORk8gICAgICBMb2cgc3BhcnNlIGluZm9ybWF0aW9uIGFib3V0IHJlcXVlc3RzLCByZXNwb25zZXMgYW5kIGV2ZW50c1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gTE9HLldBUk4gICAgICBMb2cgZmFpbHVyZXMgdGhhdCBhcmUgZXhwZWN0ZWQsIG5vcm1hbCwgaGFuZGxlZCwgYnV0IHN1Z2dlc3RzIHRoYXQgYW4gb3BlcmF0aW9uIGRpZG4ndCBjb21wbGV0ZSBhcyBpbnRlbmRlZFxuICAgKiBAcHJvcGVydHkge251bWJlcn0gTE9HLkVSUk9SICAgICBMb2cgZmFpbHVyZXMgdGhhdCBhcmUgbm90IGV4cGVjdGVkIG9yIGNvdWxkIG5vdCBiZSBoYW5kbGVkXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMT0cuTk9ORSAgICAgIExvZ3M/IFdobyBuZWVkcyBlbT9cbiAgICovXG4gIExPRzoge1xuICAgIERFQlVHOiA0LFxuICAgIElORk86IDMsXG4gICAgV0FSTjogMixcbiAgICBFUlJPUjogMSxcbiAgICBOT05FOiAwLFxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGlvbiBNb2Rlc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gW0RFTEVUSU9OX01PREU9XVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gREVMRVRJT05fTU9ERS5BTEwgICAgICAgICAgRGVsZXRlIE1lc3NhZ2UvQ29udmVyc2F0aW9uIGZvciBBbGwgdXNlcnMgYnV0IHJlbWFpbiBpbiB0aGUgQ29udmVyc2F0aW9uO1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IE1lc3NhZ2VzIHdpbGwgcmVzdG9yZSB0aGlzIENvbnZlcnNhdGlvbiBtaW51cyBhbnkgTWVzc2FnZSBIaXN0b3J5IHByaW9yIHRvIGRlbGV0aW9uLlxuICAgKiBAcHJvcGVydHkge251bWJlcn0gREVMRVRJT05fTU9ERS5NWV9ERVZJQ0VTICAgRGVsZXRlIE1lc3NhZ2Ugb3IgQ29udmVyc2F0aW9uOyBidXQgc2VlIGxheWVyLkNvbnZlcnNhdGlvbi5sZWF2ZSBpZiB5b3Ugd2FudCB0byBkZWxldGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgQ29udmVyc2F0aW9uIGFuZCBub3QgaGF2ZSBpdCBjb21lIGJhY2suXG4gICAqL1xuICBERUxFVElPTl9NT0RFOiB7XG4gICAgQUxMOiAxLFxuICAgIE1ZX0RFVklDRVM6IDIsXG4gIH0sXG59O1xuIiwiLyoqXG4gKiBUaGUgQ29udGVudCBjbGFzcyByZXByZXNlbnRzIFJpY2ggQ29udGVudC5cbiAqXG4gKiBOb3RlIHRoYXQgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3Mgd2lsbCBhdXRvbWF0aWNhbGx5IGJlXG4gKiBnZW5lcmF0ZWQgZm9yIGRldmVsb3BlcnMgYmFzZWQgb24gd2hldGhlciB0aGVpciBtZXNzYWdlIHBhcnRzXG4gKiByZXF1aXJlIGl0LlxuICpcbiAqIFRoYXQgbWVhbnMgZm9yIHRoZSBtb3N0IHBhcnQsIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0b1xuICogaW5zdGFudGlhdGUgb25lIG9mIHRoZXNlIGRpcmVjdGx5LlxuICpcbiAqICAgICAgdmFyIGNvbnRlbnQgPSBuZXcgbGF5ZXIuQ29udGVudCh7XG4gKiAgICAgICAgICBpZDogJ2xheWVyOi8vL2NvbnRlbnQvOGM4Mzk3MzUtNWY5NS00MzlhLWE4NjctMzA5MDNjMDEzM2YyJ1xuICogICAgICB9KTtcbiAqXG4gKiBAY2xhc3MgIGxheWVyLkNvbnRlbnRcbiAqIEBwcm90ZWN0ZWRcbiAqIEBleHRlbmRzIGxheWVyLlJvb3RcbiAqIEBhdXRob3IgTWljaGFlbCBLYW50b3JcbiAqL1xuXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCB4aHIgPSByZXF1aXJlKCcuL3hocicpO1xuXG5jbGFzcyBDb250ZW50IGV4dGVuZHMgUm9vdCB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSAge3N0cmluZ30gb3B0aW9ucy5pZCAtIElkZW50aWZpZXIgZm9yIHRoZSBjb250ZW50XG4gICAqIEBwYXJhbSAge3N0cmluZ30gW29wdGlvbnMuZG93bmxvYWRVcmw9bnVsbF0gLSBVcmwgdG8gZG93bmxvYWQgdGhlIGNvbnRlbnQgZnJvbVxuICAgKiBAcGFyYW0gIHtEYXRlfSBbb3B0aW9ucy5leHBpcmF0aW9uXSAtIEV4cGlyYXRpb24gZGF0ZSBmb3IgdGhlIHVybFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHRpb25zLnJlZnJlc2hVcmxdIC0gVXJsIHRvIGFjY2VzcyB0byBnZXQgYSBuZXcgZG93bmxvYWRVcmwgYWZ0ZXIgaXQgaGFzIGV4cGlyZWRcbiAgICpcbiAgICogQHJldHVybiB7bGF5ZXIuQ29udGVudH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHRpb25zID0geyBpZDogb3B0aW9ucyB9O1xuICAgIH1cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkcyB0aGUgZGF0YSBmcm9tIGdvb2dsZSdzIGNsb3VkIHN0b3JhZ2UuXG4gICAqXG4gICAqIERhdGEgaXMgcHJvdmlkZWQgdmlhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdHlwaWNhbGx5IG9uZSBzaG91bGQgdXNlIGxheWVyLk1lc3NhZ2VQYXJ0LmZldGNoQ29udGVudCgpIHJhdGhlciB0aGFuIGxheWVyLkNvbnRlbnQubG9hZENvbnRlbnQoKVxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRDb250ZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSAtIE1pbWUgdHlwZSBmb3IgdGhlIEJsb2JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtCbG9ifSBjYWxsYmFjay5kYXRhIC0gQSBCbG9iIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgZGF0YSBkb3dubG9hZGVkLiAgSWYgQmxvYiBvYmplY3QgaXMgbm90IGF2YWlsYWJsZSwgdGhlbiBtYXkgdXNlIG90aGVyIGZvcm1hdC5cbiAgICovXG4gIGxvYWRDb250ZW50KG1pbWVUeXBlLCBjYWxsYmFjaykge1xuICAgIHhocih7XG4gICAgICB1cmw6IHRoaXMuZG93bmxvYWRVcmwsXG4gICAgICByZXNwb25zZVR5cGU6ICdhcnJheWJ1ZmZlcicsXG4gICAgfSwgcmVzdWx0ID0+IHtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBpZiAodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtyZXN1bHQuZGF0YV0sIHsgdHlwZTogbWltZVR5cGUgfSk7XG4gICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGJsb2IgY2xhc3MgaXNuJ3QgZGVmaW5lZCAobm9kZWpzKSB0aGVuIGp1c3QgcmV0dXJuIHRoZSByZXN1bHQgYXMgaXNcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdC5kYXRhLCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgdGhlIFVSTCwgd2hpY2ggdXBkYXRlcyB0aGUgVVJMIGFuZCByZXNldHMgdGhlIGV4cGlyYXRpb24gdGltZSBmb3IgdGhlIFVSTFxuICAgKlxuICAgKiBAbWV0aG9kIHJlZnJlc2hDb250ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKi9cbiAgcmVmcmVzaENvbnRlbnQoY2xpZW50LCBjYWxsYmFjaykge1xuICAgIGNsaWVudC54aHIoe1xuICAgICAgdXJsOiB0aGlzLnJlZnJlc2hVcmwsXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgIH0sIHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IHJlc3VsdDtcbiAgICAgIHRoaXMuZXhwaXJhdGlvbiA9IG5ldyBEYXRlKGRhdGEuZXhwaXJhdGlvbik7XG4gICAgICB0aGlzLmRvd25sb2FkVXJsID0gZGF0YS5kb3dubG9hZF91cmw7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHRoaXMuZG93bmxvYWRVcmwpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBkb3dubG9hZCB1cmwgZXhwaXJlZCBvciBhYm91dCB0byBleHBpcmU/XG4gICAqIFdlIGNhbid0IGJlIHN1cmUgb2YgdGhlIHN0YXRlIG9mIHRoZSBkZXZpY2UncyBpbnRlcm5hbCBjbG9jayxcbiAgICogc28gaWYgaXRzIHdpdGhpbiAxMCBtaW51dGVzIG9mIGV4cGlyaW5nLCBqdXN0IHRyZWF0IGl0IGFzIGV4cGlyZWQuXG4gICAqXG4gICAqIEBtZXRob2QgaXNFeHBpcmVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNFeHBpcmVkKCkge1xuICAgIGNvbnN0IGV4cGlyYXRpb25MZWV3YXkgPSAxMCAqIDYwICogMTAwMDtcbiAgICByZXR1cm4gKHRoaXMuZXhwaXJhdGlvbi5nZXRUaW1lKCkgLSBleHBpcmF0aW9uTGVld2F5IDwgRGF0ZS5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIE1lc3NhZ2VQYXJ0IGZyb20gYSBzZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBhcnRcbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlRnJvbVNlcnZlclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGFydCAtIFNlcnZlciByZXByZXNlbnRhdGlvbiBvZiBhIHBhcnRcbiAgICovXG4gIHN0YXRpYyBfY3JlYXRlRnJvbVNlcnZlcihwYXJ0KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50KHtcbiAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgZG93bmxvYWRVcmw6IHBhcnQuZG93bmxvYWRfdXJsLFxuICAgICAgZXhwaXJhdGlvbjogbmV3IERhdGUocGFydC5leHBpcmF0aW9uKSxcbiAgICAgIHJlZnJlc2hVcmw6IHBhcnQucmVmcmVzaF91cmwsXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXJ2ZXIgZ2VuZXJhdGVkIGlkZW50aWZpZXJcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkNvbnRlbnQucHJvdG90eXBlLmlkID0gJyc7XG5cbkNvbnRlbnQucHJvdG90eXBlLmJsb2IgPSBudWxsO1xuXG4vKipcbiAqIFNlcnZlciBnZW5lcmF0ZWQgdXJsIGZvciBkb3dubG9hZGluZyB0aGUgY29udGVudFxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuQ29udGVudC5wcm90b3R5cGUuZG93bmxvYWRVcmwgPSAnJztcblxuLyoqXG4gKiBVcmwgZm9yIHJlZnJlc2hpbmcgdGhlIGRvd25sb2FkVXJsIGFmdGVyIGl0IGhhcyBleHBpcmVkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Db250ZW50LnByb3RvdHlwZS5yZWZyZXNoVXJsID0gJyc7XG5cbi8qKlxuICogU2l6ZSBvZiB0aGUgY29udGVudC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IG9ubHkgaGFzIGEgdmFsdWUgd2hlbiBpbiB0aGUgcHJvY2Vzc1xuICogb2YgQ3JlYXRpbmcgdGhlIHJpY2ggY29udGVudCBhbmQgc2VuZGluZyB0aGUgTWVzc2FnZS5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5Db250ZW50LnByb3RvdHlwZS5zaXplID0gMDtcblxuLyoqXG4gKiBFeHBpcmF0aW9uIGRhdGUgZm9yIHRoZSBkb3dubG9hZFVybFxuICogQHR5cGUge0RhdGV9XG4gKi9cbkNvbnRlbnQucHJvdG90eXBlLmV4cGlyYXRpb24gPSBudWxsO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShDb250ZW50LCBbQ29udGVudCwgJ0NvbnRlbnQnXSk7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnRlbnQ7XG4iLCIvKipcbiAqIEEgQ29udmVyc2F0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgZGlhbG9nIGFtb25nc3QgYSBzZXRcbiAqIG9mIHBhcnRpY2lwYW50cy5cbiAqXG4gKiBDcmVhdGUgYSBDb252ZXJzYXRpb24gdXNpbmcgdGhlIGNsaWVudDpcbiAqXG4gKiAgICAgIHZhciBjb252ZXJzYXRpb24gPSBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKHtcbiAqICAgICAgICAgIHBhcnRpY2lwYW50czogWydhJywnYiddLFxuICogICAgICAgICAgZGlzdGluY3Q6IHRydWVcbiAqICAgICAgfSk7XG4gKlxuICogSW4gYWRkaXRpb24sIHRoZXJlIGlzIGEgc2hvcnRjdXQgbWV0aG9kIGZvciBjcmVhdGluZ1xuICogYSBjb252ZXJzYXRpb24sIHdoaWNoIHdpbGwgZGVmYXVsdCB0byBjcmVhdGluZyBhIERpc3RpbmN0XG4gKiBDb252ZXJzYXRpb24uXG4gKlxuICogICAgICB2YXIgY29udmVyc2F0aW9uID0gY2xpZW50LmNyZWF0ZUNvbnZlcnNhdGlvbihbJ2EnLCdiJ10pO1xuICpcbiAqIE5PVEU6ICAgRG8gbm90IGNyZWF0ZSBhIGNvbnZlcnNhdGlvbiB3aXRoIG5ldyBsYXllci5Db252ZXJzYXRpb24oLi4uKSxcbiAqICAgICAgICAgVGhpcyB3aWxsIGZhaWwgdG8gaGFuZGxlIHRoZSBkaXN0aW5jdCBwcm9wZXJ0eSBzaG9ydCBvZiBnb2luZyB0byB0aGUgc2VydmVyIGZvciBldmFsdWF0aW9uLlxuICpcbiAqIE5PVEU6ICAgQ3JlYXRpbmcgYSBDb252ZXJzYXRpb24gaXMgYSBsb2NhbCBhY3Rpb24uICBBIENvbnZlcnNhdGlvbiB3aWxsIG5vdCBiZVxuICogICAgICAgICBzZW50IHRvIHRoZSBzZXJ2ZXIgdW50aWwgZWl0aGVyOlxuICpcbiAqIDEuIEEgbWVzc2FnZSBpcyBzZW50IG9uIHRoYXQgQ29udmVyc2F0aW9uXG4gKiAyLiBgQ29udmVyc2F0aW9uLnNlbmQoKWAgaXMgY2FsbGVkIChub3QgcmVjb21tZW5kZWQgYXMgbW9iaWxlIGNsaWVudHNcbiAqICAgIGV4cGVjdCBhdCBsZWFzdCBvbmUgbGF5ZXIuTWVzc2FnZSBpbiBhIENvbnZlcnNhdGlvbilcbiAqXG4gKiBLZXkgbWV0aG9kcywgZXZlbnRzIGFuZCBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIHN0YXJ0ZWQ6XG4gKlxuICogUHJvcGVydGllczpcbiAqXG4gKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5pZDogdGhpcyBwcm9wZXJ0eSBpcyB3b3J0aCBiZWluZyBmYW1pbGlhciB3aXRoOyBpdCBpZGVudGlmaWVzIHRoZVxuICogICBDb252ZXJzYXRpb24gYW5kIGNhbiBiZSB1c2VkIGluIGBjbGllbnQuZ2V0Q29udmVyc2F0aW9uKGlkKWAgdG8gcmV0cmlldmUgaXQuXG4gKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5pbnRlcm5hbElkOiBUaGlzIHByb3BlcnR5IG1ha2VzIGZvciBhIGhhbmR5IHVuaXF1ZSBJRCBmb3IgdXNlIGluIGRvbSBub2RlcztcbiAqICAgZ2F1cmVudGVlZCBub3QgdG8gY2hhbmdlIGR1cmluZyB0aGlzIHNlc3Npb24uXG4gKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZTogVGhpcyBwcm9wZXJ0eSBtYWtlcyBpdCBlYXN5IHRvIHNob3cgaW5mbyBhYm91dCB0aGUgbW9zdCByZWNlbnQgTWVzc2FnZVxuICogICAgd2hlbiByZW5kZXJpbmcgYSBsaXN0IG9mIENvbnZlcnNhdGlvbnMuXG4gKiAqIGxheWVyLkNvbnZlcnNhdGlvbi5tZXRhZGF0YTogQ3VzdG9tIGRhdGEgZm9yIHlvdXIgQ29udmVyc2F0aW9uOyBjb21tb25seSB1c2VkIHRvIHN0b3JlIGEgJ3RpdGxlJyBwcm9wZXJ0eVxuICogICAgdG8gbmFtZSB5b3VyIENvbnZlcnNhdGlvbi5cbiAqXG4gKiBNZXRob2RzOlxuICpcbiAqICogbGF5ZXIuQ29udmVyc2F0aW9uLmFkZFBhcnRpY2lwYW50cyBhbmQgbGF5ZXIuQ29udmVyc2F0aW9uLnJlbW92ZVBhcnRpY2lwYW50czogQ2hhbmdlIHRoZSBwYXJ0aWNpcGFudHMgb2YgdGhlIENvbnZlcnNhdGlvblxuICogKiBsYXllci5Db252ZXJzYXRpb24uc2V0TWV0YWRhdGFQcm9wZXJ0aWVzOiBTZXQgbWV0YWRhdGEudGl0bGUgdG8gJ015IENvbnZlcnNhdGlvbiB3aXRoIExheWVyIFN1cHBvcnQnICh1aCBvaClcbiAqICogbGF5ZXIuQ29udmVyc2F0aW9uLm9uKCkgYW5kIGxheWVyLkNvbnZlcnNhdGlvbi5vZmYoKTogZXZlbnQgbGlzdGVuZXJzIGJ1aWx0IG9uIHRvcCBvZiB0aGUgYGJhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lYCBucG0gcHJvamVjdFxuICogKiBsYXllci5Db252ZXJzYXRpb24ubGVhdmUoKSB0byBsZWF2ZSB0aGUgQ29udmVyc2F0aW9uXG4gKlxuICogRXZlbnRzOlxuICpcbiAqICogYGNvbnZlcnNhdGlvbnM6Y2hhbmdlYDogVXNlZnVsIGZvciBvYnNlcnZpbmcgY2hhbmdlcyB0byBwYXJ0aWNpcGFudHMgYW5kIG1ldGFkYXRhXG4gKiAgIGFuZCB1cGRhdGluZyByZW5kZXJpbmcgb2YgeW91ciBvcGVuIENvbnZlcnNhdGlvblxuICpcbiAqIEZpbmFsbHksIHRvIGFjY2VzcyBhIGxpc3Qgb2YgTWVzc2FnZXMgaW4gYSBDb252ZXJzYXRpb24sIHNlZSBsYXllci5RdWVyeS5cbiAqXG4gKiBAY2xhc3MgIGxheWVyLkNvbnZlcnNhdGlvblxuICogQGV4dGVuZHMgbGF5ZXIuU3luY2FibGVcbiAqIEBhdXRob3IgIE1pY2hhZWwgS2FudG9yXG4gKi9cblxuY29uc3QgU3luY2FibGUgPSByZXF1aXJlKCcuL3N5bmNhYmxlJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi9tZXNzYWdlJyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi9sYXllci1lcnJvcicpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4vY2xpZW50LXV0aWxzJyk7XG5jb25zdCBDb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0Jyk7XG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCBMYXllckV2ZW50ID0gcmVxdWlyZSgnLi9sYXllci1ldmVudCcpO1xuY29uc3QgQ2xpZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL2NsaWVudC1yZWdpc3RyeScpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuY2xhc3MgQ29udmVyc2F0aW9uIGV4dGVuZHMgU3luY2FibGUge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgY29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBUaGUgc3RhdGljIGBsYXllci5Db252ZXJzYXRpb24uY3JlYXRlKClgIG1ldGhvZFxuICAgKiB3aWxsIGNvcnJlY3RseSBsb29rdXAgZGlzdGluY3QgQ29udmVyc2F0aW9ucyBhbmRcbiAgICogcmV0dXJuIHRoZW07IGBuZXcgbGF5ZXIuQ29udmVyc2F0aW9uKClgIHdpbGwgbm90LlxuICAgKlxuICAgKiBEZXZlbG9wZXJzIHNob3VsZCB1c2UgYGxheWVyLkNvbnZlcnNhdGlvbi5jcmVhdGUoKWAuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gb3B0aW9ucy5wYXJ0aWNpcGFudHMgLSBBcnJheSBvZiBwYXJ0aWNpcGFudCBpZHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kaXN0aW5jdD10cnVlXSAtIElzIHRoZSBjb252ZXJzYXRpb24gZGlzdGluY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1ldGFkYXRhXSAtIEFuIG9iamVjdCBjb250YWluaW5nIENvbnZlcnNhdGlvbiBNZXRhZGF0YS5cbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gU2V0dXAgZGVmYXVsdCB2YWx1ZXNcbiAgICBpZiAoIW9wdGlvbnMucGFydGljaXBhbnRzKSBvcHRpb25zLnBhcnRpY2lwYW50cyA9IFtdO1xuICAgIGlmICghb3B0aW9ucy5tZXRhZGF0YSkgb3B0aW9ucy5tZXRhZGF0YSA9IHt9O1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBJRCBmcm9tIGhhbmRsZSBmcm9tU2VydmVyIHBhcmFtZXRlciBpcyB1c2VkIGJ5IHRoZSBSb290LmNvbnN0cnVjdG9yXG4gICAgaWYgKG9wdGlvbnMuZnJvbVNlcnZlcikgb3B0aW9ucy5pZCA9IG9wdGlvbnMuZnJvbVNlcnZlci5pZDtcblxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGFuIGNsaWVudElkIHByb3BlcnR5XG4gICAgaWYgKG9wdGlvbnMuY2xpZW50KSBvcHRpb25zLmNsaWVudElkID0gb3B0aW9ucy5jbGllbnQuYXBwSWQ7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcblxuXG4gICAgdGhpcy5pc0luaXRpYWxpemluZyA9IHRydWU7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcblxuICAgIC8vIElmIHRoZSBvcHRpb25zIGNvbnRhaW5zIGEgZnVsbCBzZXJ2ZXIgZGVmaW5pdGlvbiBvZiB0aGUgb2JqZWN0LFxuICAgIC8vIGNvcHkgaXQgaW4gd2l0aCBfcG9wdWxhdGVGcm9tU2VydmVyOyB0aGlzIHdpbGwgYWRkIHRoZSBDb252ZXJzYXRpb25cbiAgICAvLyB0byB0aGUgQ2xpZW50IGFzIHdlbGwuXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mcm9tU2VydmVyKSB7XG4gICAgICB0aGlzLl9wb3B1bGF0ZUZyb21TZXJ2ZXIob3B0aW9ucy5mcm9tU2VydmVyKTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCBwYXJ0aWNpcGFudHNcbiAgICBlbHNlIGlmIChjbGllbnQgJiYgdGhpcy5wYXJ0aWNpcGFudHMuaW5kZXhPZihjbGllbnQudXNlcklkKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGFydGljaXBhbnRzLnB1c2goY2xpZW50LnVzZXJJZCk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2NhbENyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAoY2xpZW50KSBjbGllbnQuX2FkZENvbnZlcnNhdGlvbih0aGlzKTtcbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGUgbG9jYWwgY29weSBvZiB0aGlzIENvbnZlcnNhdGlvbiwgY2xlYW5pbmcgdXAgYWxsIHJlc291cmNlc1xuICAgKiBpdCBjb25zdW1lcy5cbiAgICpcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMubGFzdE1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLy8gQ2xpZW50IGZpcmVzICdjb252ZXJzYXRpb25zOnJlbW92ZScgYW5kIHRoZW4gcmVtb3ZlcyB0aGUgQ29udmVyc2F0aW9uLlxuICAgIGlmICh0aGlzLmNsaWVudElkKSB0aGlzLmdldENsaWVudCgpLl9yZW1vdmVDb252ZXJzYXRpb24odGhpcyk7XG5cbiAgICBzdXBlci5kZXN0cm95KCk7XG5cbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IG51bGw7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjbGllbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQ29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIGdldENsaWVudFxuICAgKiBAcmV0dXJuIHtsYXllci5DbGllbnR9XG4gICAqL1xuICBnZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIENsaWVudFJlZ2lzdHJ5LmdldCh0aGlzLmNsaWVudElkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhpcyBDb252ZXJzYXRpb24gb24gdGhlIHNlcnZlci5cbiAgICpcbiAgICogT24gY29tcGxldGlvbiwgdGhpcyBpbnN0YW5jZSB3aWxsIHJlY2VpdmVcbiAgICogYW4gaWQsIHVybCBhbmQgY3JlYXRlZEF0LiAgSXQgbWF5IGFsc28gcmVjZWl2ZSBtZXRhZGF0YVxuICAgKiBpZiB0aGVyZSB3YXMgYSBGT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQSByZXN1bHQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgb3B0aW9uYWwgTWVzc2FnZSBwYXJhbWV0ZXIgc2hvdWxkIE5PVCBiZSB1c2VkIGV4Y2VwdFxuICAgKiBieSB0aGUgbGF5ZXIuTWVzc2FnZSBjbGFzcyBpdHNlbGYuXG4gICAqXG4gICAqIE5vdGUgdGhhdCByZWNvbW1lbmRlZCBwcmFjdGljZSBpcyB0byBzZW5kIHRoZSBDb252ZXJzYXRpb24gYnkgc2VuZGluZyBhIE1lc3NhZ2UgaW4gdGhlIENvbnZlcnNhdGlvbixcbiAgICogYW5kIE5PVCBieSBjYWxsaW5nIENvbnZlcnNhdGlvbi5zZW5kLlxuICAgKlxuICAgKiAgICAgIGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oe1xuICAgKiAgICAgICAgICBwYXJ0aWNpcGFudHM6IFsnYScsICdiJ10sXG4gICAqICAgICAgICAgIGRpc3RpbmN0OiBmYWxzZVxuICAgKiAgICAgIH0pXG4gICAqICAgICAgLnNlbmQoKVxuICAgKiAgICAgIC5vbignY29udmVyc2F0aW9uczpzZW50JywgZnVuY3Rpb24oZXZ0KSB7XG4gICAqICAgICAgICAgIGFsZXJ0KCdEb25lJyk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2Qgc2VuZFxuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2V9IFttZXNzYWdlXSBUZWxscyB0aGUgQ29udmVyc2F0aW9uIHdoYXQgaXRzIGxhc3RfbWVzc2FnZSB3aWxsIGJlXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKi9cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoIWNsaWVudCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jbGllbnRNaXNzaW5nKTtcblxuICAgIC8vIElmIHRoaXMgaXMgcGFydCBvZiBhIGNyZWF0ZSh7ZGlzdGluY3Q6dHJ1ZX0pLnNlbmQoKSBjYWxsIHdoZXJlXG4gICAgLy8gdGhlIGRpc3RpbmN0IGNvbnZlcnNhdGlvbiB3YXMgZm91bmQsIGp1c3QgdHJpZ2dlciB0aGUgY2FjaGVkIGV2ZW50IGFuZCBleGl0XG4gICAgaWYgKHRoaXMuX3NlbmREaXN0aW5jdEV2ZW50KSByZXR1cm4gdGhpcy5faGFuZGxlTG9jYWxEaXN0aW5jdENvbnZlcnNhdGlvbigpO1xuXG4gICAgLy8gSWYgYSBtZXNzYWdlIGlzIHBhc3NlZCBpbiwgdGhlbiB0aGF0IG1lc3NhZ2UgaXMgYmVpbmcgc2VudCwgYW5kIGlzIG91clxuICAgIC8vIG5ldyBsYXN0TWVzc2FnZSAodW50aWwgdGhlIHdlYnNvY2tldCB0ZWxscyB1cyBvdGhlcndpc2UpXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgIC8vIFNldHRpbmcgYSBwb3NpdGlvbiBpcyByZXF1aXJlZCBpZiBpdHMgZ29pbmcgdG8gZ2V0IHNvcnRlZCBjb3JyZWN0bHkgYnkgcXVlcnkuXG4gICAgICAvLyBUaGUgY29ycmVjdCBwb3NpdGlvbiB3aWxsIGJlIHdyaXR0ZW4gYnkgX3BvcHVsYXRlRnJvbVNlcnZlciB3aGVuIHRoZSBvYmplY3RcbiAgICAgIC8vIGlzIHJldHVybmVkIGZyb20gdGhlIHNlcnZlci4gIFdlIGluY3JlbWVudCB0aGUgcG9zaXRpb24gYnkgdGhlIHRpbWUgc2luY2UgdGhlIHByaW9yIGxhc3RNZXNzYWdlIHdhcyBzZW50XG4gICAgICAvLyBzbyB0aGF0IGlmIG11bHRpcGxlIHRhYnMgYXJlIHNlbmRpbmcgbWVzc2FnZXMgYW5kIHdyaXRpbmcgdGhlbSB0byBpbmRleGVkREIsIHRoZXkgd2lsbCBoYXZlIHBvc2l0aW9ucyBpbiBjb3JyZWN0IGNocm9ub2xvZ2ljYWwgb3JkZXIuXG4gICAgICAvLyBXQVJOSU5HOiBUaGUgcXVlcnkgd2lsbCBOT1QgYmUgcmVzb3J0ZWQgdXNpbmcgdGhlIHNlcnZlcidzIHBvc2l0aW9uIHZhbHVlLlxuICAgICAgbGV0IHBvc2l0aW9uO1xuICAgICAgaWYgKHRoaXMubGFzdE1lc3NhZ2UpIHtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmxhc3RNZXNzYWdlLnBvc2l0aW9uICsgRGF0ZS5ub3coKSAtIHRoaXMubGFzdE1lc3NhZ2Uuc2VudEF0LmdldFRpbWUoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSB0aGlzLmxhc3RNZXNzYWdlLnBvc2l0aW9uKSBwb3NpdGlvbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSAwO1xuICAgICAgfVxuICAgICAgbWVzc2FnZS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgdGhpcy5sYXN0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIENvbnZlcnNhdGlvbiBpcyBhbHJlYWR5IG9uIHRoZSBzZXJ2ZXIsIGRvbid0IHNlbmQuXG4gICAgaWYgKHRoaXMuc3luY1N0YXRlICE9PSBDb25zdGFudHMuU1lOQ19TVEFURS5ORVcpIHJldHVybiB0aGlzO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoaXMgdXNlciBpcyBhIHBhcnRpY2lwYW50IChzZXJ2ZXIgZG9lcyB0aGlzIGZvciB1cywgYnV0XG4gICAgLy8gdGhpcyBpbnN1cmVzIHRoZSBsb2NhbCBjb3B5IGlzIGNvcnJlY3QgdW50aWwgd2UgZ2V0IGEgcmVzcG9uc2UgZnJvbVxuICAgIC8vIHRoZSBzZXJ2ZXJcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudHMuaW5kZXhPZihjbGllbnQudXNlcklkKSA9PT0gLTEpIHtcbiAgICAgIHRoaXMucGFydGljaXBhbnRzLnB1c2goY2xpZW50LnVzZXJJZCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgcGFydGljaXBhbnQsIGl0cyBjbGllbnQudXNlcklkLiAgTm90IGVub3VnaFxuICAgIC8vIGZvciB1cyB0byBoYXZlIGEgZ29vZCBDb252ZXJzYXRpb24gb24gdGhlIHNlcnZlci4gIEFib3J0LlxuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkubW9yZVBhcnRpY2lwYW50c1JlcXVpcmVkKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHN5bmNTdGF0ZVxuICAgIHRoaXMuX3NldFN5bmNpbmcoKTtcblxuICAgIGNsaWVudC5zZW5kU29ja2V0UmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHt9LCAvLyBzZWUgX2dldFNlbmREYXRhXG4gICAgICBzeW5jOiB7XG4gICAgICAgIGRlcGVuZHM6IHRoaXMuaWQsXG4gICAgICAgIHRhcmdldDogdGhpcy5pZCxcbiAgICAgIH0sXG4gICAgfSwgKHJlc3VsdCkgPT4gdGhpcy5fY3JlYXRlUmVzdWx0KHJlc3VsdCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgYSBEaXN0aW5jdCBDcmVhdGUgQ29udmVyc2F0aW9uIGZvdW5kIGEgbG9jYWwgbWF0Y2guXG4gICAqXG4gICAqIFdoZW4gYW4gYXBwIGNhbGxzIGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oWy4uLl0pXG4gICAqIGFuZCByZXF1ZXN0cyBhIERpc3RpbmN0IENvbnZlcnNhdGlvbiAoZGVmYXVsdCBzZXR0aW5nKSxcbiAgICogYW5kIHRoZSBDb252ZXJzYXRpb24gYWxyZWFkeSBleGlzdHMsIHdoYXQgZG8gd2UgZG8gdG8gaGVscFxuICAgKiB0aGVtIGFjY2VzcyBpdD9cbiAgICpcbiAgICogICAgICBjbGllbnQuY3JlYXRlQ29udmVyc2F0aW9uKFtcImZyZWRcIl0pLm9uKFwiY29udmVyc2F0aW9uczpzZW50XCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgcmVuZGVyKCk7XG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIFVuZGVyIG5vcm1hbCBjb25kaXRpb25zLCBjYWxsaW5nIGBjLnNlbmQoKWAgb24gYSBtYXRjaGluZyBkaXN0aW5jdCBDb252ZXJzYXRpb25cbiAgICogd291bGQgZWl0aGVyIHRocm93IGFuIGVycm9yIG9yIGp1c3QgYmUgYSBuby1vcC4gIFdlIHVzZSB0aGlzIG1ldGhvZCB0byB0cmlnZ2VyXG4gICAqIHRoZSBleHBlY3RlZCBcImNvbnZlcnNhdGlvbnM6c2VudFwiIGV2ZW50IGV2ZW4gdGhvdWdoIGl0cyBhbHJlYWR5IGJlZW4gc2VudCBhbmRcbiAgICogd2UgZGlkIG5vdGhpbmcuICBVc2UgdGhlIGV2dC5yZXN1bHQgcHJvcGVydHkgaWYgeW91IHdhbnQgdG8ga25vdyB3aGV0aGVyIHRoZVxuICAgKiByZXN1bHQgd2FzIGEgbmV3IGNvbnZlcnNhdGlvbiBvciBtYXRjaGluZyBvbmUuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZUxvY2FsRGlzdGluY3RDb252ZXJzYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVMb2NhbERpc3RpbmN0Q29udmVyc2F0aW9uKCkge1xuICAgIGNvbnN0IGV2dCA9IHRoaXMuX3NlbmREaXN0aW5jdEV2ZW50O1xuICAgIHRoaXMuX3NlbmREaXN0aW5jdEV2ZW50ID0gbnVsbDtcblxuICAgIC8vIGRlbGF5IHNvIHRoZXJlIGlzIHRpbWUgdG8gc2V0dXAgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhpcyBjb252ZXJzYXRpb25cbiAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2NvbnZlcnNhdGlvbnM6c2VudCcsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkYXRhIGZvciBhIENyZWF0ZSByZXF1ZXN0LlxuICAgKlxuICAgKiBUaGUgbGF5ZXIuU3luY01hbmFnZXIgbmVlZHMgYSBjYWxsYmFjayB0byBjcmVhdGUgdGhlIENvbnZlcnNhdGlvbiBhcyBpdFxuICAgKiBsb29rcyBOT1csIG5vdCBiYWNrIHdoZW4gYHNlbmQoKWAgd2FzIGNhbGxlZC4gIFRoaXMgbWV0aG9kIGlzIGNhbGxlZFxuICAgKiBieSB0aGUgbGF5ZXIuU3luY01hbmFnZXIgdG8gcG9wdWxhdGUgdGhlIFBPU1QgZGF0YSBvZiB0aGUgY2FsbC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0U2VuZERhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fSBXZWJzb2NrZXQgZGF0YSBmb3IgdGhlIHJlcXVlc3RcbiAgICovXG4gIF9nZXRTZW5kRGF0YShkYXRhKSB7XG4gICAgY29uc3QgaXNNZXRhZGF0YUVtcHR5ID0gVXRpbC5pc0VtcHR5KHRoaXMubWV0YWRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6ICdDb252ZXJzYXRpb24uY3JlYXRlJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRzOiB0aGlzLnBhcnRpY2lwYW50cyxcbiAgICAgICAgZGlzdGluY3Q6IHRoaXMuZGlzdGluY3QsXG4gICAgICAgIG1ldGFkYXRhOiBpc01ldGFkYXRhRW1wdHkgPyBudWxsIDogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyByZXN1bHQgb2Ygc2VuZCBtZXRob2QuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB3ZSB1c2UgX3RyaWdnZXJBc3luYyBzbyB0aGF0XG4gICAqIGV2ZW50cyByZXBvcnRpbmcgY2hhbmdlcyB0byB0aGUgbGF5ZXIuQ29udmVyc2F0aW9uLmlkIGNhblxuICAgKiBiZSBhcHBsaWVkIGJlZm9yZSByZXBvcnRpbmcgb24gaXQgYmVpbmcgc2VudC5cbiAgICpcbiAgICogRXhhbXBsZTogUXVlcnkgd2lsbCBub3cgaGF2ZSB0aGUgcmVzb2x2ZWQgRGlzdGluY3QgSURzIHJhdGhlciB0aGFuIHRoZSBwcm9wb3NlZCBJRFxuICAgKiB3aGVuIHRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVSZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHRcbiAgICovXG4gIF9jcmVhdGVSZXN1bHQoeyBzdWNjZXNzLCBkYXRhIH0pIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICB0aGlzLl9jcmVhdGVTdWNjZXNzKGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5pZCA9PT0gJ2NvbmZsaWN0Jykge1xuICAgICAgdGhpcy5fcG9wdWxhdGVGcm9tU2VydmVyKGRhdGEuZGF0YSk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2NvbnZlcnNhdGlvbnM6c2VudCcsIHtcbiAgICAgICAgcmVzdWx0OiBDb252ZXJzYXRpb24uRk9VTkRfV0lUSE9VVF9SRVFVRVNURURfTUVUQURBVEEsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb252ZXJzYXRpb25zOnNlbnQtZXJyb3InLCB7IGVycm9yOiBkYXRhIH0pO1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0IG9mIGEgY3JlYXRlIGNhbGxcbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlU3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgU2VydmVyIGRlc2NyaXB0aW9uIG9mIENvbnZlcnNhdGlvblxuICAgKi9cbiAgX2NyZWF0ZVN1Y2Nlc3MoZGF0YSkge1xuICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihkYXRhKTtcbiAgICBpZiAoIXRoaXMuZGlzdGluY3QpIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnY29udmVyc2F0aW9uczpzZW50Jywge1xuICAgICAgICByZXN1bHQ6IENvbnZlcnNhdGlvbi5DUkVBVEVELFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEN1cnJlbnRseSB0aGUgd2Vic29ja2V0IGRvZXMgbm90IHRlbGwgdXMgaWYgaXRzXG4gICAgICAvLyByZXR1cm5pbmcgYW4gZXhpc3RpbmcgQ29udmVyc2F0aW9uLiAgU28gZ3Vlc3MuLi5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGxhc3RNZXNzYWdlLCB0aGVuIG1vc3QgbGlrZWx5LCB0aGVyZSB3YXNcbiAgICAgIC8vIG5vIGV4aXN0aW5nIENvbnZlcnNhdGlvbi4gIFNhZGx5LCBBUEktODM0OyBsYXN0X21lc3NhZ2UgaXMgY3VycmVudGx5XG4gICAgICAvLyBhbHdheXMgbnVsbC5cbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnY29udmVyc2F0aW9uczpzZW50Jywge1xuICAgICAgICByZXN1bHQ6ICF0aGlzLmxhc3RNZXNzYWdlID8gQ29udmVyc2F0aW9uLkNSRUFURUQgOiBDb252ZXJzYXRpb24uRk9VTkQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUG9wdWxhdGVzIHRoaXMgaW5zdGFuY2UgdXNpbmcgc2VydmVyLWRhdGEuXG4gICAqXG4gICAqIFNpZGUgZWZmZWN0cyBhZGQgdGhpcyB0byB0aGUgQ2xpZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIF9wb3B1bGF0ZUZyb21TZXJ2ZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb252ZXJzYXRpb24gLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbnZlcnNhdGlvblxuICAgKi9cbiAgX3BvcHVsYXRlRnJvbVNlcnZlcihjb252ZXJzYXRpb24pIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuXG4gICAgLy8gRGlzYWJsZSBldmVudHMgaWYgY3JlYXRpbmcgYSBuZXcgQ29udmVyc2F0aW9uXG4gICAgLy8gV2Ugc3RpbGwgd2FudCBwcm9wZXJ0eSBjaGFuZ2UgZXZlbnRzIGZvciBhbnl0aGluZyB0aGF0IERPRVMgY2hhbmdlXG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9ICh0aGlzLnN5bmNTdGF0ZSA9PT0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXKTtcblxuICAgIHRoaXMuX3NldFN5bmNlZCgpO1xuXG4gICAgY29uc3QgaWQgPSB0aGlzLmlkO1xuICAgIHRoaXMuaWQgPSBjb252ZXJzYXRpb24uaWQ7XG5cbiAgICAvLyBJRHMgY2hhbmdlIGlmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhIG1hdGNoaW5nIERpc3RpbmN0IENvbnZlcnNhdGlvblxuICAgIGlmIChpZCAhPT0gdGhpcy5pZCkge1xuICAgICAgY2xpZW50Ll91cGRhdGVDb252ZXJzYXRpb25JZCh0aGlzLCBpZCk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJywge1xuICAgICAgICBvbGRWYWx1ZTogaWQsXG4gICAgICAgIG5ld1ZhbHVlOiB0aGlzLmlkLFxuICAgICAgICBwcm9wZXJ0eTogJ2lkJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMudXJsID0gY29udmVyc2F0aW9uLnVybDtcbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHM7XG4gICAgdGhpcy5kaXN0aW5jdCA9IGNvbnZlcnNhdGlvbi5kaXN0aW5jdDtcbiAgICB0aGlzLmNyZWF0ZWRBdCA9IG5ldyBEYXRlKGNvbnZlcnNhdGlvbi5jcmVhdGVkX2F0KTtcbiAgICB0aGlzLm1ldGFkYXRhID0gY29udmVyc2F0aW9uLm1ldGFkYXRhO1xuICAgIHRoaXMudW5yZWFkQ291bnQgPSBjb252ZXJzYXRpb24udW5yZWFkX21lc3NhZ2VfY291bnQ7XG4gICAgdGhpcy5pc0N1cnJlbnRQYXJ0aWNpcGFudCA9IHRoaXMucGFydGljaXBhbnRzLmluZGV4T2YoY2xpZW50LnVzZXJJZCkgIT09IC0xO1xuXG4gICAgY2xpZW50Ll9hZGRDb252ZXJzYXRpb24odGhpcyk7XG5cblxuICAgIGlmIChjb252ZXJzYXRpb24ubGFzdF9tZXNzYWdlKSB7XG4gICAgICB0aGlzLmxhc3RNZXNzYWdlID0gY2xpZW50Ll9jcmVhdGVPYmplY3QoY29udmVyc2F0aW9uLmxhc3RfbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFzdE1lc3NhZ2UgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSBmYWxzZTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFkZCBhbiBhcnJheSBvZiBwYXJ0aWNpcGFudCBpZHMgdG8gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogICAgICBjb252ZXJzYXRpb24uYWRkUGFydGljaXBhbnRzKFsnYScsICdiJ10pO1xuICAgKlxuICAgKiBOZXcgcGFydGljaXBhbnRzIHdpbGwgaW1tZWRpYXRlbHkgc2hvdyB1cCBpbiB0aGUgQ29udmVyc2F0aW9uLFxuICAgKiBidXQgbWF5IG5vdCBoYXZlIHN5bmNlZCB3aXRoIHRoZSBzZXJ2ZXIgeWV0LlxuICAgKlxuICAgKiBUT0RPIFdFQi05Njc6IFJvbGwgcGFydGljaXBhbnRzIGJhY2sgb24gZ2V0dGluZyBhIHNlcnZlciBlcnJvclxuICAgKlxuICAgKiBAbWV0aG9kIGFkZFBhcnRpY2lwYW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGFydGljaXBhbnRzIC0gQXJyYXkgb2YgcGFydGljaXBhbnQgaWRzXG4gICAqIEByZXR1cm5zIHtsYXllci5Db252ZXJzYXRpb259IHRoaXNcbiAgICovXG4gIGFkZFBhcnRpY2lwYW50cyhwYXJ0aWNpcGFudHMpIHtcbiAgICAvLyBPbmx5IGFkZCB0aG9zZSB0aGF0IGFyZW4ndCBhbHJlYWR5IGluIHRoZSBsaXN0LlxuICAgIGNvbnN0IGFkZGluZyA9IHBhcnRpY2lwYW50cy5maWx0ZXIocGFydGljaXBhbnQgPT4gdGhpcy5wYXJ0aWNpcGFudHMuaW5kZXhPZihwYXJ0aWNpcGFudCkgPT09IC0xKTtcbiAgICB0aGlzLl9wYXRjaFBhcnRpY2lwYW50cyh7IGFkZDogYWRkaW5nLCByZW1vdmU6IFtdIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXJyYXkgb2YgcGFydGljaXBhbnQgaWRzIGZyb20gdGhlIGNvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogICAgICBjb252ZXJzYXRpb24ucmVtb3ZlUGFydGljaXBhbnRzKFsnYScsICdiJ10pO1xuICAgKlxuICAgKiBSZW1vdmVkIHBhcnRpY2lwYW50cyB3aWxsIGltbWVkaWF0ZWx5IGJlIHJlbW92ZWQgZnJvbSB0aGlzIENvbnZlcnNhdGlvbixcbiAgICogYnV0IG1heSBub3QgaGF2ZSBzeW5jZWQgd2l0aCB0aGUgc2VydmVyIHlldC5cbiAgICpcbiAgICogVGhyb3dzIGVycm9yIGlmIHlvdSBhdHRlbXB0IHRvIHJlbW92ZSBBTEwgcGFydGljaXBhbnRzLlxuICAgKlxuICAgKiBUT0RPICBXRUItOTY3OiBSb2xsIHBhcnRpY2lwYW50cyBiYWNrIG9uIGdldHRpbmcgYSBzZXJ2ZXIgZXJyb3JcbiAgICpcbiAgICogQG1ldGhvZCByZW1vdmVQYXJ0aWNpcGFudHNcbiAgICogQHBhcmFtICB7c3RyaW5nW119IHBhcnRpY2lwYW50cyAtIEFycmF5IG9mIHBhcnRpY2lwYW50IGlkc1xuICAgKiBAcmV0dXJucyB7bGF5ZXIuQ29udmVyc2F0aW9ufSB0aGlzXG4gICAqL1xuICByZW1vdmVQYXJ0aWNpcGFudHMocGFydGljaXBhbnRzKSB7XG4gICAgY29uc3QgY3VycmVudFBhcnRpY2lwYW50cyA9IHRoaXMucGFydGljaXBhbnRzLmNvbmNhdChbXSkuc29ydCgpO1xuICAgIGNvbnN0IHJlbW92aW5nID0gcGFydGljaXBhbnRzLmZpbHRlcihwYXJ0aWNpcGFudCA9PiB0aGlzLnBhcnRpY2lwYW50cy5pbmRleE9mKHBhcnRpY2lwYW50KSAhPT0gLTEpLnNvcnQoKTtcbiAgICBpZiAoSlNPTi5zdHJpbmdpZnkoY3VycmVudFBhcnRpY2lwYW50cykgPT09IEpTT04uc3RyaW5naWZ5KHJlbW92aW5nKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5tb3JlUGFydGljaXBhbnRzUmVxdWlyZWQpO1xuICAgIH1cbiAgICB0aGlzLl9wYXRjaFBhcnRpY2lwYW50cyh7IGFkZDogW10sIHJlbW92ZTogcmVtb3ZpbmcgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIHBhcnRpY2lwYW50cyB3aXRoIGEgbmV3IGFycmF5IG9mIG9mIHBhcnRpY2lwYW50IGlkcy5cbiAgICpcbiAgICogICAgICBjb252ZXJzYXRpb24ucmVwbGFjZVBhcnRpY2lwYW50cyhbJ2EnLCAnYiddKTtcbiAgICpcbiAgICogQ2hhbmdlZCBwYXJ0aWNpcGFudHMgd2lsbCBpbW1lZGlhdGVseSBzaG93IHVwIGluIHRoZSBDb252ZXJzYXRpb24sXG4gICAqIGJ1dCBtYXkgbm90IGhhdmUgc3luY2VkIHdpdGggdGhlIHNlcnZlciB5ZXQuXG4gICAqXG4gICAqIFRPRE8gV0VCLTk2NzogUm9sbCBwYXJ0aWNpcGFudHMgYmFjayBvbiBnZXR0aW5nIGEgc2VydmVyIGVycm9yXG4gICAqXG4gICAqIEBtZXRob2QgcmVwbGFjZVBhcnRpY2lwYW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gcGFydGljaXBhbnRzIC0gQXJyYXkgb2YgcGFydGljaXBhbnQgaWRzXG4gICAqIEByZXR1cm5zIHtsYXllci5Db252ZXJzYXRpb259IHRoaXNcbiAgICovXG4gIHJlcGxhY2VQYXJ0aWNpcGFudHMocGFydGljaXBhbnRzKSB7XG4gICAgaWYgKCFwYXJ0aWNpcGFudHMgfHwgIXBhcnRpY2lwYW50cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkubW9yZVBhcnRpY2lwYW50c1JlcXVpcmVkKTtcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2UgPSB0aGlzLl9nZXRQYXJ0aWNpcGFudENoYW5nZShwYXJ0aWNpcGFudHMsIHRoaXMucGFydGljaXBhbnRzKTtcbiAgICB0aGlzLl9wYXRjaFBhcnRpY2lwYW50cyhjaGFuZ2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2VydmVyIHdpdGggdGhlIG5ldyBwYXJ0aWNpcGFudCBsaXN0LlxuICAgKlxuICAgKiBFeGVjdXRlcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAxLiBVcGRhdGVzIHRoZSBwYXJ0aWNpcGFudHMgcHJvcGVydHkgb2YgdGhlIGxvY2FsIG9iamVjdFxuICAgKiAyLiBUcmlnZ2VycyBhIGNvbnZlcnNhdGlvbnM6Y2hhbmdlIGV2ZW50XG4gICAqIDMuIFN1Ym1pdHMgYSByZXF1ZXN0IHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlciB0byB1cGRhdGUgdGhlIHNlcnZlcidzIG9iamVjdFxuICAgKiA0LiBJZiB0aGVyZSBpcyBhbiBlcnJvciwgbm8gZXJyb3JzIGFyZSBmaXJlZCBleGNlcHQgYnkgbGF5ZXIuU3luY01hbmFnZXIsIGJ1dCBhbm90aGVyXG4gICAqICAgIGNvbnZlcnNhdGlvbnM6Y2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFzIHRoZSBjaGFuZ2UgaXMgcm9sbGVkIGJhY2suXG4gICAqXG4gICAqIEBtZXRob2QgX3BhdGNoUGFydGljaXBhbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdFtdfSBvcGVyYXRpb25zIC0gQXJyYXkgb2YgSlNPTiBwYXRjaCBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBldmVudERhdGEgLSBEYXRhIGRlc2NyaWJpbmcgdGhlIGNoYW5nZSBmb3IgdXNlIGluIGFuIGV2ZW50XG4gICAqL1xuICBfcGF0Y2hQYXJ0aWNpcGFudHMoY2hhbmdlKSB7XG4gICAgdGhpcy5fYXBwbHlQYXJ0aWNpcGFudENoYW5nZShjaGFuZ2UpO1xuICAgIHRoaXMuaXNDdXJyZW50UGFydGljaXBhbnQgPSB0aGlzLnBhcnRpY2lwYW50cy5pbmRleE9mKHRoaXMuZ2V0Q2xpZW50KCkudXNlcklkKSAhPT0gLTE7XG5cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjaGFuZ2UucmVtb3ZlLmZvckVhY2goaWQgPT4ge1xuICAgICAgb3BzLnB1c2goe1xuICAgICAgICBvcGVyYXRpb246ICdyZW1vdmUnLFxuICAgICAgICBwcm9wZXJ0eTogJ3BhcnRpY2lwYW50cycsXG4gICAgICAgIHZhbHVlOiBpZCxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY2hhbmdlLmFkZC5mb3JFYWNoKGlkID0+IHtcbiAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgb3BlcmF0aW9uOiAnYWRkJyxcbiAgICAgICAgcHJvcGVydHk6ICdwYXJ0aWNpcGFudHMnLFxuICAgICAgICB2YWx1ZTogaWQsXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3hocih7XG4gICAgICB1cmw6ICcnLFxuICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgZGF0YTogSlNPTi5zdHJpbmdpZnkob3BzKSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi92bmQubGF5ZXItcGF0Y2granNvbicsXG4gICAgICB9LFxuICAgIH0sIHJlc3VsdCA9PiB7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB0aGlzLl9sb2FkKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWxseSB3ZSB1c2UgYHthZGQ6IFtdLCByZW1vdmU6IFtdfWAgaW5zdGVhZCBvZiBMYXllck9wZXJhdGlvbnMuXG4gICAqXG4gICAqIFNvIGNvbnRyb2wgaXMgaGFuZGVkIG9mZiB0byB0aGlzIG1ldGhvZCB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlc1xuICAgKiB0byB0aGUgcGFydGljaXBhbnRzIGFycmF5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9hcHBseVBhcnRpY2lwYW50Q2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2hhbmdlXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBjaGFuZ2UuYWRkIC0gQXJyYXkgb2YgdXNlcmlkcyB0byBhZGRcbiAgICogQHBhcmFtICB7c3RyaW5nW119IGNoYW5nZS5yZW1vdmUgLSBBcnJheSBvZiB1c2VyaWRzIHRvIHJlbW92ZVxuICAgKi9cbiAgX2FwcGx5UGFydGljaXBhbnRDaGFuZ2UoY2hhbmdlKSB7XG4gICAgY29uc3QgcGFydGljaXBhbnRzID0gW10uY29uY2F0KHRoaXMucGFydGljaXBhbnRzKTtcbiAgICBjaGFuZ2UuYWRkLmZvckVhY2goaWQgPT4ge1xuICAgICAgaWYgKHBhcnRpY2lwYW50cy5pbmRleE9mKGlkKSA9PT0gLTEpIHBhcnRpY2lwYW50cy5wdXNoKGlkKTtcbiAgICB9KTtcbiAgICBjaGFuZ2UucmVtb3ZlLmZvckVhY2goaWQgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBwYXJ0aWNpcGFudHMuaW5kZXhPZihpZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSBwYXJ0aWNpcGFudHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9KTtcbiAgICB0aGlzLnBhcnRpY2lwYW50cyA9IHBhcnRpY2lwYW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIENvbnZlcnNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgYW5kIHJlbW92ZXMgdGhpcyB1c2VyIGFzIGEgcGFydGljaXBhbnQuXG4gICAqXG4gICAqIEBtZXRob2QgbGVhdmVcbiAgICogQHJldHVybiBudWxsXG4gICAqL1xuICBsZWF2ZSgpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pc0Rlc3Ryb3llZCk7XG4gICAgdGhpcy5fZGVsZXRlKCdtb2RlPW15X2RldmljZXMmbGVhdmU9dHJ1ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgQ29udmVyc2F0aW9uIGZyb20gdGhlIHNlcnZlciwgYnV0IGRlbGV0aW9uIG1vZGUgbWF5IGNhdXNlIHVzZXIgdG8gcmVtYWluIGEgcGFydGljaXBhbnQuXG4gICAqXG4gICAqIFRoaXMgY2FsbCB3aWxsIHN1cHBvcnQgdmFyaW91cyBkZWxldGlvbiBtb2Rlcy5cbiAgICpcbiAgICogRGVsZXRpb24gTW9kZXM6XG4gICAqXG4gICAqICogbGF5ZXIuQ29uc3RhbnRzLkRFTEVUSU9OX01PREUuQUxMOiBUaGlzIGRlbGV0ZXMgdGhlIGxvY2FsIGNvcHkgaW1tZWRpYXRlbHksIGFuZCBhdHRlbXB0cyB0byBhbHNvXG4gICAqICAgZGVsZXRlIHRoZSBzZXJ2ZXIncyBjb3B5LlxuICAgKiAqIGxheWVyLkNvbnN0YW50cy5ERUxFVElPTl9NT0RFLk1ZX0RFVklDRVM6IERlbGV0ZXMgdGhlIGxvY2FsIGNvcHkgaW1tZWRpYXRlbHksIGFuZCBhdHRlbXB0cyB0byBkZWxldGUgaXQgZnJvbSBhbGxcbiAgICogICBvZiBteSBkZXZpY2VzLiAgT3RoZXIgdXNlcnMgcmV0YWluIGFjY2Vzcy5cbiAgICogKiB0cnVlOiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgdGhpIGlzIHRoZSBzYW1lIGFzIEFMTC5cbiAgICpcbiAgICogTVlfREVWSUNFUyBkb2VzIG5vdCByZW1vdmUgdGhpcyB1c2VyIGFzIGEgcGFydGljaXBhbnQuICBUaGF0IG1lYW5zIGEgbmV3IE1lc3NhZ2Ugb24gdGhpcyBDb252ZXJzYXRpb24gd2lsbCByZWNyZWF0ZSB0aGVcbiAgICogQ29udmVyc2F0aW9uIGZvciB0aGlzIHVzZXIuICBTZWUgbGF5ZXIuQ29udmVyc2F0aW9uLmxlYXZlKCkgaW5zdGVhZC5cbiAgICpcbiAgICogRXhlY3V0ZXMgYXMgZm9sbG93czpcbiAgICpcbiAgICogMS4gU3VibWl0cyBhIHJlcXVlc3QgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIGRlbGV0ZSB0aGUgc2VydmVyJ3Mgb2JqZWN0XG4gICAqIDIuIERlbGV0ZSdzIHRoZSBsb2NhbCBvYmplY3RcbiAgICogMy4gSWYgdGhlcmUgaXMgYW4gZXJyb3IsIG5vIGVycm9ycyBhcmUgZmlyZWQgZXhjZXB0IGJ5IGxheWVyLlN5bmNNYW5hZ2VyLCBidXQgdGhlIENvbnZlcnNhdGlvbiB3aWxsIGJlIHJlbG9hZGVkIGZyb20gdGhlIHNlcnZlcixcbiAgICogICAgdHJpZ2dlcmluZyBhIGNvbnZlcnNhdGlvbnM6YWRkIGV2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsZXRpb25Nb2RlIC0gbGF5ZXIuQ29uc3RhbnRzLkRFTEVUSU9OX01PREUuQUxMIGlzIG9ubHkgc3VwcG9ydGVkIG1vZGUgYXQgdGhpcyB0aW1lXG4gICAqIEByZXR1cm4gbnVsbFxuICAgKi9cbiAgZGVsZXRlKG1vZGUpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pc0Rlc3Ryb3llZCk7XG5cbiAgICBsZXQgcXVlcnlTdHI7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTDpcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcXVlcnlTdHIgPSAnbW9kZT1hbGxfcGFydGljaXBhbnRzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLk1ZX0RFVklDRVM6XG4gICAgICAgIHF1ZXJ5U3RyID0gJ21vZGU9bXlfZGV2aWNlcyZsZWF2ZT1mYWxzZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5kZWxldGlvbk1vZGVVbnN1cHBvcnRlZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVsZXRlKHF1ZXJ5U3RyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIENvbnZlcnNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgKGludGVybmFsIHZlcnNpb24pLlxuICAgKlxuICAgKiBUaGlzIHZlcnNpb24gb2YgRGVsZXRlIHRha2VzIGEgUXVlcnkgU3RyaW5nIHRoYXQgaXMgcGFja2FnZWQgdXAgYnlcbiAgICogbGF5ZXIuQ29udmVyc2F0aW9uLmRlbGV0ZSBhbmQgbGF5ZXIuQ29udmVyc2F0aW9uLmxlYXZlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9kZWxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5U3RyIC0gUXVlcnkgc3RyaW5nIGZvciB0aGUgREVMRVRFIHJlcXVlc3RcbiAgICovXG4gIF9kZWxldGUocXVlcnlTdHIpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuaWQ7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICB0aGlzLl94aHIoe1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIHVybDogJz8nICsgcXVlcnlTdHIsXG4gICAgfSwgcmVzdWx0ID0+IHtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MgJiYgKCFyZXN1bHQuZGF0YSB8fCByZXN1bHQuZGF0YS5pZCAhPT0gJ25vdF9mb3VuZCcpKSBDb252ZXJzYXRpb24ubG9hZChpZCwgY2xpZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX2RlbGV0ZWQoKTtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgQ29udmVyc2F0aW9uIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIENhbGxlZCBmcm9tIFdlYnNvY2tldE1hbmFnZXIgYW5kIGZyb20gbGF5ZXIuQ29udmVyc2F0aW9uLmRlbGV0ZSgpO1xuICAgKlxuICAgKiBEZXN0cm95IG11c3QgYmUgY2FsbGVkIHNlcGFyYXRlbHksIGFuZCBoYW5kbGVzIG1vc3QgY2xlYW51cC5cbiAgICpcbiAgICogQG1ldGhvZCBfZGVsZXRlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZGVsZXRlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbnZlcnNhdGlvbnM6ZGVsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGxheWVyLk1lc3NhZ2UgaW5zdGFuY2Ugd2l0aGluIHRoaXMgY29udmVyc2F0aW9uXG4gICAqXG4gICAqICAgICAgdmFyIG1lc3NhZ2UgPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSgnaGVsbG8nKTtcbiAgICpcbiAgICogICAgICB2YXIgbWVzc2FnZSA9IGNvbnZlcnNhdGlvbi5jcmVhdGVNZXNzYWdlKHtcbiAgICogICAgICAgICAgcGFydHM6IFtuZXcgbGF5ZXIuTWVzc2FnZVBhcnQoe1xuICAgKiAgICAgICAgICAgICAgICAgICAgICBib2R5OiAnaGVsbG8nLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nXG4gICAqICAgICAgICAgICAgICAgICAgfSldXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIFNlZSBsYXllci5NZXNzYWdlIGZvciBtb3JlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAbWV0aG9kIGNyZWF0ZU1lc3NhZ2VcbiAgICogQHBhcmFtICB7c3RyaW5nfE9iamVjdH0gb3B0aW9ucyAtIElmIGl0cyBhIHN0cmluZywgYSBNZXNzYWdlUGFydCBpcyBjcmVhdGVkIGFyb3VuZCB0aGF0IHN0cmluZy5cbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlUGFydFtdfSBvcHRpb25zLnBhcnRzIC0gQW4gYXJyYXkgb2YgTWVzc2FnZVBhcnRzLiAgVGhlcmUgaXMgc29tZSB0b2xlcmFuY2UgZm9yXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBub3QgYmVpbmcgYW4gYXJyYXksIG9yIGZvciBpdCBiZWluZyBhIHN0cmluZyB0byBiZSB0dXJuZWRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludG8gYSBNZXNzYWdlUGFydC5cbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIGNyZWF0ZU1lc3NhZ2Uob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZUNvbmZpZyA9ICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpID8ge1xuICAgICAgcGFydHM6IFt7IGJvZHk6IG9wdGlvbnMsIG1pbWVUeXBlOiAndGV4dC9wbGFpbicgfV0sXG4gICAgfSA6IG9wdGlvbnM7XG4gICAgbWVzc2FnZUNvbmZpZy5jbGllbnRJZCA9IHRoaXMuY2xpZW50SWQ7XG4gICAgbWVzc2FnZUNvbmZpZy5jb252ZXJzYXRpb25JZCA9IHRoaXMuaWQ7XG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBqc29uLXBhdGNoIG9wZXJhdGlvbnMgZm9yIG1vZGlmeWluZyBwYXJ0aWNpcGFudHMgb3IgbWV0YWRhdGFcbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlUGF0Y2hFdmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3RbXX0gZGF0YSAtIEFycmF5IG9mIG9wZXJhdGlvbnNcbiAgICovXG4gIF9oYW5kbGVQYXRjaEV2ZW50KG5ld1ZhbHVlLCBvbGRWYWx1ZSwgcGF0aHMpIHtcbiAgICAvLyBDZXJ0YWluIHR5cGVzIG9mIF9fdXBkYXRlIGhhbmRsZXJzIGFyZSBkaXNhYmxlZCB3aGlsZSB2YWx1ZXMgYXJlIGJlaW5nIHNldCBieVxuICAgIC8vIGxheWVyIHBhdGNoIHBhcnNlciBiZWNhdXNlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gc2V0dGluZyBhIHZhbHVlICh0cmlnZ2VycyBhbiBldmVudClcbiAgICAvLyBhbmQgY2hhbmdlIGEgcHJvcGVydHkgb2YgYSB2YWx1ZSAodHJpZ2dlcnMgb25seSB0aGlzIGNhbGxiYWNrKSByZXN1bHQgaW4gaW5jb25zaXN0ZW50XG4gICAgLy8gYmVoYXZpb3JzLiAgRW5hYmxlIHRoZW0gbG9uZyBlbm91Z2ggdG8gYWxsb3cgX191cGRhdGUgY2FsbHMgdG8gYmUgbWFkZVxuICAgIHRoaXMuX2luTGF5ZXJQYXJzZXIgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRzID0gdGhpcy5fZGlzYWJsZUV2ZW50cztcbiAgICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSBmYWxzZTtcbiAgICAgIGlmIChwYXRoc1swXS5pbmRleE9mKCdtZXRhZGF0YScpID09PSAwKSB7XG4gICAgICAgIHRoaXMuX191cGRhdGVNZXRhZGF0YShuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGhzKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aHNbMF0gPT09ICdwYXJ0aWNpcGFudHMnKSB7XG4gICAgICAgIHRoaXMuX191cGRhdGVQYXJ0aWNpcGFudHMobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Rpc2FibGVFdmVudHMgPSBldmVudHM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIHRoaXMuX2luTGF5ZXJQYXJzZXIgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHRoZSBvbGRWYWx1ZSBhbmQgbmV3VmFsdWUgZm9yIHBhcnRpY2lwYW50cyxcbiAgICogZ2VuZXJhdGUgYSBsaXN0IG9mIHdob20gd2FzIGFkZGVkIGFuZCB3aG9tIHdhcyByZW1vdmVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9nZXRQYXJ0aWNpcGFudENoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gbmV3VmFsdWVcbiAgICogQHBhcmFtICB7c3RyaW5nW119IG9sZFZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBjaGFuZ2VzIGluIHRoZSBmb3JtIG9mIGB7YWRkOiBbLi4uXSwgcmVtb3ZlOiBbLi4uXX1gXG4gICAqL1xuICBfZ2V0UGFydGljaXBhbnRDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgY2hhbmdlLmFkZCA9IG5ld1ZhbHVlLmZpbHRlcihwYXJ0aWNpcGFudCA9PiBvbGRWYWx1ZS5pbmRleE9mKHBhcnRpY2lwYW50KSA9PT0gLTEpO1xuICAgIGNoYW5nZS5yZW1vdmUgPSBvbGRWYWx1ZS5maWx0ZXIocGFydGljaXBhbnQgPT4gbmV3VmFsdWUuaW5kZXhPZihwYXJ0aWNpcGFudCkgPT09IC0xKTtcbiAgICByZXR1cm4gY2hhbmdlO1xuICB9XG5cblxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHNwZWNpZmllZCBtZXRhZGF0YSBrZXlzLlxuICAgKlxuICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBvYmplY3QncyBtZXRhZGF0YSBhbmQgc3luY3MgdGhlIGNoYW5nZSB0byB0aGUgc2VydmVyLlxuICAgKlxuICAgKiAgICAgIGNvbnZlcnNhdGlvbi5zZXRNZXRhZGF0YVByb3BlcnRpZXMoe1xuICAgKiAgICAgICAgICAndGl0bGUnOiAnSSBhbSBhIHRpdGxlJyxcbiAgICogICAgICAgICAgJ2NvbG9ycy5iYWNrZ3JvdW5kJzogJ3JlZCcsXG4gICAqICAgICAgICAgICdjb2xvcnMudGV4dCc6IHtcbiAgICogICAgICAgICAgICAgICdmaWxsJzogJ2JsdWUnLFxuICAgKiAgICAgICAgICAgICAgJ3NoYWRvdyc6ICdibGFjaydcbiAgICogICAgICAgICAgIH0sXG4gICAqICAgICAgICAgICAnY29sb3JzLnRpdGxlLmZpbGwnOiAncmVkJ1xuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBVc2Ugc2V0TWV0YWRhdGFQcm9wZXJ0aWVzIHRvIHNwZWNpZnkgdGhlIHBhdGggdG8gYSBwcm9wZXJ0eSwgYW5kIGEgbmV3IHZhbHVlIGZvciB0aGF0IHByb3BlcnR5LlxuICAgKiBNdWx0aXBsZSBwcm9wZXJ0aWVzIGNhbiBiZSBjaGFuZ2VkIHRoaXMgd2F5LiAgV2hhdGV2ZXIgdmFsdWUgd2FzIHRoZXJlIGJlZm9yZSBpc1xuICAgKiByZXBsYWNlZCB3aXRoIHRoZSBuZXcgdmFsdWU7IHNvIGluIHRoZSBhYm92ZSBleGFtcGxlLCB3aGF0ZXZlciBvdGhlciBrZXlzIG1heSBoYXZlXG4gICAqIGV4aXN0ZWQgdW5kZXIgYGNvbG9ycy50ZXh0YCBoYXZlIGJlZW4gcmVwbGFjZWQgYnkgdGhlIG5ldyBvYmplY3QgYHtmaWxsOiAnYmx1ZScsIHNoYWRvdzogJ2JsYWNrJ31gLlxuICAgKlxuICAgKiBOb3RlIGFsc28gdGhhdCBvbmx5IHN0cmluZyBhbmQgc3Vib2JqZWN0cyBhcmUgYWNjZXB0ZWQgYXMgdmFsdWVzLlxuICAgKlxuICAgKiBLZXlzIHdpdGggJy4nIHdpbGwgdXBkYXRlIGEgZmllbGQgb2YgYW4gb2JqZWN0IChhbmQgY3JlYXRlIGFuIG9iamVjdCBpZiBpdCB3YXNuJ3QgdGhlcmUpOlxuICAgKlxuICAgKiBJbml0aWFsIG1ldGFkYXRhOiB7fVxuICAgKlxuICAgKiAgICAgIGNvbnZlcnNhdGlvbi5zZXRNZXRhZGF0YVByb3BlcnRpZXMoe1xuICAgKiAgICAgICAgICAnY29sb3JzLmJhY2tncm91bmQnOiAncmVkJyxcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogTWV0YWRhdGEgaXMgbm93OiBge2NvbG9yczoge2JhY2tncm91bmQ6ICdyZWQnfX1gXG4gICAqXG4gICAqICAgICAgY29udmVyc2F0aW9uLnNldE1ldGFkYXRhUHJvcGVydGllcyh7XG4gICAqICAgICAgICAgICdjb2xvcnMuZm9yZWdyb3VuZCc6ICdibGFjaycsXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIE1ldGFkYXRhIGlzIG5vdzogYHtjb2xvcnM6IHtiYWNrZ3JvdW5kOiAncmVkJywgZm9yZWdyb3VuZDogJ2JsYWNrJ319YFxuICAgKlxuICAgKiBFeGVjdXRlcyBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAxLiBVcGRhdGVzIHRoZSBtZXRhZGF0YSBwcm9wZXJ0eSBvZiB0aGUgbG9jYWwgb2JqZWN0XG4gICAqIDIuIFRyaWdnZXJzIGEgY29udmVyc2F0aW9uczpjaGFuZ2UgZXZlbnRcbiAgICogMy4gU3VibWl0cyBhIHJlcXVlc3QgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyIHRvIHVwZGF0ZSB0aGUgc2VydmVyJ3Mgb2JqZWN0XG4gICAqIDQuIElmIHRoZXJlIGlzIGFuIGVycm9yLCBubyBlcnJvcnMgYXJlIGZpcmVkIGV4Y2VwdCBieSBsYXllci5TeW5jTWFuYWdlciwgYnV0IGFub3RoZXJcbiAgICogICAgY29udmVyc2F0aW9uczpjaGFuZ2UgZXZlbnQgaXMgZmlyZWQgYXMgdGhlIGNoYW5nZSBpcyByb2xsZWQgYmFjay5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRNZXRhZGF0YVByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKlxuICAgKi9cbiAgc2V0TWV0YWRhdGFQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgY29uc3QgbGF5ZXJQYXRjaE9wZXJhdGlvbnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIGxldCBmdWxsTmFtZSA9IG5hbWU7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gJ21ldGFkYXRhJyAmJiBuYW1lLmluZGV4T2YoJ21ldGFkYXRhLicpICE9PSAwKSB7XG4gICAgICAgICAgZnVsbE5hbWUgPSAnbWV0YWRhdGEuJyArIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJQYXRjaE9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgb3BlcmF0aW9uOiAnc2V0JyxcbiAgICAgICAgICBwcm9wZXJ0eTogZnVsbE5hbWUsXG4gICAgICAgICAgdmFsdWU6IHByb3BzW25hbWVdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2luTGF5ZXJQYXJzZXIgPSB0cnVlO1xuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgc2V0U3luY2luZyBhcyBpZiB0aGVyZSBhcmUgYW55IGVycm9ycywgd2Ugc2hvdWxkIG5ldmVyIGV2ZW5cbiAgICAvLyBzdGFydCBzZXR0aW5nIHVwIGEgcmVxdWVzdC5cbiAgICBVdGlsLmxheWVyUGFyc2Uoe1xuICAgICAgb2JqZWN0OiB0aGlzLFxuICAgICAgdHlwZTogJ0NvbnZlcnNhdGlvbicsXG4gICAgICBvcGVyYXRpb25zOiBsYXllclBhdGNoT3BlcmF0aW9ucyxcbiAgICAgIGNsaWVudDogdGhpcy5nZXRDbGllbnQoKSxcbiAgICB9KTtcbiAgICB0aGlzLl9pbkxheWVyUGFyc2VyID0gZmFsc2U7XG5cbiAgICB0aGlzLl94aHIoe1xuICAgICAgdXJsOiAnJyxcbiAgICAgIG1ldGhvZDogJ1BBVENIJyxcbiAgICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGxheWVyUGF0Y2hPcGVyYXRpb25zKSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi92bmQubGF5ZXItcGF0Y2granNvbicsXG4gICAgICB9LFxuICAgIH0sIHJlc3VsdCA9PiB7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB0aGlzLl9sb2FkKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgc3BlY2lmaWVkIG1ldGFkYXRhIGtleXMuXG4gICAqXG4gICAqIFVwZGF0ZXMgdGhlIGxvY2FsIG9iamVjdCdzIG1ldGFkYXRhIGFuZCBzeW5jcyB0aGUgY2hhbmdlIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqICAgICAgY29udmVyc2F0aW9uLmRlbGV0ZU1ldGFkYXRhUHJvcGVydGllcyhcbiAgICogICAgICAgICAgWyd0aXRsZScsICdjb2xvcnMuYmFja2dyb3VuZCcsICdjb2xvcnMudGl0bGUuZmlsbCddXG4gICAqICAgICAgKTtcbiAgICpcbiAgICogVXNlIGRlbGV0ZU1ldGFkYXRhUHJvcGVydGllcyB0byBzcGVjaWZ5IHBhdGhzIHRvIHByb3BlcnRpZXMgdG8gYmUgZGVsZXRlZC5cbiAgICogTXVsdGlwbGUgcHJvcGVydGllcyBjYW4gYmUgZGVsZXRlZC5cbiAgICpcbiAgICogRXhlY3V0ZXMgYXMgZm9sbG93czpcbiAgICpcbiAgICogMS4gVXBkYXRlcyB0aGUgbWV0YWRhdGEgcHJvcGVydHkgb2YgdGhlIGxvY2FsIG9iamVjdFxuICAgKiAyLiBUcmlnZ2VycyBhIGNvbnZlcnNhdGlvbnM6Y2hhbmdlIGV2ZW50XG4gICAqIDMuIFN1Ym1pdHMgYSByZXF1ZXN0IHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlciB0byB1cGRhdGUgdGhlIHNlcnZlcidzIG9iamVjdFxuICAgKiA0LiBJZiB0aGVyZSBpcyBhbiBlcnJvciwgbm8gZXJyb3JzIGFyZSBmaXJlZCBleGNlcHQgYnkgbGF5ZXIuU3luY01hbmFnZXIsIGJ1dCBhbm90aGVyXG4gICAqICAgIGNvbnZlcnNhdGlvbnM6Y2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFzIHRoZSBjaGFuZ2UgaXMgcm9sbGVkIGJhY2suXG4gICAqXG4gICAqIEBtZXRob2QgZGVsZXRlTWV0YWRhdGFQcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBwcm9wZXJ0aWVzXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn1cbiAgICpcbiAgICovXG4gIGRlbGV0ZU1ldGFkYXRhUHJvcGVydGllcyhwcm9wcykge1xuICAgIGNvbnN0IGxheWVyUGF0Y2hPcGVyYXRpb25zID0gW107XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgIT09ICdtZXRhZGF0YScgJiYgcHJvcGVydHkuaW5kZXhPZignbWV0YWRhdGEuJykgIT09IDApIHtcbiAgICAgICAgcHJvcGVydHkgPSAnbWV0YWRhdGEuJyArIHByb3BlcnR5O1xuICAgICAgfVxuICAgICAgbGF5ZXJQYXRjaE9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgIG9wZXJhdGlvbjogJ2RlbGV0ZScsXG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9pbkxheWVyUGFyc2VyID0gdHJ1ZTtcblxuICAgIC8vIERvIHRoaXMgYmVmb3JlIHNldFN5bmNpbmcgYXMgaWYgdGhlcmUgYXJlIGFueSBlcnJvcnMsIHdlIHNob3VsZCBuZXZlciBldmVuXG4gICAgLy8gc3RhcnQgc2V0dGluZyB1cCBhIHJlcXVlc3QuXG4gICAgVXRpbC5sYXllclBhcnNlKHtcbiAgICAgIG9iamVjdDogdGhpcyxcbiAgICAgIHR5cGU6ICdDb252ZXJzYXRpb24nLFxuICAgICAgb3BlcmF0aW9uczogbGF5ZXJQYXRjaE9wZXJhdGlvbnMsXG4gICAgICBjbGllbnQ6IHRoaXMuZ2V0Q2xpZW50KCksXG4gICAgfSk7XG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IGZhbHNlO1xuXG4gICAgdGhpcy5feGhyKHtcbiAgICAgIHVybDogJycsXG4gICAgICBtZXRob2Q6ICdQQVRDSCcsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShsYXllclBhdGNoT3BlcmF0aW9ucyksXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vdm5kLmxheWVyLXBhdGNoK2pzb24nLFxuICAgICAgfSxcbiAgICB9LCByZXN1bHQgPT4ge1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgdGhpcy5fbG9hZCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBbnkgeGhyIG1ldGhvZCBjYWxsZWQgb24gdGhpcyBjb252ZXJzYXRpb24gdXNlcyB0aGUgY29udmVyc2F0aW9uJ3MgdXJsLlxuICAgKlxuICAgKiBGb3IgZGV0YWlscyBvbiBwYXJhbWV0ZXJzIHNlZSB7QGxpbmsgbGF5ZXIuQ2xpZW50QXV0aGVudGljYXRvciN4aHJ9XG4gICAqXG4gICAqIEBtZXRob2QgX3hoclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKi9cbiAgX3hocihhcmdzLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG5cbiAgICAvLyBWYWxpZGF0aW9uXG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuaXNEZXN0cm95ZWQpO1xuICAgIGlmICghY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmNsaWVudE1pc3NpbmcpO1xuICAgIGlmICghKCd1cmwnIGluIGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LnVybFJlcXVpcmVkKTtcbiAgICBpZiAoYXJncy5tZXRob2QgIT09ICdQT1NUJyAmJiB0aGlzLnN5bmNTdGF0ZSA9PT0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXKSByZXR1cm4gdGhpcztcblxuICAgIGlmIChhcmdzLnN5bmMgIT09IGZhbHNlKSB7XG4gICAgICBpZiAoIWFyZ3Muc3luYykgYXJncy5zeW5jID0ge307XG4gICAgICBpZiAoIWFyZ3Muc3luYy50YXJnZXQpIHtcbiAgICAgICAgYXJncy5zeW5jLnRhcmdldCA9IHRoaXMuaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFyZ3MudXJsICYmICFhcmdzLnVybC5tYXRjaCgvXihcXC98XFw/KS8pKSBhcmdzLnVybCA9ICcvJyArIGFyZ3MudXJsO1xuICAgIGlmICghYXJncy5zeW5jKSBhcmdzLnVybCA9IHRoaXMudXJsICsgYXJncy51cmw7XG5cbiAgICBpZiAoYXJncy5tZXRob2QgJiYgYXJncy5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICB0aGlzLl9zZXRTeW5jaW5nKCk7XG4gICAgfVxuXG4gICAgY2xpZW50LnhocihhcmdzLCAocmVzdWx0KSA9PiB7XG4gICAgICBpZiAoYXJncy5tZXRob2QgJiYgYXJncy5tZXRob2QgIT09ICdHRVQnICYmICF0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3NldFN5bmNlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhyZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBfZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB0aGlzLnVybCArICh1cmwgfHwgJycpO1xuICB9XG5cbiAgX2xvYWRlZChkYXRhKSB7XG4gICAgdGhpcy5nZXRDbGllbnQoKS5fYWRkQ29udmVyc2F0aW9uKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkIGBvbigpYCBwcm92aWRlZCBieSBsYXllci5Sb290LlxuICAgKlxuICAgKiBBZGRzIHNvbWUgc3BlY2lhbCBoYW5kbGluZyBvZiAnY29udmVyc2F0aW9uczpsb2FkZWQnIHNvIHRoYXQgY2FsbHMgc3VjaCBhc1xuICAgKlxuICAgKiAgICAgIHZhciBjID0gY2xpZW50LmdldENvbnZlcnNhdGlvbignbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy8xMjMnLCB0cnVlKVxuICAgKiAgICAgIC5vbignY29udmVyc2F0aW9uczpsb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgICogICAgICAgICAgbXlyZXJlbmRlcihjKTtcbiAgICogICAgICB9KTtcbiAgICogICAgICBteXJlbmRlcihjKTsgLy8gcmVuZGVyIGEgcGxhY2Vob2xkZXIgZm9yIGMgdW50aWwgdGhlIGRldGFpbHMgb2YgYyBoYXZlIGxvYWRlZFxuICAgKlxuICAgKiBjYW4gZmlyZSB0aGVpciBjYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNsaWVudCBsb2FkcyBvciBoYXNcbiAgICogYWxyZWFkeSBsb2FkZWQgdGhlIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBvblxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn0gdGhpc1xuICAgKi9cbiAgb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBoYXNMb2FkZWRFdnQgPSBuYW1lID09PSAnY29udmVyc2F0aW9uczpsb2FkZWQnIHx8XG4gICAgICBuYW1lICYmIHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyAmJiBuYW1lWydjb252ZXJzYXRpb25zOmxvYWRlZCddO1xuXG4gICAgaWYgKGhhc0xvYWRlZEV2dCAmJiAhdGhpcy5pc0xvYWRpbmcpIHtcbiAgICAgIGNvbnN0IGNhbGxOb3cgPSBuYW1lID09PSAnY29udmVyc2F0aW9uczpsb2FkZWQnID8gY2FsbGJhY2sgOiBuYW1lWydjb252ZXJzYXRpb25zOmxvYWRlZCddO1xuICAgICAgVXRpbC5kZWZlcigoKSA9PiBjYWxsTm93LmFwcGx5KGNvbnRleHQpKTtcbiAgICB9XG4gICAgc3VwZXIub24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKlxuICAgKiBJbnN1cmUgdGhhdCBjb252ZXJzYXRpb24udW5yZWFkQ291bnQtLSBjYW4gbmV2ZXIgcmVkdWNlIHRoZSB2YWx1ZSB0byBuZWdhdGl2ZSB2YWx1ZXMuXG4gICAqL1xuICBfX2FkanVzdFVucmVhZENvdW50KG5ld1ZhbHVlKSB7XG4gICAgaWYgKG5ld1ZhbHVlIDwgMCkgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogX18gTWV0aG9kcyBhcmUgYXV0b21hdGljYWxseSBjYWxsZWQgYnkgcHJvcGVydHkgc2V0dGVycy5cbiAgICpcbiAgICogQW55IGNoYW5nZSBpbiB0aGUgdW5yZWFkQ291bnQgcHJvcGVydHkgd2lsbCBjYWxsIHRoaXMgbWV0aG9kIGFuZCBmaXJlIGFcbiAgICogY2hhbmdlIGV2ZW50LlxuICAgKlxuICAgKiBBbnkgdHJpZ2dlcmluZyBvZiB0aGlzIGZyb20gYSB3ZWJzb2NrZXQgcGF0Y2ggdW5yZWFkX21lc3NhZ2VfY291bnQgc2hvdWxkIHdhaXQgYSBzZWNvbmQgYmVmb3JlIGZpcmluZyBhbnkgZXZlbnRzXG4gICAqIHNvIHRoYXQgaWYgdGhlcmUgYXJlIGEgc2VyaWVzIG9mIHRoZXNlIHVwZGF0ZXMsIHdlIGRvbid0IHNlZSBhIGxvdCBvZiBqaXR0ZXIuXG4gICAqXG4gICAqIE5PVEU6IF9vbGRVbnJlYWRDb3VudCBpcyB1c2VkIHRvIHBhc3MgZGF0YSB0byBfdXBkYXRlVW5yZWFkQ291bnRFdmVudCBiZWNhdXNlIHRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgbWFueSB0aW1lc1xuICAgKiBhIHNlY29uZCwgYW5kIHdlIG9ubHkgd2FudCB0byB0cmlnZ2VyIHRoaXMgd2l0aCBhIHN1bW1hcnkgb2YgY2hhbmdlcyByYXRoZXIgdGhhbiBlYWNoIGluZGl2aWR1YWwgY2hhbmdlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9fdXBkYXRlVW5yZWFkQ291bnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9sZFZhbHVlXG4gICAqL1xuICBfX3VwZGF0ZVVucmVhZENvdW50KG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmICh0aGlzLl9pbkxheWVyUGFyc2VyKSB7XG4gICAgICBpZiAodGhpcy5fb2xkVW5yZWFkQ291bnQgPT09IHVuZGVmaW5lZCkgdGhpcy5fb2xkVW5yZWFkQ291bnQgPSBvbGRWYWx1ZTtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVVbnJlYWRDb3VudFRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVVbnJlYWRDb3VudFRpbWVvdXQpO1xuICAgICAgdGhpcy5fdXBkYXRlVW5yZWFkQ291bnRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl91cGRhdGVVbnJlYWRDb3VudEV2ZW50KCksIDEwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91cGRhdGVVbnJlYWRDb3VudEV2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgZXZlbnRzIHJlbGF0ZWQgdG8gY2hhbmdlcyB0byB1bnJlYWRDb3VudFxuICAgKlxuICAgKiBAbWV0aG9kIF91cGRhdGVVbnJlYWRDb3VudEV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlVW5yZWFkQ291bnRFdmVudCgpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5fb2xkVW5yZWFkQ291bnQ7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLl9fdW5yZWFkQ291bnQ7XG4gICAgdGhpcy5fb2xkVW5yZWFkQ291bnQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSByZXR1cm47XG4gICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjb252ZXJzYXRpb25zOmNoYW5nZScsIHtcbiAgICAgIG5ld1ZhbHVlLFxuICAgICAgb2xkVmFsdWUsXG4gICAgICBwcm9wZXJ0eTogJ3VucmVhZENvdW50JyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBfXyBNZXRob2RzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgKlxuICAgKiBBbnkgY2hhbmdlIGluIHRoZSBsYXN0TWVzc2FnZSBwb2ludGVyIHdpbGwgY2FsbCB0aGlzIG1ldGhvZCBhbmQgZmlyZSBhXG4gICAqIGNoYW5nZSBldmVudC4gIENoYW5nZXMgdG8gcHJvcGVydGllcyB3aXRoaW4gdGhlIGxhc3RNZXNzYWdlIG9iamVjdCB3aWxsXG4gICAqIG5vdCB0cmlnZ2VyIHRoaXMgY2FsbC5cbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZUxhc3RNZXNzYWdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLk1lc3NhZ2V9IG5ld1ZhbHVlXG4gICAqIEBwYXJhbSAge2xheWVyLk1lc3NhZ2V9IG9sZFZhbHVlXG4gICAqL1xuICBfX3VwZGF0ZUxhc3RNZXNzYWdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmIChuZXdWYWx1ZSAmJiBvbGRWYWx1ZSAmJiBuZXdWYWx1ZS5pZCA9PT0gb2xkVmFsdWUuaWQpIHJldHVybjtcbiAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJywge1xuICAgICAgcHJvcGVydHk6ICdsYXN0TWVzc2FnZScsXG4gICAgICBuZXdWYWx1ZSxcbiAgICAgIG9sZFZhbHVlLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIF9fIE1ldGhvZHMgYXJlIGF1dG9tYXRpY2FsbHkgY2FsbGVkIGJ5IHByb3BlcnR5IHNldHRlcnMuXG4gICAqXG4gICAqIEFueSBjaGFuZ2UgaW4gdGhlIHBhcnRpY2lwYW50cyBwcm9wZXJ0eSB3aWxsIGNhbGwgdGhpcyBtZXRob2QgYW5kIGZpcmUgYVxuICAgKiBjaGFuZ2UgZXZlbnQuICBDaGFuZ2VzIHRvIHRoZSBwYXJ0aWNpcGFudHMgYXJyYXkgdGhhdCBkb24ndCByZXBsYWNlIHRoZSBhcnJheVxuICAgKiB3aXRoIGEgbmV3IGFycmF5IHdpbGwgcmVxdWlyZSBkaXJlY3RseSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAbWV0aG9kIF9fdXBkYXRlUGFydGljaXBhbnRzXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ1tdfSBuZXdWYWx1ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gb2xkVmFsdWVcbiAgICovXG4gIF9fdXBkYXRlUGFydGljaXBhbnRzKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGlmICh0aGlzLl9pbkxheWVyUGFyc2VyKSByZXR1cm47XG4gICAgY29uc3QgY2hhbmdlID0gdGhpcy5fZ2V0UGFydGljaXBhbnRDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICBpZiAoY2hhbmdlLmFkZC5sZW5ndGggfHwgY2hhbmdlLnJlbW92ZS5sZW5ndGgpIHtcbiAgICAgIGNoYW5nZS5wcm9wZXJ0eSA9ICdwYXJ0aWNpcGFudHMnO1xuICAgICAgY2hhbmdlLm9sZFZhbHVlID0gb2xkVmFsdWU7XG4gICAgICBjaGFuZ2UubmV3VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnY29udmVyc2F0aW9uczpjaGFuZ2UnLCBjaGFuZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBfXyBNZXRob2RzIGFyZSBhdXRvbWF0aWNhbGx5IGNhbGxlZCBieSBwcm9wZXJ0eSBzZXR0ZXJzLlxuICAgKlxuICAgKiBBbnkgY2hhbmdlIGluIHRoZSBtZXRhZGF0YSBwcm9wZXJ0eSB3aWxsIGNhbGwgdGhpcyBtZXRob2QgYW5kIGZpcmUgYVxuICAgKiBjaGFuZ2UgZXZlbnQuICBDaGFuZ2VzIHRvIHRoZSBtZXRhZGF0YSBvYmplY3QgdGhhdCBkb24ndCByZXBsYWNlIHRoZSBvYmplY3RcbiAgICogd2l0aCBhIG5ldyBvYmplY3Qgd2lsbCByZXF1aXJlIGRpcmVjdGx5IGNhbGxpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBtZXRob2QgX191cGRhdGVNZXRhZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG5ld1ZhbHVlXG4gICAqIEBwYXJhbSAge09iamVjdH0gb2xkVmFsdWVcbiAgICovXG4gIF9fdXBkYXRlTWV0YWRhdGEobmV3VmFsdWUsIG9sZFZhbHVlLCBwYXRocykge1xuICAgIGlmICh0aGlzLl9pbkxheWVyUGFyc2VyKSByZXR1cm47XG4gICAgaWYgKEpTT04uc3RyaW5naWZ5KG5ld1ZhbHVlKSAhPT0gSlNPTi5zdHJpbmdpZnkob2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJywge1xuICAgICAgICBwcm9wZXJ0eTogJ21ldGFkYXRhJyxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIG9sZFZhbHVlLFxuICAgICAgICBwYXRocyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0LlxuICAgKlxuICAgKiBPYmplY3Qgd2lsbCBoYXZlIGFsbCB0aGUgc2FtZSBwdWJsaWMgcHJvcGVydGllcyBhcyB0aGlzXG4gICAqIENvbnZlcnNhdGlvbiBpbnN0YW5jZS4gIE5ldyBvYmplY3QgaXMgcmV0dXJuZWQgYW55IHRpbWVcbiAgICogYW55IG9mIHRoaXMgb2JqZWN0J3MgcHJvcGVydGllcyBjaGFuZ2UuXG4gICAqXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fSBQT0pPIHZlcnNpb24gb2YgdGhpcy5cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5fdG9PYmplY3QpIHtcbiAgICAgIHRoaXMuX3RvT2JqZWN0ID0gc3VwZXIudG9PYmplY3QoKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0Lm1ldGFkYXRhID0gVXRpbC5jbG9uZSh0aGlzLm1ldGFkYXRhKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0LmlzTmV3ID0gdGhpcy5pc05ldygpO1xuICAgICAgdGhpcy5fdG9PYmplY3QuaXNTYXZpbmcgPSB0aGlzLmlzU2F2aW5nKCk7XG4gICAgICB0aGlzLl90b09iamVjdC5pc1NhdmVkID0gdGhpcy5pc1NhdmVkKCk7XG4gICAgICB0aGlzLl90b09iamVjdC5pc1N5bmNlZCA9IHRoaXMuaXNTeW5jZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0O1xuICB9XG5cbiAgX3RyaWdnZXJBc3luYyhldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci5fdHJpZ2dlckFzeW5jKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgdHJpZ2dlcihldnROYW1lLCBhcmdzKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBzdXBlci50cmlnZ2VyKGV2dE5hbWUsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNvbnZlcnNhdGlvbiBpbnN0YW5jZSBmcm9tIGEgc2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb252ZXJzYXRpb24uXG4gICAqXG4gICAqIElmIHRoZSBDb252ZXJzYXRpb24gYWxyZWFkeSBleGlzdHMsIHdpbGwgdXBkYXRlIHRoZSBleGlzdGluZyBjb3B5IHdpdGhcbiAgICogcHJlc3VtYWJseSBuZXdlciB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZUZyb21TZXJ2ZXJcbiAgICogQHByb3RlY3RlZFxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udmVyc2F0aW9uIC0gU2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29udmVyc2F0aW9uXG4gICAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50IFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVGcm9tU2VydmVyKGNvbnZlcnNhdGlvbiwgY2xpZW50KSB7XG4gICAgLy8gSWYgdGhlIENvbnZlcnNhdGlvbiBhbHJlYWR5IGV4aXN0cyBpbiBjYWNoZSwgdXBkYXRlIHRoZSBjYWNoZVxuICAgIHJldHVybiBuZXcgQ29udmVyc2F0aW9uKHtcbiAgICAgIGNsaWVudCxcbiAgICAgIGZyb21TZXJ2ZXI6IGNvbnZlcnNhdGlvbixcbiAgICAgIF9mcm9tREI6IGNvbnZlcnNhdGlvbi5fZnJvbURCLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgb3IgY3JlYXRlIGEgbmV3IGNvbnZlcmF0aW9uLlxuICAgKlxuICAgKiAgICAgIHZhciBjb252ZXJzYXRpb24gPSBsYXllci5Db252ZXJzYXRpb24uY3JlYXRlKHtcbiAgICogICAgICAgICAgcGFydGljaXBhbnRzOiBbJ2EnLCAnYiddLFxuICAgKiAgICAgICAgICBkaXN0aW5jdDogdHJ1ZSxcbiAgICogICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICogICAgICAgICAgICAgIHRpdGxlOiAnSSBhbSBub3QgYSB0aXRsZSEnXG4gICAqICAgICAgICAgIH0sXG4gICAqICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgKiAgICAgICAgICAnY29udmVyc2F0aW9uczpsb2FkZWQnOiBmdW5jdGlvbihldnQpIHtcbiAgICpcbiAgICogICAgICAgICAgfVxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBPbmx5IHRyaWVzIHRvIGZpbmQgYSBDb252ZXJzYXRpb24gaWYgaXRzIGEgRGlzdGluY3QgQ29udmVyc2F0aW9uLlxuICAgKiBEaXN0aW5jdCBkZWZhdWx0cyB0byB0cnVlLlxuICAgKlxuICAgKiBSZWNvbW1lbmQgdXNpbmcgYGNsaWVudC5jcmVhdGVDb252ZXJzYXRpb24oey4uLn0pYFxuICAgKiBpbnN0ZWFkIG9mIGBDb252ZXJzYXRpb24uY3JlYXRlKHsuLi59KWAuXG4gICAqXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEBzdGF0aWNcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7bGF5ZXIuQ2xpZW50fSBvcHRpb25zLmNsaWVudFxuICAgKiBAcGFyYW0gIHtzdHJpbmdbXX0gb3B0aW9ucy5wYXJ0aWNpcGFudHMgLSBBcnJheSBvZiBwYXJ0aWNpcGFudCBpZHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kaXN0aW5jdD1mYWxzZV0gLSBDcmVhdGUgYSBkaXN0aW5jdCBjb252ZXJzYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLm1ldGFkYXRhPXt9XSAtIEluaXRpYWwgbWV0YWRhdGEgZm9yIENvbnZlcnNhdGlvblxuICAgKiBAcmV0dXJuIHtsYXllci5Db252ZXJzYXRpb259XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuY2xpZW50KSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmNsaWVudE1pc3NpbmcpO1xuICAgIGlmIChvcHRpb25zLmRpc3RpbmN0KSB7XG4gICAgICBjb25zdCBjb252ID0gdGhpcy5fY3JlYXRlRGlzdGluY3Qob3B0aW9ucyk7XG4gICAgICBpZiAoY29udikgcmV0dXJuIGNvbnY7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb252ZXJzYXRpb24ob3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIG9yIEZpbmQgYSBEaXN0aW5jdCBDb252ZXJzYXRpb24uXG4gICAqXG4gICAqIElmIHRoZSBzdGF0aWMgQ29udmVyc2F0aW9uLmNyZWF0ZSBtZXRob2QgZ2V0cyBhIHJlcXVlc3QgZm9yIGEgRGlzdGluY3QgQ29udmVyc2F0aW9uLFxuICAgKiBzZWUgaWYgd2UgaGF2ZSBvbmUgY2FjaGVkLlxuICAgKlxuICAgKiBXaWxsIGZpcmUgdGhlICdjb252ZXJzYXRpb25zOmxvYWRlZCcgZXZlbnQgaWYgb25lIGlzIHByb3ZpZGVkIGluIHRoaXMgY2FsbCxcbiAgICogYW5kIGEgQ29udmVyc2F0aW9uIGlzIGZvdW5kLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVEaXN0aW5jdFxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAtIFNlZSBsYXllci5Db252ZXJzYXRpb24uY3JlYXRlIG9wdGlvbnNcbiAgICogQHJldHVybiB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVEaXN0aW5jdChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucGFydGljaXBhbnRzLmluZGV4T2Yob3B0aW9ucy5jbGllbnQudXNlcklkKSA9PT0gLTEpIHtcbiAgICAgIG9wdGlvbnMucGFydGljaXBhbnRzLnB1c2gob3B0aW9ucy5jbGllbnQudXNlcklkKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0aWNpcGFudHMgPSBvcHRpb25zLnBhcnRpY2lwYW50cy5zb3J0KCk7XG4gICAgY29uc3QgcFN0cmluZyA9IHBhcnRpY2lwYW50cy5qb2luKCcsJyk7XG5cbiAgICBjb25zdCBjb252ID0gb3B0aW9ucy5jbGllbnQuZmluZENhY2hlZENvbnZlcnNhdGlvbihhQ29udiA9PiB7XG4gICAgICBpZiAoYUNvbnYuZGlzdGluY3QgJiYgYUNvbnYucGFydGljaXBhbnRzLmxlbmd0aCA9PT0gcGFydGljaXBhbnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudHMyID0gYUNvbnYucGFydGljaXBhbnRzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIHBhcnRpY2lwYW50czIuam9pbignLCcpID09PSBwU3RyaW5nO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNvbnYpIHtcbiAgICAgIGNvbnYuX3NlbmREaXN0aW5jdEV2ZW50ID0gbmV3IExheWVyRXZlbnQoe1xuICAgICAgICB0YXJnZXQ6IGNvbnYsXG4gICAgICAgIHJlc3VsdDogIW9wdGlvbnMubWV0YWRhdGEgfHwgVXRpbC5kb2VzT2JqZWN0TWF0Y2gob3B0aW9ucy5tZXRhZGF0YSwgY29udi5tZXRhZGF0YSkgP1xuICAgICAgICAgIENvbnZlcnNhdGlvbi5GT1VORCA6IENvbnZlcnNhdGlvbi5GT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQSxcbiAgICAgIH0sICdjb252ZXJzYXRpb25zOnNlbnQnKTtcbiAgICAgIHJldHVybiBjb252O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZGVudGlmaWVzIHdoZXRoZXIgYSBDb252ZXJzYXRpb24gcmVjZWl2aW5nIHRoZSBzcGVjaWZpZWQgcGF0Y2ggZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQW55IGNoYW5nZSB0byBhIENvbnZlcnNhdGlvbiBpbmRpY2F0ZXMgdGhhdCB0aGUgQ29udmVyc2F0aW9uIGlzIGFjdGl2ZSBhbmQgb2YgcG90ZW50aWFsIGludGVyZXN0OyBnbyBhaGVhZCBhbmQgbG9hZCB0aGF0XG4gICAqIENvbnZlcnNhdGlvbiBpbiBjYXNlIHRoZSBhcHAgaGFzIG5lZWQgb2YgaXQuICBJbiB0aGUgZnV0dXJlIHdlIG1heSBpZ25vcmUgY2hhbmdlcyB0byB1bnJlYWQgY291bnQuICBPbmx5IHJlbGV2YW50XG4gICAqIHdoZW4gd2UgZ2V0IFdlYnNvY2tldCBldmVudHMgZm9yIGEgQ29udmVyc2F0aW9uIHRoYXQgaGFzIG5vdCBiZWVuIGxvYWRlZC9jYWNoZWQgb24gQ2xpZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkUmVzb3VyY2VGb3JQYXRjaFxuICAgKiBAc3RhdGljXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX2xvYWRSZXNvdXJjZUZvclBhdGNoKHBhdGNoRGF0YSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQXJyYXkgb2YgcGFydGljaXBhbnQgaWRzLlxuICpcbiAqIERvIG5vdCBkaXJlY3RseSBtYW5pcHVsYXRlO1xuICogdXNlIGFkZFBhcnRpY2lwYW50cywgcmVtb3ZlUGFydGljaXBhbnRzIGFuZCByZXBsYWNlUGFydGljaXBhbnRzXG4gKiB0byBtYW5pcHVsYXRlIHRoZSBhcnJheS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUucGFydGljaXBhbnRzID0gbnVsbDtcblxuLyoqXG4gKiBsYXllci5DbGllbnQgdGhhdCB0aGUgY29udmVyc2F0aW9uIGJlbG9uZ3MgdG8uXG4gKlxuICogQWN0dWFsIHZhbHVlIG9mIHRoaXMgc3RyaW5nIG1hdGNoZXMgdGhlIGFwcElkLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuQ29udmVyc2F0aW9uLnByb3RvdHlwZS5jbGllbnRJZCA9ICcnO1xuXG4vKipcbiAqIFRpbWUgdGhhdCB0aGUgY29udmVyc2F0aW9uIHdhcyBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogQHR5cGUge0RhdGV9XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUuY3JlYXRlZEF0ID0gbnVsbDtcblxuLyoqXG4gKiBDb252ZXJzYXRpb24gdW5pcXVlIGlkZW50aWZpZXIuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuQ29udmVyc2F0aW9uLnByb3RvdHlwZS5pZCA9ICcnO1xuXG4vKipcbiAqIFVSTCB0byBhY2Nlc3MgdGhlIGNvbnZlcnNhdGlvbiBvbiB0aGUgc2VydmVyLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUudXJsID0gJyc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHVucmVhZCBtZXNzYWdlcyBpbiB0aGUgY29udmVyc2F0aW9uLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUudW5yZWFkQ291bnQgPSAwO1xuXG4vKipcbiAqIFRoaXMgaXMgYSBEaXN0aW5jdCBDb252ZXJzYXRpb24uXG4gKlxuICogWW91IGNhbiBoYXZlIDEgZGlzdGluY3QgY29udmVyc2F0aW9uIGFtb25nIGEgc2V0IG9mIHBhcnRpY2lwYW50cy5cbiAqIFRoZXJlIGFyZSBubyBsaW1pdHMgdG8gaG93IG1hbnkgbm9uLWRpc3RpbmN0IENvbnZlcnNhdGlvbnMgeW91IGhhdmUgaGF2ZVxuICogYW1vbmcgYSBzZXQgb2YgcGFydGljaXBhbnRzLlxuICpcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5Db252ZXJzYXRpb24ucHJvdG90eXBlLmRpc3RpbmN0ID0gdHJ1ZTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgdGhlIGNvbnZlcnNhdGlvbi5cbiAqXG4gKiBNZXRhZGF0YSB2YWx1ZXMgY2FuIGJlIHBsYWluIG9iamVjdHMgYW5kIHN0cmluZ3MsIGJ1dFxuICogbm8gYXJyYXlzLCBudW1iZXJzLCBib29sZWFucyBvciBkYXRlcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUubWV0YWRhdGEgPSBudWxsO1xuXG4vKipcbiAqIFRpbWUgdGhhdCB0aGUgY29udmVyc2F0aW9uIG9iamVjdCB3YXMgaW5zdGFudGlhdGVkXG4gKiBpbiB0aGUgY3VycmVudCBjbGllbnQuXG4gKiBAdHlwZSB7RGF0ZX1cbiAqL1xuQ29udmVyc2F0aW9uLnByb3RvdHlwZS5sb2NhbENyZWF0ZWRBdCA9IG51bGw7XG5cbi8qKlxuICogVGhlIGF1dGhlbnRpY2F0ZWQgdXNlciBpcyBhIGN1cnJlbnQgcGFydGljaXBhbnQgaW4gdGhpcyBDb252ZXJzYXRpb24uXG4gKlxuICogU2V0IHRvIGZhbHNlIGlmIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIHRoaXMgY29udmVyc2F0aW9uLlxuICpcbiAqIEEgcmVtb3ZlZCB1c2VyIGNhbiBzZWUgbWVzc2FnZXMgdXAgdG8gdGhlIHRpbWUgdGhleSB3ZXJlIHJlbW92ZWQsXG4gKiBidXQgY2FuIG5vIGxvbmdlciBpbnRlcmFjdCB3aXRoIHRoZSBjb252ZXJzYXRpb24uXG4gKlxuICogQSByZW1vdmVkIHVzZXIgY2FuIG5vIGxvbmdlciBzZWUgdGhlIHBhcnRpY2lwYW50IGxpc3QuXG4gKlxuICogUmVhZCBhbmQgRGVsaXZlcnkgcmVjZWlwdHMgd2lsbCBmYWlsIG9uIGFueSBNZXNzYWdlIGluIHN1Y2ggYSBDb252ZXJzYXRpb24uXG4gKlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUuaXNDdXJyZW50UGFydGljaXBhbnQgPSB0cnVlO1xuXG4vKipcbiAqIFRoZSBsYXN0IGxheWVyLk1lc3NhZ2UgdG8gYmUgc2VudC9yZWNlaXZlZCBmb3IgdGhpcyBDb252ZXJzYXRpb24uXG4gKlxuICogVmFsdWUgbWF5IGJlIGEgTWVzc2FnZSB0aGF0IGhhcyBiZWVuIGxvY2FsbHkgY3JlYXRlZCBidXQgbm90IHlldCByZWNlaXZlZCBieSBzZXJ2ZXIuXG4gKiBAdHlwZSB7bGF5ZXIuTWVzc2FnZX1cbiAqL1xuQ29udmVyc2F0aW9uLnByb3RvdHlwZS5sYXN0TWVzc2FnZSA9IG51bGw7XG5cbi8qKlxuICogQ2FjaGVzIGxhc3QgcmVzdWx0IG9mIHRvT2JqZWN0KClcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5Db252ZXJzYXRpb24ucHJvdG90eXBlLl90b09iamVjdCA9IG51bGw7XG5cbkNvbnZlcnNhdGlvbi5ldmVudFByZWZpeCA9ICdjb252ZXJzYXRpb25zJztcblxuLyoqXG4gKiBDYWNoZSdzIGEgRGlzdGluY3QgRXZlbnQuXG4gKlxuICogT24gY3JlYXRpbmcgYSBEaXN0aW5jdCBDb252ZXJzYXRpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyxcbiAqIHdoZW4gdGhlIHNlbmQoKSBtZXRob2QgaXMgY2FsbGVkLCB3ZSBzaG91bGQgdHJpZ2dlclxuICogc3BlY2lmaWMgZXZlbnRzIGRldGFpbGluZyB0aGUgcmVzdWx0cy4gIFJlc3VsdHNcbiAqIG1heSBiZSBkZXRlcm1pbmVkIGxvY2FsbHkgb3Igb24gdGhlIHNlcnZlciwgYnV0IHNhbWUgRXZlbnQgbWF5IGJlIG5lZWRlZC5cbiAqXG4gKiBAdHlwZSB7bGF5ZXIuTGF5ZXJFdmVudH1cbiAqIEBwcml2YXRlXG4gKi9cbkNvbnZlcnNhdGlvbi5wcm90b3R5cGUuX3NlbmREaXN0aW5jdEV2ZW50ID0gbnVsbDtcblxuXG5Db252ZXJzYXRpb24ucHJvdG90eXBlLl9mcm9tREIgPSBmYWxzZTtcblxuLyoqXG4gKiBQcmVmaXggdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBhbiBJRCBmb3IgaW5zdGFuY2VzIG9mIHRoaXMgY2xhc3NcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc3RhdGljXG4gKiBAcHJpdmF0ZVxuICovXG5Db252ZXJzYXRpb24ucHJlZml4VVVJRCA9ICdsYXllcjovLy9jb252ZXJzYXRpb25zLyc7XG5cbi8qKlxuICogUHJvcGVydHkgdG8gbG9vayBmb3Igd2hlbiBidWJibGluZyB1cCBldmVudHMuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQHN0YXRpY1xuICogQHByaXZhdGVcbiAqL1xuQ29udmVyc2F0aW9uLmJ1YmJsZUV2ZW50UGFyZW50ID0gJ2dldENsaWVudCc7XG5cbi8qKlxuICogVGhlIENvbnZlcnNhdGlvbiB0aGF0IHdhcyByZXF1ZXN0ZWQgaGFzIGJlZW4gY3JlYXRlZC5cbiAqXG4gKiBVc2VkIGluICdjb252ZXJzYXRpb25zOnNlbnQnIGV2ZW50cy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cbkNvbnZlcnNhdGlvbi5DUkVBVEVEID0gJ0NyZWF0ZWQnO1xuXG4vKipcbiAqIFRoZSBDb252ZXJzYXRpb24gdGhhdCB3YXMgcmVxdWVzdGVkIGhhcyBiZWVuIGZvdW5kLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBpdCBkaWQgbm90IG5lZWQgdG8gYmUgY3JlYXRlZC5cbiAqXG4gKiBVc2VkIGluICdjb252ZXJzYXRpb25zOnNlbnQnIGV2ZW50cy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cbkNvbnZlcnNhdGlvbi5GT1VORCA9ICdGb3VuZCc7XG5cbi8qKlxuICogVGhlIENvbnZlcnNhdGlvbiB0aGF0IHdhcyByZXF1ZXN0ZWQgaGFzIGJlZW4gZm91bmQsIGJ1dCB0aGVyZSB3YXMgYSBtaXNtYXRjaCBpbiBtZXRhZGF0YS5cbiAqXG4gKiBJZiB0aGUgY3JlYXRlQ29udmVyc2F0aW9uIHJlcXVlc3QgY29udGFpbmVkIG1ldGFkYXRhIGFuZCBpdCBkaWQgbm90IG1hdGNoIHRoZSBEaXN0aW5jdCBDb252ZXJzYXRpb25cbiAqIHRoYXQgbWF0Y2hlZCB0aGUgcmVxdWVzdGVkIHBhcnRpY2lwYW50cywgdGhlbiB0aGlzIHZhbHVlIGlzIHBhc3NlZCB0byBub3RpZnkgeW91ciBhcHAgdGhhdCB0aGUgQ29udmVyc2F0aW9uXG4gKiB3YXMgcmV0dXJuZWQgYnV0IGRvZXMgbm90IGV4YWN0bHkgbWF0Y2ggeW91ciByZXF1ZXN0LlxuICpcbiAqIFVzZWQgaW4gJ2NvbnZlcnNhdGlvbnM6c2VudCcgZXZlbnRzLlxuICogQHR5cGUge1N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuQ29udmVyc2F0aW9uLkZPVU5EX1dJVEhPVVRfUkVRVUVTVEVEX01FVEFEQVRBID0gJ0ZvdW5kTWlzbWF0Y2gnO1xuXG5Db252ZXJzYXRpb24uX3N1cHBvcnRlZEV2ZW50cyA9IFtcblxuXG5cbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gaXMgbm93IG9uIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIENhbGxlZCBhZnRlciBzdWNjZXNzZnVsbHkgY3JlYXRpbmcgdGhlIGNvbnZlcnNhdGlvblxuICAgKiBvbiB0aGUgc2VydmVyLiAgVGhlIFJlc3VsdCBwcm9wZXJ0eSBpcyBvbmUgb2Y6XG4gICAqXG4gICAqICogQ29udmVyc2F0aW9uLkNSRUFURUQ6IEEgbmV3IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBjcmVhdGVkXG4gICAqICogQ29udmVyc2F0aW9uLkZPVU5EOiBBIG1hdGNoaW5nIERpc3RpbmN0IENvbnZlcnNhdGlvbiBoYXMgYmVlbiBmb3VuZFxuICAgKiAqIENvbnZlcnNhdGlvbi5GT1VORF9XSVRIT1VUX1JFUVVFU1RFRF9NRVRBREFUQTogQSBtYXRjaGluZyBEaXN0aW5jdCBDb252ZXJzYXRpb24gaGFzIGJlZW4gZm91bmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhlIG1ldGFkYXRhIGlzIE5PVCB3aGF0IHlvdSByZXF1ZXN0ZWQuXG4gICAqXG4gICAqIEFsbCBvZiB0aGVzZSByZXN1bHRzIHdpbGwgYWxzbyBtZWFuIHRoYXQgdGhlIHVwZGF0ZWQgcHJvcGVydHkgdmFsdWVzIGhhdmUgYmVlblxuICAgKiBjb3BpZWQgaW50byB5b3VyIENvbnZlcnNhdGlvbiBvYmplY3QuICBUaGF0IG1lYW5zIHlvdXIgbWV0YWRhdGEgcHJvcGVydHkgbWF5IG5vXG4gICAqIGxvbmdlciBiZSBpdHMgaW5pdGlhbCB2YWx1ZTsgaXQgbWF5IGJlIHRoZSB2YWx1ZSBmb3VuZCBvbiB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQucmVzdWx0XG4gICAqL1xuICAnY29udmVyc2F0aW9uczpzZW50JyxcblxuICAvKipcbiAgICogQW4gYXR0ZW1wdCB0byBzZW5kIHRoaXMgY29udmVyc2F0aW9uIHRvIHRoZSBzZXJ2ZXIgaGFzIGZhaWxlZC5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldmVudC5lcnJvclxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6c2VudC1lcnJvcicsXG5cbiAgLyoqXG4gICAqIFRoZSBjb252ZXJzYXRpb24gaXMgbm93IGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgdXNlZCBpbiByZXNwb25zZSB0byB0aGUgbGF5ZXIuQ29udmVyc2F0aW9uLmxvYWQoKSBtZXRob2QuXG4gICAqIGZyb20gdGhlIHNlcnZlci5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICovXG4gICdjb252ZXJzYXRpb25zOmxvYWRlZCcsXG5cbiAgLyoqXG4gICAqIEFuIGF0dGVtcHQgdG8gbG9hZCB0aGlzIGNvbnZlcnNhdGlvbiBmcm9tIHRoZSBzZXJ2ZXIgaGFzIGZhaWxlZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgaXMgb25seSB1c2VkIGluIHJlc3BvbnNlIHRvIHRoZSBsYXllci5Db252ZXJzYXRpb24ubG9hZCgpIG1ldGhvZC5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldmVudC5lcnJvclxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6bG9hZGVkLWVycm9yJyxcblxuICAvKipcbiAgICogVGhlIGNvbnZlcnNhdGlvbiBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2F1c2VkIGJ5IGVpdGhlciBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBkZWxldGUoKSBvbiB0aGlzIGluc3RhbmNlXG4gICAqIG9yIGJ5IGEgcmVtb3RlIHVzZXIuXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2ZW50XG4gICAqL1xuICAnY29udmVyc2F0aW9uczpkZWxldGUnLFxuXG4gIC8qKlxuICAgKiBUaGlzIGNvbnZlcnNhdGlvbiBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gZXZlbnQuY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgcmVwb3J0ZWQgYnkgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge01peGVkfSBldmVudC5jaGFuZ2VzLm5ld1ZhbHVlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGV2ZW50LmNoYW5nZXMub2xkVmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LmNoYW5nZXMucHJvcGVydHkgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0aGF0IGNoYW5nZWRcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb259IGV2ZW50LnRhcmdldFxuICAgKi9cbiAgJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJ10uY29uY2F0KFN5bmNhYmxlLl9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShDb252ZXJzYXRpb24sIFtDb252ZXJzYXRpb24sICdDb252ZXJzYXRpb24nXSk7XG5TeW5jYWJsZS5zdWJjbGFzc2VzLnB1c2goQ29udmVyc2F0aW9uKTtcbm1vZHVsZS5leHBvcnRzID0gQ29udmVyc2F0aW9uO1xuIiwiLyoqXG4gKiBQZXJzaXN0ZW5jZSBtYW5hZ2VyLlxuICpcbiAqIFRoaXMgY2xhc3MgbWFuYWdlcyBhbGwgaW5kZXhlZERCIGFjY2Vzcy4gIEl0IGlzIG5vdCByZXNwb25zaWJsZSBmb3IgYW55IGxvY2FsU3RvcmFnZSBhY2Nlc3MsIHRob3VnaCBpdCBtYXlcbiAqIHJlY2VpdmUgY29uZmlndXJhdGlvbnMgcmVsYXRlZCB0byBkYXRhIHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2UuICBJdCB3aWxsIHNpbXBseSBpZ25vcmUgdGhvc2UgY29uZmlndXJhdGlvbnMuXG4gKlxuICogVE9ETzpcbiAqIDAuIFJlZGVzaWduIHRoaXMgc28gdGhhdCBrbm93bGVkZ2Ugb2YgdGhlIGRhdGEgaXMgbm90IGhhcmQtY29kZWQgaW5cbiAqIDEuIEpTRHVjayB0aGlzIGNsYXNzXG4gKiAyLiBVcGRhdGUgZG9jdW1lbnRhdGlvbiByZXBvXG4gKiBAY2xhc3MgbGF5ZXIuZGItbWFuYWdlclxuICogQHByb3RlY3RlZFxuICovXG5cbmNvbnN0IERCX1ZFUlNJT04gPSAxMztcbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCBTeW5jRXZlbnQgPSByZXF1aXJlKCcuL3N5bmMtZXZlbnQnKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuXG5mdW5jdGlvbiBnZXREYXRlKGluRGF0ZSkge1xuICByZXR1cm4gaW5EYXRlID8gaW5EYXRlLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5jbGFzcyBEYk1hbmFnZXIgZXh0ZW5kcyBSb290IHtcblxuICAvKipcbiAgICogQ3JlYXRlIHRoZSBEQiBNYW5hZ2VyXG4gICAqXG4gICAqIEtleSBjb25maWd1cmF0aW9uIGlzIHRoZSBsYXllci5EYk1hbmFnZXIucGVyc2lzdGVuY2VGZWF0dXJlcyBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IG9wdGlvbnMuY2xpZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBlcnNpc3RlbmNlRmVhdHVyZXNcbiAgICogQHJldHVybiB7bGF5ZXIuRGJNYW5hZ2VyfSB0aGlzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAvLyBJZiBDbGllbnQgaXMgYSBsYXllci5DbGllbnRBdXRoZW50aWNhdG9yLCBpdCB3b24ndCBzdXBwb3J0IHRoZXNlIGV2ZW50czsgdGhpcyBhZmZlY3RzIFVuaXQgVGVzdHNcbiAgICBpZiAodGhpcy5jbGllbnQuY29uc3RydWN0b3IuX3N1cHBvcnRlZEV2ZW50cy5pbmRleE9mKCdjb252ZXJzYXRpb25zOmFkZCcpICE9PSAtMSkge1xuICAgICAgdGhpcy5jbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6YWRkJywgZXZ0ID0+IHRoaXMud3JpdGVDb252ZXJzYXRpb25zKGV2dC5jb252ZXJzYXRpb25zLCBmYWxzZSkpO1xuICAgICAgdGhpcy5jbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJywgZXZ0ID0+IHRoaXMud3JpdGVDb252ZXJzYXRpb25zKFtldnQudGFyZ2V0XSwgdHJ1ZSkpO1xuICAgICAgdGhpcy5jbGllbnQub24oJ2NvbnZlcnNhdGlvbnM6ZGVsZXRlJywgZXZ0ID0+IHRoaXMuZGVsZXRlT2JqZWN0cygnY29udmVyc2F0aW9ucycsIFtldnQudGFyZ2V0XSkpO1xuXG4gICAgICB0aGlzLmNsaWVudC5vbignbWVzc2FnZXM6YWRkJywgZXZ0ID0+IHRoaXMud3JpdGVNZXNzYWdlcyhldnQubWVzc2FnZXMsIGZhbHNlKSk7XG4gICAgICB0aGlzLmNsaWVudC5vbignbWVzc2FnZXM6Y2hhbmdlJywgZXZ0ID0+IHRoaXMud3JpdGVNZXNzYWdlcyhbZXZ0LnRhcmdldF0sIHRydWUpKTtcbiAgICAgIHRoaXMuY2xpZW50Lm9uKCdtZXNzYWdlczpkZWxldGUnLCBldnQgPT4gdGhpcy5kZWxldGVPYmplY3RzKCdtZXNzYWdlcycsIFtldnQudGFyZ2V0XSkpO1xuICAgIH1cblxuICAgIHRoaXMuY2xpZW50LnN5bmNNYW5hZ2VyLm9uKCdzeW5jOmFkZCcsIGV2dCA9PiB0aGlzLndyaXRlU3luY0V2ZW50cyhbZXZ0LnJlcXVlc3RdLCBmYWxzZSkpO1xuICAgIHRoaXMuY2xpZW50LnN5bmNNYW5hZ2VyLm9uKCdzeW5jOmFib3J0IHN5bmM6ZXJyb3InLCBldnQgPT4gdGhpcy5kZWxldGVPYmplY3RzKCdzeW5jUXVldWUnLCBbZXZ0LnJlcXVlc3RdKSk7XG5cbiAgICAvLyBJZiBubyBpbmRleGVkREIsIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgZGlzYWJsZWQuXG4gICAgaWYgKCF3aW5kb3cuaW5kZXhlZERCKSB7XG4gICAgICB0aGlzLnRhYmxlcyA9IHtcbiAgICAgICAgaWRlbnRpdGllczogdHJ1ZSxcbiAgICAgICAgY29udmVyc2F0aW9uczogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZXM6IHRydWUsXG4gICAgICAgIHN5bmNRdWV1ZTogdHJ1ZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gU3luYyBRdWV1ZSBvbmx5IHJlYWxseSB3b3JrcyBwcm9wZXJseSBpZiB3ZSBoYXZlIHRoZSBNZXNzYWdlcyBhbmQgQ29udmVyc2F0aW9ucyB3cml0dGVuIHRvIHRoZSBEQjsgdHVybiBpdCBvZmZcbiAgICAvLyBpZiB0aGF0IHdvbid0IGJlIHRoZSBjYXNlLlxuICAgIGlmICghdGhpcy50YWJsZXMuY29udmVyc2F0aW9ucyB8fCAhdGhpcy50YWJsZXMubWVzc2FnZXMpIHtcbiAgICAgIHRoaXMudGFibGVzLnN5bmNRdWV1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9vcGVuKCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBEYXRhYmFzZSBDb25uZWN0aW9uLlxuICAgKlxuICAgKiBUaGlzIGlzIG9ubHkgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAgICogQG1ldGhvZCBfb3BlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW4oKSB7XG4gICAgLy8gQWJvcnQgaWYgYWxsIHRhYmxlcyBhcmUgZGlzYWJsZWRcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy50YWJsZXMpLmZpbHRlcihrZXkgPT4gdGhpcy50YWJsZXNba2V5XSkubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBPcGVuIHRoZSBkYXRhYmFzZVxuICAgIGNvbnN0IHJlcXVlc3QgPSB3aW5kb3cuaW5kZXhlZERCLm9wZW4oJ0xheWVyV2ViU0RLXycgKyB0aGlzLmNsaWVudC5hcHBJZCArICdfJyArIHRoaXMuY2xpZW50LnVzZXJJZCwgREJfVkVSU0lPTik7XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSAoZXZ0KSA9PiBjb25zb2xlLmVycm9yKCdEYXRhYmFzZSBVbmFibGUgdG8gT3BlbjogJywgZXZ0LnRhcmdldC5lcnJvcik7XG4gICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSAoZXZ0KSA9PiB0aGlzLl9vblVwZ3JhZGVOZWVkZWQoZXZ0KTtcbiAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IChldnQpID0+IHtcbiAgICAgIHRoaXMuZGIgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignb3BlbicpO1xuXG4gICAgICB0aGlzLmRiLm9udmVyc2lvbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5kYi5jbG9zZSgpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5kYi5lcnJvciA9IGVyciA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcignZGItbWFuYWdlciBFcnJvcjogJywgZXJyKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyB0byBzZXR1cCBhIGNhbGwgdG8gaGFwcGVuIGFzIHNvb24gYXMgdGhlIGRhdGFiYXNlIGlzIG9wZW4uXG4gICAqXG4gICAqIFR5cGljYWxseSwgdGhpcyBjYWxsIHdpbGwgaW1tZWRpYXRlbHksIHN5bmNocm9ub3VzbHkgY2FsbCB5b3VyIGNhbGxiYWNrLlxuICAgKiBCdXQgaWYgdGhlIERCIGlzIG5vdCBvcGVuIHlldCwgeW91ciBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBvbmNlIGl0cyBvcGVuLlxuICAgKiBAbWV0aG9kIG9uT3BlblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKi9cbiAgb25PcGVuKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuKSBjYWxsYmFjaygpO1xuICAgIGVsc2UgdGhpcy5vbmNlKCdvcGVuJywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBvblVwZ3JhZGVOZWVkZWQgZnVuY3Rpb24gaXMgY2FsbGVkIGJ5IEluZGV4ZWREQiBhbnkgdGltZSBEQl9WRVJTSU9OIGlzIGluY3JlbWVudGVkLlxuICAgKlxuICAgKiBUaGlzIGludm9jYXRpb24gaXMgcGFydCBvZiB0aGUgYnVpbHQtaW4gbGlmZWN5Y2xlIG9mIEluZGV4ZWREQi5cbiAgICpcbiAgICogQG1ldGhvZCBfb25VcGdyYWRlTmVlZGVkXG4gICAqIEBwYXJhbSB7SURCVmVyc2lvbkNoYW5nZUV2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgX29uVXBncmFkZU5lZWRlZChldmVudCkge1xuICAgIGNvbnN0IGRiID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoJ2NvbnZlcnNhdGlvbnMnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBOb29wXG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBkYi5kZWxldGVPYmplY3RTdG9yZSgnaWRlbnRpdGllcycpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCdtZXNzYWdlcycpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKCdzeW5jUXVldWUnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBOb29wXG4gICAgfVxuICAgIGNvbnN0IHN0b3JlcyA9IFtcbiAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKCdjb252ZXJzYXRpb25zJywgeyBrZXlQYXRoOiAnaWQnIH0pLFxuICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ21lc3NhZ2VzJywgeyBrZXlQYXRoOiAnaWQnIH0pLFxuICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoJ2lkZW50aXRpZXMnLCB7IGtleVBhdGg6ICdpZCcgfSksXG4gICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSgnc3luY1F1ZXVlJywgeyBrZXlQYXRoOiAnaWQnIH0pLFxuICAgIF07XG5cbiAgICBzdG9yZXNbMV0uY3JlYXRlSW5kZXgoJ2NvbnZlcnNhdGlvbicsICdjb252ZXJzYXRpb24nLCB7IHVuaXF1ZTogZmFsc2UgfSk7XG5cbiAgICBsZXQgY29tcGxldGVDb3VudCA9IDA7XG4gICAgZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgIGNvbXBsZXRlQ291bnQrKztcbiAgICAgIGlmIChjb21wbGV0ZUNvdW50ID09PSBzdG9yZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdvcGVuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RvcmVzLmZvckVhY2goc3RvcmUgPT4gKHN0b3JlLnRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBvbkNvbXBsZXRlKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhcnJheSBvZiBDb252ZXJzYXRpb24gaW5zdGFuY2VzIGludG8gQ29udmVyc2F0aW9uIERCIEVudHJpZXMuXG4gICAqXG4gICAqIEEgQ29udmVyc2F0aW9uIERCIGVudHJ5IGxvb2tzIGEgbG90IGxpa2UgdGhlIHNlcnZlciByZXByZXNlbnRhdGlvbiwgYnV0XG4gICAqIGluY2x1ZGVzIGEgc3luY19zdGF0ZSBwcm9wZXJ0eSwgYW5kIGBsYXN0X21lc3NhZ2VgIGNvbnRhaW5zIGEgbWVzc2FnZSBJRCBub3RcbiAgICogYSBNZXNzYWdlIG9iamVjdC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0Q29udmVyc2F0aW9uRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBjb252ZXJzYXRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBjb252ZXJzYXRpb25zXG4gICAqL1xuICBfZ2V0Q29udmVyc2F0aW9uRGF0YShjb252ZXJzYXRpb25zKSB7XG4gICAgcmV0dXJuIGNvbnZlcnNhdGlvbnMuZmlsdGVyKGNvbnZlcnNhdGlvbiA9PiB7XG4gICAgICBpZiAoY29udmVyc2F0aW9uLl9mcm9tREIpIHtcbiAgICAgICAgY29udmVyc2F0aW9uLl9mcm9tREIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChjb252ZXJzYXRpb24uaXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChjb252ZXJzYXRpb24gPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgaWQ6IGNvbnZlcnNhdGlvbi5pZCxcbiAgICAgICAgdXJsOiBjb252ZXJzYXRpb24udXJsLFxuICAgICAgICBwYXJ0aWNpcGFudHM6IGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHMsXG4gICAgICAgIGRpc3RpbmN0OiBjb252ZXJzYXRpb24uZGlzdGluY3QsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IGdldERhdGUoY29udmVyc2F0aW9uLmNyZWF0ZWRBdCksXG4gICAgICAgIG1ldGFkYXRhOiBjb252ZXJzYXRpb24ubWV0YWRhdGEsXG4gICAgICAgIHVucmVhZF9tZXNzYWdlX2NvdW50OiBjb252ZXJzYXRpb24udW5yZWFkQ291bnQsXG4gICAgICAgIGxhc3RfbWVzc2FnZTogY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID8gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLmlkIDogJycsXG4gICAgICAgIHN5bmNfc3RhdGU6IGNvbnZlcnNhdGlvbi5zeW5jU3RhdGUsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGFuIGFycmF5IG9mIENvbnZlcnNhdGlvbnMgdG8gdGhlIERhdGFiYXNlLlxuICAgKlxuICAgKiBUaGVyZSBhcmUgdGltZXMgd2hlbiB5b3Ugd2lsbCBub3Qga25vdyBpZiB0aGlzIGlzIGFuIEluc2VydCBvciBVcGRhdGUgb3BlcmF0aW9uO1xuICAgKiBpZiB0aGVyZSBpcyB1bmNlcnRhaW55LCBzZXQgYGlzVXBkYXRlYCB0byBmYWxzZSwgYW5kIHRoZSBjb3JyZWN0IGVuZCByZXN1bHQgd2lsbFxuICAgKiBzdGlsbCBiZSBhY2hpZXZlZCAoYnV0IGxlc3MgZWZmaWNpZW50bHkpLlxuICAgKlxuICAgKiBAbWV0aG9kIHdyaXRlQ29udmVyc2F0aW9uc1xuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBjb252ZXJzYXRpb25zIC0gQXJyYXkgb2YgQ29udmVyc2F0aW9ucyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVXBkYXRlIC0gSWYgdHJ1ZSwgdGhlbiB1cGRhdGUgYW4gZW50cnk7IGlmIGZhbHNlLCBpbnNlcnQgYW4gZW50cnkuLi4gYW5kIGlmIG9uZSBpcyBmb3VuZCB0byBhbHJlYWR5IGV4aXN0LCB1cGRhdGUgaXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHdyaXRlQ29udmVyc2F0aW9ucyhjb252ZXJzYXRpb25zLCBpc1VwZGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl93cml0ZU9iamVjdHMoJ2NvbnZlcnNhdGlvbnMnLFxuICAgICAgdGhpcy5fZ2V0Q29udmVyc2F0aW9uRGF0YShjb252ZXJzYXRpb25zLmZpbHRlcihjb252ZXJzYXRpb24gPT4gIWNvbnZlcnNhdGlvbi5pc0Rlc3Ryb3llZCkpLCBpc1VwZGF0ZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYXJyYXkgb2YgTWVzc2FnZSBpbnN0YW5jZXMgaW50byBNZXNzYWdlIERCIEVudHJpZXMuXG4gICAqXG4gICAqIEEgTWVzc2FnZSBEQiBlbnRyeSBsb29rcyBhIGxvdCBsaWtlIHRoZSBzZXJ2ZXIgcmVwcmVzZW50YXRpb24sIGJ1dFxuICAgKiBpbmNsdWRlcyBhIHN5bmNfc3RhdGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldE1lc3NhZ2VEYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bGF5ZXIuTWVzc2FnZVtdfSBtZXNzYWdlc1xuICAgKiBAcmV0dXJuIHtPYmplY3RbXX0gbWVzc2FnZXNcbiAgICovXG4gIF9nZXRNZXNzYWdlRGF0YShtZXNzYWdlcykge1xuICAgIHJldHVybiBtZXNzYWdlcy5maWx0ZXIobWVzc2FnZSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5fZnJvbURCKSB7XG4gICAgICAgIG1lc3NhZ2UuX2Zyb21EQiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc3luY1N0YXRlID09PSBDb25zdGFudHMuU1lOQ19TVEFURS5MT0FESU5HKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChtZXNzYWdlID0+ICh7XG4gICAgICBpZDogbWVzc2FnZS5pZCxcbiAgICAgIHVybDogbWVzc2FnZS51cmwsXG4gICAgICBwYXJ0czogbWVzc2FnZS5wYXJ0cy5tYXAocGFydCA9PiAoe1xuICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgYm9keTogcGFydC5ib2R5LFxuICAgICAgICBlbmNvZGluZzogcGFydC5lbmNvZGluZyxcbiAgICAgICAgbWltZV90eXBlOiBwYXJ0Lm1pbWVUeXBlLFxuICAgICAgICBjb250ZW50OiAhcGFydC5fY29udGVudCA/IG51bGwgOiB7XG4gICAgICAgICAgaWQ6IHBhcnQuX2NvbnRlbnQuaWQsXG4gICAgICAgICAgZG93bmxvYWRfdXJsOiBwYXJ0Ll9jb250ZW50LmRvd25sb2FkVXJsLFxuICAgICAgICAgIGV4cGlyYXRpb246IHBhcnQuX2NvbnRlbnQuZXhwaXJhdGlvbixcbiAgICAgICAgICByZWZyZXNoX3VybDogcGFydC5fY29udGVudC5yZWZyZXNoVXJsLFxuICAgICAgICAgIHNpemU6IHBhcnQuX2NvbnRlbnQuc2l6ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pKSxcbiAgICAgIHBvc2l0aW9uOiBtZXNzYWdlLnBvc2l0aW9uLFxuICAgICAgc2VuZGVyOiB7XG4gICAgICAgIG5hbWU6IG1lc3NhZ2Uuc2VuZGVyLm5hbWUsXG4gICAgICAgIHVzZXJfaWQ6IG1lc3NhZ2Uuc2VuZGVyLnVzZXJJZCxcbiAgICAgIH0sXG4gICAgICByZWNpcGllbnRfc3RhdHVzOiBtZXNzYWdlLnJlY2lwaWVudFN0YXR1cyxcbiAgICAgIHNlbnRfYXQ6IGdldERhdGUobWVzc2FnZS5zZW50QXQpLFxuICAgICAgcmVjZWl2ZWRfYXQ6IGdldERhdGUobWVzc2FnZS5yZWNlaXZlZEF0KSxcbiAgICAgIGNvbnZlcnNhdGlvbjogbWVzc2FnZS5jb25zdHJ1Y3Rvci5wcmVmaXhVVUlEID09PSAnbGF5ZXI6Ly8vYW5ub3VuY2VtZW50cy8nID8gJ2Fubm91bmNlbWVudCcgOiBtZXNzYWdlLmNvbnZlcnNhdGlvbklkLFxuICAgICAgc3luY19zdGF0ZTogbWVzc2FnZS5zeW5jU3RhdGUsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlcyBhbiBhcnJheSBvZiBNZXNzYWdlcyB0byB0aGUgRGF0YWJhc2UuXG4gICAqXG4gICAqIFRoZXJlIGFyZSB0aW1lcyB3aGVuIHlvdSB3aWxsIG5vdCBrbm93IGlmIHRoaXMgaXMgYW4gSW5zZXJ0IG9yIFVwZGF0ZSBvcGVyYXRpb247XG4gICAqIGlmIHRoZXJlIGlzIHVuY2VydGFpbnksIHNldCBgaXNVcGRhdGVgIHRvIGZhbHNlLCBhbmQgdGhlIGNvcnJlY3QgZW5kIHJlc3VsdCB3aWxsXG4gICAqIHN0aWxsIGJlIGFjaGlldmVkIChidXQgbGVzcyBlZmZpY2llbnRseSkuXG4gICAqXG4gICAqIEBtZXRob2Qgd3JpdGVNZXNzYWdlc1xuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2VbXX0gbWVzc2FnZXMgLSBBcnJheSBvZiBNZXNzYWdlcyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVXBkYXRlIC0gSWYgdHJ1ZSwgdGhlbiB1cGRhdGUgYW4gZW50cnk7IGlmIGZhbHNlLCBpbnNlcnQgYW4gZW50cnkuLi4gYW5kIGlmIG9uZSBpcyBmb3VuZCB0byBhbHJlYWR5IGV4aXN0LCB1cGRhdGUgaXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHdyaXRlTWVzc2FnZXMobWVzc2FnZXMsIGlzVXBkYXRlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3dyaXRlT2JqZWN0cygnbWVzc2FnZXMnLCB0aGlzLl9nZXRNZXNzYWdlRGF0YShtZXNzYWdlcy5maWx0ZXIobWVzc2FnZSA9PiAhbWVzc2FnZS5pc0Rlc3Ryb3llZCkpLFxuICAgICAgaXNVcGRhdGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFycmF5IG9mIFN5bmNFdmVudCBpbnN0YW5jZXMgaW50byBTeW5jRXZlbnQgREIgRW50cmllcy5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0U3luY0V2ZW50RGF0YVxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudFtdfSBzeW5jRXZlbnRzXG4gICAqIEByZXR1cm4ge09iamVjdFtdfSBzeW5jRXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U3luY0V2ZW50RGF0YShzeW5jRXZlbnRzKSB7XG4gICAgcmV0dXJuIHN5bmNFdmVudHMuZmlsdGVyKHN5bmNFdnQgPT4ge1xuICAgICAgaWYgKHN5bmNFdnQuZnJvbURCKSB7XG4gICAgICAgIHN5bmNFdnQuZnJvbURCID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pLm1hcChzeW5jRXZlbnQgPT4ge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgaWQ6IHN5bmNFdmVudC5pZCxcbiAgICAgICAgdGFyZ2V0OiBzeW5jRXZlbnQudGFyZ2V0LFxuICAgICAgICBkZXBlbmRzOiBzeW5jRXZlbnQuZGVwZW5kcyxcbiAgICAgICAgaXNXZWJzb2NrZXQ6IHN5bmNFdmVudCBpbnN0YW5jZW9mIFN5bmNFdmVudC5XZWJzb2NrZXRTeW5jRXZlbnQsXG4gICAgICAgIG9wZXJhdGlvbjogc3luY0V2ZW50Lm9wZXJhdGlvbixcbiAgICAgICAgZGF0YTogc3luY0V2ZW50LmRhdGEsXG4gICAgICAgIHVybDogc3luY0V2ZW50LnVybCB8fCAnJyxcbiAgICAgICAgaGVhZGVyczogc3luY0V2ZW50LmhlYWRlcnMgfHwgbnVsbCxcbiAgICAgICAgbWV0aG9kOiBzeW5jRXZlbnQubWV0aG9kIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IHN5bmNFdmVudC5jcmVhdGVkQXQsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGFuIGFycmF5IG9mIFN5bmNFdmVudCB0byB0aGUgRGF0YWJhc2UuXG4gICAqXG4gICAqIEBtZXRob2Qgd3JpdGVTeW5jRXZlbnRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IHN5bmNFdmVudHMgLSBBcnJheSBvZiBTeW5jIEV2ZW50cyB0byB3cml0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVXBkYXRlIC0gSWYgdHJ1ZSwgdGhlbiB1cGRhdGUgYW4gZW50cnk7IGlmIGZhbHNlLCBpbnNlcnQgYW4gZW50cnkuLi4gYW5kIGlmIG9uZSBpcyBmb3VuZCB0byBhbHJlYWR5IGV4aXN0LCB1cGRhdGUgaXQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHdyaXRlU3luY0V2ZW50cyhzeW5jRXZlbnRzLCBpc1VwZGF0ZSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl93cml0ZU9iamVjdHMoJ3N5bmNRdWV1ZScsIHRoaXMuX2dldFN5bmNFdmVudERhdGEoc3luY0V2ZW50cyksIGlzVXBkYXRlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgYW4gYXJyYXkgb2YgZGF0YSB0byB0aGUgc3BlY2lmaWVkIERhdGFiYXNlIHRhYmxlLlxuICAgKlxuICAgKiBAbWV0aG9kIF93cml0ZU9iamVjdHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB0YWJsZSB0byB3cml0ZSB0b1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhIC0gQXJyYXkgb2YgUE9KTyBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNVcGRhdGUgLSBJZiB0cnVlLCB0aGVuIHVwZGF0ZSBhbiBlbnRyeTsgaWYgZmFsc2UsIGluc2VydCBhbiBlbnRyeS4uLiBhbmQgaWYgb25lIGlzIGZvdW5kIHRvIGFscmVhZHkgZXhpc3QsIHVwZGF0ZSBpdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIENhbGxlZCB3aGVuIGFsbCBkYXRhIGlzIHdyaXR0ZW5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3dyaXRlT2JqZWN0cyh0YWJsZU5hbWUsIGRhdGEsIGlzVXBkYXRlLCBjYWxsYmFjaykge1xuXG4gICAgLy8gSnVzdCBxdWl0IGlmIG5vIGRhdGEgdG8gd3JpdGVcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdHJhbnNhY3Rpb25Db21wbGV0ZSB3aWxsIGNhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIGFsbCB3cml0ZXMgYXJlIGRvbmUuXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIGlzIDEgKyBudW1iZXIgb2YgZmFpbGVkIGluc2VydHNcbiAgICBsZXQgdHJhbnNhY3Rpb25Db3VudCA9IDEsXG4gICAgICB0cmFuc2FjdGlvbkNvbXBsZXRlQ291bnQgPSAwO1xuICAgIGZ1bmN0aW9uIHRyYW5zYWN0aW9uQ29tcGxldGUoKSB7XG4gICAgICB0cmFuc2FjdGlvbkNvbXBsZXRlQ291bnQrKztcbiAgICAgIGlmICh0cmFuc2FjdGlvbkNvbXBsZXRlQ291bnQgPT09IHRyYW5zYWN0aW9uQ291bnQgJiYgY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLy8gUFVUICh1ZHBhdGUpIG9yIEFERCAoaW5zZXJ0KSBlYWNoIGl0ZW0gb2YgZGF0YSBvbmUgYXQgYSB0aW1lLCBidXQgYWxsIGFzIHBhcnQgb2Ygb25lIGxhcmdlIHRyYW5zYWN0aW9uLlxuICAgIHRoaXMub25PcGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGFibGVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSB0cmFuc2FjdGlvbkNvbXBsZXRlO1xuXG4gICAgICBkYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcSA9IGlzVXBkYXRlID8gc3RvcmUucHV0KGl0ZW0pIDogc3RvcmUuYWRkKGl0ZW0pO1xuXG4gICAgICAgIC8vIElmIHRoZSByZXF1ZXN0IGZhaWxzLCBhbmQgd2Ugd2VyZSBkb2luZyBhbiBpbnNlcnQsIHRyeSBhbiB1cGRhdGUgaW5zdGVhZC5cbiAgICAgICAgLy8gVGhpcyB3aWxsIGNyZWF0ZSBvbmUgdHJhbnNhY3Rpb24gcGVyIGVycm9yLlxuICAgICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBjYXB0dXJpbmcgYWxsIGVycm9ycyBhbmQgdGhlbiB1c2luZyBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgYWxsIGZhaWxlZCBpdGVtcy5cbiAgICAgICAgcmVxLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc1VwZGF0ZSkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25Db3VudCsrO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24yID0gdGhpcy5kYi50cmFuc2FjdGlvbihbdGFibGVOYW1lXSwgJ3JlYWR3cml0ZScpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmUyID0gdHJhbnNhY3Rpb24yLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbjIub25jb21wbGV0ZSA9IHRyYW5zYWN0aW9uMi5vbmVycm9yID0gdHJhbnNhY3Rpb25Db21wbGV0ZTtcbiAgICAgICAgICAgIHN0b3JlMi5wdXQoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgY29udmVyc2F0aW9ucyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCBsb2FkQ29udmVyc2F0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLkNvbnZlcnNhdGlvbltdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGxvYWRDb252ZXJzYXRpb25zKGNhbGxiYWNrKSB7XG4gICAgLy8gU3RlcCAxOiBHZXQgYWxsIENvbnZlcnNhdGlvbnNcbiAgICB0aGlzLl9sb2FkQWxsKCdjb252ZXJzYXRpb25zJywgZGF0YSA9PiB7XG5cbiAgICAgIC8vIFN0ZXAgMjogR2F0aGVyIGFsbCBNZXNzYWdlIElEcyBuZWVkZWQgdG8gaW5pdGlhbGl6ZSB0aGVzZSBDb252ZXJzYXRpb24ncyBsYXN0TWVzc2FnZSBwcm9wZXJ0aWVzLlxuICAgICAgY29uc3QgbWVzc2FnZXNUb0xvYWQgPSBkYXRhXG4gICAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLmxhc3RfbWVzc2FnZSlcbiAgICAgICAgLmZpbHRlcihtZXNzYWdlSWQgPT4gbWVzc2FnZUlkICYmICF0aGlzLmNsaWVudC5nZXRNZXNzYWdlKG1lc3NhZ2VJZCkpO1xuXG4gICAgICAvLyBTdGVwIDM6IExvYWQgYWxsIE1lc3NhZ2VzIG5lZWRlZCB0byBpbml0aWFsaXplIHRoZXNlIENvbnZlcnNhdGlvbidzIGxhc3RNZXNzYWdlIHByb3BlcnRpZXMuXG4gICAgICB0aGlzLmdldE9iamVjdHMoJ21lc3NhZ2VzJywgbWVzc2FnZXNUb0xvYWQsIG1lc3NhZ2VzID0+IHtcbiAgICAgICAgdGhpcy5fbG9hZENvbnZlcnNhdGlvbnNSZXN1bHQoZGF0YSwgbWVzc2FnZXMsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VtYmxlIGFsbCBMYXN0TWVzc2FnZXMgYW5kIENvbnZlcnNhdGlvbiBQT0pPcyBpbnRvIGxheWVyLk1lc3NhZ2UgYW5kIGxheWVyLkNvbnZlcnNhdGlvbiBpbnN0YW5jZXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRDb252ZXJzYXRpb25zUmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNvbnZlcnNhdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3RbXX0gbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5Db252ZXJzYXRpb25bXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBfbG9hZENvbnZlcnNhdGlvbnNSZXN1bHQoY29udmVyc2F0aW9ucywgbWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgLy8gSW5zdGFudGlhdGUgYW5kIFJlZ2lzdGVyIGVhY2ggTWVzc2FnZVxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB0aGlzLl9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpKTtcblxuICAgIC8vIEluc3RhbnRpYXRlIGFuZCBSZWdpc3RlciBlYWNoIENvbnZlcnNhdGlvbjsgd2lsbCBmaW5kIGFueSBsYXN0TWVzc2FnZSB0aGF0IHdhcyByZWdpc3RlcmVkLlxuICAgIGNvbnZlcnNhdGlvbnMuZm9yRWFjaChjb252ZXJzYXRpb24gPT4gdGhpcy5fY3JlYXRlQ29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbikpO1xuICAgIGNvbnN0IG5ld0RhdGEgPSBjb252ZXJzYXRpb25zXG4gICAgICAubWFwKGNvbnZlcnNhdGlvbiA9PiB0aGlzLmNsaWVudC5nZXRDb252ZXJzYXRpb24oY29udmVyc2F0aW9uLmlkKSlcbiAgICAgIC5maWx0ZXIoY29udmVyc2F0aW9uID0+IGNvbnZlcnNhdGlvbik7XG5cbiAgICAvLyBSZXR1cm4gdGhlIGRhdGFcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG5ld0RhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIG1lc3NhZ2VzIGZvciBhIGdpdmVuIENvbnZlcnNhdGlvbiBJRCBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogVXNlIF9sb2FkQWxsIGlmIGxvYWRpbmcgQWxsIE1lc3NhZ2VzIHJhdGhlciB0aGFuIGFsbCBNZXNzYWdlcyBmb3IgYSBDb252ZXJzYXRpb24uXG4gICAqXG4gICAqIEBtZXRob2QgbG9hZE1lc3NhZ2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb252ZXJzYXRpb25JZCAtIElEIG9mIHRoZSBDb252ZXJzYXRpb24gd2hvc2UgTWVzc2FnZXMgYXJlIG9mIGludGVyZXN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLk1lc3NhZ2VbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBsb2FkTWVzc2FnZXMoY29udmVyc2F0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9hZEJ5SW5kZXgoJ21lc3NhZ2VzJywgJ2NvbnZlcnNhdGlvbicsIGNvbnZlcnNhdGlvbklkLCBkYXRhID0+IHtcbiAgICAgIHRoaXMuX2xvYWRNZXNzYWdlc1Jlc3VsdChkYXRhLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgQW5ub3VuY2VtZW50cyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICpcbiAgICogQG1ldGhvZCBsb2FkQW5ub3VuY2VtZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2xheWVyLkFubm91bmNlbWVudFtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIGxvYWRBbm5vdW5jZW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9hZEJ5SW5kZXgoJ21lc3NhZ2VzJywgJ2NvbnZlcnNhdGlvbicsICdhbm5vdW5jZW1lbnQnLCBkYXRhID0+IHtcbiAgICAgIHRoaXMuX2xvYWRNZXNzYWdlc1Jlc3VsdChkYXRhLCBjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuZCBzb3J0cyB0aGUgbWVzc2FnZSBvYmplY3RzIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBUT0RPOiBFbmNvZGUgbGltaXRzIG9uIHRoaXMsIGVsc2Ugd2UgYXJlIHNvcnRpbmcgdGVucyBvZiB0aG91c2FuZHNcbiAgICogb2YgbWVzc2FnZXMgaW4gamF2YXNjcmlwdC5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZE1lc3NhZ2VzUmVzdWx0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IE1lc3NhZ2Ugb2JqZWN0cyBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlfSBjYWxsYmFjay5yZXN1bHQgLSBNZXNzYWdlIGluc3RhbmNlcyBjcmVhdGVkIGZyb20gdGhlIGRhdGFiYXNlXG4gICAqL1xuICBfbG9hZE1lc3NhZ2VzUmVzdWx0KG1lc3NhZ2VzLCBjYWxsYmFjaykge1xuICAgIC8vIEluc3RhbnRpYXRlIGFuZCBSZWdpc3RlciBlYWNoIE1lc3NhZ2VcbiAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4gdGhpcy5fY3JlYXRlTWVzc2FnZShtZXNzYWdlKSk7XG5cbiAgICAvLyBSZXRyaWV2ZSBhbGwgTWVzc2FnZXMgcmVnaXN0ZXJlZCBvciBwcmVyZWdpc3RlcmVkIGluIHRoaXMgd2F5XG4gICAgY29uc3QgbmV3RGF0YSA9IG1lc3NhZ2VzXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gdGhpcy5jbGllbnQuZ2V0TWVzc2FnZShtZXNzYWdlLmlkKSlcbiAgICAgIC5maWx0ZXIobWVzc2FnZSA9PiBtZXNzYWdlKTtcblxuICAgIC8vIFNvcnQgdGhlIHJlc3VsdHMgYnkgcG9zaXRpb25cbiAgICBVdGlsLnNvcnRCeShuZXdEYXRhLCBpdGVtID0+IGl0ZW0ucG9zaXRpb24pO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHRzXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhuZXdEYXRhKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIGFuZCBSZWdpc3RlciB0aGUgQ29udmVyc2F0aW9uIGZyb20gYSBjb252ZXJzYXRpb24gREIgRW50cnkuXG4gICAqXG4gICAqIElmIHRoZSBsYXllci5Db252ZXJzYXRpb24gYWxyZWFkeSBleGlzdHMsIHRoZW4gaXRzIHByZXN1bWVkIHRoYXQgd2hhdGV2ZXIgaXMgaW5cbiAgICogamF2YXNjcmlwdCBjYWNoZSBpcyBtb3JlIHVwIHRvIGRhdGUgdGhhbiB3aGF0cyBpbiBJbmRleGVkREIgY2FjaGUuXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGFzc2lnbiB0aGUgbGFzdE1lc3NhZ2UgcHJvcGVydHkgdG8gcmVmZXIgdG8gYXBwcm9wcmlhdGUgTWVzc2FnZS4gIElmIGl0IGZhaWxzLFxuICAgKiBpdCB3aWxsIGJlIHNldCB0byBudWxsLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jcmVhdGVDb252ZXJzYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnZlcnNhdGlvblxuICAgKiBAcmV0dXJucyB7bGF5ZXIuQ29udmVyc2F0aW9ufVxuICAgKi9cbiAgX2NyZWF0ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50LmdldENvbnZlcnNhdGlvbihjb252ZXJzYXRpb24uaWQpKSB7XG4gICAgICBjb252ZXJzYXRpb24uX2Zyb21EQiA9IHRydWU7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IGNvbnZlcnNhdGlvbi5sYXN0X21lc3NhZ2U7XG4gICAgICBjb252ZXJzYXRpb24ubGFzdF9tZXNzYWdlID0gJyc7XG4gICAgICBjb25zdCBuZXdDb252ZXJzYXRpb24gPSB0aGlzLmNsaWVudC5fY3JlYXRlT2JqZWN0KGNvbnZlcnNhdGlvbik7XG4gICAgICBuZXdDb252ZXJzYXRpb24uc3luY1N0YXRlID0gY29udmVyc2F0aW9uLnN5bmNfc3RhdGU7XG4gICAgICBuZXdDb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgPSB0aGlzLmNsaWVudC5nZXRNZXNzYWdlKGxhc3RNZXNzYWdlKSB8fCBudWxsO1xuICAgICAgcmV0dXJuIG5ld0NvbnZlcnNhdGlvbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW5kIFJlZ2lzdGVyIHRoZSBNZXNzYWdlIGZyb20gYSBtZXNzYWdlIERCIEVudHJ5LlxuICAgKlxuICAgKiBJZiB0aGUgbGF5ZXIuTWVzc2FnZSBhbHJlYWR5IGV4aXN0cywgdGhlbiBpdHMgcHJlc3VtZWQgdGhhdCB3aGF0ZXZlciBpcyBpblxuICAgKiBqYXZhc2NyaXB0IGNhY2hlIGlzIG1vcmUgdXAgdG8gZGF0ZSB0aGFuIHdoYXRzIGluIEluZGV4ZWREQiBjYWNoZS5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlTWVzc2FnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIF9jcmVhdGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBpZiAoIXRoaXMuY2xpZW50LmdldE1lc3NhZ2UobWVzc2FnZS5pZCkpIHtcbiAgICAgIG1lc3NhZ2UuX2Zyb21EQiA9IHRydWU7XG4gICAgICBtZXNzYWdlLmNvbnZlcnNhdGlvbiA9IHsgaWQ6IG1lc3NhZ2UuY29udmVyc2F0aW9uIH07XG4gICAgICBjb25zdCBuZXdNZXNzYWdlID0gdGhpcy5jbGllbnQuX2NyZWF0ZU9iamVjdChtZXNzYWdlKTtcbiAgICAgIG5ld01lc3NhZ2Uuc3luY1N0YXRlID0gbWVzc2FnZS5zeW5jX3N0YXRlO1xuICAgICAgcmV0dXJuIG5ld01lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIExvYWQgYWxsIFN5bmMgRXZlbnRzIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgKlxuICAgKiBAbWV0aG9kIGxvYWRTeW5jUXVldWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnRbXX0gY2FsbGJhY2sucmVzdWx0XG4gICAqL1xuICBsb2FkU3luY1F1ZXVlKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fbG9hZEFsbCgnc3luY1F1ZXVlJywgc3luY0V2ZW50cyA9PiB7XG4gICAgICB0aGlzLl9sb2FkU3luY0V2ZW50UmVsYXRlZERhdGEoc3luY0V2ZW50cywgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIHRoYXQgd2UgaGF2ZSBhcHByb3ByaWF0ZSBkYXRhIGZvciBlYWNoIFN5bmNFdmVudCBhbmQgaW5zdGFudGlhdGUgaXQuXG4gICAqXG4gICAqIEFueSBvcGVyYXRpb24gdGhhdCBpcyBub3QgYSBERUxFVEUgbXVzdCBoYXZlIGEgdmFsaWQgdGFyZ2V0IGZvdW5kIGluIHRoZSBkYXRhYmFzZSBvciBqYXZhc2NyaXB0IGNhY2hlLFxuICAgKiBvdGhlcndpc2UgaXQgY2FuIG5vdCBiZSBleGVjdXRlZC5cbiAgICpcbiAgICogVE9ETzogTmVlZCB0byBjbGVhbnVwIHN5bmMgZW50cmllcyB0aGF0IGhhdmUgaW52YWxpZCB0YXJnZXRzXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRTeW5jRXZlbnRSZWxhdGVkRGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBzeW5jRXZlbnRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRTeW5jRXZlbnRSZWxhdGVkRGF0YShzeW5jRXZlbnRzLCBjYWxsYmFjaykge1xuICAgIC8vIEdhdGhlciBhbGwgTWVzc2FnZSBJRHMgdGhhdCBhcmUgdGFyZ2V0cyBvZiBvcGVyYXRpb25zLlxuICAgIGNvbnN0IG1lc3NhZ2VJZHMgPSBzeW5jRXZlbnRzXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS5vcGVyYXRpb24gIT09ICdERUxFVEUnICYmIGl0ZW0udGFyZ2V0ICYmIGl0ZW0udGFyZ2V0Lm1hdGNoKC9tZXNzYWdlcy8pKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0udGFyZ2V0KTtcblxuICAgIC8vIEdhdGhlciBhbGwgQ29udmVyc2F0aW9uIElEcyB0aGF0IGFyZSB0YXJnZXRzIG9mIG9wZXJhdGlvbnMuXG4gICAgY29uc3QgY29udmVyc2F0aW9uSWRzID0gc3luY0V2ZW50c1xuICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0ub3BlcmF0aW9uICE9PSAnREVMRVRFJyAmJiBpdGVtLnRhcmdldCAmJiBpdGVtLnRhcmdldC5tYXRjaCgvY29udmVyc2F0aW9ucy8pKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0udGFyZ2V0KTtcblxuICAgIC8vIExvYWQgYW55IE1lc3NhZ2VzL0NvbnZlcnNhdGlvbnMgdGhhdCBhcmUgdGFyZ2V0cyBvZiBvcGVyYXRpb25zLlxuICAgIC8vIENhbGwgX2NyZWF0ZU1lc3NhZ2Ugb3IgX2NyZWF0ZUNvbnZlcnNhdGlvbiBvbiBhbGwgdGFyZ2V0cyBmb3VuZC5cbiAgICB0aGlzLmdldE9iamVjdHMoJ21lc3NhZ2VzJywgbWVzc2FnZUlkcywgbWVzc2FnZXMgPT4ge1xuICAgICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHRoaXMuX2NyZWF0ZU1lc3NhZ2UobWVzc2FnZSkpO1xuICAgICAgdGhpcy5nZXRPYmplY3RzKCdjb252ZXJzYXRpb25zJywgY29udmVyc2F0aW9uSWRzLCBjb252ZXJzYXRpb25zID0+IHtcbiAgICAgICAgY29udmVyc2F0aW9ucy5mb3JFYWNoKGNvbnZlcnNhdGlvbiA9PiB0aGlzLl9jcmVhdGVDb252ZXJzYXRpb24oY29udmVyc2F0aW9uKSk7XG4gICAgICAgIHRoaXMuX2xvYWRTeW5jRXZlbnRSZXN1bHRzKHN5bmNFdmVudHMsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFR1cm4gYW4gYXJyYXkgb2YgU3luYyBFdmVudCBEQiBFbnRyaWVzIGludG8gYW4gYXJyYXkgb2YgbGF5ZXIuU3luY0V2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkU3luY0V2ZW50UmVzdWx0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBzeW5jRXZlbnRzXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRTeW5jRXZlbnRSZXN1bHRzKHN5bmNFdmVudHMsIGNhbGxiYWNrKSB7XG5cbiAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIHByZXNlbnQgaW4gdGhlIHN5bmMgZXZlbnQsIGJ1dCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgc3lzdGVtLFxuICAgIC8vIGRvIE5PVCBhdHRlbXB0IHRvIGluc3RhbnRpYXRlIHRoaXMgZXZlbnQuLi4gdW5sZXNzIGl0cyBhIERFTEVURSBvcGVyYXRpb24uXG4gICAgY29uc3QgbmV3RGF0YSA9IHN5bmNFdmVudHNcbiAgICAuZmlsdGVyKHN5bmNFdmVudCA9PiB7XG4gICAgICBjb25zdCBoYXNUYXJnZXQgPSBCb29sZWFuKHN5bmNFdmVudC50YXJnZXQgJiYgdGhpcy5jbGllbnQuX2dldE9iamVjdChzeW5jRXZlbnQudGFyZ2V0KSk7XG4gICAgICByZXR1cm4gc3luY0V2ZW50Lm9wZXJhdGlvbiA9PT0gJ0RFTEVURScgfHwgaGFzVGFyZ2V0O1xuICAgIH0pXG4gICAgLm1hcChzeW5jRXZlbnQgPT4ge1xuICAgICAgaWYgKHN5bmNFdmVudC5pc1dlYnNvY2tldCkge1xuICAgICAgICByZXR1cm4gbmV3IFN5bmNFdmVudC5XZWJzb2NrZXRTeW5jRXZlbnQoe1xuICAgICAgICAgIHRhcmdldDogc3luY0V2ZW50LnRhcmdldCxcbiAgICAgICAgICBkZXBlbmRzOiBzeW5jRXZlbnQuZGVwZW5kcyxcbiAgICAgICAgICBvcGVyYXRpb246IHN5bmNFdmVudC5vcGVyYXRpb24sXG4gICAgICAgICAgaWQ6IHN5bmNFdmVudC5pZCxcbiAgICAgICAgICBkYXRhOiBzeW5jRXZlbnQuZGF0YSxcbiAgICAgICAgICBmcm9tREI6IHRydWUsXG4gICAgICAgICAgY3JlYXRlZEF0OiBzeW5jRXZlbnQuY3JlYXRlZF9hdCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFN5bmNFdmVudC5YSFJTeW5jRXZlbnQoe1xuICAgICAgICAgIHRhcmdldDogc3luY0V2ZW50LnRhcmdldCxcbiAgICAgICAgICBkZXBlbmRzOiBzeW5jRXZlbnQuZGVwZW5kcyxcbiAgICAgICAgICBvcGVyYXRpb246IHN5bmNFdmVudC5vcGVyYXRpb24sXG4gICAgICAgICAgaWQ6IHN5bmNFdmVudC5pZCxcbiAgICAgICAgICBkYXRhOiBzeW5jRXZlbnQuZGF0YSxcbiAgICAgICAgICBtZXRob2Q6IHN5bmNFdmVudC5tZXRob2QsXG4gICAgICAgICAgaGVhZGVyczogc3luY0V2ZW50LmhlYWRlcnMsXG4gICAgICAgICAgdXJsOiBzeW5jRXZlbnQudXJsLFxuICAgICAgICAgIGZyb21EQjogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IHN5bmNFdmVudC5jcmVhdGVkX2F0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQgdGhlIHJlc3VsdHMgYW5kIHRoZW4gcmV0dXJuIHRoZW0uXG4gICAgVXRpbC5zb3J0QnkobmV3RGF0YSwgaXRlbSA9PiBpdGVtLmNyZWF0ZWRBdCk7XG4gICAgY2FsbGJhY2sobmV3RGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbGwgZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgdGFibGUuXG4gICAqXG4gICAqIEBtZXRob2QgX2xvYWRBbGxcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGFibGVOYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgX2xvYWRBbGwodGFibGVOYW1lLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy50YWJsZXNbdGFibGVOYW1lXSkgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0YWJsZU5hbWVdLCAncmVhZG9ubHknKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpLm9wZW5DdXJzb3IoKS5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IGV2dC50YXJnZXQucmVzdWx0O1xuICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgZGF0YS5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLmlzRGVzdHJveWVkKSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGFsbCBkYXRhIGZyb20gdGhlIHNwZWNpZmllZCB0YWJsZSBhbmQgd2l0aCB0aGUgc3BlY2lmaWVkIGluZGV4IHZhbHVlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkQnlJbmRleFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGluZGV4TmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5kZXhWYWx1ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge09iamVjdFtdfSBjYWxsYmFjay5yZXN1bHRcbiAgICovXG4gIF9sb2FkQnlJbmRleCh0YWJsZU5hbWUsIGluZGV4TmFtZSwgaW5kZXhWYWx1ZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMudGFibGVzW3RhYmxlTmFtZV0pIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB3aW5kb3cuSURCS2V5UmFuZ2Uub25seShpbmRleFZhbHVlKTtcbiAgICAgIHRoaXMuZGIudHJhbnNhY3Rpb24oW3RhYmxlTmFtZV0sICdyZWFkb25seScpXG4gICAgICAgICAgLm9iamVjdFN0b3JlKHRhYmxlTmFtZSlcbiAgICAgICAgICAuaW5kZXgoaW5kZXhOYW1lKVxuICAgICAgICAgIC5vcGVuQ3Vyc29yKHJhbmdlKVxuICAgICAgICAgIC5vbnN1Y2Nlc3MgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgZGF0YS5wdXNoKGN1cnNvci52YWx1ZSk7XG4gICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGVzdHJveWVkKSBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBvYmplY3RzIGZyb20gdGhlIHNwZWNpZmllZCB0YWJsZS5cbiAgICpcbiAgICogQ3VycmVudGx5IHRha2VzIGFuIGFycmF5IG9mIGRhdGEgdG8gZGVsZXRlIHJhdGhlciB0aGFuIGFuIGFycmF5IG9mIElEcztcbiAgICogSWYgeW91IG9ubHkgaGF2ZSBhbiBJRCwgW3tpZDogbXlJZH1dIHNob3VsZCB3b3JrLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZU9iamVjdHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRhYmxlTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIGRlbGV0ZU9iamVjdHModGFibGVOYW1lLCBkYXRhLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy50YWJsZXNbdGFibGVOYW1lXSkgcmV0dXJuIGNhbGxiYWNrID8gY2FsbGJhY2soKSA6IG51bGw7XG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0YWJsZU5hbWVdLCAncmVhZHdyaXRlJyk7XG4gICAgICBjb25zdCBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gY2FsbGJhY2s7XG4gICAgICBkYXRhLmZvckVhY2goaXRlbSA9PiBzdG9yZS5kZWxldGUoaXRlbS5pZCkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBpZGVudGlmaWVkIG9iamVjdHMgZnJvbSB0aGUgc3BlY2lmaWVkIGRhdGFiYXNlIHRhYmxlLlxuICAgKlxuICAgKiBUdXJuaW5nIHRoZXNlIGludG8gaW5zdGFuY2VzIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyLlxuICAgKlxuICAgKiBJbnNwaXJlZCBieSBodHRwOi8vd3d3LmNvZGVwcm9qZWN0LmNvbS9BcnRpY2xlcy83NDQ5ODYvSG93LXRvLWRvLXNvbWUtbWFnaWMtd2l0aC1pbmRleGVkREJcbiAgICpcbiAgICogQG1ldGhvZCBnZXRPYmplY3RzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0YWJsZU5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gaWRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgZ2V0T2JqZWN0cyh0YWJsZU5hbWUsIGlkcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMudGFibGVzW3RhYmxlTmFtZV0pIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgLy8gR2F0aGVyLCBzb3J0LCBhbmQgZmlsdGVyIHJlcGxpY2EgSURzXG4gICAgY29uc3Qgc29ydGVkSWRzID0gaWRzLnNvcnQoKTtcbiAgICBmb3IgKGxldCBpID0gc29ydGVkSWRzLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgIGlmIChzb3J0ZWRJZHNbaV0gPT09IHNvcnRlZElkc1tpIC0gMV0pIHNvcnRlZElkcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRhYmxlIHNlYXJjaGluZyBmb3IgdGhlIHNwZWNpZmllZCBJRHNcbiAgICB0aGlzLm9uT3BlbigoKSA9PiB7XG4gICAgICB0aGlzLmRiLnRyYW5zYWN0aW9uKFt0YWJsZU5hbWVdLCAncmVhZG9ubHknKVxuICAgICAgICAub2JqZWN0U3RvcmUodGFibGVOYW1lKVxuICAgICAgICAub3BlbkN1cnNvcigpLm9uc3VjY2VzcyA9IChldnQpID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBldnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGtleSA9IGN1cnNvci5rZXk7XG5cbiAgICAgICAgICAvLyBUaGUgY3Vyc29yIGhhcyBwYXNzZWQgYmV5b25kIHRoaXMga2V5LiBDaGVjayBuZXh0LlxuICAgICAgICAgIHdoaWxlIChrZXkgPiBzb3J0ZWRJZHNbaW5kZXhdKSBpbmRleCsrO1xuXG4gICAgICAgICAgLy8gVGhlIGN1cnNvciBpcyBwb2ludGluZyBhdCBvbmUgb2Ygb3VyIElEcywgZ2V0IGl0IGFuZCBjaGVjayBuZXh0LlxuICAgICAgICAgIGlmIChrZXkgPT09IHNvcnRlZElkc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb25lIG9yIGNoZWNrIG5leHRcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHNvcnRlZElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Rlc3Ryb3llZCkgY2FsbGJhY2soZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShzb3J0ZWRJZHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2xhaW0gYSBTeW5jIEV2ZW50LlxuICAgKlxuICAgKiBBIHN5bmMgZXZlbnQgaXMgY2xhaW1lZCBieSBsb2NraW5nIHRoZSB0YWJsZSwgIHZhbGlkYXRpbmcgdGhhdCBpdCBpcyBzdGlsbCBpbiB0aGUgdGFibGUuLi4gYW5kIHRoZW4gZGVsZXRpbmcgaXQgZnJvbSB0aGUgdGFibGUuXG4gICAqXG4gICAqIEBtZXRob2QgY2xhaW1TeW5jRXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnR9IHN5bmNFdmVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhbGxiYWNrLnJlc3VsdFxuICAgKi9cbiAgY2xhaW1TeW5jRXZlbnQoc3luY0V2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy50YWJsZXMuc3luY1F1ZXVlKSByZXR1cm4gY2FsbGJhY2sodHJ1ZSk7XG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnc3luY1F1ZXVlJ10sICdyZWFkd3JpdGUnKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ3N5bmNRdWV1ZScpO1xuICAgICAgc3RvcmUuZ2V0KHN5bmNFdmVudC5pZCkub25zdWNjZXNzID0gZXZ0ID0+IGNhbGxiYWNrKEJvb2xlYW4oZXZ0LnRhcmdldC5yZXN1bHQpKTtcbiAgICAgIHN0b3JlLmRlbGV0ZShzeW5jRXZlbnQuaWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbGwgZGF0YSBmcm9tIGFsbCB0YWJsZXMuXG4gICAqXG4gICAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBmcm9tIGxheWVyLkNsaWVudC5sb2dvdXQoKVxuICAgKlxuICAgKiBAbWV0aG9kIGRlbGV0ZVRhYmxlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGxiYWNrXVxuICAgKi9cbiAgZGVsZXRlVGFibGVzKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbk9wZW4oKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0aGlzLmRiLnRyYW5zYWN0aW9uKFsnY29udmVyc2F0aW9ucycsICdpZGVudGl0aWVzJywgJ21lc3NhZ2VzJywgJ3N5bmNRdWV1ZSddLCAncmVhZHdyaXRlJyk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKCdjb252ZXJzYXRpb25zJykuY2xlYXIoKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoJ2lkZW50aXRpZXMnKS5jbGVhcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnbWVzc2FnZXMnKS5jbGVhcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSgnc3luY1F1ZXVlJykuY2xlYXIoKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGNhbGxiYWNrO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZSB7bGF5ZXIuQ2xpZW50fSBMYXllciBDbGllbnQgaW5zdGFuY2VcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlIHtib29sZWFufSBpcyB0aGUgZGIgY29ubmVjdGlvbiBvcGVuXG4gKi9cbkRiTWFuYWdlci5wcm90b3R5cGUuaXNPcGVuID0gZmFsc2U7XG5cbi8qKlxuICogQHR5cGUge09iamVjdH0gQSBsaXN0IG9mIHRhYmxlcyB0aGF0IGFyZSBlbmFibGVkLlxuICpcbiAqIERpc2FibGVkIHRhYmxlcyBhcmUgb21pdHRlZCBvciBmYWxzZS5cbiAqIHN5bmMtZXZlbnRzIGNhbiBvbmx5IGJlIGVuYWJsZWQgSUYgY29udmVyc2F0aW9ucyBhbmQgbWVzc2FnZXMgYXJlIGVuYWJsZWRcbiAqL1xuRGJNYW5hZ2VyLnByb3RvdHlwZS50YWJsZXMgPSBudWxsO1xuXG4vKipcbiAqIEB0eXBlIElEQkRhdGFiYXNlXG4gKi9cbkRiTWFuYWdlci5wcm90b3R5cGUuZGIgPSBudWxsO1xuXG5EYk1hbmFnZXIuX3N1cHBvcnRlZEV2ZW50cyA9IFtcbiAgJ29wZW4nLFxuXTtcblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoRGJNYW5hZ2VyLCBbRGJNYW5hZ2VyLCAnRGJNYW5hZ2VyJ10pO1xubW9kdWxlLmV4cG9ydHMgPSBEYk1hbmFnZXI7XG4iLCIvKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIExheWVyIEVycm9yLlxuICpcbiAqIEF0IHRoaXMgcG9pbnQsIGEgTGF5ZXJFcnJvciBpcyBvbmx5IHVzZWQgaW4gcmVzcG9uc2UgdG8gYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyLlxuICogSXQgbWF5IGJlIGV4dGVuZGVkIHRvIHJlcG9ydCBvbiBpbnRlcm5hbCBlcnJvcnMuLi4gYnV0IHR5cGljYWxseSBpbnRlcm5hbCBlcnJvcnNcbiAqIGFyZSByZXBvcnRlZCB2aWEgYHRocm93IG5ldyBFcnJvciguLi4pO2BcbiAqXG4gKiBMYXllciBFcnJvciBpcyBwYXNzZWQgYXMgcGFydCBvZiB0aGUgbGF5ZXIuTGF5ZXJFdmVudCdzIGRhdGEgcHJvcGVydHkuXG4gKlxuICogICAgIG9iamVjdC50cmlnZ2VyKCd4eHgtZXJyb3InLCBuZXcgTGF5ZXJFdmVudCh7XG4gKiAgICAgICBkYXRhOiBuZXcgTGF5ZXJFcnJvcigpXG4gKiAgICAgfSkpO1xuICpcbiAqIEBjbGFzcyBsYXllci5MYXllckVycm9yXG4gKi9cbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jbGFzcyBMYXllckVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgTGF5ZXJFcnJvcikge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgZXJyVHlwZTogb3B0aW9ucy5lcnJUeXBlLFxuICAgICAgICBodHRwU3RhdHVzOiBvcHRpb25zLmh0dHBTdGF0dXMsXG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMubWVzc2FnZSxcbiAgICAgICAgY29kZTogb3B0aW9ucy5jb2RlLFxuICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGEsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMuZXJyVHlwZSA9IG9wdGlvbnMuaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMpLmZvckVhY2gobmFtZSA9PiB0aGlzW25hbWVdID0gb3B0aW9uc1tuYW1lXSk7XG4gICAgaWYgKCF0aGlzLmRhdGEpIHRoaXMuZGF0YSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgZWl0aGVyICcnIG9yIGEgbm9uY2UuXG4gICAqXG4gICAqIElmIGEgbm9uY2UgaGFzIGJlZW4gcmV0dXJuZWRcbiAgICogYnkgdGhlIHNlcnZlciBhcyBwYXJ0IG9mIGEgc2Vzc2lvbi1leHBpcmF0aW9uIGVycm9yLFxuICAgKiB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRoYXQgbm9uY2UuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Tm9uY2VcbiAgICogQHJldHVybiB7c3RyaW5nfSBub25jZVxuICAgKi9cbiAgZ2V0Tm9uY2UoKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLm5vbmNlKSA/IHRoaXMuZGF0YS5ub25jZSA6ICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3JcbiAgICpcbiAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlICsgJyAoJyArIHRoaXMuaWQgKyAnKTogJyArIHRoaXMubWVzc2FnZSArICc7IChzZWUgJyArIHRoaXMudXJsICsgJyknO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZyB0aGUgZXJyb3JzXG4gICAqXG4gICAqIEBtZXRob2QgbG9nXG4gICAqIEBkZXByZWNhdGVkIHNlZSBsYXllci5Mb2dnZXJcbiAgICovXG4gIGxvZygpIHtcbiAgICBMb2dnZXIuZXJyb3IoJ0xheWVyLUVycm9yOiAnICsgdGhpcy50b1N0cmluZygpKTtcbiAgfVxuXG59XG5cbi8qKlxuICogQSBzdHJpbmcgbmFtZSBmb3IgdGhlIGV2ZW50OyB0aGVzZSBuYW1lcyBhcmUgcGFpcmVkIHdpdGggY29kZXMuXG4gKlxuICogQ29kZXMgY2FuIGJlIGxvb2tlZCB1cCBhdCBodHRwczovL2dpdGh1Yi5jb20vbGF5ZXJocS9kb2NzL2Jsb2Ivd2ViLWFwaS9zcGVjcy9yZXN0LWFwaS5tZCNjbGllbnQtZXJyb3JzXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5MYXllckVycm9yLnByb3RvdHlwZS5lcnJUeXBlID0gJyc7XG5cbi8qKlxuICogTnVtZXJpY2FsIGVycm9yIGNvZGUuXG4gKlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubGF5ZXIuY29tL2RvY3MvY2xpZW50L3Jlc3QjZnVsbC1saXN0XG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5MYXllckVycm9yLnByb3RvdHlwZS5jb2RlID0gMDtcblxuLyoqXG4gKiBVUkwgdG8gZ28gdG8gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhpcyBlcnJvci5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkxheWVyRXJyb3IucHJvdG90eXBlLnVybCA9ICcnO1xuXG4vKipcbiAqIERldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoZSBlcnJvci5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkxheWVyRXJyb3IucHJvdG90eXBlLm1lc3NhZ2UgPSAnJztcblxuLyoqXG4gKiBIdHRwIGVycm9yIGNvZGU7IG5vIHZhbHVlIGlmIGl0cyBhIHdlYnNvY2tldCByZXNwb25zZS5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkxheWVyRXJyb3IucHJvdG90eXBlLmh0dHBTdGF0dXMgPSAwO1xuXG4vKipcbiAqIENvbnRhaW5zIGRhdGEgZnJvbSB0aGUgeGhyIHJlcXVlc3Qgb2JqZWN0LlxuICpcbiAqICAqIHVybDogdGhlIHVybCB0byB0aGUgc2VydmljZSBlbmRwb2ludFxuICogICogZGF0YTogeGhyLmRhdGEsXG4gKiAgKiB4aHI6IFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkxheWVyRXJyb3IucHJvdG90eXBlLnJlcXVlc3QgPSBudWxsO1xuXG4vKipcbiAqIEFueSBhZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhlIGVycm9yIHNlbnQgYXMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTGF5ZXJFcnJvci5wcm90b3R5cGUuZGF0YSA9IG51bGw7XG5cbi8qKlxuICogUG9pbnRlciB0byB0aGUgeGhyIG9iamVjdCB0aGF0IGZpcmVkIHRoZSBhY3R1YWwgcmVxdWVzdCBhbmQgY29udGFpbnMgdGhlIHJlc3BvbnNlLlxuICogQHR5cGUge1hNTEh0dHBSZXF1ZXN0fVxuICovXG5MYXllckVycm9yLnByb3RvdHlwZS54aHIgPSBudWxsO1xuXG4vKipcbiAqIERpY3Rpb25hcnkgb2YgZXJyb3IgbWVzc2FnZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZGljdGlvbmFyeT17fV1cbiAqL1xuTGF5ZXJFcnJvci5kaWN0aW9uYXJ5ID0ge1xuICBhcHBJZE1pc3Npbmc6ICdQcm9wZXJ0eSBtaXNzaW5nOiBhcHBJZCBpcyByZXF1aXJlZCcsXG4gIGlkZW50aXR5VG9rZW5NaXNzaW5nOiAnSWRlbnRpdHkgVG9rZW4gbWlzc2luZzogYW5zd2VyQXV0aGVudGljYXRpb25DaGFsbGVuZ2UgcmVxdWlyZXMgYW4gaWRlbnRpdHkgdG9rZW4nLFxuICBzZXNzaW9uVG9rZW5NaXNzaW5nOiAnU2Vzc2lvbiBUb2tlbiBtaXNzaW5nOiBfYXV0aENvbXBsZXRlIHJlcXVpcmVzIGEge3Nlc3Npb25fdG9rZW46IHZhbHVlfSBpbnB1dCcsXG4gIGNsaWVudE1pc3Npbmc6ICdQcm9wZXJ0eSBtaXNzaW5nOiBjbGllbnQgaXMgcmVxdWlyZWQnLFxuICBjb252ZXJzYXRpb25NaXNzaW5nOiAnUHJvcGVydHkgbWlzc2luZzogY29udmVyc2F0aW9uIGlzIHJlcXVpcmVkJyxcbiAgcGFydHNNaXNzaW5nOiAnUHJvcGVydHkgbWlzc2luZzogcGFydHMgaXMgcmVxdWlyZWQnLFxuICBtb3JlUGFydGljaXBhbnRzUmVxdWlyZWQ6ICdDb252ZXJzYXRpb24gbmVlZHMgcGFydGljaXBhbnRzIG90aGVyIHRoYW4gdGhlIGN1cnJlbnQgdXNlcicsXG4gIGlzRGVzdHJveWVkOiAnT2JqZWN0IGlzIGRlc3Ryb3llZCcsXG4gIHVybFJlcXVpcmVkOiAnT2JqZWN0IG5lZWRzIGEgdXJsIHByb3BlcnR5JyxcbiAgaW52YWxpZFVybDogJ1VSTCBpcyBpbnZhbGlkJyxcbiAgaW52YWxpZElkOiAnSWRlbnRpZmllciBpcyBpbnZhbGlkJyxcbiAgaWRQYXJhbVJlcXVpcmVkOiAnVGhlIElEIFBhcmFtZXRlciBpcyByZXF1aXJlZCcsXG4gIHdyb25nQ2xhc3M6ICdQYXJhbWV0ZXIgY2xhc3MgZXJyb3I7IHNob3VsZCBiZTogJyxcbiAgaW5Qcm9ncmVzczogJ09wZXJhdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzJyxcbiAgY2FudENoYW5nZUlmQ29ubmVjdGVkOiAnWW91IGNhbiBub3QgY2hhbmdlIHZhbHVlIGFmdGVyIGNvbm5lY3RpbmcnLFxuICBhbHJlYWR5U2VudDogJ0FscmVhZHkgc2VudCBvciBzZW5kaW5nJyxcbiAgY29udGVudFJlcXVpcmVkOiAnTWVzc2FnZVBhcnQgcmVxdWlyZXMgcmljaCBjb250ZW50IGZvciB0aGlzIGNhbGwnLFxuICBhbHJlYWR5RGVzdHJveWVkOiAnVGhpcyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQnLFxuICBkZWxldGlvbk1vZGVVbnN1cHBvcnRlZDogJ0NhbGwgdG8gZGVsZXRpb24gd2FzIG1hZGUgd2l0aCBhbiB1bnN1cHBvcnRlZCBkZWxldGlvbiBtb2RlJyxcbiAgc2Vzc2lvbkFuZFVzZXJSZXF1aXJlZDogJ2Nvbm5lY3RXaXRoU2Vzc2lvbiByZXF1aXJlcyBib3RoIGEgdXNlcklkIGFuZCBhIHNlc3Npb25Ub2tlbicsXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheWVyRXJyb3I7XG4iLCIvKipcbiAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIExheWVyIEV2ZW50LCBhbmQgaXMgdXNlZCBhcyB0aGUgcGFyYW1ldGVyIGZvciBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogQ2FsbHMgdG9cbiAqXG4gKiAgICAgIG9iai50cmlnZ2VyKCdldmVudE5hbWUyJywge2hleTogJ2hvJ30pO1xuICpcbiAqIHJlc3VsdHMgaW46XG4gKlxuICogICAgICBvYmoub24oJ2V2ZW50TmFtZTInLCBmdW5jdGlvbihsYXllckV2ZW50KSB7XG4gKiAgICAgICAgICBhbGVydChsYXllckV2ZW50LnRhcmdldC50b1N0cmluZygpICsgJyBoYXMgZmlyZWQgYSB2YWx1ZSBvZiAnICsgbGF5ZXJFdmVudC5oZXkpO1xuICogICAgICB9KTtcbiAqXG4gKiBDaGFuZ2UgZXZlbnRzIChldmVudHMgZW5kaW5nIGluICc6Y2hhbmdlJykgZ2V0IHNwZWNpYWwgaGFuZGxpbmc6XG4gKlxuICogICAgICBvYmoudHJpZ2dlcignb2JqOmNoYW5nZScsIHtcbiAqICAgICAgICAgIG5ld1ZhbHVlOiA1NSxcbiAqICAgICAgICAgIG9sZFZhbHVlOiAyNSxcbiAqICAgICAgICAgIHByb3BlcnR5OiAnaGV5J1xuICogICAgICB9KTtcbiAqXG4gKiByZXN1bHRzIGluIHlvdXIgZXZlbnQgZGF0YSBiZWluZyB3cmFwcGVkIGluIGEgYGNoYW5nZXNgIGFycmF5OlxuICpcbiAqICAgICAgb2JqLm9uKCdvYmo6Y2hhbmdlJywgZnVuY3Rpb24obGF5ZXJFdmVudCkge1xuICogICAgICAgICAgbGF5ZXJFdmVudC5jaGFuZ2VzLmZvckVhY2goZnVuY3Rpb24oY2hhbmdlKSB7XG4gKiAgICAgICAgICAgICAgYWxlcnQobGF5ZXJFdmVudC50YXJnZXQudG9TdHJpbmcoKSArICcgY2hhbmdlZCAnICtcbiAqICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJvcGVydHkgKyAnIGZyb20gJyArIGNoYW5nZS5vbGRWYWx1ZSArXG4gKiAgICAgICAgICAgICAgICAgICAgJyB0byAnICsgY2hhbmdlLm5ld1ZhbHVlKTtcbiAqICAgICAgICAgIH0pO1xuICogICAgICB9KTtcbiAqXG4gKiBUaGUgYGxheWVyLkxheWVyRXZlbnQuZ2V0Q2hhbmdlc0ZvcigpYCBhbmQgYGxheWVyLkxheWVyRXZlbnQuaGFzUHJvcGVydHkoKWAgbWV0aG9kc1xuICogc2ltcGxpZnkgd29ya2luZyB3aXRoIHh4eDpjaGFuZ2UgZXZlbnRzIHNvIHlvdSBkb24ndCBuZWVkXG4gKiB0byBpdGVyYXRlIG92ZXIgdGhlIGBjaGFuZ2VzYCBhcnJheS5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuTGF5ZXJFdmVudFxuICovXG5cbmNsYXNzIExheWVyRXZlbnQge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIExheWVyRXZlbnQuXG4gICAqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBhcmdzIC0gUHJvcGVydGllcyB0byBtaXhpbiB0byB0aGUgZXZlbnRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB0aGF0IGdlbmVyYXRlZCB0aGlzIExheWVyRXZlbnQuXG4gICAqIEByZXR1cm4ge2xheWVyLkxheWVyRXZlbnR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzLCBldmVudE5hbWUpIHtcbiAgICBsZXQgcHRyID0gdGhpcztcblxuICAgIC8vIElzIGl0IGEgY2hhbmdlIGV2ZW50PyAgaWYgc28sIHNldHVwIHRoZSBjaGFuZ2UgcHJvcGVydGllcy5cbiAgICBpZiAoZXZlbnROYW1lLm1hdGNoKC86Y2hhbmdlJC8pKSB7XG4gICAgICB0aGlzLmNoYW5nZXMgPSBbe31dO1xuICAgICAgLy8gQWxsIGFyZ3MgZ2V0IGNvcGllZCBpbnRvIHRoZSBjaGFuZ2VzIG9iamVjdCBpbnN0ZWFkIG9mIHRoaXNcbiAgICAgIHB0ciA9IHRoaXMuY2hhbmdlc1swXTtcbiAgICAgIHRoaXMuaXNDaGFuZ2UgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzQ2hhbmdlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ29weSB0aGUgYXJncyBpbnRvIGVpdGhlciB0aGlzIEV2ZW50IG9iamVjdC4uLiBvciBpbnRvIHRoZSBjaGFuZ2Ugb2JqZWN0LlxuICAgIC8vIFdvdWxkbid0IGJlIG5lZWRlZCBpZiB0aGlzIGluaGVyaXRlZCBmcm9tIFJvb3QuXG4gICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgIC8vIEV2ZW4gaWYgd2UgYXJlIGNvcHlpbmcgcHJvcGVydGllcyBpbnRvIHRoZSBjaGFuZ2Ugb2JqZWN0LCB0YXJnZXQgcmVtYWluc1xuICAgICAgLy8gYSBwcm9wZXJ0eSBvZiBMYXllckV2ZW50LlxuICAgICAgaWYgKHB0ciAhPT0gdGhpcyAmJiBuYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IGFyZ3MudGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHRyW25hbWVdID0gYXJnc1tuYW1lXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSB3YXMgY2hhbmdlZC5cbiAgICpcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGlzIGlzIG5vdCBhIGNoYW5nZSBldmVudC5cbiAgICpcbiAgICogICAgICBpZiAobGF5ZXJFdmVudC5oYXNQcm9wZXJ0eSgnYWdlJykpIHtcbiAgICogICAgICAgICAgaGFuZGxlQWdlQ2hhbmdlKG9iai5hZ2UpO1xuICAgKiAgICAgIH1cbiAgICpcbiAgICogQG1ldGhvZCBoYXNQcm9wZXJ0eVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lIC0gTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc1Byb3BlcnR5KG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDaGFuZ2UpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmNoYW5nZXMuZmlsdGVyKGNoYW5nZSA9PiBjaGFuZ2UucHJvcGVydHkgPT09IG5hbWUpLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjaGFuZ2VzIHRvIHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBjaGFuZ2VzLlxuICAgKiBJZiB0aGlzIGlzIG5vdCBhIGNoYW5nZSBldmVudCwgd2lsbCByZXR1cm4gW11cbiAgICogQ2hhbmdlcyBhcmUgdHlwaWNhbGx5IG9mIHRoZSBmb3JtOlxuICAgKlxuICAgKiAgICAgIGxheWVyRXZlbnQuZ2V0Q2hhbmdlc0ZvcignYWdlJyk7XG4gICAqICAgICAgPiBbe1xuICAgKiAgICAgICAgICBvbGRWYWx1ZTogMTAsXG4gICAqICAgICAgICAgIG5ld1ZhbHVlOiA1LFxuICAgKiAgICAgICAgICBwcm9wZXJ0eTogJ2FnZSdcbiAgICogICAgICB9XVxuICAgKlxuICAgKiBAbWV0aG9kIGdldENoYW5nZXNGb3JcbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgd2hvc2UgY2hhbmdlcyBhcmUgb2YgaW50ZXJlc3RcbiAgICogQHJldHVybiB7T2JqZWN0W119XG4gICAqL1xuICBnZXRDaGFuZ2VzRm9yKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuaXNDaGFuZ2UpIHJldHVybiBbXTtcbiAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLmZpbHRlcihjaGFuZ2UgPT4gY2hhbmdlLnByb3BlcnR5ID09PSBuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSBjaGFuZ2VzIGludG8gYSBzaW5nbGUgY2hhbmdlcyBhcnJheS5cbiAgICpcbiAgICogVGhlIG90aGVyIGV2ZW50IHdpbGwgbmVlZCB0byBiZSBkZWxldGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9tZXJnZUNoYW5nZXNcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICovXG4gIF9tZXJnZUNoYW5nZXMoZXZ0KSB7XG4gICAgdGhpcy5jaGFuZ2VzID0gdGhpcy5jaGFuZ2VzLmNvbmNhdChldnQuY2hhbmdlcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGlzIGlzIGEgY2hhbmdlIGV2ZW50LlxuICpcbiAqIElmIHRoZSBldmVudCBuYW1lIGVuZHMgd2l0aCAnOmNoYW5nZScgdGhlblxuICogaXQgaXMgdHJlYXRlZCBhcyBhIGNoYW5nZSBldmVudDsgIHN1Y2hcbiAqIGV2ZW50cyBhcmUgYXNzdW1lZCB0byBjb21lIHdpdGggYG5ld1ZhbHVlYCwgYG9sZFZhbHVlYCBhbmQgYHByb3BlcnR5YCBpbiB0aGUgbGF5ZXIuTGF5ZXJFdmVudC5jaGFuZ2VzIHByb3BlcnR5LlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cbkxheWVyRXZlbnQucHJvdG90eXBlLmlzQ2hhbmdlID0gZmFsc2U7XG5cbi8qKlxuICogQXJyYXkgb2YgY2hhbmdlcyAoQ2hhbmdlIEV2ZW50cyBvbmx5KS5cbiAqXG4gKiBJZiBpdHMgYSBDaGFuZ2UgRXZlbnQsIHRoZW4gdGhlIGNoYW5nZXMgcHJvcGVydHkgY29udGFpbnMgYW4gYXJyYXkgb2YgY2hhbmdlIG9iamVjdHNcbiAqIHdoaWNoIGVhY2ggY29udGFpbjpcbiAqXG4gKiAqIG9sZFZhbHVlXG4gKiAqIG5ld1ZhbHVlXG4gKiAqIHByb3BlcnR5XG4gKlxuICogQHR5cGUge09iamVjdFtdfVxuICovXG5MYXllckV2ZW50LnByb3RvdHlwZS5jaGFuZ2VzID0gbnVsbDtcblxuLyoqXG4gKiBDb21wb25lbnQgdGhhdCB3YXMgdGhlIHNvdXJjZSBvZiB0aGUgY2hhbmdlLlxuICpcbiAqIElmIG9uZSBjYWxsc1xuICpcbiAqICAgICAgb2JqLnRyaWdnZXIoJ2V2ZW50Jyk7XG4gKlxuICogdGhlbiBvYmogd2lsbCBiZSB0aGUgdGFyZ2V0LlxuICogQHR5cGUge2xheWVyLlJvb3R9XG4gKi9cbkxheWVyRXZlbnQucHJvdG90eXBlLnRhcmdldCA9IG51bGw7XG5cbi8qKlxuICogVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRoYXQgY3JlYXRlZCB0aGlzIGluc3RhbmNlLlxuICpcbiAqIElmIG9uZSBjYWxsc1xuICpcbiAqICAgICAgb2JqLnRyaWdnZXIoJ215ZXZlbnQnKTtcbiAqXG4gKiB0aGVuIGV2ZW50TmFtZSA9ICdteWV2ZW50J1xuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbkxheWVyRXZlbnQucHJvdG90eXBlLmV2ZW50TmFtZSA9ICcnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheWVyRXZlbnQ7XG4iLCIvKipcbiAqIEBjbGFzcyBsYXllci5Mb2dnZXJcbiAqIEBwcml2YXRlXG4gKlxuICovXG5jb25zdCB7IERFQlVHLCBJTkZPLCBXQVJOLCBFUlJPUiwgTk9ORSB9ID0gcmVxdWlyZSgnLi9jb25zdCcpLkxPRztcbmNvbnN0IHsgaXNFbXB0eSB9ID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcblxuLy8gUHJldHR5IGFyYml0cmFyeSB0ZXN0IHRoYXQgSUUvZWRnZSBmYWlscyBhbmQgb3RoZXJzIGRvbid0LiAgWWVzIEkgY291bGQgZG8gYSBtb3JlIGRpcmVjdFxuLy8gdGVzdCBmb3IgSUUvZWRnZSBidXQgaXRzIGhvcGVkIHRoYXQgTVMgd2lsbCBmaXggdGhpcyBhcm91bmQgdGhlIHRpbWUgdGhleSBjbGVhbnVwIHRoZWlyIGludGVybmFsIGNvbnNvbGUgb2JqZWN0LlxuY29uc3Qgc3VwcG9ydHNDb25zb2xlRm9ybWF0dGluZyA9IEJvb2xlYW4oY29uc29sZS5hc3NlcnQgJiYgY29uc29sZS5hc3NlcnQudG9TdHJpbmcoKS5tYXRjaCgvYXNzZXJ0LykpO1xuY29uc3QgTGF5ZXJDc3MgPSAnY29sb3I6ICM4ODg7IGZvbnQtd2VpZ2h0OiBib2xkOyc7XG5jb25zdCBCbGFjayA9ICdjb2xvcjogYmxhY2snO1xuLyogaXN0YW5idWxpZnkgaWdub3JlIG5leHQgKi9cbmNsYXNzIExvZ2dlciB7XG4gIGxvZyhtc2csIG9iaiwgdHlwZSwgY29sb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0xvY2FsZVRpbWVTdHJpbmcoKTtcbiAgICAgIGlmIChzdXBwb3J0c0NvbnNvbGVGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAlY0xheWVyJWMgJHt0eXBlfSVjIFske3RpbWVzdGFtcH1dOiAke21zZ31gLCBMYXllckNzcywgYGNvbG9yOiAke2NvbG9yfWAsIEJsYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBMYXllciAke3R5cGV9IFske3RpbWVzdGFtcH1dOiAke21zZ31gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbG9nT2JqKG1zZywgdHlwZSwgY29sb3IpO1xuICAgIH1cbiAgICBpZiAob2JqKSB0aGlzLl9sb2dPYmoob2JqLCB0eXBlLCBjb2xvcik7XG4gIH1cbiAgX2xvZ09iaihvYmosIHR5cGUsIGNvbG9yKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIW9iaiB8fCBpc0VtcHR5KG9iaikpIHJldHVybjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICAgIGlmIChzdXBwb3J0c0NvbnNvbGVGb3JtYXR0aW5nKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGAlY0xheWVyJWMgJHt0eXBlfSVjOiAke0pTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgNCl9YCwgTGF5ZXJDc3MsIGBjb2xvcjogJHtjb2xvcn1gLCBCbGFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhgTGF5ZXIgJHt0eXBlfTogJHtKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDQpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3VwcG9ydHNDb25zb2xlRm9ybWF0dGluZykge1xuICAgICAgICBjb25zb2xlLmxvZyhgJWNMYXllciVjICR7dHlwZX0lYzogJU9gLCBMYXllckNzcywgYGNvbG9yOiAke2NvbG9yfWAsIEJsYWNrLCBvYmopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYExheWVyICR7dHlwZX06YCwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWJ1Zyhtc2csIG9iaikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMubGV2ZWwgPj0gREVCVUcpIHRoaXMubG9nKG1zZywgb2JqLCAnREVCVUcnLCAnIzg4OCcpO1xuICB9XG5cbiAgaW5mbyhtc2csIG9iaikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMubGV2ZWwgPj0gSU5GTykgdGhpcy5sb2cobXNnLCBvYmosICdJTkZPJywgJ2JsYWNrJyk7XG4gIH1cblxuICB3YXJuKG1zZywgb2JqKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodGhpcy5sZXZlbCA+PSBXQVJOKSB0aGlzLmxvZyhtc2csIG9iaiwgJ1dBUk4nLCAnb3JhbmdlJyk7XG4gIH1cblxuICBlcnJvcihtc2csIG9iaikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHRoaXMubGV2ZWwgPj0gRVJST1IpIHRoaXMubG9nKG1zZywgb2JqLCAnRVJST1InLCAncmVkJyk7XG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbkxvZ2dlci5wcm90b3R5cGUubGV2ZWwgPSB0eXBlb2YgamFzbWluZSA9PT0gJ3VuZGVmaW5lZCcgPyBFUlJPUiA6IE5PTkU7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dnZXI7XG4iLCIvKipcbiAqIFRoZSBNZXNzYWdlUGFydCBjbGFzcyByZXByZXNlbnRzIGFuIGVsZW1lbnQgb2YgYSBtZXNzYWdlLlxuICpcbiAqICAgICAgLy8gQ3JlYXRlIGEgTWVzc2FnZSBQYXJ0IHdpdGggYW55IG1pbWVUeXBlXG4gKiAgICAgIHZhciBwYXJ0ID0gbmV3IGxheWVyLk1lc3NhZ2VQYXJ0KHtcbiAqICAgICAgICAgIGJvZHk6IFwiaGVsbG9cIixcbiAqICAgICAgICAgIG1pbWVUeXBlOiBcInRleHQvcGxhaW5cIlxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIENyZWF0ZSBhIHRleHQvcGxhaW4gb25seSBNZXNzYWdlIFBhcnRcbiAqICAgICAgdmFyIHBhcnQgPSBuZXcgbGF5ZXIuTWVzc2FnZVBhcnQoXCJIZWxsbyBJIGFtIHRleHQvcGxhaW5cIik7XG4gKlxuICogWW91IGNhbiBhbHNvIGNyZWF0ZSBhIE1lc3NhZ2UgUGFydCBmcm9tIGEgRmlsZSBJbnB1dCBkb20gbm9kZTpcbiAqXG4gKiAgICAgIHZhciBmaWxlSW5wdXROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUZpbGVJbnB1dFwiKTtcbiAqICAgICAgdmFyIHBhcnQgPSBuZXcgbGF5ZXIuTWVzc2FnZVBhcnQoZmlsZUlucHV0Tm9kZS5maWxlc1swXSk7XG4gKlxuICogWW91IGNhbiBhbHNvIGNyZWF0ZSBNZXNzYWdlIFBhcnRzIGZyb20gYSBmaWxlIGRyYWcgYW5kIGRyb3Agb3BlcmF0aW9uOlxuICpcbiAqICAgICAgb25GaWxlRHJvcDogZnVuY3Rpb24oZXZ0KSB7XG4gKiAgICAgICAgICAgdmFyIGZpbGVzID0gZXZ0LmRhdGFUcmFuc2Zlci5maWxlcztcbiAqICAgICAgICAgICB2YXIgbSA9IGNvbnZlcnNhdGlvbi5jcmVhdGVNZXNzYWdlKHtcbiAqICAgICAgICAgICAgICAgcGFydHM6IGZpbGVzLm1hcChmdW5jdGlvbihmaWxlKSB7XG4gKiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbGF5ZXIuTWVzc2FnZVBhcnQoe2JvZHk6IGZpbGUsIG1pbWVUeXBlOiBmaWxlLnR5cGV9KTtcbiAqICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgIH0pO1xuICogICAgICB9KTtcbiAqXG4gKiBZb3UgY2FuIGFsc28gdXNlIGJhc2U2NCBlbmNvZGVkIGRhdGE6XG4gKlxuICogICAgICB2YXIgcGFydCA9IG5ldyBsYXllci5NZXNzYWdlUGFydCh7XG4gKiAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gKiAgICAgICAgICBtaW1lVHlwZTogJ2ltYWdlL3BuZycsXG4gKiAgICAgICAgICBib2R5OiAnaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUlBQUFBQ0FDQVlBQUFERFBtSExBQUFFQ0VsRVFWUjRYdTJaTzQ0VFVSUkVhMFNBV0JBU0tTVDh4Q2REUU1BcStPeUF6dzRJU2ZtTERCQVNJU0VSaTJBREVJQ0VXcktsa1lXbnk2Kzc3ZnVxYWxKZnowelZPWE5mdi9FUjhtWGR3SkYxK29SSEJEQ1hJQUpFQVBNR3pPTm5BMFFBOHdiTTQyY0RSQUR6QnN6alp3TkVBUE1Hek9ObkEwUUE4d2JNNDJjRFJBRHpCc3pqWndORUFQTUd6T05uQTBRQTh3Yk00MmNEUkFEekJzempad05FQVBNR3pPTm5BMFFBOHdiTTQyY0RSQUR6QnN6alp3TkVBUE1Hek9ObkEwUUE4d2JNNDJjRFJBRHpCc3pqWndORUFQTUd6T05uQTBRQTh3Yk00MmNEUkFEekJzempad05FQVBNR3pPTm5BMFFBOHdhV2pYOE93SGNBdjVmOU1lM2ZQUnVndmJ1eGQxNEM4QjdBVndBM3Ewb1FBY1l3dHIyK2huOTY5ZmFQVlNXSUFHMkFUM3JYSnZ6MTdDY0FONnB0Z2dnd3J3RGI0SmVWSUFMTUo4QVkvSklTUklCNUJHRGhyMy9hWndEWEt4d0hFV0M2QUpjQnZBT3dmdUJqdnVOZkFCY0JmR0dHbDV5SkFOUGFiWVYvQjhETGFUOTZubmRIZ1BZZXU0Yy9SSThBYlFKSXdPOUZnRE1BZnJWeFd1UmRNdkI3RU9BK2dIc0FMZ0Q0dVFqTzNiNnBGUHpxQWp3QThIVEY1d2VBOHdlV1FBNStaUUdPdzEvL2pSNVNBa240VlFWNENPREpsczE4Q0FtdUFIamJjTTh2YzlVNzZaU3JkZ3Q0Qk9EeHlMRzhUd2xhNFA4QmNMZktQWC9zRWFlU0FBejhmUjRIOHZBckhRSFhBSHdZczNYajlTVTNnUVg4U2dLY0F2Qml0VHAzOFdBSkNXemdWeEpnK0YwcVNHQUZ2NW9BaDViQURuNUZBUTRsd1ZVQWIzYTg2blgxdEwvdFhLMTBDemorTys3ek9MQ0ZYM1VEckVYWWh3VFc4S3NMc1BSeDBBcC8rQS9mcTEydUtwVm5xeDRCU3g4SGdiOXF1QWNCNXQ0RWdYL3N6NnNYQWVhU0lQQTN6cU9lQkpncXdUTUF6eHV1ZWxKbi91YnpTRzhDVEpGZzEyZXg0WjR2RGIrSFc4QTJhSzFYUkZZQ0MvZzlDN0RrSnJDQjM3c0FTMGhnQlY5QmdEa2xHT0RmQnZDYVBTY1U1bnA4Q1B4ZjcxT2ZDU3pocTJ5QXFaOGQyTUpYRTZEbE9MQ0dyeWpBTGhMWXcxY1ZnSkVnOER2N01LamxnWHZiZzJIZ2QvcGgwQndTQkg3bkh3Wk5rZUNXNHoxL3JEQ1Yvd09NNVJ5T2c3TUF2bzBOdXIzdUlvQWJWenB2QktDcjBoeU1BSnBjNlZRUmdLNUtjekFDYUhLbFUwVUF1aXJOd1FpZ3laVk9GUUhvcWpRSEk0QW1WenBWQktDcjBoeU1BSnBjNlZRUmdLNUtjekFDYUhLbFUwVUF1aXJOd1FpZ3laVk9GUUhvcWpRSEk0QW1WenBWQktDcjBoeU1BSnBjNlZRUmdLNUtjekFDYUhLbFUwVUF1aXJOd1FpZ3laVk9GUUhvcWpRSEk0QW1WenBWQktDcjBoeU1BSnBjNlZRUmdLNUtjekFDYUhLbFUwVUF1aXJOd1FpZ3laVk9GUUhvcWpRSEk0QW1WenBWQktDcjBoeU1BSnBjNlZRUmdLNUtjekFDYUhLbFUwVUF1aXJOd1FpZ3laVk9GUUhvcWpRSEk0QW1WenBWQktDcjBoejhCeklYdFlFM1ZjUG5BQUFBQUVsRlRrU3VRbUNDJ1xuICogICAgICB9KTtcbiAqXG4gKiAjIyMgQWNjZXNpbmcgUmljaCBDb250ZW50XG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIG9mIGFjY2Vzc2luZyByaWNoIGNvbnRlbnRcbiAqXG4gKiAxLiBBY2Nlc3MgdGhlIGRhdGEgZGlyZWN0bHk6IGBwYXJ0LmZldGNoQ29udGVudChmdW5jdGlvbihkYXRhKSB7bXlSZW5kZXJEYXRhKGRhdGEpO30pYC4gVGhpcyBhcHByb2FjaCBkb3dubG9hZHMgdGhlIGRhdGEsXG4gKiAgICB3cml0ZXMgaXQgdG8gdGhlIHRoZSBgYm9keWAgcHJvcGVydHksIHdyaXRlcyBhIERhdGEgVVJJIHRvIHRoZSBwYXJ0J3MgYHVybGAgcHJvcGVydHksIGFuZCB0aGVuIGNhbGxzIHlvdXIgY2FsbGJhY2suXG4gKiAgICBCeSBkb3dubG9hZGluZyB0aGUgZGF0YSBhbmQgc3RvcmluZyBpdCBpbiBgYm9keWAsIHRoZSBkYXRhIGRvZXMgbm90IGV4cGlyZS5cbiAqIDIuIEFjY2VzcyB0aGUgVVJMIHJhdGhlciB0aGFuIHRoZSBkYXRhOiBgcGFydC5mZXRjaFN0cmVhbShjYWxsYmFjaylgLiAgVVJMcyBhcmUgbmVlZGVkIGZvciBzdHJlYW1pbmcsIGFuZCBmb3IgY29udGVudCB0aGF0IGRvZXNuJ3RcbiAqICAgIHlldCBuZWVkIHRvIGJlIHJlbmRlcmVkIChoeXBlcmxpbmtzIHRvIGRhdGEgdGhhdCB3aWxsIHJlbmRlciB3aGVuIGNsaWNrZWQpLiAgVGhlc2UgVVJMcyBleHBpcmUuICBUaGUgdXJsIHByb3BlcnR5IHdpbGwgcmV0dXJuIGFcbiAqICAgIHN0cmluZyBpZiB0aGUgdXJsIGlzIHZhbGlkLCBvciAnJyBpZiBpdHMgZXhwaXJlZCBhbmQgZmV0Y2hTdHJlYW0gbXVzdCBiZSBjYWxsZWQgdG8gdXBkYXRlIHRoZSB1cmwuXG4gKiAgICBUaGUgZm9sbG93aW5nIHBhdHRlcm4gaXMgcmVjb21tZW5kZWQ6XG4gKlxuICogICAgICAgIGlmICghcGFydC51cmwpIHtcbiAqICAgICAgICAgIHBhcnQuZmV0Y2hTdHJlYW0oZnVuY3Rpb24odXJsKSB7bXlSZW5kZXJVcmwodXJsKX0pO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBteVJlbmRlclVybChwYXJ0LnVybCk7XG4gKiAgICAgICAgfVxuICpcbiAqIE5PVEU6IGBsYXllci5NZXNzYWdlUGFydC51cmxgIHNob3VsZCBoYXZlIGEgdmFsdWUgd2hlbiB0aGUgbWVzc2FnZSBpcyBmaXJzdCByZWNlaXZlZCwgYW5kIHdpbGwgb25seSBmYWlsIGBpZiAoIXBhcnQudXJsKWAgb25jZSB0aGUgdXJsIGhhcyBleHBpcmVkLlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuTWVzc2FnZVBhcnRcbiAqIEBleHRlbmRzIGxheWVyLlJvb3RcbiAqIEBhdXRob3IgTWljaGFlbCBLYW50b3JcbiAqL1xuXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCBDb250ZW50ID0gcmVxdWlyZSgnLi9jb250ZW50Jyk7XG5jb25zdCB4aHIgPSByZXF1aXJlKCcuL3hocicpO1xuY29uc3QgQ2xpZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL2NsaWVudC1yZWdpc3RyeScpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IEhhc0Jsb2IgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBMb2NhbEZpbGVSZWFkZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ2ZpbGVyZWFkZXInKSA6IEZpbGVSZWFkZXI7XG5cblxuY2xhc3MgTWVzc2FnZVBhcnQgZXh0ZW5kcyBSb290IHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgLSBDYW4gYmUgYW4gb2JqZWN0IHdpdGggYm9keSBhbmQgbWltZVR5cGUsIG9yIGl0IGNhbiBiZSBhIHN0cmluZywgb3IgYSBCbG9iL0ZpbGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSBvcHRpb25zLmJvZHkgLSBUbyBzZW5kIGJpbmFyeSwgdXNlIGJhc2U2NCBlbmNvZGVkIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHRpb25zLm1pbWVUeXBlPXRleHQvcGxhaW5dIC0gTWltZSB0eXBlOyBjYW4gYmUgYW55dGhpbmc7IGlmIHlvdXIgY2xpZW50IGRvZXNuJ3QgaGF2ZSBhIHJlbmRlcmVyIGZvciBpdCwgaXQgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IFtvcHRpb25zLmVuY29kaW5nPV0gLSBFbmNvZGluZyBmb3IgeW91ciBNZXNzYWdlUGFydDsgdXNlICdiYXNlNjQnIGlmIHRoZSBib2R5IGlzIGEgYmFzZTY0IHN0cmluZzsgZWxzZSBsZWF2ZSBibGFuay5cbiAgICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5zaXplPTBdIC0gU2l6ZSBvZiB5b3VyIHBhcnQuIFdpbGwgYmUgY2FsY3VsYXRlZCBmb3IgeW91IGlmIG5vdCBwcm92aWRlZC5cbiAgICpcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZVBhcnR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCAuLi5hcmdzKSB7XG4gICAgbGV0IG5ld09wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5ld09wdGlvbnMgPSB7IGJvZHk6IG9wdGlvbnMgfTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV3T3B0aW9ucy5taW1lVHlwZSA9IGFyZ3NbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPcHRpb25zLm1pbWVUeXBlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoSGFzQmxvYiAmJiAob3B0aW9ucyBpbnN0YW5jZW9mIEJsb2IgfHwgb3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgQmxvYikpIHtcbiAgICAgIGNvbnN0IGJvZHlCbG9iID0gb3B0aW9ucyBpbnN0YW5jZW9mIEJsb2IgPyBvcHRpb25zIDogb3B0aW9ucy5ib2R5O1xuICAgICAgbmV3T3B0aW9ucyA9IHtcbiAgICAgICAgbWltZVR5cGU6IGJvZHlCbG9iLnR5cGUsXG4gICAgICAgIGJvZHk6IGJvZHlCbG9iLFxuICAgICAgICBzaXplOiBib2R5QmxvYi5zaXplLFxuICAgICAgICBoYXNDb250ZW50OiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG4gICAgc3VwZXIobmV3T3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLnNpemUgJiYgdGhpcy5ib2R5KSB0aGlzLnNpemUgPSB0aGlzLmJvZHkubGVuZ3RoO1xuICAgIGlmIChIYXNCbG9iICYmIHRoaXMuYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgIHRoaXMudXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTCh0aGlzLmJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX191cmwpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fX3VybCk7XG4gICAgICB0aGlzLl9fdXJsID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5ib2R5ID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsYXllci5DbGllbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5ZXIuTWVzc2FnZVBhcnQuXG4gICAqXG4gICAqIFVzZXMgdGhlIGxheWVyLk1lc3NhZ2VQYXJ0LmNsaWVudElkIHByb3BlcnR5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9nZXRDbGllbnRcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7bGF5ZXIuQ2xpZW50fVxuICAgKi9cbiAgX2dldENsaWVudCgpIHtcbiAgICByZXR1cm4gQ2xpZW50UmVnaXN0cnkuZ2V0KHRoaXMuY2xpZW50SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIuTWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsYXllci5NZXNzYWdlUGFydC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0TWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlfVxuICAgKi9cbiAgX2dldE1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldENsaWVudCgpLmdldE1lc3NhZ2UodGhpcy5pZC5yZXBsYWNlKC9cXC9wYXJ0cy4qJC8sICcnKSk7XG4gIH1cblxuICAvKipcbiAgICogRG93bmxvYWQgUmljaCBDb250ZW50IGZyb20gY2xvdWQgc2VydmVyLlxuICAgKlxuICAgKiBGb3IgTWVzc2FnZVBhcnRzIHdpdGggcmljaCBjb250ZW50LCB3aWxsIGxvYWQgdGhlIGRhdGEgZnJvbSBnb29nbGUncyBjbG91ZCBzdG9yYWdlLlxuICAgKiBUaGUgYm9keSBwcm9wZXJ0eSBvZiB0aGlzIE1lc3NhZ2VQYXJ0IGlzIHNldCB0byB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiAgICAgIG1lc3NhZ2VwYXJ0LmZldGNoQ29udGVudCgpXG4gICAqICAgICAgLm9uKFwiY29udGVudC1sb2FkZWRcIiwgZnVuY3Rpb24oKSB7XG4gICAqICAgICAgICAgIHJlbmRlcihtZXNzYWdlcGFydC5ib2R5KTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBmZXRjaENvbnRlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXVxuICAgKiBAcGFyYW0ge01peGVkfSBjYWxsYmFjay5kYXRhIC0gRWl0aGVyIGEgc3RyaW5nIChtaW1lVHlwZT10ZXh0L3BsYWluKSBvciBhIEJsb2IgKGFsbCBvdGhlciBtaW1lVHlwZXMpXG4gICAqL1xuICBmZXRjaENvbnRlbnQoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fY29udGVudCAmJiAhdGhpcy5pc0ZpcmluZykge1xuICAgICAgdGhpcy5pc0ZpcmluZyA9IHRydWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5taW1lVHlwZSA9PT0gJ2ltYWdlL2pwZWcrcHJldmlldycgPyAnaW1hZ2UvanBlZycgOiB0aGlzLm1pbWVUeXBlO1xuICAgICAgdGhpcy5fY29udGVudC5sb2FkQ29udGVudCh0eXBlLCAoZXJyLCByZXN1bHQpID0+IHRoaXMuX2ZldGNoQ29udGVudENhbGxiYWNrKGVyciwgcmVzdWx0LCBjYWxsYmFjaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9mZXRjaENvbnRlbnRDYWxsYmFjayhlcnIsIHJlc3VsdCwgY2FsbGJhY2spIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbnRlbnQtbG9hZGVkLWVycm9yJywgZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHJlc3VsdCk7XG4gICAgICB0aGlzLmlzRmlyaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBMb2NhbEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZmV0Y2hDb250ZW50Q29tcGxldGUocmVhZGVyLnJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQocmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZldGNoQ29udGVudENvbXBsZXRlKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9mZXRjaENvbnRlbnRDb21wbGV0ZShib2R5LCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9nZXRNZXNzYWdlKCk7XG5cbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuXG4gICAgdGhpcy50cmlnZ2VyKCdjb250ZW50LWxvYWRlZCcpO1xuICAgIG1lc3NhZ2UuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6Y2hhbmdlJywge1xuICAgICAgb2xkVmFsdWU6IG1lc3NhZ2UucGFydHMsXG4gICAgICBuZXdWYWx1ZTogbWVzc2FnZS5wYXJ0cyxcbiAgICAgIHByb3BlcnR5OiAncGFydHMnLFxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2sodGhpcy5ib2R5KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEFjY2VzcyB0aGUgVVJMIHRvIHRoZSByZW1vdGUgcmVzb3VyY2UuXG4gICAqXG4gICAqIEZvciBNZXNzYWdlUGFydHMgd2l0aCBSaWNoIENvbnRlbnQsIHdpbGwgbG9va3VwIGEgVVJMIHRvIHlvdXIgUmljaCBDb250ZW50LlxuICAgKiBVc2VmdWwgZm9yIHN0cmVhbWluZyBhbmQgY29udGVudCBzbyB0aGF0IHlvdSBkb24ndCBoYXZlIHRvIGRvd25sb2FkIHRoZSBlbnRpcmUgZmlsZSBiZWZvcmUgcmVuZGVyaW5nIGl0LlxuICAgKlxuICAgKiAgICAgIG1lc3NhZ2VwYXJ0LmZldGNoU3RyZWFtKGZ1bmN0aW9uKHVybCkge1xuICAgKiAgICAgICAgICByZW5kZXIodXJsKTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBmZXRjaFN0cmVhbVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7TWl4ZWR9IGNhbGxiYWNrLnVybFxuICAgKi9cbiAgZmV0Y2hTdHJlYW0oY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2NvbnRlbnQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY29udGVudFJlcXVpcmVkKTtcbiAgICBpZiAodGhpcy5fY29udGVudC5pc0V4cGlyZWQoKSkge1xuICAgICAgdGhpcy5fY29udGVudC5yZWZyZXNoQ29udGVudCh0aGlzLl9nZXRDbGllbnQoKSwgdXJsID0+IHRoaXMuX2ZldGNoU3RyZWFtQ29tcGxldGUodXJsLCBjYWxsYmFjaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mZXRjaFN0cmVhbUNvbXBsZXRlKHRoaXMuX2NvbnRlbnQuZG93bmxvYWRVcmwsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICAvLyBEb2VzIG5vdCBzZXQgdGhpcy51cmw7IGluc3RlYWQgcmVsaWVzIG9uIGZhY3QgdGhhdCB0aGlzLl9jb250ZW50LmRvd25sb2FkVXJsIGhhcyBiZWVuIHVwZGF0ZWRcbiAgX2ZldGNoU3RyZWFtQ29tcGxldGUodXJsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9nZXRNZXNzYWdlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3VybC1sb2FkZWQnKTtcbiAgICBtZXNzYWdlLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOmNoYW5nZScsIHtcbiAgICAgIG9sZFZhbHVlOiBtZXNzYWdlLnBhcnRzLFxuICAgICAgbmV3VmFsdWU6IG1lc3NhZ2UucGFydHMsXG4gICAgICBwcm9wZXJ0eTogJ3BhcnRzJyxcbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHVybCk7XG4gIH1cblxuICAvKipcbiAgICogUHJlcHMgYSBNZXNzYWdlUGFydCBmb3Igc2VuZGluZy4gIE5vcm1hbGx5IHRoYXQgaXMgdHJpdmlhbC5cbiAgICogQnV0IGlmIHRoZXJlIGlzIHJpY2ggY29udGVudCwgdGhlbiB0aGUgY29udGVudCBtdXN0IGJlIHVwbG9hZGVkXG4gICAqIGFuZCB0aGVuIHdlIGNhbiB0cmlnZ2VyIGEgXCJwYXJ0czpzZW5kXCIgZXZlbnQgaW5kaWNhdGluZyB0aGF0XG4gICAqIHRoZSBwYXJ0IGlzIHJlYWR5IHRvIHNlbmQuXG4gICAqXG4gICAqIEBtZXRob2QgX3NlbmRcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAZmlyZXMgcGFydHM6c2VuZFxuICAgKi9cbiAgX3NlbmQoY2xpZW50KSB7XG4gICAgLy8gVGhlcmUgaXMgYWxyZWFkeSBhIENvbnRlbnQgb2JqZWN0LCBwcmVzdW1hYmx5IHRoZSBkZXZlbG9wZXJcbiAgICAvLyBhbHJlYWR5IHRvb2sgY2FyZSBvZiB0aGlzIHN0ZXAgZm9yIHVzLlxuICAgIGlmICh0aGlzLl9jb250ZW50KSB7XG4gICAgICB0aGlzLl9zZW5kV2l0aENvbnRlbnQoKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2l6ZSBpcyBsYXJnZSwgQ3JlYXRlIGFuZCB1cGxvYWQgdGhlIENvbnRlbnRcbiAgICBpZiAodGhpcy5zaXplID4gMjA0OCkge1xuICAgICAgdGhpcy5fZ2VuZXJhdGVDb250ZW50QW5kU2VuZChjbGllbnQpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBib2R5IGlzIGEgYmxvYiBlaXRoZXIgYmFzZTY0IGVuY29kZSBpdFxuICAgIGVsc2UgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICB0aGlzLl9zZW5kQmxvYihjbGllbnQpO1xuICAgIH1cblxuICAgIC8vIEVsc2UgdGhlIG1lc3NhZ2UgcGFydCBjYW4gYmUgc2VudCBhcyBpcy5cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NlbmRCb2R5KCk7XG4gICAgfVxuICB9XG5cbiAgX3NlbmRCb2R5KCkge1xuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgIG1pbWVfdHlwZTogdGhpcy5taW1lVHlwZSxcbiAgICAgIGJvZHk6IHRoaXMuYm9keSxcbiAgICB9O1xuICAgIGlmICh0aGlzLmVuY29kaW5nKSBvYmouZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuICAgIHRoaXMudHJpZ2dlcigncGFydHM6c2VuZCcsIG9iaik7XG4gIH1cblxuICBfc2VuZFdpdGhDb250ZW50KCkge1xuICAgIHRoaXMudHJpZ2dlcigncGFydHM6c2VuZCcsIHtcbiAgICAgIG1pbWVfdHlwZTogdGhpcy5taW1lVHlwZSxcbiAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBpZDogdGhpcy5fY29udGVudC5pZCxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBfc2VuZEJsb2IoY2xpZW50KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgTG9jYWxGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0O1xuICAgICAgaWYgKGJhc2U2NGRhdGEubGVuZ3RoIDwgMjA0OCkge1xuICAgICAgICB0aGlzLmJvZHkgPSBiYXNlNjRkYXRhO1xuICAgICAgICB0aGlzLmJvZHkgPSB0aGlzLmJvZHkuc3Vic3RyaW5nKHRoaXMuYm9keS5pbmRleE9mKCcsJykgKyAxKTtcbiAgICAgICAgdGhpcy5lbmNvZGluZyA9ICdiYXNlNjQnO1xuICAgICAgICB0aGlzLl9zZW5kQm9keShjbGllbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVDb250ZW50QW5kU2VuZChjbGllbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwodGhpcy5ib2R5KTsgLy8gZW5jb2RlcyB0byBiYXNlNjRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gcmljaCBDb250ZW50IG9iamVjdCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGNhbGwgX3Byb2Nlc3NDb250ZW50UmVzcG9uc2VcbiAgICpcbiAgICogQG1ldGhvZCBfZ2VuZXJhdGVDb250ZW50QW5kU2VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKi9cbiAgX2dlbmVyYXRlQ29udGVudEFuZFNlbmQoY2xpZW50KSB7XG4gICAgdGhpcy5oYXNDb250ZW50ID0gdHJ1ZTtcbiAgICBjbGllbnQueGhyKHtcbiAgICAgIHVybDogJy9jb250ZW50JyxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXBsb2FkLUNvbnRlbnQtVHlwZSc6IHRoaXMubWltZVR5cGUsXG4gICAgICAgICdVcGxvYWQtQ29udGVudC1MZW5ndGgnOiB0aGlzLnNpemUsXG4gICAgICAgICdVcGxvYWQtT3JpZ2luJzogdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyA/IGxvY2F0aW9uLm9yaWdpbiA6ICcnLFxuICAgICAgfSxcbiAgICAgIHN5bmM6IHt9LFxuICAgIH0sIHJlc3VsdCA9PiB7XG4gICAgICB0aGlzLl9wcm9jZXNzQ29udGVudFJlc3BvbnNlKHJlc3VsdC5kYXRhLCBjbGllbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBsYXllci5Db250ZW50IG9iamVjdCBmcm9tIHRoZSBzZXJ2ZXInc1xuICAgKiBDb250ZW50IG9iamVjdCwgYW5kIHRoZW4gdXBsb2FkcyB0aGUgZGF0YSB0byBnb29nbGUgY2xvdWQgc3RvcmFnZS5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc0NvbnRlbnRSZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqL1xuICBfcHJvY2Vzc0NvbnRlbnRSZXNwb25zZShyZXNwb25zZSwgY2xpZW50KSB7XG4gICAgdGhpcy5fY29udGVudCA9IG5ldyBDb250ZW50KHJlc3BvbnNlLmlkKTtcbiAgICB0aGlzLmhhc0NvbnRlbnQgPSB0cnVlO1xuICAgIHhocih7XG4gICAgICB1cmw6IHJlc3BvbnNlLnVwbG9hZF91cmwsXG4gICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgZGF0YTogdGhpcy5ib2R5LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXBsb2FkLUNvbnRlbnQtTGVuZ3RoJzogdGhpcy5zaXplLFxuICAgICAgICAnVXBsb2FkLUNvbnRlbnQtVHlwZSc6IHRoaXMubWltZVR5cGUsXG4gICAgICB9LFxuICAgIH0sIHJlc3VsdCA9PiB0aGlzLl9wcm9jZXNzQ29udGVudFVwbG9hZFJlc3BvbnNlKHJlc3VsdCwgcmVzcG9uc2UsIGNsaWVudCkpO1xuICB9XG5cbiAgX3Byb2Nlc3NDb250ZW50VXBsb2FkUmVzcG9uc2UodXBsb2FkUmVzdWx0LCBjb250ZW50UmVzcG9uc2UsIGNsaWVudCkge1xuICAgIGlmICghdXBsb2FkUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGlmICghY2xpZW50Lm9ubGluZU1hbmFnZXIuaXNPbmxpbmUpIHtcbiAgICAgICAgY2xpZW50Lm9ubGluZU1hbmFnZXIub25jZSgnY29ubmVjdGVkJywgdGhpcy5fcHJvY2Vzc0NvbnRlbnRSZXNwb25zZS5iaW5kKHRoaXMsIGNvbnRlbnRSZXNwb25zZSwgY2xpZW50KSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdXZSBkb25cXCd0IHlldCBoYW5kbGUgdGhpcyEnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmlnZ2VyKCdwYXJ0czpzZW5kJywge1xuICAgICAgICBtaW1lX3R5cGU6IHRoaXMubWltZVR5cGUsXG4gICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgICAgaWQ6IHRoaXMuX2NvbnRlbnQuaWQsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBmb3IgYW55IHRleHQvcGxhaW4gcGFydC5cbiAgICpcbiAgICogUmV0dXJucyAnJyBpZiBpdHMgbm90IGEgdGV4dC9wbGFpbiBwYXJ0LlxuICAgKlxuICAgKiBAbWV0aG9kIGdldFRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dCgpIHtcbiAgICBpZiAodGhpcy5taW1lVHlwZSA9PT0gJ3RleHQvcGxhaW4nKSB7XG4gICAgICByZXR1cm4gdGhpcy5ib2R5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIE1lc3NhZ2VQYXJ0IHdpdGggbmV3IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBDdXJyZW50bHksIE1lc3NhZ2VQYXJ0IHByb3BlcnRpZXMgZG8gbm90IHVwZGF0ZS4uLiBob3dldmVyLFxuICAgKiB0aGUgbGF5ZXIuQ29udGVudCBvYmplY3QgdGhhdCBSaWNoIENvbnRlbnQgTWVzc2FnZVBhcnRzIGNvbnRhaW5cbiAgICogZG8gZ2V0IHVwZGF0ZWQgd2l0aCByZWZyZXNoZWQgZXhwaXJpbmcgdXJscy5cbiAgICpcbiAgICogQG1ldGhvZCBfcG9wdWxhdGVGcm9tU2VydmVyXG4gICAqIEBwYXJhbSAge09iamVjdH0gcGFydCAtIFNlcnZlciByZXByZXNlbnRhdGlvbiBvZiBhIHBhcnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9wb3B1bGF0ZUZyb21TZXJ2ZXIocGFydCkge1xuICAgIGlmIChwYXJ0LmNvbnRlbnQgJiYgdGhpcy5fY29udGVudCkge1xuICAgICAgdGhpcy5fY29udGVudC5kb3dubG9hZFVybCA9IHBhcnQuY29udGVudC5kb3dubG9hZF91cmw7XG4gICAgICB0aGlzLl9jb250ZW50LmV4cGlyYXRpb24gPSBuZXcgRGF0ZShwYXJ0LmNvbnRlbnQuZXhwaXJhdGlvbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBNZXNzYWdlUGFydCBmcm9tIGEgc2VydmVyIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXJ0XG4gICAqXG4gICAqIEBtZXRob2QgX2NyZWF0ZUZyb21TZXJ2ZXJcbiAgICogQHByaXZhdGVcbiAgICogQHN0YXRpY1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBhcnQgLSBTZXJ2ZXIgcmVwcmVzZW50YXRpb24gb2YgYSBwYXJ0XG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUZyb21TZXJ2ZXIocGFydCkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAocGFydC5jb250ZW50KSA/IENvbnRlbnQuX2NyZWF0ZUZyb21TZXJ2ZXIocGFydC5jb250ZW50KSA6IG51bGw7XG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VQYXJ0KHtcbiAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgbWltZVR5cGU6IHBhcnQubWltZV90eXBlLFxuICAgICAgYm9keTogcGFydC5ib2R5IHx8ICcnLFxuICAgICAgX2NvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICBoYXNDb250ZW50OiBCb29sZWFuKGNvbnRlbnQpLFxuICAgICAgc2l6ZTogcGFydC5zaXplIHx8IDAsXG4gICAgICBlbmNvZGluZzogcGFydC5lbmNvZGluZyB8fCAnJyxcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIGxheWVyLkNsaWVudCB0aGF0IHRoZSBjb252ZXJzYXRpb24gYmVsb25ncyB0by5cbiAqXG4gKiBBY3R1YWwgdmFsdWUgb2YgdGhpcyBzdHJpbmcgbWF0Y2hlcyB0aGUgYXBwSWQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuY2xpZW50SWQgPSAnJztcblxuLyoqXG4gKiBTZXJ2ZXIgZ2VuZXJhdGVkIGlkZW50aWZpZXIgZm9yIHRoZSBwYXJ0XG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuaWQgPSAnJztcblxuLyoqXG4gKiBCb2R5IG9mIHlvdXIgbWVzc2FnZSBwYXJ0LlxuICpcbiAqIFRoaXMgaXMgdGhlIGNvcmUgZGF0YSBvZiB5b3VyIHBhcnQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUuYm9keSA9IG51bGw7XG5cbi8qKlxuICogUmljaCBjb250ZW50IG9iamVjdC5cbiAqXG4gKiBUaGlzIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGZvciB5b3UgaWYgeW91ciBsYXllci5NZXNzYWdlUGFydC5ib2R5XG4gKiBpcyBsYXJnZS5cbiAqIEB0eXBlIHtsYXllci5Db250ZW50fVxuICogQHByaXZhdGVcbiAqL1xuTWVzc2FnZVBhcnQucHJvdG90eXBlLl9jb250ZW50ID0gbnVsbDtcblxuLyoqXG4gKiBUaGUgUGFydCBoYXMgcmljaCBjb250ZW50XG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuTWVzc2FnZVBhcnQucHJvdG90eXBlLmhhc0NvbnRlbnQgPSBmYWxzZTtcblxuLyoqXG4gKiBVUkwgdG8gcmljaCBjb250ZW50IG9iamVjdC5cbiAqXG4gKiBQYXJ0cyB3aXRoIHJpY2ggY29udGVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggdGhpcyBwcm9wZXJ0eSBzZXQuICBCdXQgaXRzIHZhbHVlIHdpbGwgZXhwaXJlLlxuICpcbiAqIFdpbGwgY29udGFpbiBhbiBleHBpcmluZyB1cmwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSBhbmQgYmUgcmVmcmVzaGVkIHdpdGggY2FsbHMgdG8gYGxheWVyLk1lc3NhZ2VQYXJ0LmZldGNoU3RyZWFtKClgLlxuICogV2lsbCBjb250YWluIGEgbm9uLWV4cGlyaW5nIHVybCB0byBhIGxvY2FsIHJlc291cmNlIGlmIGBsYXllci5NZXNzYWdlUGFydC5mZXRjaENvbnRlbnQoKWAgaXMgY2FsbGVkLlxuICpcbiAqIEB0eXBlIHtsYXllci5Db250ZW50fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWVzc2FnZVBhcnQucHJvdG90eXBlLCAndXJsJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAvLyBJdHMgcG9zc2libGUgdG8gaGF2ZSBhIHVybCBhbmQgbm8gY29udGVudCBpZiBpdCBoYXMgYmVlbiBpbnN0YW50aWF0ZWQgYnV0IG5vdCB5ZXQgc2VudC5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIF9fdXJsIHRoZW4gaXRzIGEgbG9jYWwgdXJsIGdlbmVyYXRlZCBmcm9tIHRoZSBib2R5IHByb3BlcnR5IGFuZCBkb2VzIG5vdCBleHBpcmUuXG4gICAgaWYgKHRoaXMuX191cmwpIHJldHVybiB0aGlzLl9fdXJsO1xuICAgIGlmICh0aGlzLl9jb250ZW50KSByZXR1cm4gdGhpcy5fY29udGVudC5pc0V4cGlyZWQoKSA/ICcnIDogdGhpcy5fY29udGVudC5kb3dubG9hZFVybDtcbiAgICByZXR1cm4gJyc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KGluVmFsdWUpIHtcbiAgICB0aGlzLl9fdXJsID0gaW5WYWx1ZTtcbiAgfSxcbn0pO1xuXG4vKipcbiAqIE1pbWUgVHlwZSBmb3IgdGhlIGRhdGEgaW4gbGF5ZXIuTWVzc2FnZVBhcnQuYm9keS5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZXNzYWdlUGFydC5wcm90b3R5cGUubWltZVR5cGUgPSAndGV4dC9wbGFpbic7XG5cbi8qKlxuICogRW5jb2RpbmcgdXNlZCBmb3IgdGhlIGJvZHkgb2YgdGhpcyBwYXJ0LlxuICpcbiAqIE5vIHZhbHVlIGlzIHRoZSBkZWZhdWx0IGVuY29kaW5nLiAgJ2Jhc2U2NCcgaXMgYWxzbyBhIGNvbW1vbiB2YWx1ZS5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cbk1lc3NhZ2VQYXJ0LnByb3RvdHlwZS5lbmNvZGluZyA9ICcnO1xuXG4vKipcbiAqIFNpemUgb2YgdGhlIGxheWVyLk1lc3NhZ2VQYXJ0LmJvZHkuXG4gKlxuICogV2lsbCBiZSBzZXQgZm9yIHlvdSBpZiBub3QgcHJvdmlkZWQuXG4gKiBPbmx5IG5lZWRlZCBmb3IgdXNlIHdpdGggcmljaCBjb250ZW50LlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbk1lc3NhZ2VQYXJ0LnByb3RvdHlwZS5zaXplID0gMDtcblxuTWVzc2FnZVBhcnQuX3N1cHBvcnRlZEV2ZW50cyA9IFtcbiAgJ3BhcnRzOnNlbmQnLFxuICAnY29udGVudC1sb2FkZWQnLFxuICAndXJsLWxvYWRlZCcsXG4gICdjb250ZW50LWxvYWRlZC1lcnJvcicsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuUm9vdC5pbml0Q2xhc3MuYXBwbHkoTWVzc2FnZVBhcnQsIFtNZXNzYWdlUGFydCwgJ01lc3NhZ2VQYXJ0J10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1lc3NhZ2VQYXJ0O1xuIiwiLyoqXG4gKiBUaGUgTWVzc2FnZSBDbGFzcyByZXByZXNlbnRzIE1lc3NhZ2VzIHNlbnQgYW1vbmdzdCBwYXJ0aWNpcGFudHNcbiAqIG9mIG9mIGEgQ29udmVyc2F0aW9uLlxuICpcbiAqIFRoZSBzaW1wbGVzdCB3YXkgdG8gY3JlYXRlIGFuZCBzZW5kIGEgbWVzc2FnZSBpczpcbiAqXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2UoJ0hlbGxvIHRoZXJlJykuc2VuZCgpO1xuICpcbiAqIEZvciBjb252ZXJzYXRpb25zIHRoYXQgaW52b2x2ZSBub3RpZmljYXRpb25zIChwcmltYXJpbHkgZm9yIEFuZHJvaWQgYW5kIElPUyksIHRoZSBtb3JlIGNvbW1vbiBwYXR0ZXJuIGlzOlxuICpcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSgnSGVsbG8gdGhlcmUnKS5zZW5kKHt0ZXh0OiBcIk1lc3NhZ2UgZnJvbSBGcmVkOiBIZWxsbyB0aGVyZVwifSk7XG4gKlxuICogVHlwaWNhbGx5LCByZW5kZXJpbmcgd291bGQgYmUgZG9uZSBhcyBmb2xsb3dzOlxuICpcbiAqICAgICAgLy8gQ3JlYXRlIGEgbGF5ZXIuUXVlcnkgdGhhdCBsb2FkcyBNZXNzYWdlcyBmb3IgdGhlXG4gKiAgICAgIC8vIHNwZWNpZmllZCBDb252ZXJzYXRpb24uXG4gKiAgICAgIHZhciBxdWVyeSA9IGNsaWVudC5jcmVhdGVRdWVyeSh7XG4gKiAgICAgICAgbW9kZWw6IFF1ZXJ5Lk1lc3NhZ2UsXG4gKiAgICAgICAgcHJlZGljYXRlOiAnY29udmVyc2F0aW9uID0gXCInICsgY29udmVyc2F0aW9uLmlkICsgJ1wiJ1xuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIEFueSB0aW1lIHRoZSBRdWVyeSdzIGRhdGEgY2hhbmdlcyB0aGUgJ2NoYW5nZSdcbiAqICAgICAgLy8gZXZlbnQgd2lsbCBmaXJlLlxuICogICAgICBxdWVyeS5vbignY2hhbmdlJywgZnVuY3Rpb24obGF5ZXJFdnQpIHtcbiAqICAgICAgICByZW5kZXJOZXdNZXNzYWdlcyhxdWVyeS5kYXRhKTtcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBUaGlzIHdpbGwgY2FsbCB3aWxsIGNhdXNlIHRoZSBhYm92ZSBldmVudCBoYW5kbGVyIHRvIHJlY2VpdmVcbiAqICAgICAgLy8gYSBjaGFuZ2UgZXZlbnQsIGFuZCB3aWxsIHVwZGF0ZSBxdWVyeS5kYXRhLlxuICogICAgICBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSgnSGVsbG8gdGhlcmUnKS5zZW5kKCk7XG4gKlxuICogVGhlIGFib3ZlIGNvZGUgd2lsbCB0cmlnZ2VyIHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqICAqIE1lc3NhZ2UgSW5zdGFuY2UgZmlyZXNcbiAqICAgICogbWVzc2FnZXM6c2VuZGluZzogQW4gZXZlbnQgdGhhdCBsZXRzIHlvdSBtb2RpZnkgdGhlIG1lc3NhZ2UgcHJpb3IgdG8gc2VuZGluZ1xuICogICAgKiBtZXNzYWdlczpzZW50OiBUaGUgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgYnkgdGhlIHNlcnZlclxuICogICogUXVlcnkgSW5zdGFuY2UgZmlyZXNcbiAqICAgICogY2hhbmdlOiBUaGUgcXVlcnkgaGFzIHJlY2VpdmVkIGEgbmV3IE1lc3NhZ2VcbiAqICAgICogY2hhbmdlOmFkZDogU2FtZSBhcyB0aGUgY2hhbmdlIGV2ZW50IGJ1dCBtb3JlIHNwZWNpZmljXG4gKlxuICogV2hlbiBjcmVhdGluZyBhIE1lc3NhZ2UgdGhlcmUgYXJlIGEgbnVtYmVyIG9mIHdheXMgdG8gc3RydWN0dXJlIGl0LlxuICogQWxsIG9mIHRoZXNlIGFyZSB2YWxpZCBhbmQgY3JlYXRlIHRoZSBzYW1lIGV4YWN0IE1lc3NhZ2U6XG4gKlxuICogICAgICAvLyBGdWxsIEFQSSBzdHlsZTpcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogW25ldyBsYXllci5NZXNzYWdlUGFydCh7XG4gKiAgICAgICAgICAgICAgYm9keTogJ0hlbGxvIHRoZXJlJyxcbiAqICAgICAgICAgICAgICBtaW1lVHlwZTogJ3RleHQvcGxhaW4nXG4gKiAgICAgICAgICB9KV1cbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBPcHRpb24gMTogUGFzcyBpbiBhbiBPYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydHNcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czoge1xuICogICAgICAgICAgICAgIGJvZHk6ICdIZWxsbyB0aGVyZScsXG4gKiAgICAgICAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJ1xuICogICAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiAgICAgIC8vIE9wdGlvbiAyOiBQYXNzIGluIGFuIGFycmF5IG9mIE9iamVjdHMgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydHNcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogW3tcbiAqICAgICAgICAgICAgICBib2R5OiAnSGVsbG8gdGhlcmUnLFxuICogICAgICAgICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbidcbiAqICAgICAgICAgIH1dXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gT3B0aW9uIDM6IFBhc3MgaW4gYSBzdHJpbmcgKGF1dG9tYXRpY2FsbHkgYXNzdW1lcyBtaW1lVHlwZSBpcyB0ZXh0L3BsYWluKVxuICogICAgICAvLyBpbnN0ZWFkIG9mIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2Uoe1xuICogICAgICAgICAgcGFydHM6ICdIZWxsbydcbiAqICAgICAgfSk7XG4gKlxuICogICAgICAvLyBPcHRpb24gNDogUGFzcyBpbiBhbiBhcnJheSBvZiBzdHJpbmdzIChhdXRvbWF0aWNhbGx5IGFzc3VtZXMgbWltZVR5cGUgaXMgdGV4dC9wbGFpbilcbiAqICAgICAgdmFyIG0gPSBjb252ZXJzYXRpb24uY3JlYXRlTWVzc2FnZSh7XG4gKiAgICAgICAgICBwYXJ0czogWydIZWxsbyddXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgLy8gT3B0aW9uIDU6IFBhc3MgaW4ganVzdCBhIHN0cmluZyBhbmQgbm90aGluZyBlbHNlXG4gKiAgICAgIHZhciBtID0gY29udmVyc2F0aW9uLmNyZWF0ZU1lc3NhZ2UoJ0hlbGxvJyk7XG4gKlxuICogICAgICAvLyBPcHRpb24gNjogVXNlIGFkZFBhcnQuXG4gKiAgICAgIHZhciBtID0gY29udmVyc2VhdGlvbi5jcmVhdGVNZXNzYWdlKCk7XG4gKiAgICAgIG0uYWRkUGFydCh7Ym9keTogXCJoZWxsb1wiLCBtaW1lVHlwZTogXCJ0ZXh0L3BsYWluXCJ9KTtcbiAqXG4gKiBLZXkgbWV0aG9kcywgZXZlbnRzIGFuZCBwcm9wZXJ0aWVzIGZvciBnZXR0aW5nIHN0YXJ0ZWQ6XG4gKlxuICogUHJvcGVydGllczpcbiAqXG4gKiAqIGxheWVyLk1lc3NhZ2UuaWQ6IHRoaXMgcHJvcGVydHkgaXMgd29ydGggYmVpbmcgZmFtaWxpYXIgd2l0aDsgaXQgaWRlbnRpZmllcyB0aGVcbiAqICAgTWVzc2FnZSBhbmQgY2FuIGJlIHVzZWQgaW4gYGNsaWVudC5nZXRNZXNzYWdlKGlkKWAgdG8gcmV0cmlldmUgaXRcbiAqICAgYXQgYW55IHRpbWUuXG4gKiAqIGxheWVyLk1lc3NhZ2UuaW50ZXJuYWxJZDogVGhpcyBwcm9wZXJ0eSBtYWtlcyBmb3IgYSBoYW5keSB1bmlxdWUgSUQgZm9yIHVzZSBpbiBkb20gbm9kZXMuXG4gKiAgIEl0IGlzIGdhdXJlbnRlZWQgbm90IHRvIGNoYW5nZSBkdXJpbmcgdGhpcyBzZXNzaW9uLlxuICogKiBsYXllci5NZXNzYWdlLmlzUmVhZDogSW5kaWNhdGVzIGlmIHRoZSBNZXNzYWdlIGhhcyBiZWVuIHJlYWQgeWV0OyBzZXQgYG0uaXNSZWFkID0gdHJ1ZWBcbiAqICAgdG8gdGVsbCB0aGUgY2xpZW50IGFuZCBzZXJ2ZXIgdGhhdCB0aGUgbWVzc2FnZSBoYXMgYmVlbiByZWFkLlxuICogKiBsYXllci5NZXNzYWdlLnBhcnRzOiBBbiBhcnJheSBvZiBsYXllci5NZXNzYWdlUGFydCBjbGFzc2VzIHJlcHJlc2VudGluZyB0aGUgY29udGVudHMgb2YgdGhlIE1lc3NhZ2UuXG4gKiAqIGxheWVyLk1lc3NhZ2Uuc2VudEF0OiBEYXRlIHRoZSBtZXNzYWdlIHdhcyBzZW50XG4gKiAqIGxheWVyLk1lc3NhZ2Uuc2VuZGVyJ3MgYHVzZXJJZGAgcHJvcGVydHk6IENvbnZlcnNhdGlvbiBwYXJ0aWNpcGFudCB3aG8gc2VudCB0aGUgTWVzc2FnZS4gWW91IG1heVxuICogICBuZWVkIHRvIGRvIGEgbG9va3VwIG9uIHRoaXMgaWQgaW4geW91ciBvd24gc2VydmVycyB0byBmaW5kIGFcbiAqICAgZGlzcGxheWFibGUgbmFtZSBmb3IgaXQuXG4gKlxuICogTWV0aG9kczpcbiAqXG4gKiAqIGxheWVyLk1lc3NhZ2Uuc2VuZCgpOiBTZW5kcyB0aGUgbWVzc2FnZSB0byB0aGUgc2VydmVyIGFuZCB0aGUgb3RoZXIgcGFydGljaXBhbnRzLlxuICogKiBsYXllci5NZXNzYWdlLm9uKCkgYW5kIGxheWVyLk1lc3NhZ2Uub2ZmKCk7IGV2ZW50IGxpc3RlbmVycyBidWlsdCBvbiB0b3Agb2YgdGhlIGBiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZWAgbnBtIHByb2plY3RcbiAqXG4gKiBFdmVudHM6XG4gKlxuICogKiBgbWVzc2FnZXM6c2VudGA6IFRoZSBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIENhbiBhbHNvIHN1YnNjcmliZSB0b1xuICogICB0aGlzIGV2ZW50IGZyb20gdGhlIGxheWVyLkNsaWVudCB3aGljaCBpcyB1c3VhbGx5IHNpbXBsZXIuXG4gKlxuICogQGNsYXNzICBsYXllci5NZXNzYWdlXG4gKiBAZXh0ZW5kcyBsYXllci5TeW5jYWJsZVxuICovXG5cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IFN5bmNhYmxlID0gcmVxdWlyZSgnLi9zeW5jYWJsZScpO1xuY29uc3QgTWVzc2FnZVBhcnQgPSByZXF1aXJlKCcuL21lc3NhZ2UtcGFydCcpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IENvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuY29uc3QgQ2xpZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuL2NsaWVudC1yZWdpc3RyeScpO1xuXG5jbGFzcyBNZXNzYWdlIGV4dGVuZHMgU3luY2FibGUge1xuICAvKipcbiAgICogU2VlIGxheWVyLkNvbnZlcnNhdGlvbi5jcmVhdGVNZXNzYWdlKClcbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYSBzZXJ2ZXIgcmVwcmVzZW50YXRpb24sIHRoaXMgaXMgYSBkZXZlbG9wZXIncyBzaG9ydGhhbmQ7XG4gICAgLy8gZmlsbCBpbiB0aGUgbWlzc2luZyBwcm9wZXJ0aWVzIGFyb3VuZCBpc1JlYWQvaXNVbnJlYWQgYmVmb3JlIGluaXRpYWxpemluZy5cbiAgICBpZiAoIW9wdGlvbnMuZnJvbVNlcnZlcikge1xuICAgICAgaWYgKCdpc1VucmVhZCcgaW4gb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLmlzUmVhZCA9ICFvcHRpb25zLmlzVW5yZWFkICYmICFvcHRpb25zLmlzX3VucmVhZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuaXNSZWFkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5pZCA9IG9wdGlvbnMuZnJvbVNlcnZlci5pZDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jbGllbnQpIG9wdGlvbnMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudC5hcHBJZDtcbiAgICBpZiAoIW9wdGlvbnMuY2xpZW50SWQpIHRocm93IG5ldyBFcnJvcignY2xpZW50SWQgcHJvcGVydHkgcmVxdWlyZWQgdG8gY3JlYXRlIGEgTWVzc2FnZScpO1xuICAgIGlmIChvcHRpb25zLmNvbnZlcnNhdGlvbikgb3B0aW9ucy5jb252ZXJzYXRpb25JZCA9IG9wdGlvbnMuY29udmVyc2F0aW9uLmlkO1xuXG4gICAgLy8gSW5zdXJlIF9fYWRqdXN0UGFydHMgaXMgc2V0IEFGVEVSIGNsaWVudElkIGlzIHNldC5cbiAgICBjb25zdCBwYXJ0cyA9IG9wdGlvbnMucGFydHM7XG4gICAgb3B0aW9ucy5wYXJ0cyA9IG51bGw7XG5cbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLnBhcnRzID0gcGFydHM7XG5cbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSB0cnVlO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZnJvbVNlcnZlcikge1xuICAgICAgdGhpcy5fcG9wdWxhdGVGcm9tU2VydmVyKG9wdGlvbnMuZnJvbVNlcnZlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZGVyID0geyB1c2VySWQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXJ0cykgdGhpcy5wYXJ0cyA9IFtdO1xuICAgIHRoaXMubG9jYWxDcmVhdGVkQXQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9IHRydWU7XG4gICAgaWYgKCFvcHRpb25zLmZyb21TZXJ2ZXIpIHRoaXMucmVjaXBpZW50U3RhdHVzID0ge307XG4gICAgZWxzZSB0aGlzLl9fdXBkYXRlUmVjaXBpZW50U3RhdHVzKHRoaXMucmVjaXBpZW50U3RhdHVzKTtcbiAgICB0aGlzLl9kaXNhYmxlRXZlbnRzID0gZmFsc2U7XG5cbiAgICB0aGlzLmlzSW5pdGlhbGl6aW5nID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5mcm9tU2VydmVyKSB7XG4gICAgICBjbGllbnQuX2FkZE1lc3NhZ2UodGhpcyk7XG4gICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnJlY2lwaWVudFN0YXR1c1tjbGllbnQudXNlcklkXTtcbiAgICAgIGlmIChzdGF0dXMgIT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQgJiYgc3RhdHVzICE9PSBDb25zdGFudHMuUkVDRUlQVF9TVEFURS5ERUxJVkVSRUQpIHtcbiAgICAgICAgdGhpcy5fc2VuZFJlY2VpcHQoJ2RlbGl2ZXJ5Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIuQ2xpZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheWVyLk1lc3NhZ2UuXG4gICAqXG4gICAqIFVzZXMgdGhlIGxheWVyLk1lc3NhZ2UuY2xpZW50SWQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Q2xpZW50XG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudH1cbiAgICovXG4gIGdldENsaWVudCgpIHtcbiAgICByZXR1cm4gQ2xpZW50UmVnaXN0cnkuZ2V0KHRoaXMuY2xpZW50SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGF5ZXIuQ29udmVyc2F0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheWVyLk1lc3NhZ2UuXG4gICAqXG4gICAqIFVzZXMgdGhlIGxheWVyLk1lc3NhZ2UuY29udmVyc2F0aW9uSWQuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Q29udmVyc2F0aW9uXG4gICAqIEByZXR1cm4ge2xheWVyLkNvbnZlcnNhdGlvbn1cbiAgICovXG4gIGdldENvbnZlcnNhdGlvbihsb2FkKSB7XG4gICAgaWYgKHRoaXMuY29udmVyc2F0aW9uSWQpIHtcbiAgICAgIHJldHVybiBDbGllbnRSZWdpc3RyeS5nZXQodGhpcy5jbGllbnRJZCkuZ2V0Q29udmVyc2F0aW9uKHRoaXMuY29udmVyc2F0aW9uSWQsIGxvYWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUdXJuIGlucHV0IGludG8gdmFsaWQgbGF5ZXIuTWVzc2FnZVBhcnRzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCBhbnkgdGltZSB0aGUgcGFydHNcbiAgICogcHJvcGVydHkgaXMgc2V0IChpbmNsdWRpbmcgZHVyaW5nIGludGlhbGl6YXRpb24pLiAgVGhpc1xuICAgKiBpcyB3aGVyZSB3ZSBjb252ZXJ0IHN0cmluZ3MgaW50byBNZXNzYWdlUGFydHMsIGFuZCBpbnN0YW5jZXNcbiAgICogaW50byBhcnJheXMuXG4gICAqXG4gICAqIEBtZXRob2QgX19hZGp1c3RQYXJ0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtNaXhlZH0gcGFydHMgLS0gQ291bGQgYmUgYSBzdHJpbmcsIGFycmF5LCBvYmplY3Qgb3IgTWVzc2FnZVBhcnQgaW5zdGFuY2VcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZVBhcnRbXX1cbiAgICovXG4gIF9fYWRqdXN0UGFydHMocGFydHMpIHtcbiAgICBpZiAodHlwZW9mIHBhcnRzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtuZXcgTWVzc2FnZVBhcnQoe1xuICAgICAgICBib2R5OiBwYXJ0cyxcbiAgICAgICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICB9KV07XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhcnRzKSkge1xuICAgICAgcmV0dXJuIHBhcnRzLm1hcChwYXJ0ID0+IHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKHBhcnQgaW5zdGFuY2VvZiBNZXNzYWdlUGFydCkge1xuICAgICAgICAgIHJlc3VsdCA9IHBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0ID0gbmV3IE1lc3NhZ2VQYXJ0KHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5jbGllbnRJZCA9IHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzICYmIHR5cGVvZiBwYXJ0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhcnRzLmNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcbiAgICAgIHJldHVybiBbbmV3IE1lc3NhZ2VQYXJ0KHBhcnRzKV07XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQWRkIGEgbGF5ZXIuTWVzc2FnZVBhcnQgdG8gdGhpcyBNZXNzYWdlLlxuICAgKlxuICAgKiBTaG91bGQgb25seSBiZSBjYWxsZWQgb24gYW4gdW5zZW50IE1lc3NhZ2UuXG4gICAqXG4gICAqIEBtZXRob2QgYWRkUGFydFxuICAgKiBAcGFyYW0gIHtsYXllci5NZXNzYWdlUGFydC9PYmplY3R9IHBhcnQgLSBBIGxheWVyLk1lc3NhZ2VQYXJ0IGluc3RhbmNlIG9yIGEgYHttaW1lVHlwZTogJ3RleHQvcGxhaW4nLCBib2R5OiAnSGVsbG8nfWAgZm9ybWF0dGVkIE9iamVjdC5cbiAgICovXG4gIGFkZFBhcnQocGFydCkge1xuICAgIGlmIChwYXJ0KSB7XG4gICAgICBwYXJ0LmNsaWVudElkID0gdGhpcy5jbGllbnRJZDtcbiAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKG5ldyBNZXNzYWdlUGFydChwYXJ0KSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgaW5zdGFuY2VvZiBNZXNzYWdlUGFydCkge1xuICAgICAgICB0aGlzLnBhcnRzLnB1c2gocGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2Vzc29yIGNhbGxlZCB3aGVuZXZlciB0aGUgYXBwIGFjY2Vzc2VzIGBtZXNzYWdlLnJlY2lwaWVudFN0YXR1c2AuXG4gICAqXG4gICAqIEluc3VyZXMgdGhhdCBwYXJ0aWNpcGFudHMgd2hvIGhhdmVuJ3QgeWV0IGJlZW4gc2VudCB0aGUgTWVzc2FnZSBhcmUgbWFya2VkIGFzIGxheWVyLkNvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlBFTkRJTkdcbiAgICpcbiAgICogQG1ldGhvZCBfX2dldFJlY2lwaWVudFN0YXR1c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcEtleSAtIFRoZSBhY3R1YWwgcHJvcGVydHkga2V5IHdoZXJlIHRoZSB2YWx1ZSBpcyBzdG9yZWRcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX19nZXRSZWNpcGllbnRTdGF0dXMocEtleSkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpc1twS2V5XSB8fCB7fTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGlmIChjbGllbnQpIHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9IGNsaWVudC51c2VySWQ7XG4gICAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgICBpZiAoY29udmVyc2F0aW9uKSB7XG4gICAgICAgIGNvbnZlcnNhdGlvbi5wYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICAgICAgaWYgKCF2YWx1ZVtwYXJ0aWNpcGFudF0pIHtcbiAgICAgICAgICAgIHZhbHVlW3BhcnRpY2lwYW50XSA9IHBhcnRpY2lwYW50ID09PSB1c2VySWQgP1xuICAgICAgICAgICAgICBDb25zdGFudHMuUkVDRUlQVF9TVEFURS5SRUFEIDogQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUEVORElORztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGNoYW5nZXMgdG8gdGhlIHJlY2lwaWVudFN0YXR1cyBwcm9wZXJ0eS5cbiAgICpcbiAgICogQW55IHRpbWUgdGhlIHJlY2lwaWVudFN0YXR1cyBwcm9wZXJ0eSBpcyBzZXQsXG4gICAqIFJlY2FsY3VsYXRlIGFsbCBvZiB0aGUgcmVjZWlwdCByZWxhdGVkIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIDEuIGlzUmVhZFxuICAgKiAyLiByZWFkU3RhdHVzXG4gICAqIDMuIGRlbGl2ZXJ5U3RhdHVzXG4gICAqXG4gICAqIEBtZXRob2QgX191cGRhdGVSZWNpcGllbnRTdGF0dXNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGF0dXMgLSBPYmplY3QgZGVzY3JpYmluZyB0aGUgZGVsaXZlcmVkL3JlYWQvc2VudCB2YWx1ZSBmb3IgZWFjaCBwYXJ0aWNpcGFudFxuICAgKlxuICAgKi9cbiAgX191cGRhdGVSZWNpcGllbnRTdGF0dXMoc3RhdHVzLCBvbGRTdGF0dXMpIHtcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcblxuICAgIGlmICghY29udmVyc2F0aW9uIHx8IFV0aWwuZG9lc09iamVjdE1hdGNoKHN0YXR1cywgb2xkU3RhdHVzKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgdXNlcklkID0gY2xpZW50LnVzZXJJZDtcbiAgICBjb25zdCBpc1NlbmRlciA9IHRoaXMuc2VuZGVyLnVzZXJJZCA9PT0gdXNlcklkO1xuICAgIGNvbnN0IHVzZXJIYXNSZWFkID0gc3RhdHVzW3VzZXJJZF0gPT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQ7XG5cbiAgICB0cnkge1xuICAgICAgLy8gLTEgc28gd2UgZG9uJ3QgY291bnQgdGhpcyB1c2VyXG4gICAgICBjb25zdCB1c2VyQ291bnQgPSBjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIElmIHNlbnQgYnkgdGhpcyB1c2VyIG9yIHJlYWQgYnkgdGhpcyB1c2VyLCB1cGRhdGUgaXNSZWFkL3VucmVhZFxuICAgICAgaWYgKCF0aGlzLl9faXNSZWFkICYmIChpc1NlbmRlciB8fCB1c2VySGFzUmVhZCkpIHtcbiAgICAgICAgdGhpcy5fX2lzUmVhZCA9IHRydWU7IC8vIG5vIF9fdXBkYXRlSXNSZWFkIGV2ZW50IGZpcmVkXG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSB0aGUgcmVhZFN0YXR1cy9kZWxpdmVyeVN0YXR1cyBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCB7IHJlYWRDb3VudCwgZGVsaXZlcmVkQ291bnQgfSA9IHRoaXMuX2dldFJlY2VpcHRTdGF0dXMoc3RhdHVzLCB1c2VySWQpO1xuICAgICAgdGhpcy5fc2V0UmVjZWlwdFN0YXR1cyhyZWFkQ291bnQsIGRlbGl2ZXJlZENvdW50LCB1c2VyQ291bnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuXG4gICAgLy8gT25seSB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgLy8gMS4gd2UncmUgbm90IGluaXRpYWxpemluZyBhIG5ldyBNZXNzYWdlXG4gICAgLy8gMi4gdGhlIHVzZXIncyBzdGF0ZSBoYXMgYmVlbiB1cGRhdGVkIHRvIHJlYWQ7IHdlIGRvbid0IGNhcmUgYWJvdXQgdXBkYXRlcyBmcm9tIG90aGVyIHVzZXJzIGlmIHdlIGFyZW4ndCB0aGUgc2VuZGVyLlxuICAgIC8vICAgIFdlIGFsc28gZG9uJ3QgY2FyZSBhYm91dCBzdGF0ZSBjaGFuZ2VzIHRvIGRlbGl2ZXJlZDsgdGhlc2UgZG8gbm90IGluZm9ybSByZW5kZXJpbmcgYXMgdGhlIGZhY3Qgd2UgYXJlIHByb2Nlc3NpbmcgaXRcbiAgICAvLyAgICBwcm92ZXMgaXRzIGRlbGl2ZXJlZC5cbiAgICAvLyAzLiBUaGUgdXNlciBpcyB0aGUgc2VuZGVyOyBpbiB0aGF0IGNhc2Ugd2UgZG8gY2FyZSBhYm91dCByZW5kZXJpbmcgcmVjZWlwdHMgZnJvbSBvdGhlciB1c2Vyc1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemluZyAmJiBvbGRTdGF0dXMpIHtcbiAgICAgIGNvbnN0IHVzZXJzU3RhdGVVcGRhdGVkVG9SZWFkID0gdXNlckhhc1JlYWQgJiYgb2xkU3RhdHVzW3VzZXJJZF0gIT09IENvbnN0YW50cy5SRUNFSVBUX1NUQVRFLlJFQUQ7XG4gICAgICBpZiAodXNlcnNTdGF0ZVVwZGF0ZWRUb1JlYWQgfHwgaXNTZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdtZXNzYWdlczpjaGFuZ2UnLCB7XG4gICAgICAgICAgb2xkVmFsdWU6IG9sZFN0YXR1cyxcbiAgICAgICAgICBuZXdWYWx1ZTogc3RhdHVzLFxuICAgICAgICAgIHByb3BlcnR5OiAncmVjaXBpZW50U3RhdHVzJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbnVtYmVyIG9mIHBhcnRpY2lwYW50cyB3aG8gaGF2ZSByZWFkIGFuZCBiZWVuIGRlbGl2ZXJlZFxuICAgKiB0aGlzIE1lc3NhZ2VcbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0UmVjZWlwdFN0YXR1c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXR1cyAtIE9iamVjdCBkZXNjcmliaW5nIHRoZSBkZWxpdmVyZWQvcmVhZC9zZW50IHZhbHVlIGZvciBlYWNoIHBhcnRpY2lwYW50XG4gICAqIEBwYXJhbSAge3N0cmluZ30gdXNlcklkIC0gVXNlciBJRCBmb3IgdGhpcyB1c2VyOyBub3QgY291bnRlZCB3aGVuIHJlcG9ydGluZyBvbiBob3cgbWFueSBwZW9wbGUgaGF2ZSByZWFkL3JlY2VpdmVkLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IHJlc3VsdC5yZWFkQ291bnRcbiAgICogQHJldHVybiB7bnVtYmVyfSByZXN1bHQuZGVsaXZlcmVkQ291bnRcbiAgICovXG4gIF9nZXRSZWNlaXB0U3RhdHVzKHN0YXR1cywgdXNlcklkKSB7XG4gICAgbGV0IHJlYWRDb3VudCA9IDAsXG4gICAgICBkZWxpdmVyZWRDb3VudCA9IDA7XG4gICAgT2JqZWN0LmtleXMoc3RhdHVzKS5maWx0ZXIocGFydGljaXBhbnQgPT4gcGFydGljaXBhbnQgIT09IHVzZXJJZCkuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICBpZiAoc3RhdHVzW3BhcnRpY2lwYW50XSA9PT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCkge1xuICAgICAgICByZWFkQ291bnQrKztcbiAgICAgICAgZGVsaXZlcmVkQ291bnQrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzW3BhcnRpY2lwYW50XSA9PT0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuREVMSVZFUkVEKSB7XG4gICAgICAgIGRlbGl2ZXJlZENvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVhZENvdW50LFxuICAgICAgZGVsaXZlcmVkQ291bnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsYXllci5NZXNzYWdlLnJlYWRTdGF0dXMgYW5kIGxheWVyLk1lc3NhZ2UuZGVsaXZlcnlTdGF0dXMgcHJvcGVydGllcy5cbiAgICpcbiAgICogQG1ldGhvZCBfc2V0UmVjZWlwdFN0YXR1c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJlYWRDb3VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRlbGl2ZXJlZENvdW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gdXNlckNvdW50XG4gICAqL1xuICBfc2V0UmVjZWlwdFN0YXR1cyhyZWFkQ291bnQsIGRlbGl2ZXJlZENvdW50LCB1c2VyQ291bnQpIHtcbiAgICBpZiAocmVhZENvdW50ID09PSB1c2VyQ291bnQpIHtcbiAgICAgIHRoaXMucmVhZFN0YXR1cyA9IENvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuQUxMO1xuICAgIH0gZWxzZSBpZiAocmVhZENvdW50ID4gMCkge1xuICAgICAgdGhpcy5yZWFkU3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5TT01FO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlYWRTdGF0dXMgPSBDb25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLk5PTkU7XG4gICAgfVxuICAgIGlmIChkZWxpdmVyZWRDb3VudCA9PT0gdXNlckNvdW50KSB7XG4gICAgICB0aGlzLmRlbGl2ZXJ5U3RhdHVzID0gQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5BTEw7XG4gICAgfSBlbHNlIGlmIChkZWxpdmVyZWRDb3VudCA+IDApIHtcbiAgICAgIHRoaXMuZGVsaXZlcnlTdGF0dXMgPSBDb25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLlNPTUU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVsaXZlcnlTdGF0dXMgPSBDb25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLk5PTkU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjaGFuZ2VzIHRvIHRoZSBpc1JlYWQgcHJvcGVydHkuXG4gICAqXG4gICAqIElmIHNvbWVvbmUgY2FsbGVkIG0uaXNSZWFkID0gdHJ1ZSwgQU5EXG4gICAqIGlmIGl0IHdhcyBwcmV2aW91c2x5IGZhbHNlLCBBTkRcbiAgICogaWYgdGhlIGNhbGwgZGlkbid0IGNvbWUgZnJvbSBsYXllci5NZXNzYWdlLl9fdXBkYXRlUmVjaXBpZW50U3RhdHVzLFxuICAgKiBUaGVuIG5vdGlmeSB0aGUgc2VydmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gcmVhZC5cbiAgICpcbiAgICpcbiAgICogQG1ldGhvZCBfX3VwZGF0ZUlzUmVhZFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSB2YWx1ZSAtIFRydWUgaWYgaXNSZWFkIGlzIHRydWUuXG4gICAqL1xuICBfX3VwZGF0ZUlzUmVhZCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2VuZFJlY2VpcHQoQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCk7XG4gICAgICB0aGlzLl90cmlnZ2VyQXN5bmMoJ21lc3NhZ2VzOnJlYWQnKTtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbiA9IHRoaXMuZ2V0Q29udmVyc2F0aW9uKGZhbHNlKTtcbiAgICAgIGlmIChjb252ZXJzYXRpb24pIGNvbnZlcnNhdGlvbi51bnJlYWRDb3VudC0tO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBSZWFkIG9yIERlbGl2ZXJ5IFJlY2VpcHQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZCBzZW5kUmVjZWlwdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9bGF5ZXIuQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRF0gLSBPbmUgb2YgbGF5ZXIuQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCBvciBsYXllci5Db25zdGFudHMuUkVDRUlQVF9TVEFURS5ERUxJVkVSWVxuICAgKiBAcmV0dXJuIHtsYXllci5NZXNzYWdlfSB0aGlzXG4gICAqL1xuICBzZW5kUmVjZWlwdCh0eXBlID0gQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCkge1xuICAgIGlmICh0eXBlID09PSBDb25zdGFudHMuUkVDRUlQVF9TVEFURS5SRUFEKSB7XG4gICAgICBpZiAodGhpcy5pc1JlYWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaXRob3V0IHRyaWdnZXJpbmcgdGhlIGV2ZW50LCBjbGVhck9iamVjdCBpc24ndCBjYWxsZWQsXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIHRob3NlIHVzaW5nIHRoZSB0b09iamVjdCgpIGRhdGEgd2lsbCBoYXZlIGFuIGlzUmVhZCB0aGF0IGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgLy8gdGhpcyBpbnN0YW5jZS4gIFdoaWNoIHR5cGljYWxseSBsZWFkcyB0byBsb3RzIG9mIGV4dHJhIGF0dGVtcHRzXG4gICAgICAgIC8vIHRvIG1hcmsgdGhlIG1lc3NhZ2UgYXMgcmVhZC5cbiAgICAgICAgdGhpcy5fX2lzUmVhZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6cmVhZCcpO1xuICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgICAgIGlmIChjb252ZXJzYXRpb24pIGNvbnZlcnNhdGlvbi51bnJlYWRDb3VudC0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZW5kUmVjZWlwdCh0eXBlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgUmVhZCBvciBEZWxpdmVyeSBSZWNlaXB0IHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIFRoaXMgYnlwYXNzZXMgYW55IHZhbGlkYXRpb24gYW5kIGdvZXMgZGlyZWN0IHRvIHNlbmRpbmcgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogTk9URTogU2VydmVyIGVycm9ycyBhcmUgbm90IGhhbmRsZWQ7IHRoZSBsb2NhbCByZWNlaXB0IHN0YXRlIGlzIHN1aXRhYmxlIGV2ZW5cbiAgICogaWYgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zZW5kUmVjZWlwdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9cmVhZF0gLSBPbmUgb2YgbGF5ZXIuQ29uc3RhbnRzLlJFQ0VJUFRfU1RBVEUuUkVBRCBvciBsYXllci5Db25zdGFudHMuUkVDRUlQVF9TVEFURS5ERUxJVkVSWVxuICAgKi9cbiAgX3NlbmRSZWNlaXB0KHR5cGUpIHtcblxuICAgIC8vIFRoaXMgbGl0dGxlIHRlc3QgZXhpc3RzIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCByZWNlaXB0cyBvbiBDb252ZXJzYXRpb25zIHdlIGFyZSBubyBsb25nZXJcbiAgICAvLyBwYXJ0aWNpcGFudHMgaW4gKHBhcnRpY2lwYW50cyA9IFtdIGlmIHdlIGFyZSBub3QgYSBwYXJ0aWNpcGFudClcbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbihmYWxzZSk7XG4gICAgaWYgKGNvbnZlcnNhdGlvbiAmJiBjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgdGhpcy5fc2V0U3luY2luZygpO1xuICAgIHRoaXMuX3hocih7XG4gICAgICB1cmw6ICcvcmVjZWlwdHMnLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGUsXG4gICAgICB9LFxuICAgICAgc3luYzoge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgdHJlYXRlZCBhcyBhIFBPU1QvQ1JFQVRFIHJlcXVlc3Qgb24gdGhlIE1lc3NhZ2VcbiAgICAgICAgb3BlcmF0aW9uOiAnUkVDRUlQVCcsXG4gICAgICB9LFxuICAgIH0sICgpID0+IHRoaXMuX3NldFN5bmNlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIHRoZSBtZXNzYWdlIHRvIGFsbCBwYXJ0aWNpcGFudHMgb2YgdGhlIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogTWVzc2FnZSBtdXN0IGhhdmUgcGFydHMgYW5kIGEgdmFsaWQgY29udmVyc2F0aW9uIHRvIHNlbmQgc3VjY2Vzc2Z1bGx5LlxuICAgKlxuICAgKiBAbWV0aG9kIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtub3RpZmljYXRpb25dIC0gUGFyYW1ldGVycyBmb3IgY29udHJvbGluZyBob3cgdGhlIHBob25lcyBtYW5hZ2Ugbm90aWZpY2F0aW9ucyBvZiB0aGUgbmV3IE1lc3NhZ2UuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgSU9TIGFuZCBBbmRyb2lkIGRvY3MgZm9yIGRldGFpbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbm90aWZpY2F0aW9uLnRleHRdIC0gVGV4dCBvZiB5b3VyIG5vdGlmaWNhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25vdGlmaWNhdGlvbi5zb3VuZF0gLSBOYW1lIG9mIGFuIGF1ZGlvIGZpbGUgb3Igb3RoZXIgc291bmQtcmVsYXRlZCBoaW50XG4gICAqIEByZXR1cm4ge2xheWVyLk1lc3NhZ2V9IHRoaXNcbiAgICovXG4gIHNlbmQobm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcbiAgICBpZiAoIWNsaWVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5jbGllbnRNaXNzaW5nKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmdldENvbnZlcnNhdGlvbih0cnVlKTtcblxuICAgIGlmICghY29udmVyc2F0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmNvbnZlcnNhdGlvbk1pc3NpbmcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN5bmNTdGF0ZSAhPT0gQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmFscmVhZHlTZW50KTtcbiAgICB9XG5cblxuICAgIGlmIChjb252ZXJzYXRpb24uaXNMb2FkaW5nKSB7XG4gICAgICByZXR1cm4gY29udmVyc2F0aW9uLm9uY2UoJ2NvbnZlcnNhdGlvbnM6bG9hZGVkJywgKCkgPT4gdGhpcy5zZW5kKG5vdGlmaWNhdGlvbikpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5wYXJ0cyB8fCAhdGhpcy5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkucGFydHNNaXNzaW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnNlbmRlci51c2VySWQgPSBjbGllbnQudXNlcklkO1xuICAgIHRoaXMuX3NldFN5bmNpbmcoKTtcbiAgICBjbGllbnQuX2FkZE1lc3NhZ2UodGhpcyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgQ29udmVyc2F0aW9uIGhhcyBiZWVuIGNyZWF0ZWQgb24gdGhlIHNlcnZlclxuICAgIC8vIGFuZCB1cGRhdGUgdGhlIGxhc3RNZXNzYWdlIHByb3BlcnR5XG4gICAgY29udmVyc2F0aW9uLnNlbmQodGhpcyk7XG5cbiAgICAvLyBhbGxvdyBmb3IgbW9kaWZpY2F0aW9uIG9mIG1lc3NhZ2UgYmVmb3JlIHNlbmRpbmdcbiAgICB0aGlzLnRyaWdnZXIoJ21lc3NhZ2VzOnNlbmRpbmcnKTtcblxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICBwYXJ0czogbmV3IEFycmF5KHRoaXMucGFydHMubGVuZ3RoKSxcbiAgICAgIGlkOiB0aGlzLmlkLFxuICAgIH07XG4gICAgaWYgKG5vdGlmaWNhdGlvbikgZGF0YS5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG5cbiAgICB0aGlzLl9wcmVwYXJlUGFydHNGb3JTZW5kaW5nKGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3VyZXMgdGhhdCBlYWNoIHBhcnQgaXMgcmVhZHkgdG8gc2VuZCBiZWZvcmUgYWN0dWFsbHkgc2VuZGluZyB0aGUgTWVzc2FnZS5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJlcGFyZVBhcnRzRm9yU2VuZGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0cnVjdHVyZSB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICovXG4gIF9wcmVwYXJlUGFydHNGb3JTZW5kaW5nKGRhdGEpIHtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmdldENsaWVudCgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgdGhpcy5wYXJ0cy5mb3JFYWNoKChwYXJ0LCBpbmRleCkgPT4ge1xuICAgICAgcGFydC5vbmNlKCdwYXJ0czpzZW5kJywgZXZ0ID0+IHtcbiAgICAgICAgZGF0YS5wYXJ0c1tpbmRleF0gPSB7XG4gICAgICAgICAgbWltZV90eXBlOiBldnQubWltZV90eXBlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoZXZ0LmNvbnRlbnQpIGRhdGEucGFydHNbaW5kZXhdLmNvbnRlbnQgPSBldnQuY29udGVudDtcbiAgICAgICAgaWYgKGV2dC5ib2R5KSBkYXRhLnBhcnRzW2luZGV4XS5ib2R5ID0gZXZ0LmJvZHk7XG4gICAgICAgIGlmIChldnQuZW5jb2RpbmcpIGRhdGEucGFydHNbaW5kZXhdLmVuY29kaW5nID0gZXZ0LmVuY29kaW5nO1xuXG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIGlmIChjb3VudCA9PT0gdGhpcy5wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9zZW5kKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHBhcnQuX3NlbmQoY2xpZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdGhlIGFjdHVhbCBzZW5kaW5nLlxuICAgKlxuICAgKiBsYXllci5NZXNzYWdlLnNlbmQgaGFzIHNvbWUgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzXG4gICAqIHByZXByb2Nlc3NpbmcgdG8gZG8gYmVmb3JlIHNlbmRpbmcgKFJpY2ggQ29udGVudCk7IGFjdHVhbCBzZW5kaW5nXG4gICAqIGlzIGRvbmUgaGVyZS5cbiAgICpcbiAgICogQG1ldGhvZCBfc2VuZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NlbmQoZGF0YSkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5nZXRDb252ZXJzYXRpb24oZmFsc2UpO1xuXG4gICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZSgpO1xuICAgIGNsaWVudC5zZW5kU29ja2V0UmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgbWV0aG9kOiAnTWVzc2FnZS5jcmVhdGUnLFxuICAgICAgICBvYmplY3RfaWQ6IGNvbnZlcnNhdGlvbi5pZCxcbiAgICAgICAgZGF0YSxcbiAgICAgIH0sXG4gICAgICBzeW5jOiB7XG4gICAgICAgIGRlcGVuZHM6IFt0aGlzLmNvbnZlcnNhdGlvbklkLCB0aGlzLmlkXSxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmlkLFxuICAgICAgfSxcbiAgICB9LCAoc3VjY2Vzcywgc29ja2V0RGF0YSkgPT4gdGhpcy5fc2VuZFJlc3VsdChzdWNjZXNzLCBzb2NrZXREYXRhKSk7XG4gIH1cblxuICBfZ2V0U2VuZERhdGEoZGF0YSkge1xuICAgIGRhdGEub2JqZWN0X2lkID0gdGhpcy5jb252ZXJzYXRpb25JZDtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgICogbGF5ZXIuTWVzc2FnZS5zZW5kKCkgU3VjY2VzcyBDYWxsYmFjay5cbiAgICAqXG4gICAgKiBJZiBzdWNjZXNzZnVsbHkgc2VuZGluZyB0aGUgbWVzc2FnZTsgdHJpZ2dlcnMgYSAnc2VudCcgZXZlbnQsXG4gICAgKiBhbmQgdXBkYXRlcyB0aGUgbWVzc2FnZS5pZC91cmxcbiAgICAqXG4gICAgKiBAbWV0aG9kIF9zZW5kUmVzdWx0XG4gICAgKiBAcHJpdmF0ZVxuICAgICogQHBhcmFtIHtPYmplY3R9IG1lc3NhZ2VEYXRhIC0gU2VydmVyIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXNzYWdlXG4gICAgKi9cbiAgX3NlbmRSZXN1bHQoeyBzdWNjZXNzLCBkYXRhIH0pIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihkYXRhKTtcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6c2VudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ21lc3NhZ2VzOnNlbnQtZXJyb3InLCB7IGVycm9yOiBkYXRhIH0pO1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuX3NldFN5bmNlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAgICogU3RhbmRhcmQgYG9uKClgIHByb3ZpZGVkIGJ5IGxheWVyLlJvb3QuXG4gICAgICpcbiAgICAgKiBBZGRzIHNvbWUgc3BlY2lhbCBoYW5kbGluZyBvZiAnbWVzc2FnZXM6bG9hZGVkJyBzbyB0aGF0IGNhbGxzIHN1Y2ggYXNcbiAgICAgKlxuICAgICAqICAgICAgdmFyIG0gPSBjbGllbnQuZ2V0TWVzc2FnZSgnbGF5ZXI6Ly8vbWVzc2FnZXMvMTIzJywgdHJ1ZSlcbiAgICAgKiAgICAgIC5vbignbWVzc2FnZXM6bG9hZGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgbXlyZXJlbmRlcihtKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqICAgICAgbXlyZW5kZXIobSk7IC8vIHJlbmRlciBhIHBsYWNlaG9sZGVyIGZvciBtIHVudGlsIHRoZSBkZXRhaWxzIG9mIG0gaGF2ZSBsb2FkZWRcbiAgICAgKlxuICAgICAqIGNhbiBmaXJlIHRoZWlyIGNhbGxiYWNrIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgY2xpZW50IGxvYWRzIG9yIGhhc1xuICAgICAqIGFscmVhZHkgbG9hZGVkIHRoZSBNZXNzYWdlLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBvblxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGV2ZW50SGFuZGxlclxuICAgICAqIEBwYXJhbSAge09iamVjdH0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge2xheWVyLk1lc3NhZ2V9IHRoaXNcbiAgICAgKi9cbiAgb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBoYXNMb2FkZWRFdnQgPSBuYW1lID09PSAnbWVzc2FnZXM6bG9hZGVkJyB8fFxuICAgICAgbmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcgJiYgbmFtZVsnbWVzc2FnZXM6bG9hZGVkJ107XG5cbiAgICBpZiAoaGFzTG9hZGVkRXZ0ICYmICF0aGlzLmlzTG9hZGluZykge1xuICAgICAgY29uc3QgY2FsbE5vdyA9IG5hbWUgPT09ICdtZXNzYWdlczpsb2FkZWQnID8gY2FsbGJhY2sgOiBuYW1lWydtZXNzYWdlczpsb2FkZWQnXTtcbiAgICAgIFV0aWwuZGVmZXIoKCkgPT4gY2FsbE5vdy5hcHBseShjb250ZXh0KSk7XG4gICAgfVxuICAgIHN1cGVyLm9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGUgdGhlIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBUaGlzIGNhbGwgd2lsbCBzdXBwb3J0IHZhcmlvdXMgZGVsZXRpb24gbW9kZXMuICBDYWxsaW5nIHdpdGhvdXQgYSBkZWxldGlvbiBtb2RlIGlzIGRlcHJlY2F0ZWQuXG4gICAqXG4gICAqIERlbGV0aW9uIE1vZGVzOlxuICAgKlxuICAgKiAqIGxheWVyLkNvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTDogVGhpcyBkZWxldGVzIHRoZSBsb2NhbCBjb3B5IGltbWVkaWF0ZWx5LCBhbmQgYXR0ZW1wdHMgdG8gYWxzb1xuICAgKiAgIGRlbGV0ZSB0aGUgc2VydmVyJ3MgY29weS5cbiAgICpcbiAgICogQG1ldGhvZCBkZWxldGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0aW9uTW9kZSAtIGxheWVyLkNvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTCBpcyBvbmx5IHN1cHBvcnRlZCBtb2RlIGF0IHRoaXMgdGltZVxuICAgKi9cbiAgZGVsZXRlKG1vZGUpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5pc0Rlc3Ryb3llZCk7XG5cbiAgICBsZXQgcXVlcnlTdHI7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLkFMTDpcbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgcXVlcnlTdHIgPSAnbW9kZT1hbGxfcGFydGljaXBhbnRzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENvbnN0YW50cy5ERUxFVElPTl9NT0RFLk1ZX0RFVklDRVM6XG4gICAgICAgIHF1ZXJ5U3RyID0gJ21vZGU9bXlfZGV2aWNlcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5kZWxldGlvbk1vZGVVbnN1cHBvcnRlZCk7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSB0aGlzLmlkO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgdGhpcy5feGhyKHtcbiAgICAgIHVybDogJz8nICsgcXVlcnlTdHIsXG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0sIHJlc3VsdCA9PiB7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzICYmICghcmVzdWx0LmRhdGEgfHwgcmVzdWx0LmRhdGEuaWQgIT09ICdub3RfZm91bmQnKSkgTWVzc2FnZS5sb2FkKGlkLCBjbGllbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fZGVsZXRlZCgpO1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBNZXNzYWdlIGhhcyBiZWVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIENhbGxlZCBmcm9tIGxheWVyLldlYnNvY2tldHMuQ2hhbmdlTWFuYWdlciBhbmQgZnJvbSBsYXllci5NZXNzYWdlLmRlbGV0ZSgpO1xuICAgKlxuICAgKiBEZXN0cm95IG11c3QgYmUgY2FsbGVkIHNlcGFyYXRlbHksIGFuZCBoYW5kbGVzIG1vc3QgY2xlYW51cC5cbiAgICpcbiAgICogQG1ldGhvZCBfZGVsZXRlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZGVsZXRlZCgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ21lc3NhZ2VzOmRlbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGlzIE1lc3NhZ2UgZnJvbSB0aGUgc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgZGVyZWdpc3RlciB0aGUgTWVzc2FnZSwgcmVtb3ZlIGFsbCBldmVudHNcbiAgICogYW5kIGFsbG93IGdhcmJhZ2UgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuZ2V0Q2xpZW50KCk7XG4gICAgaWYgKGNsaWVudCkgY2xpZW50Ll9yZW1vdmVNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMucGFydHMuZm9yRWFjaChwYXJ0ID0+IHBhcnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLl9fcGFydHMgPSBudWxsO1xuXG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvcHVsYXRlcyB0aGlzIGluc3RhbmNlIHdpdGggdGhlIGRlc2NyaXB0aW9uIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2FuIGJlIHVzZWQgZm9yIGNyZWF0aW5nIG9yIGZvciB1cGRhdGluZyB0aGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBtZXRob2QgX3BvcHVsYXRlRnJvbVNlcnZlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gbSAtIFNlcnZlciBkZXNjcmlwdGlvbiBvZiB0aGUgbWVzc2FnZVxuICAgKi9cbiAgX3BvcHVsYXRlRnJvbVNlcnZlcihtZXNzYWdlKSB7XG4gICAgdGhpcy5pZCA9IG1lc3NhZ2UuaWQ7XG4gICAgdGhpcy51cmwgPSBtZXNzYWdlLnVybDtcbiAgICBjb25zdCBvbGRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgdGhpcy5wb3NpdGlvbiA9IG1lc3NhZ2UucG9zaXRpb247XG5cblxuICAgIC8vIEFzc2lnbiBJRHMgdG8gcHJlZXhpc3RpbmcgUGFydHMgc28gdGhhdCB3ZSBjYW4gY2FsbCBnZXRQYXJ0QnlJZCgpXG4gICAgaWYgKHRoaXMucGFydHMpIHtcbiAgICAgIHRoaXMucGFydHMuZm9yRWFjaCgocGFydCwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKCFwYXJ0LmlkKSBwYXJ0LmlkID0gYCR7dGhpcy5pZH0vcGFydHMvJHtpbmRleH1gO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5wYXJ0cyA9IG1lc3NhZ2UucGFydHMubWFwKHBhcnQgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdQYXJ0ID0gdGhpcy5nZXRQYXJ0QnlJZChwYXJ0LmlkKTtcbiAgICAgIGlmIChleGlzdGluZ1BhcnQpIHtcbiAgICAgICAgZXhpc3RpbmdQYXJ0Ll9wb3B1bGF0ZUZyb21TZXJ2ZXIocGFydCk7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1BhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWVzc2FnZVBhcnQuX2NyZWF0ZUZyb21TZXJ2ZXIocGFydCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnJlY2lwaWVudFN0YXR1cyA9IG1lc3NhZ2UucmVjaXBpZW50X3N0YXR1cyB8fCB7fTtcblxuICAgIHRoaXMuaXNSZWFkID0gIW1lc3NhZ2UuaXNfdW5yZWFkO1xuXG4gICAgdGhpcy5zZW50QXQgPSBuZXcgRGF0ZShtZXNzYWdlLnNlbnRfYXQpO1xuICAgIHRoaXMucmVjZWl2ZWRBdCA9IG1lc3NhZ2UucmVjZWl2ZWRfYXQgPyBuZXcgRGF0ZShtZXNzYWdlLnJlY2VpdmVkX2F0KSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuc2VuZGVyID0ge1xuICAgICAgdXNlcklkOiBtZXNzYWdlLnNlbmRlci51c2VyX2lkIHx8ICcnLFxuICAgICAgbmFtZTogbWVzc2FnZS5zZW5kZXIubmFtZSB8fCAnJyxcbiAgICB9O1xuXG4gICAgdGhpcy5fc2V0U3luY2VkKCk7XG5cbiAgICBpZiAob2xkUG9zaXRpb24gJiYgb2xkUG9zaXRpb24gIT09IHRoaXMucG9zaXRpb24pIHtcbiAgICAgIHRoaXMuX3RyaWdnZXJBc3luYygnbWVzc2FnZXM6Y2hhbmdlJywge1xuICAgICAgICBvbGRWYWx1ZTogb2xkUG9zaXRpb24sXG4gICAgICAgIG5ld1ZhbHVlOiB0aGlzLnBvc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0eTogJ3Bvc2l0aW9uJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBNZXNzYWdlJ3MgbGF5ZXIuTWVzc2FnZVBhcnQgd2l0aCB0aGUgc3BlY2lmaWVkIHRoZSBwYXJ0IElELlxuICAgKlxuICAgKiBAbWV0aG9kIGdldFBhcnRCeUlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJ0SWRcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZVBhcnR9XG4gICAqL1xuICBnZXRQYXJ0QnlJZChwYXJ0SWQpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0cyA/IHRoaXMucGFydHMuZmlsdGVyKHBhcnQgPT4gcGFydC5pZCA9PT0gcGFydElkKVswXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0cyBqc29uLXBhdGNoIG9wZXJhdGlvbnMgZm9yIG1vZGlmeWluZyByZWNpcGllbnRTdGF0dXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZVBhdGNoRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0W119IGRhdGEgLSBBcnJheSBvZiBvcGVyYXRpb25zXG4gICAqL1xuICBfaGFuZGxlUGF0Y2hFdmVudChuZXdWYWx1ZSwgb2xkVmFsdWUsIHBhdGhzKSB7XG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IGZhbHNlO1xuICAgIGlmIChwYXRoc1swXS5pbmRleE9mKCdyZWNpcGllbnRfc3RhdHVzJykgPT09IDApIHtcbiAgICAgIHRoaXMuX191cGRhdGVSZWNpcGllbnRTdGF0dXModGhpcy5yZWNpcGllbnRTdGF0dXMsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5faW5MYXllclBhcnNlciA9IHRydWU7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBbnkgeGhyIG1ldGhvZCBjYWxsZWQgb24gdGhpcyBtZXNzYWdlIHVzZXMgdGhlIG1lc3NhZ2UncyB1cmwuXG4gICAqXG4gICAqIEZvciBtb3JlIGluZm8gb24geGhyIG1ldGhvZCBwYXJhbWV0ZXJzIHNlZSB7QGxpbmsgbGF5ZXIuQ2xpZW50QXV0aGVudGljYXRvciN4aHJ9XG4gICAqXG4gICAqIEBtZXRob2QgX3hoclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge2xheWVyLk1lc3NhZ2V9IHRoaXNcbiAgICovXG4gIF94aHIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAvLyBpbml0aWFsaXplXG4gICAgbGV0IGluVXJsID0gb3B0aW9ucy51cmw7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5nZXRDbGllbnQoKTtcblxuICAgIC8vIFZhbGlkYXRhdGlvblxuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmlzRGVzdHJveWVkKTtcbiAgICBpZiAoISgndXJsJyBpbiBvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS51cmxSZXF1aXJlZCk7XG5cbiAgICBpZiAoaW5VcmwgJiYgIWluVXJsLm1hdGNoKC9eKFxcL3xcXD8pLykpIG9wdGlvbnMudXJsID0gaW5VcmwgPSAnLycgKyBvcHRpb25zLnVybDtcbiAgICBpZiAoIW9wdGlvbnMuc3luYykgb3B0aW9ucy51cmwgPSB0aGlzLnVybCArIG9wdGlvbnMudXJsO1xuXG4gICAgLy8gU2V0dXAgc3luYyBzdHJ1Y3R1cmVcbiAgICBvcHRpb25zLnN5bmMgPSB0aGlzLl9zZXR1cFN5bmNPYmplY3Qob3B0aW9ucy5zeW5jKTtcblxuICAgIGNsaWVudC54aHIob3B0aW9ucywgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2dldFVybCh1cmwpIHtcbiAgICByZXR1cm4gdGhpcy51cmwgKyAodXJsIHx8ICcnKTtcbiAgfVxuXG4gIF9zZXR1cFN5bmNPYmplY3Qoc3luYykge1xuICAgIGlmIChzeW5jICE9PSBmYWxzZSkge1xuICAgICAgaWYgKCFzeW5jKSBzeW5jID0ge307XG4gICAgICBpZiAoIXN5bmMudGFyZ2V0KSBzeW5jLnRhcmdldCA9IHRoaXMuaWQ7XG4gICAgICBpZiAoIXN5bmMuZGVwZW5kcykge1xuICAgICAgICBzeW5jLmRlcGVuZHMgPSBbdGhpcy5jb252ZXJzYXRpb25JZF07XG4gICAgICB9IGVsc2UgaWYgKHN5bmMuZGVwZW5kcy5pbmRleE9mKHRoaXMuaWQpID09PSAtMSkge1xuICAgICAgICBzeW5jLmRlcGVuZHMucHVzaCh0aGlzLmNvbnZlcnNhdGlvbklkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN5bmM7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBHZXQgYWxsIHRleHQgcGFydHMgb2YgdGhlIE1lc3NhZ2UuXG4gICAqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBleHRyYWN0aW5nIGFsbCBvZiB0aGUgdGV4dC9wbGFpbiBwYXJ0c1xuICAgKiBhbmQgY29uY2F0ZW5hdGluZyBhbGwgb2YgdGhlaXIgYm9keXMgdG9nZXRoZXIgaW50byBhIHNpbmdsZSBzdHJpbmcuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0VGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2pvaW5TdHI9Jy4gICddIElmIG11bHRpcGxlIG1lc3NhZ2UgcGFydHMgb2YgdHlwZSB0ZXh0L3BsYWluLCBob3cgZG8geW91IHdhbnQgdGhlbSBqb2luZWQgdG9nZXRoZXI/XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRleHQoam9pblN0ciA9ICcuICcpIHtcbiAgICBsZXQgdGV4dEFycmF5ID0gdGhpcy5wYXJ0c1xuICAgICAgLmZpbHRlcihwYXJ0ID0+IHBhcnQubWltZVR5cGUgPT09ICd0ZXh0L3BsYWluJylcbiAgICAgIC5tYXAocGFydCA9PiBwYXJ0LmJvZHkpO1xuICAgIHRleHRBcnJheSA9IHRleHRBcnJheS5maWx0ZXIoZGF0YSA9PiBkYXRhKTtcbiAgICByZXR1cm4gdGV4dEFycmF5LmpvaW4oam9pblN0cik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdC5cbiAgICpcbiAgICogT2JqZWN0IHdpbGwgaGF2ZSBhbGwgdGhlIHNhbWUgcHVibGljIHByb3BlcnRpZXMgYXMgdGhpc1xuICAgKiBNZXNzYWdlIGluc3RhbmNlLiAgTmV3IG9iamVjdCBpcyByZXR1cm5lZCBhbnkgdGltZVxuICAgKiBhbnkgb2YgdGhpcyBvYmplY3QncyBwcm9wZXJ0aWVzIGNoYW5nZS5cbiAgICpcbiAgICogQG1ldGhvZCB0b09iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFBPSk8gdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIGlmICghdGhpcy5fdG9PYmplY3QpIHtcbiAgICAgIHRoaXMuX3RvT2JqZWN0ID0gc3VwZXIudG9PYmplY3QoKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0LnJlY2lwaWVudFN0YXR1cyA9IFV0aWwuY2xvbmUodGhpcy5yZWNpcGllbnRTdGF0dXMpO1xuICAgICAgdGhpcy5fdG9PYmplY3QuaXNOZXcgPSB0aGlzLmlzTmV3KCk7XG4gICAgICB0aGlzLl90b09iamVjdC5pc1NhdmluZyA9IHRoaXMuaXNTYXZpbmcoKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0LmlzU2F2ZWQgPSB0aGlzLmlzU2F2ZWQoKTtcbiAgICAgIHRoaXMuX3RvT2JqZWN0LmlzU3luY2VkID0gdGhpcy5pc1N5bmNlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdG9PYmplY3Q7XG4gIH1cblxuICBfdHJpZ2dlckFzeW5jKGV2dE5hbWUsIGFyZ3MpIHtcbiAgICB0aGlzLl9jbGVhck9iamVjdCgpO1xuICAgIHN1cGVyLl90cmlnZ2VyQXN5bmMoZXZ0TmFtZSwgYXJncyk7XG4gIH1cblxuICB0cmlnZ2VyKGV2dE5hbWUsIGFyZ3MpIHtcbiAgICB0aGlzLl9jbGVhck9iamVjdCgpO1xuICAgIHN1cGVyLnRyaWdnZXIoZXZ0TmFtZSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBTaW1pbGFyIHRvIF9wb3B1bGF0ZUZyb21TZXJ2ZXIsIGhvd2V2ZXIsIHRoaXMgbWV0aG9kIHRha2VzIGFcbiAgICogbWVzc2FnZSBkZXNjcmlwdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBtZXNzYWdlIGluc3RhbmNlIHVzaW5nIF9wb3B1bGF0ZUZyb21TZXJ2ZXJcbiAgICogdG8gc2V0dXAgdGhlIHZhbHVlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfY3JlYXRlRnJvbVNlcnZlclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtZXNzYWdlIC0gU2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjb252ZXJzYXRpb25JZCAtIENvbnZlcnNhdGlvbiBmb3IgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtICB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHJldHVybiB7bGF5ZXIuTWVzc2FnZX1cbiAgICovXG4gIHN0YXRpYyBfY3JlYXRlRnJvbVNlcnZlcihtZXNzYWdlLCBjbGllbnQpIHtcbiAgICBjb25zdCBmcm9tV2Vic29ja2V0ID0gbWVzc2FnZS5mcm9tV2Vic29ja2V0O1xuICAgIHJldHVybiBuZXcgTWVzc2FnZSh7XG4gICAgICBjb252ZXJzYXRpb25JZDogbWVzc2FnZS5jb252ZXJzYXRpb24uaWQsXG4gICAgICBmcm9tU2VydmVyOiBtZXNzYWdlLFxuICAgICAgY2xpZW50SWQ6IGNsaWVudC5hcHBJZCxcbiAgICAgIF9mcm9tREI6IG1lc3NhZ2UuX2Zyb21EQixcbiAgICAgIF9ub3RpZnk6IGZyb21XZWJzb2NrZXQgJiYgbWVzc2FnZS5pc191bnJlYWQgJiYgbWVzc2FnZS5zZW5kZXIudXNlcl9pZCAhPT0gY2xpZW50LnVzZXJJZCxcbiAgICB9KTtcbiAgfVxuXG4gIF9sb2FkZWQoZGF0YSkge1xuICAgIHRoaXMuY29udmVyc2F0aW9uSWQgPSBkYXRhLmNvbnZlcnNhdGlvbi5pZDtcbiAgICB0aGlzLmdldENsaWVudCgpLl9hZGRNZXNzYWdlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIElkZW50aWZpZXMgd2hldGhlciBhIE1lc3NhZ2UgcmVjZWl2aW5nIHRoZSBzcGVjaWZpZWQgcGF0Y2ggZGF0YSBzaG91bGQgYmUgbG9hZGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQXBwbGllcyBvbmx5IHRvIE1lc3NhZ2VzIHRoYXQgYXJlbid0IGFscmVhZHkgbG9hZGVkOyB1c2VkIHRvIGluZGljYXRlIGlmIGEgY2hhbmdlIGV2ZW50IGlzXG4gICAqIHNpZ25pZmljYW50IGVub3VnaCB0byBsb2FkIHRoZSBNZXNzYWdlIGFuZCB0cmlnZ2VyIGNoYW5nZSBldmVudHMgb24gdGhhdCBNZXNzYWdlLlxuICAgKlxuICAgKiBBdCB0aGlzIHRpbWUgdGhlcmUgYXJlIG5vIHByb3BlcnRpZXMgdGhhdCBhcmUgcGF0Y2hlZCBvbiBNZXNzYWdlcyB2aWEgd2Vic29ja2V0c1xuICAgKiB0aGF0IHdvdWxkIGp1c3RpZnkgbG9hZGluZyB0aGUgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXIgc28gYXMgdG8gbm90aWZ5IHRoZSBhcHAuXG4gICAqXG4gICAqIE9ubHkgcmVjaXBpZW50IHN0YXR1cyBjaGFuZ2VzIGFuZCBtYXliZSBpc191bnJlYWQgY2hhbmdlcyBhcmUgc2VudDtcbiAgICogbmVpdGhlciBvZiB3aGljaCBhcmUgcmVsZXZhbnQgdG8gYW4gYXBwIHRoYXQgaXNuJ3QgcmVuZGVyaW5nIHRoYXQgbWVzc2FnZS5cbiAgICpcbiAgICogQG1ldGhvZCBfbG9hZFJlc291cmNlRm9yUGF0Y2hcbiAgICogQHN0YXRpY1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIF9sb2FkUmVzb3VyY2VGb3JQYXRjaChwYXRjaERhdGEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGllbnQgdGhhdCB0aGUgTWVzc2FnZSBiZWxvbmdzIHRvLlxuICpcbiAqIEFjdHVhbCB2YWx1ZSBvZiB0aGlzIHN0cmluZyBtYXRjaGVzIHRoZSBhcHBJZC5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLmNsaWVudElkID0gJyc7XG5cbi8qKlxuICogQ29udmVyc2F0aW9uIHRoYXQgdGhpcyBNZXNzYWdlIGJlbG9uZ3MgdG8uXG4gKlxuICogQWN0dWFsIHZhbHVlIGlzIHRoZSBJRCBvZiB0aGUgQ29udmVyc2F0aW9uJ3MgSUQuXG4gKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUuY29udmVyc2F0aW9uSWQgPSAnJztcblxuLyoqXG4gKiBBcnJheSBvZiBsYXllci5NZXNzYWdlUGFydCBvYmplY3RzXG4gKlxuICogQHR5cGUge2xheWVyLk1lc3NhZ2VQYXJ0W119XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnBhcnRzID0gbnVsbDtcblxuLyoqXG4gKiBNZXNzYWdlIElkZW50aWZpZXIuXG4gKlxuICogVGhpcyB2YWx1ZSBpcyBzaGFyZWQgYnkgYWxsIHBhcnRpY2lwYW50cyBhbmQgZGV2aWNlcy5cbiAqXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5pZCA9ICcnO1xuXG4vKipcbiAqIFVSTCB0byB0aGUgc2VydmVyIGVuZHBvaW50IGZvciBvcGVyYXRpbmcgb24gdGhlIG1lc3NhZ2UuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS51cmwgPSAnJztcblxuLyoqXG4gKiBUaW1lIHRoYXQgdGhlIG1lc3NhZ2Ugd2FzIHNlbnQuXG4gKiBAdHlwZSB7RGF0ZX1cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUuc2VudEF0ID0gbnVsbDtcblxuLyoqXG4gKiBUaW1lIHRoYXQgdGhlIGZpcnN0IGRlbGl2ZXJ5IHJlY2VpcHQgd2FzIHNlbnQgYnkgeW91clxuICogdXNlciBhY2tub3dsZWRnaW5nIHJlY2VpcHQgb2YgdGhlIG1lc3NhZ2UuXG4gKiBAdHlwZSB7RGF0ZX1cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUucmVjZWl2ZWRBdCA9IG51bGw7XG5cbi8qKlxuICogT2JqZWN0IHJlcHJlc2VudGluZyB0aGUgc2VuZGVyIG9mIHRoZSBNZXNzYWdlLlxuICpcbiAqIENvbnRhaW5zIGB1c2VySWRgIHByb3BlcnR5IHdoaWNoIGlzXG4gKiBwb3B1bGF0ZWQgd2hlbiB0aGUgbWVzc2FnZSB3YXMgc2VudCBieSBhIHBhcnRpY2lwYW50IChvciBmb3JtZXIgcGFydGljaXBhbnQpXG4gKiBpbiB0aGUgQ29udmVyc2F0aW9uLiAgQ29udGFpbnMgYSBgbmFtZWAgcHJvcGVydHkgd2hpY2ggaXNcbiAqIHVzZWQgd2hlbiB0aGUgTWVzc2FnZSBpcyBzZW50IHZpYSBhIE5hbWVkIFBsYXRmb3JtIEFQSSBzZW5kZXJcbiAqIHN1Y2ggYXMgXCJBZG1pblwiLCBcIk1vZGVyYXRvclwiLCBcIlJvYm90IEplcmtpbmcgeW91IEFyb3VuZFwiLlxuICpcbiAqICAgICAgPHNwYW4gY2xhc3M9J3NlbnQtYnknPlxuICogICAgICAgIHttZXNzYWdlLnNlbmRlci5uYW1lIHx8IGdldERpc3BsYXlOYW1lRm9ySWQobWVzc2FnZS5zZW5kZXIudXNlcklkKX1cbiAqICAgICAgPC9zcGFuPlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnNlbmRlciA9IG51bGw7XG5cbi8qKlxuICogUG9zaXRpb24gb2YgdGhpcyBtZXNzYWdlIHdpdGhpbiB0aGUgY29udmVyc2F0aW9uLlxuICpcbiAqIE5PVEVTOlxuICpcbiAqIDEuIERlbGV0aW5nIGEgbWVzc2FnZSBkb2VzIG5vdCBhZmZlY3QgcG9zaXRpb24gb2Ygb3RoZXIgTWVzc2FnZXMuXG4gKiAyLiBBIHBvc2l0aW9uIGlzIG5vdCBnYXVyZW50ZWVkIHRvIGJlIHVuaXF1ZSAobXVsdGlwbGUgbWVzc2FnZXMgc2VudCBhdCB0aGUgc2FtZSB0aW1lIGNvdWxkXG4gKiBhbGwgY2xhaW0gdGhlIHNhbWUgcG9zaXRpb24pXG4gKiAzLiBFYWNoIHN1Y2Nlc3NpdmUgbWVzc2FnZSB3aXRoaW4gYSBjb252ZXJzYXRpb24gc2hvdWxkIGV4cGVjdCBhIGhpZ2hlciBwb3NpdGlvbi5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5wb3NpdGlvbiA9IDA7XG5cbi8qKlxuICogSGludCB1c2VkIGJ5IGxheWVyLkNsaWVudCBvbiB3aGV0aGVyIHRvIHRyaWdnZXIgYSBtZXNzYWdlczpub3RpZnkgZXZlbnQuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcHJpdmF0ZVxuICovXG5NZXNzYWdlLnByb3RvdHlwZS5fbm90aWZ5ID0gZmFsc2U7XG5cbi8qIFJlY2lwaWVudCBTdGF0dXMgKi9cblxuLyoqXG4gKiBSZWFkL2RlbGl2ZXJ5IFN0YXRlIG9mIGFsbCBwYXJ0aWNpcGFudHMuXG4gKlxuICogVGhpcyBpcyBhbiBvYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBlYWNoIHBhcnRpY2lwYW50LFxuICogYW5kIGEgdmFsdWUgb2Y6XG4gKiAqIGxheWVyLlJFQ0VJUFRfU1RBVEUuU0VOVFxuICogKiBsYXllci5SRUNFSVBUX1NUQVRFLkRFTElWRVJFRFxuICogKiBsYXllci5SRUNFSVBUX1NUQVRFLlJFQURcbiAqICogbGF5ZXIuUkVDRUlQVF9TVEFURS5QRU5ESU5HXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUucmVjaXBpZW50U3RhdHVzID0gbnVsbDtcblxuLyoqXG4gKiBUcnVlIGlmIHRoaXMgTWVzc2FnZSBoYXMgYmVlbiByZWFkIGJ5IHRoaXMgdXNlci5cbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSBpc1JlYWQgcHJvZ3JhbWF0aWNhbGx5XG4gKlxuICogICAgICBtLmlzUmVhZCA9IHRydWU7XG4gKlxuICogVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgbm90aWZ5IHRoZSBzZXJ2ZXIgdGhhdCB0aGUgbWVzc2FnZSB3YXMgcmVhZCBieSB5b3VyIHVzZXIuXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUuaXNSZWFkID0gZmFsc2U7XG5cbi8qKlxuICogVGhpcyBwcm9wZXJ0eSBpcyBoZXJlIGZvciBjb252ZW5pZW5jZSBvbmx5OyBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgb3Bwb3NpdGUgb2YgaXNSZWFkLlxuICogQHR5cGUge0Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2UucHJvdG90eXBlLCAnaXNVbnJlYWQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiAhdGhpcy5pc1JlYWQ7XG4gIH0sXG59KTtcblxuLyoqXG4gKiBIYXZlIHRoZSBvdGhlciBwYXJ0aWNpcGFudHMgcmVhZCB0aGlzIE1lc3NhZ2UgeWV0LlxuICpcbiAqIFRoaXMgdmFsdWUgaXMgb25lIG9mOlxuICpcbiAqICAqIGxheWVyLkNvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuQUxMXG4gKiAgKiBsYXllci5Db25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLlNPTUVcbiAqICAqIGxheWVyLkNvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuTk9ORVxuICpcbiAqICBUaGlzIHZhbHVlIGlzIHVwZGF0ZWQgYW55IHRpbWUgcmVjaXBpZW50U3RhdHVzIGNoYW5nZXMuXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUucmVhZFN0YXR1cyA9IENvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuTk9ORTtcblxuLyoqXG4gKiBIYXZlIHRoZSBvdGhlciBwYXJ0aWNpcGFudHMgcmVjZWl2ZWQgdGhpcyBNZXNzYWdlIHlldC5cbiAqXG4gICogVGhpcyB2YWx1ZSBpcyBvbmUgb2Y6XG4gKlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5BTExcbiAqICAqIGxheWVyLkNvbnN0YW50cy5SRUNJUElFTlRfU1RBVEUuU09NRVxuICogICogbGF5ZXIuQ29uc3RhbnRzLlJFQ0lQSUVOVF9TVEFURS5OT05FXG4gKlxuICogIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCBhbnkgdGltZSByZWNpcGllbnRTdGF0dXMgY2hhbmdlcy5cbiAqXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUuZGVsaXZlcnlTdGF0dXMgPSBDb25zdGFudHMuUkVDSVBJRU5UX1NUQVRFLk5PTkU7XG5cbi8qKlxuICogVGhlIHRpbWUgdGhhdCB0aGlzIGNsaWVudCBjcmVhdGVkIHRoaXMgaW5zdGFuY2UuXG4gKiBAdHlwZSB7RGF0ZX1cbiAqL1xuTWVzc2FnZS5wcm90b3R5cGUubG9jYWxDcmVhdGVkQXQgPSBudWxsO1xuXG5NZXNzYWdlLnByb3RvdHlwZS5fdG9PYmplY3QgPSBudWxsO1xuXG5NZXNzYWdlLnByb3RvdHlwZS5fZnJvbURCID0gZmFsc2U7XG5cbk1lc3NhZ2UuZXZlbnRQcmVmaXggPSAnbWVzc2FnZXMnO1xuXG5NZXNzYWdlLnByZWZpeFVVSUQgPSAnbGF5ZXI6Ly8vbWVzc2FnZXMvJztcblxuTWVzc2FnZS5pbk9iamVjdElnbm9yZSA9IFN5bmNhYmxlLmluT2JqZWN0SWdub3JlO1xuXG5NZXNzYWdlLmJ1YmJsZUV2ZW50UGFyZW50ID0gJ2dldENsaWVudCc7XG5cbk1lc3NhZ2UuaW1hZ2VUeXBlcyA9IFtcbiAgJ2ltYWdlL2dpZicsXG4gICdpbWFnZS9wbmcnLFxuICAnaW1hZ2UvanBlZycsXG4gICdpbWFnZS9qcGcnLFxuXTtcblxuTWVzc2FnZS5fc3VwcG9ydGVkRXZlbnRzID0gW1xuXG4gIC8qKlxuICAgKiBNZXNzYWdlIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgdXNlZCBpbiByZXNwb25zZSB0byB0aGUgbGF5ZXIuTWVzc2FnZS5sb2FkKCkgbWV0aG9kLlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICovXG4gICdtZXNzYWdlczpsb2FkZWQnLFxuXG4gIC8qKlxuICAgKiBUaGUgbG9hZCBtZXRob2QgZmFpbGVkIHRvIGxvYWQgdGhlIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHVzZWQgaW4gcmVzcG9uc2UgdG8gdGhlIGxheWVyLk1lc3NhZ2UubG9hZCgpIG1ldGhvZC5cbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICAnbWVzc2FnZXM6bG9hZGVkLWVycm9yJyxcblxuICAvKipcbiAgICogTWVzc2FnZSBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2F1c2VkIGJ5IGEgY2FsbCB0byBsYXllci5NZXNzYWdlLmRlbGV0ZSgpIG9yIGEgd2Vic29ja2V0IGV2ZW50LlxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKiBAZXZlbnRcbiAgICovXG4gICdtZXNzYWdlczpkZWxldGUnLFxuXG4gIC8qKlxuICAgKiBNZXNzYWdlIGlzIGFib3V0IHRvIGJlIHNlbnQuXG4gICAqXG4gICAqIExhc3QgY2hhbmNlIHRvIG1vZGlmeSBvciB2YWxpZGF0ZSB0aGUgbWVzc2FnZSBwcmlvciB0byBzZW5kaW5nLlxuICAgKlxuICAgKiAgICAgbWVzc2FnZS5vbignbWVzc2FnZXM6c2VuZGluZycsIGZ1bmN0aW9uKGV2dCkge1xuICAgKiAgICAgICAgbWVzc2FnZS5hZGRQYXJ0KHttaW1lVHlwZTogJ2FwcGxpY2F0aW9uL2xvY2F0aW9uJywgYm9keTogSlNPTi5zdHJpbmdpZnkoZ2V0R1BTTG9jYXRpb24oKSl9KTtcbiAgICogICAgIH0pO1xuICAgKlxuICAgKiBUeXBpY2FsbHksIHlvdSB3b3VsZCBsaXN0ZW4gdG8gdGhpcyBldmVudCBtb3JlIGJyb2FkbHkgdXNpbmcgYGNsaWVudC5vbignbWVzc2FnZXM6c2VuZGluZycpYFxuICAgKiB3aGljaCB3b3VsZCB0cmlnZ2VyIGJlZm9yZSBzZW5kaW5nIEFOWSBNZXNzYWdlcy5cbiAgICpcbiAgICogQGV2ZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqL1xuICAnbWVzc2FnZXM6c2VuZGluZycsXG5cbiAgLyoqXG4gICAqIE1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQgYnkgdGhlIHNlcnZlci5cbiAgICpcbiAgICogSXQgZG9lcyBOT1QgaW5kaWNhdGUgZGVsaXZlcnkgdG8gb3RoZXIgdXNlcnMuXG4gICAqXG4gICAqIEl0IGRvZXMgTk9UIGluZGljYXRlIG1lc3NhZ2VzIHNlbnQgYnkgb3RoZXIgdXNlcnMuXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgJ21lc3NhZ2VzOnNlbnQnLFxuXG4gIC8qKlxuICAgKiBTZXJ2ZXIgZmFpbGVkIHRvIHJlY2VpdmUgdGhlIE1lc3NhZ2UuXG4gICAqXG4gICAqIE1lc3NhZ2Ugd2lsbCBiZSBkZWxldGVkIGltbWVkaWF0ZWx5IGFmdGVyIGZpcmluZyB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckVycm9yfSBldnQuZXJyb3JcbiAgICovXG4gICdtZXNzYWdlczpzZW50LWVycm9yJyxcblxuICAvKipcbiAgICogRmlyZWQgd2hlbiBtZXNzYWdlLmlzUmVhZCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogU29tZXRpbWVzIHRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IG1hcmtpbmcgdGhlIE1lc3NhZ2UgYXMgcmVhZCBsb2NhbGx5OyBzb21ldGltZXMgaXRzIHRyaWdnZXJlZFxuICAgKiBieSB5b3VyIHVzZXIgb24gYSBzZXBhcmF0ZSBkZXZpY2UvYnJvd3NlciBtYXJraW5nIHRoZSBNZXNzYWdlIGFzIHJlYWQgcmVtb3RlbHkuXG4gICAqXG4gICAqIFVzZWZ1bCBpZiB5b3Ugc3R5bGUgdW5yZWFkIG1lc3NhZ2VzIGluIGJvbGQsIGFuZCBuZWVkIGFuIGV2ZW50IHRvIHRlbGwgeW91IHdoZW5cbiAgICogdG8gdW5ib2xkIHRoZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICogQHBhcmFtIHtsYXllci5NZXNzYWdlW119IGV2dC5tZXNzYWdlcyAtIEFycmF5IG9mIG1lc3NhZ2VzIHRoYXQgaGF2ZSBqdXN0IGJlZW4gbWFya2VkIGFzIHJlYWRcbiAgICovXG4gICdtZXNzYWdlczpyZWFkJyxcblxuICAvKipcbiAgICogVGhlIHJlY2lwaWVudFN0YXR1cyBwcm9wZXJ0eSBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogVGhpcyBoYXBwZW5zIGluIHJlc3BvbnNlIHRvIGFuIHVwZGF0ZVxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIuLi4gYnV0IGlzIGFsc28gY2F1c2VkIGJ5IG1hcmtpbmcgdGhlIGN1cnJlbnQgdXNlciBoYXMgaGF2aW5nIHJlYWRcbiAgICogb3IgcmVjZWl2ZWQgdGhlIG1lc3NhZ2UuXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgJ21lc3NhZ2VzOmNoYW5nZScsXG5cblxuXS5jb25jYXQoU3luY2FibGUuX3N1cHBvcnRlZEV2ZW50cyk7XG5cblJvb3QuaW5pdENsYXNzLmFwcGx5KE1lc3NhZ2UsIFtNZXNzYWdlLCAnTWVzc2FnZSddKTtcblN5bmNhYmxlLnN1YmNsYXNzZXMucHVzaChNZXNzYWdlKTtcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcbiIsIi8qKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIGEgc3RhdGUgdmFyaWFibGUgZm9yIHdoZXRoZXIgd2UgYXJlIG9ubGluZS9vZmZsaW5lLCB0cmlnZ2VycyBldmVudHNcbiAqIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMsIGFuZCBkZXRlcm1pbmVzIHdoZW4gdG8gcGVyZm9ybSB0ZXN0cyB0byB2YWxpZGF0ZSBvdXIgb25saW5lIHN0YXR1cy5cbiAqXG4gKiBJdCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHRhc2tzOlxuICpcbiAqIDEuIEFueSB0aW1lIHdlIGdvIG1vcmUgdGhhbiB0aGlzLnBpbmdGcmVxdWVuY3kgKDEwMCBzZWNvbmRzKSB3aXRob3V0IGFueSBkYXRhIGZyb20gdGhlIHNlcnZlciwgZmxhZyB1cyBhcyBiZWluZyBvZmZsaW5lLlxuICogICAgUmF0aW9uYWxlOiBUaGUgd2Vic29ja2V0IG1hbmFnZXIgaXMgY2FsbGluZyBgZ2V0Q291bnRlcmAgZXZlcnkgMzAgc2Vjb25kczsgc28gaXQgd291bGQgaGF2ZSBoYWQgdG8gZmFpbCB0byBnZXQgYW55IHJlc3BvbnNlXG4gKiAgICAzIHRpbWVzIGJlZm9yZSB3ZSBnaXZlIHVwLlxuICogMi4gV2hpbGUgd2UgYXJlIG9mZmxpbmUsIHBpbmcgdGhlIHNlcnZlciB1bnRpbCB3ZSBkZXRlcm1pbmUgd2UgYXJlIGluIGZhY3QgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXJcbiAqIDMuIFRyaWdnZXIgZXZlbnRzIGBjb25uZWN0ZWRgIGFuZCBgZGlzY29ubmVjdGVkYCB0byBsZXQgdGhlIHJlc3Qgb2YgdGhlIHN5c3RlbSBrbm93IHdoZW4gd2UgYXJlL2FyZSBub3QgY29ubmVjdGVkLlxuICogICAgTk9URTogVGhlIFdlYnNvY2tldCBtYW5hZ2VyIHdpbGwgdXNlIHRoYXQgdG8gcmVjb25uZWN0IGl0cyB3ZWJzb2NrZXQsIGFuZCByZXN1bWUgaXRzIGBnZXRDb3VudGVyYCBjYWxsIGV2ZXJ5IDMwIHNlY29uZHMuXG4gKlxuICogTk9URTogQXBwcyB0aGF0IHdhbnQgdG8gYmUgbm90aWZpZWQgb2YgY2hhbmdlcyB0byBvbmxpbmUvb2ZmbGluZSBzdGF0ZSBzaG91bGQgc2VlIGxheWVyLkNsaWVudCdzIGBvbmxpbmVgIGV2ZW50LlxuICpcbiAqIE5PVEU6IE9uZSBpdGVyYXRpb24gb2YgdGhpcyBjbGFzcyB0cmVhdGVkIG5hdmlnYXRvci5vbkxpbmUgPSBmYWxzZSBhcyBmYWN0LiAgSWYgb25MaW5lIGlzIGZhbHNlLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gdGVzdFxuICogYW55dGhpbmcuICBJZiBpdHMgdHJ1ZSwgdGhlbiB0aGlzIGNsYXNzIHZlcmlmaWVzIGl0IGNhbiByZWFjaCBsYXllcidzIHNlcnZlcnMuICBIb3dldmVyLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mjc3MzcyIGhhcyByZXBsaWNhdGVkIG11bHRpcGxlIHRpbWVzIGluIGNocm9tZTsgdGhpcyBidWcgY2F1c2VzIG9uZSB0YWIgb2YgY2hyb21lIHRvIGhhdmUgbmF2aWdhdG9yLm9uTGluZT1mYWxzZSB3aGlsZSBhbGwgb3RoZXIgdGFic1xuICogY29ycmVjdGx5IHJlcG9ydCBuYXZpZ2F0b3Iub25MaW5lPXRydWUuICBBcyBhIHJlc3VsdCwgd2UgY2FuJ3QgcmVseSBvbiB0aGlzIHZhbHVlIGFuZCB0aGlzIGNsYXNzIG11c3QgY29udGludWUgdG8gcG9sbCB0aGUgc2VydmVyIHdoaWxlXG4gKiBvZmZsaW5lIGFuZCB0byBpZ25vcmUgdmFsdWVzIGZyb20gbmF2aWdhdG9yLm9uTGluZS4gIEZ1dHVyZSBXb3JrOiBBbGxvdyBub24tY2hyb21lIGJyb3dzZXJzIHRvIHVzZSBuYXZpZ2F0b3Iub25MaW5lLlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuT25saW5lU3RhdGVNYW5hZ2VyXG4gKiBAcHJpdmF0ZVxuICogQGV4dGVuZHMgbGF5ZXIuUm9vdFxuICpcbiAqL1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuY29uc3QgeGhyID0gcmVxdWlyZSgnLi94aHInKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4vY2xpZW50LXV0aWxzJyk7XG5cbmNsYXNzIE9ubGluZVN0YXRlTWFuYWdlciBleHRlbmRzIFJvb3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPbmxpbmVTdGF0ZU1hbmFnZXIuXG4gICAqXG4gICAqIEFuIEFwcGxpY2F0aW9uIGlzIGV4cGVjdGVkIHRvIG9ubHkgaGF2ZSBvbmUgb2YgdGhlc2UuXG4gICAqXG4gICAqICAgICAgdmFyIG9ubGluZVN0YXRlTWFuYWdlciA9IG5ldyBsYXllci5PbmxpbmVTdGF0ZU1hbmFnZXIoe1xuICAgKiAgICAgICAgICBzb2NrZXRNYW5hZ2VyOiBzb2NrZXRNYW5hZ2VyLFxuICAgKiAgICAgICAgICB0ZXN0VXJsOiAnaHR0cHM6Ly9hcGkubGF5ZXIuY29tL25vbmNlcydcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtICB7bGF5ZXIuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyfSBvcHRpb25zLnNvY2tldE1hbmFnZXIgLSBBIHdlYnNvY2tldCBtYW5hZ2VyIHRvIG1vbml0b3IgZm9yIG1lc3NhZ2VzXG4gICAqIEBwYXJhbSAge3N0cmluZ30gb3B0aW9ucy50ZXN0VXJsIC0gQSB1cmwgdG8gc2VuZCByZXF1ZXN0cyB0byB3aGVuIHRlc3RpbmcgaWYgd2UgYXJlIG9ubGluZVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgLy8gTGlzdGVuIHRvIGFsbCB4aHIgZXZlbnRzIGFuZCB3ZWJzb2NrZXQgbWVzc2FnZXMgZm9yIG9ubGluZS1zdGF0dXMgaW5mb1xuICAgIHhoci5hZGRDb25uZWN0aW9uTGlzdGVuZXIoZXZ0ID0+IHRoaXMuX2Nvbm5lY3Rpb25MaXN0ZW5lcihldnQpKTtcbiAgICB0aGlzLnNvY2tldE1hbmFnZXIub24oJ21lc3NhZ2UnLCAoKSA9PiB0aGlzLl9jb25uZWN0aW9uTGlzdGVuZXIoeyBzdGF0dXM6ICdjb25uZWN0aW9uOnN1Y2Nlc3MnIH0pLCB0aGlzKTtcblxuICAgIC8vIEFueSBjaGFuZ2UgaW4gb25saW5lIHN0YXR1cyByZXBvcnRlZCBieSB0aGUgYnJvd3NlciBzaG91bGQgcmVzdWx0IGluXG4gICAgLy8gYW4gaW1tZWRpYXRlIHVwZGF0ZSB0byBvdXIgb25saW5lL29mZmxpbmUgc3RhdGVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29ubGluZScsIHRoaXMuX2hhbmRsZU9ubGluZUV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCB0aGlzLl9oYW5kbGVPbmxpbmVFdmVudC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2UgZG9uJ3QgYWN0dWFsbHkgc3RhcnQgbWFuYWdpbmcgb3VyIG9ubGluZSBzdGF0ZSB1bnRpbCBhZnRlciB0aGUgY2xpZW50IGhhcyBhdXRoZW50aWNhdGVkLlxuICAgKiBDYWxsIHN0YXJ0KCkgd2hlbiB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBjbGllbnQgdG8gc3RhcnQgbWFuYWdpbmcgb3VyIHN0YXRlLlxuICAgKlxuICAgKiBUaGUgY2xpZW50IHdvbid0IGNhbGwgc3RhcnQoKSB3aXRob3V0IGZpcnN0IHZhbGlkYXRpbmcgdGhhdCB3ZSBoYXZlIGEgdmFsaWQgc2Vzc2lvbiwgc28gYnkgZGVmaW5pdGlvbixcbiAgICogY2FsbGluZyBzdGFydCBtZWFucyB3ZSBhcmUgb25saW5lLlxuICAgKlxuICAgKiBAbWV0aG9kIHN0YXJ0XG4gICAqL1xuICBzdGFydCgpIHtcbiAgICBsb2dnZXIuaW5mbygnT25saW5lU3RhdGVNYW5hZ2VyOiBzdGFydCcpO1xuICAgIHRoaXMuaXNDbGllbnRSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5pc09ubGluZSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLl9maXJzdFN0YXJ0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Nvbm5lY3RlZCcsIHsgb2ZmbGluZUR1cmF0aW9uOiAwIH0pO1xuICAgIH1cbiAgICB0aGlzLl9maXJzdFN0YXJ0ID0gZmFsc2U7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0T25saW5lQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgY2xpZW50IGJlY29tZXMgdW5hdXRoZW50aWNhdGVkLCBzdG9wIGNoZWNraW5nIGlmIHdlIGFyZSBvbmxpbmUsIGFuZCBhbm5vdW5jZSB0aGF0IHdlIGFyZSBvZmZsaW5lLlxuICAgKlxuICAgKiBAbWV0aG9kIHN0b3BcbiAgICovXG4gIHN0b3AoKSB7XG4gICAgbG9nZ2VyLmluZm8oJ09ubGluZVN0YXRlTWFuYWdlcjogc3RvcCcpO1xuICAgIHRoaXMuaXNDbGllbnRSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMuX2NsZWFyQ2hlY2soKTtcbiAgICB0aGlzLl9jaGFuZ2VUb09mZmxpbmUoKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBvdXIgbmV4dCBjYWxsIHRvIF9vbmxpbmVFeHBpcmVkIGlmIG9ubGluZSBvciBjaGVja09ubGluZVN0YXR1cyBpZiBvZmZsaW5lLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zY2hlZHVsZU5leHRPbmxpbmVDaGVja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NjaGVkdWxlTmV4dE9ubGluZUNoZWNrKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnT25saW5lU3RhdGVNYW5hZ2VyOiBza2lwIHNjaGVkdWxlJyk7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQgfHwgIXRoaXMuaXNDbGllbnRSZWFkeSkgcmV0dXJuO1xuXG4gICAgLy8gUmVwbGFjZSBhbnkgc2NoZWR1bGVkIGNhbGxzIHdpdGggdGhlIG5ld2x5IHNjaGVkdWxlZCBjYWxsOlxuICAgIHRoaXMuX2NsZWFyQ2hlY2soKTtcblxuICAgIC8vIElmIHRoaXMgaXMgY2FsbGVkIHdoaWxlIHdlIGFyZSBvbmxpbmUsIHRoZW4gd2UgYXJlIHVzaW5nIHRoaXMgdG8gZGV0ZWN0IHdoZW4gd2UndmUgZ29uZSB3aXRob3V0IGRhdGEgZm9yIG1vcmUgdGhhbiBwaW5nRnJlcXVlbmN5LlxuICAgIC8vIENhbGwgdGhpcy5fb25saW5lRXhwaXJlZCBhZnRlciBwaW5nRnJlcXVlbmN5IG9mIG5vIHNlcnZlciByZXNwb25zZXMuXG4gICAgaWYgKHRoaXMuaXNPbmxpbmUpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnT25saW5lU3RhdGVNYW5hZ2VyOiBTY2hlZHVsZWQgb25saW5lRXhwaXJlZCcpO1xuICAgICAgdGhpcy5vbmxpbmVDaGVja0lkID0gc2V0VGltZW91dCh0aGlzLl9vbmxpbmVFeHBpcmVkLmJpbmQodGhpcyksIHRoaXMucGluZ0ZyZXF1ZW5jeSk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhpcyBpcyBjYWxsZWQgd2hpbGUgd2UgYXJlIG9mZmxpbmUsIHdlJ3JlIGRvaW5nIGV4cG9uZW50aWFsIGJhY2tvZmYgcGluZ2luZyB0aGUgc2VydmVyIHRvIHNlZSBpZiB3ZSd2ZSBjb21lIGJhY2sgb25saW5lLlxuICAgIGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oJ09ubGluZVN0YXRlTWFuYWdlcjogU2NoZWR1bGVkIGNoZWNrT25saW5lU3RhdHVzJyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IFV0aWxzLmdldEV4cG9uZW50aWFsQmFja29mZlNlY29uZHModGhpcy5tYXhPZmZsaW5lV2FpdCwgTWF0aC5taW4oMTAsIHRoaXMub2ZmbGluZUNvdW50ZXIrKykpO1xuICAgICAgdGhpcy5vbmxpbmVDaGVja0lkID0gc2V0VGltZW91dCh0aGlzLmNoZWNrT25saW5lU3RhdHVzLmJpbmQodGhpcyksIE1hdGguZmxvb3IoZHVyYXRpb24gKiAxMDAwKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYW55IHVwY29taW5nIGNhbGxzIHRvIGNoZWNrT25saW5lU3RhdHVzXG4gICAqXG4gICAqIEBtZXRob2QgX2NsZWFyQ2hlY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhckNoZWNrKCkge1xuICAgIGlmICh0aGlzLm9ubGluZUNoZWNrSWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLm9ubGluZUNoZWNrSWQpO1xuICAgICAgdGhpcy5vbmxpbmVDaGVja0lkID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzcG9uZCB0byB0aGUgYnJvd3NlcidzIG9ubGluZS9vZmZsaW5lIGV2ZW50cy5cbiAgICpcbiAgICogT3VyIHJlc3BvbnNlIGlzIG5vdCB0byB0cnVzdCB0aGVtLCBidXQgdG8gdXNlIHRoZW0gYXNcbiAgICogYSB0cmlnZ2VyIHRvIGluZGljYXRlIHdlIHNob3VsZCBpbW1lZGlhdGVseSBkbyBvdXIgb3duXG4gICAqIHZhbGlkYXRpb24uXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZU9ubGluZUV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnQgLSBCcm93c2VyIG9ubGluZS9vZmZsaW5lIGV2ZW50IG9iamVjdFxuICAgKi9cbiAgX2hhbmRsZU9ubGluZUV2ZW50KGV2dCkge1xuICAgIC8vIFJlc2V0IHRoZSBjb3VudGVyIGJlY2F1c2Ugb3VyIGZpcnN0IHJlcXVlc3QgbWF5IGZhaWwgYXMgdGhleSBtYXkgbm90IGJlXG4gICAgLy8gZnVsbHkgY29ubmVjdGVkIHlldFxuICAgIHRoaXMub2ZmbGluZUNvdW50ZXIgPSAwO1xuICAgIHRoaXMuY2hlY2tPbmxpbmVTdGF0dXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdXIgb25saW5lIHN0YXRlIGhhcyBleHBpcmVkOyB3ZSBhcmUgbm93IG9mZmxpbmUuXG4gICAqXG4gICAqIElmIHRoaXMgbWV0aG9kIGdldHMgY2FsbGVkLCBpdCBtZWFucyB0aGF0IG91ciBjb25uZWN0aW9uIGhhcyBnb25lIHRvbyBsb25nIHdpdGhvdXQgYW55IGRhdGFcbiAgICogYW5kIGlzIG5vdyBjb25zaWRlcmVkIHRvIGJlIGRpc2Nvbm5lY3RlZC4gIFN0YXJ0IHNjaGVkdWxpbmcgdGVzdHMgdG8gc2VlIHdoZW4gd2UgYXJlIGJhY2sgb25saW5lLlxuICAgKlxuICAgKiBAbWV0aG9kIF9vbmxpbmVFeHBpcmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25saW5lRXhwaXJlZCgpIHtcbiAgICB0aGlzLl9jbGVhckNoZWNrKCk7XG4gICAgdGhpcy5fY2hhbmdlVG9PZmZsaW5lKCk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0T25saW5lQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBub25jZSB0byBzZWUgaWYgd2UgY2FuIHJlYWNoIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIFdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIHJlc3VsdCxcbiAgICogd2UganVzdCBjYXJlIGFib3V0IHRyaWdnZXJpbmcgYSAnY29ubmVjdGlvbjpzdWNjZXNzJyBvciAnY29ubmVjdGlvbjplcnJvcicgZXZlbnRcbiAgICogd2hpY2ggY29ubmVjdGlvbkxpc3RlbmVyIHdpbGwgcmVzcG9uZCB0by5cbiAgICpcbiAgICogICAgICBjbGllbnQub25saW5lTWFuYWdlci5jaGVja09ubGluZVN0YXR1cyhmdW5jdGlvbihyZXN1bHQpIHtcbiAgICogICAgICAgICAgYWxlcnQocmVzdWx0ID8gJ1dlJ3JlIG9ubGluZSEnIDogJ0RvaCEnKTtcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZCBjaGVja09ubGluZVN0YXR1c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbGxiYWNrLmlzT25saW5lIC0gQ2FsbGJhY2sgaXMgY2FsbGVkIHdpdGggdHJ1ZSBpZiBvbmxpbmUsIGZhbHNlIGlmIG5vdFxuICAgKi9cbiAgY2hlY2tPbmxpbmVTdGF0dXMoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9jbGVhckNoZWNrKCk7XG5cbiAgICBsb2dnZXIuaW5mbygnT25saW5lU3RhdGVNYW5hZ2VyOiBGaXJpbmcgWEhSIGZvciBvbmxpbmUgY2hlY2snKTtcbiAgICB0aGlzLl9sYXN0Q2hlY2tPbmxpbmVTdGF0dXMgPSBuZXcgRGF0ZSgpO1xuICAgIC8vIFBpbmcgdGhlIHNlcnZlciBhbmQgc2VlIGlmIHdlJ3JlIGNvbm5lY3RlZC5cbiAgICB4aHIoe1xuICAgICAgdXJsOiB0aGlzLnRlc3RVcmwsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgYWNjZXB0OiAnYXBwbGljYXRpb24vdm5kLmxheWVyK2pzb247IHZlcnNpb249MS4wJyxcbiAgICAgIH0sXG4gICAgfSwgKCkgPT4ge1xuICAgICAgLy8gdGhpcy5pc09ubGluZSB3aWxsIGJlIHVwZGF0ZWQgdmlhIF9jb25uZWN0aW9uTGlzdGVuZXIgcHJpb3IgdG8gdGhpcyBsaW5lIGV4ZWN1dGluZ1xuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayh0aGlzLmlzT25saW5lKTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIE9uIGRldGVybWluaW5nIHRoYXQgd2UgYXJlIG9mZmxpbmUsIGhhbmRsZXMgdGhlIHN0YXRlIHRyYW5zaXRpb24gYW5kIGxvZ2dpbmcuXG4gICAqXG4gICAqIEBtZXRob2QgX2NoYW5nZVRvT2ZmbGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoYW5nZVRvT2ZmbGluZSgpIHtcbiAgICBpZiAodGhpcy5pc09ubGluZSkge1xuICAgICAgdGhpcy5pc09ubGluZSA9IGZhbHNlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgIGxvZ2dlci5pbmZvKCdPbmxpbmVTdGF0ZU1hbmFnZXI6IENvbm5lY3Rpb24gbG9zdCcpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSB3ZWJzb2NrZXQgZXZlbnQgYXJyaXZlcywgb3IgYW4geGhyIGNhbGwgY29tcGxldGVzOyB1cGRhdGVzIG91ciBpc09ubGluZSBzdGF0ZS5cbiAgICpcbiAgICogQW55IGNhbGwgdG8gdGhpcyBtZXRob2Qgd2lsbCByZXNjaGVkdWxlIG91ciBuZXh0IGlzLW9ubGluZSB0ZXN0XG4gICAqXG4gICAqIEBtZXRob2QgX2Nvbm5lY3Rpb25MaXN0ZW5lclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGV2dCAtIE5hbWUgb2YgdGhlIGV2ZW50OyBlaXRoZXIgJ2Nvbm5lY3Rpb246c3VjY2Vzcycgb3IgJ2Nvbm5lY3Rpb246ZXJyb3InXG4gICAqL1xuICBfY29ubmVjdGlvbkxpc3RlbmVyKGV2dCkge1xuICAgIC8vIElmIGV2ZW50IGlzIGEgc3VjY2VzcywgY2hhbmdlIHVzIHRvIG9ubGluZVxuICAgIGlmIChldnQuc3RhdHVzID09PSAnY29ubmVjdGlvbjpzdWNjZXNzJykge1xuICAgICAgY29uc3QgbGFzdFRpbWUgPSB0aGlzLmxhc3RNZXNzYWdlVGltZTtcbiAgICAgIHRoaXMubGFzdE1lc3NhZ2VUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgIGlmICghdGhpcy5pc09ubGluZSkge1xuICAgICAgICB0aGlzLmlzT25saW5lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vZmZsaW5lQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY29ubmVjdGVkJywgeyBvZmZsaW5lRHVyYXRpb246IGxhc3RUaW1lID8gRGF0ZS5ub3coKSAtIGxhc3RUaW1lIDogMCB9KTtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkQ291bnRlciA9PT0gdW5kZWZpbmVkKSB0aGlzLmNvbm5lY3RlZENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENvdW50ZXIrKztcbiAgICAgICAgbG9nZ2VyLmluZm8oJ09ubGluZVN0YXRlTWFuYWdlcjogQ29ubmVjdGVkIHJlc3RvcmVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZXZlbnQgaXMgTk9UIHN1Y2Nlc3MsIGNoYW5nZSB1cyB0byBvZmZsaW5lLlxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fY2hhbmdlVG9PZmZsaW5lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0T25saW5lQ2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnVwL3NodXRkb3duXG4gICAqXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9jbGVhckNoZWNrKCk7XG4gICAgdGhpcy5zb2NrZXRNYW5hZ2VyID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5pc0NsaWVudFJlYWR5ID0gZmFsc2U7XG5cbi8qKlxuICogVVJMIFRvIGZpcmUgd2hlbiB0ZXN0aW5nIHRvIHNlZSBpZiB3ZSBhcmUgb25saW5lLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS50ZXN0VXJsID0gJyc7XG5cbi8qKlxuICogQSBXZWJzb2NrZXQgbWFuYWdlciB3aG9zZSAnbWVzc2FnZScgZXZlbnQgd2Ugd2lsbCBsaXN0ZW4gdG9cbiAqIGluIG9yZGVyIHRvIGtub3cgdGhhdCB3ZSBhcmUgc3RpbGwgb25saW5lLlxuICogQHR5cGUge2xheWVyLldlYnNvY2tldHMuU29ja2V0TWFuYWdlcn1cbiAqL1xuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXRNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBOdW1iZXIgb2YgdGVzdFVybCByZXF1ZXN0cyB3ZSd2ZSBiZWVuIG9mZmxpbmUgZm9yLlxuICpcbiAqIFdpbGwgc3RvcCBncm93aW5nIG9uY2UgdGhlIG51bWJlciBpcyBzdWl0YWJseSBsYXJnZSAoMTAtMjApLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5vZmZsaW5lQ291bnRlciA9IDA7XG5cbi8qKlxuICogTWF4aW11bSB3YWl0IGR1cmluZyBleHBvbmVudGlhbCBiYWNrb2ZmIHdoaWxlIG9mZmxpbmUuXG4gKlxuICogV2hpbGUgb2ZmbGluZSwgZXhwb25lbnRpYWwgYmFja29mZiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBob3cgbG9uZyB0byB3YWl0IGJldHdlZW4gY2hlY2tpbmcgd2l0aCB0aGUgc2VydmVyXG4gKiB0byBzZWUgaWYgd2UgYXJlIG9ubGluZSBhZ2Fpbi4gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIHRoZSBtYXhpbXVtIHdhaXQ7IGFueSBoaWdoZXIgdmFsdWUgcmV0dXJuZWQgYnkgZXhwb25lbnRpYWwgYmFja29mZlxuICogYXJlIGlnbm9yZWQgYW5kIHRoaXMgdmFsdWUgdXNlZCBpbnN0ZWFkLlxuICogVmFsdWUgaXMgbWVhc3VyZWQgaW4gc2Vjb25kcy5cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk9ubGluZVN0YXRlTWFuYWdlci5wcm90b3R5cGUubWF4T2ZmbGluZVdhaXQgPSA1ICogNjA7XG5cbi8qKlxuICogTWluaW11bSB3YWl0IGJldHdlZW4gdHJpZXMgaW4gbXMuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5PbmxpbmVTdGF0ZU1hbmFnZXIucHJvdG90eXBlLm1pbkJhY2tvZmZXYWl0ID0gMTAwO1xuXG4vKipcbiAqIFRpbWUgdGhhdCB0aGUgbGFzdCBzdWNjZXNzZnVsIG1lc3NhZ2Ugd2FzIG9ic2VydmVkLlxuICogQHR5cGUge0RhdGV9XG4gKi9cbk9ubGluZVN0YXRlTWFuYWdlci5wcm90b3R5cGUubGFzdE1lc3NhZ2VUaW1lID0gbnVsbDtcblxuLyoqXG4gKiBGb3IgZGVidWdnaW5nLCB0cmFja3MgdGhlIGxhc3QgdGltZSB3ZSBjaGVja2VkIGlmIHdlIGFyZSBvbmxpbmUuXG4gKiBAdHlwZSB7RGF0ZX1cbiAqL1xuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5fbGFzdENoZWNrT25saW5lU3RhdHVzID0gbnVsbDtcblxuLyoqXG4gKiBBcmUgd2UgY3VycmVudGx5IG9ubGluZT9cbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG5PbmxpbmVTdGF0ZU1hbmFnZXIucHJvdG90eXBlLmlzT25saW5lID0gZmFsc2U7XG5cbi8qKlxuICogc2V0VGltZW91dElkIGZvciB0aGUgbmV4dCBjaGVja09ubGluZVN0YXR1cygpIGNhbGwuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5PbmxpbmVTdGF0ZU1hbmFnZXIucHJvdG90eXBlLm9ubGluZUNoZWNrSWQgPSAwO1xuXG4vKipcbiAqIFRydWUgdW50aWwgdGhlIGZpcnN0IHRpbWUgc3RhcnQoKSBpcyBjYWxsZWQuXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuT25saW5lU3RhdGVNYW5hZ2VyLnByb3RvdHlwZS5fZmlyc3RTdGFydCA9IHRydWU7XG5cbi8qKlxuICogSWYgd2UgYXJlIG9ubGluZSwgaG93IG9mdGVuIGRvIHdlIG5lZWQgdG8gcGluZyB0byB2ZXJpZnkgd2UgYXJlIHN0aWxsIG9ubGluZS5cbiAqXG4gKiBWYWx1ZSBpcyByZXNldCBhbnkgdGltZSB3ZSBvYnNlcnZlIGFueSBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gKiBNZWFzdXJlZCBpbiBtaWxpc2Vjb25kcy4gTk9URTogV2Vic29ja2V0IGhhcyBhIHNlcGFyYXRlIHBpbmcgd2hpY2ggbW9zdGx5IG1ha2VzXG4gKiB0aGlzIG9uZSB1bm5lY2Vzc2FyeS4gIE1heSBlbmQgdXAgcmVtb3ZpbmcgdGhpcyBvbmUuLi4gdGhvdWdoIHdlJ2Qga2VlcCB0aGVcbiAqIHBpbmcgZm9yIHdoZW4gb3VyIHN0YXRlIGlzIG9mZmxpbmUuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5PbmxpbmVTdGF0ZU1hbmFnZXIucHJvdG90eXBlLnBpbmdGcmVxdWVuY3kgPSAxMDAgKiAxMDAwO1xuXG5PbmxpbmVTdGF0ZU1hbmFnZXIuX3N1cHBvcnRlZEV2ZW50cyA9IFtcbiAgLyoqXG4gICAqIFdlIGFwcGVhciB0byBiZSBvbmxpbmUgYW5kIGFibGUgdG8gc2VuZCBhbmQgcmVjZWl2ZVxuICAgKiBAZXZlbnQgY29ubmVjdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvbmxpbmVEdXJhdGlvbiAtIE51bWJlciBvZiBtaWxpc2Vjb25kcyBzaW5jZSB3ZSB3ZXJlIGxhc3Qga25vd24gdG8gYmUgb25saW5lXG4gICAqL1xuICAnY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogV2UgYXBwZWFyIHRvIGJlIG9mZmxpbmUgYW5kIHVuYWJsZSB0byBzZW5kIG9yIHJlY2VpdmVcbiAgICogQGV2ZW50IGRpc2Nvbm5lY3RlZFxuICAgKi9cbiAgJ2Rpc2Nvbm5lY3RlZCcsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuUm9vdC5pbml0Q2xhc3MuYXBwbHkoT25saW5lU3RhdGVNYW5hZ2VyLCBbT25saW5lU3RhdGVNYW5hZ2VyLCAnT25saW5lU3RhdGVNYW5hZ2VyJ10pO1xubW9kdWxlLmV4cG9ydHMgPSBPbmxpbmVTdGF0ZU1hbmFnZXI7XG4iLCJjb25zdCBRdWVyeSA9IHJlcXVpcmUoJy4vcXVlcnknKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuL2xheWVyLWVycm9yJyk7XG5cbi8qKlxuICogUXVlcnkgYnVpbGRlciBjbGFzcyBnZW5lcmF0aW5nIHF1ZXJpZXMgZm9yIGEgc2V0IG9mIG1lc3NhZ2VzLlxuICogVXNlZCBpbiBDcmVhdGluZyBhbmQgVXBkYXRpbmcgbGF5ZXIuUXVlcnkgaW5zdGFuY2VzLlxuICpcbiAqIFVzaW5nIHRoZSBRdWVyeSBCdWlsZGVyLCB3ZSBzaG91bGQgYmUgYWJsZSB0byBpbnN0YW50aWF0ZSBhIFF1ZXJ5XG4gKlxuICogICAgICB2YXIgcUJ1aWxkZXIgPSBRdWVyeUJ1aWxkZXJcbiAqICAgICAgIC5tZXNzYWdlcygpXG4gKiAgICAgICAuZm9yQ29udmVyc2F0aW9uKCdsYXllcjovLy9jb252ZXJzYXRpb25zL2ZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZicpXG4gKiAgICAgICAucGFnaW5hdGlvbldpbmRvdygxMDApO1xuICogICAgICB2YXIgcXVlcnkgPSBjbGllbnQuY3JlYXRlUXVlcnkocUJ1aWxkZXIpO1xuICpcbiAqXG4gKiBZb3UgY2FuIHRoZW4gY3JlYXRlIGFkZGl0aW9uYWwgYnVpbGRlcnMgYW5kIHVwZGF0ZSB0aGUgcXVlcnk6XG4gKlxuICogICAgICB2YXIgcUJ1aWxkZXIyID0gUXVlcnlCdWlsZGVyXG4gKiAgICAgICAubWVzc2FnZXMoKVxuICogICAgICAgLmZvckNvbnZlcnNhdGlvbignbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy9iYmJiYmJiYi1iYmJiLWJiYmItYmJiYi1iYmJiYmJiYmJiYmInKVxuICogICAgICAgLnBhZ2luYXRpb25XaW5kb3coMjAwKTtcbiAqICAgICAgcXVlcnkudXBkYXRlKHFCdWlsZGVyKTtcbiAqXG4gKiBAY2xhc3MgbGF5ZXIuUXVlcnlCdWlsZGVyLk1lc3NhZ2VzUXVlcnlcbiAqL1xuY2xhc3MgTWVzc2FnZXNRdWVyeSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcXVlcnkgYnVpbGRlciBmb3IgYSBzZXQgb2YgbWVzc2FnZXMuXG4gICAqXG4gICAqIFN0YW5kYXJkIHVzZSBpcyB3aXRob3V0IGFueSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbcXVlcnk9bnVsbF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICB0aGlzLl9xdWVyeSA9IHtcbiAgICAgICAgbW9kZWw6IHF1ZXJ5Lm1vZGVsLFxuICAgICAgICByZXR1cm5UeXBlOiBxdWVyeS5yZXR1cm5UeXBlLFxuICAgICAgICBkYXRhVHlwZTogcXVlcnkuZGF0YVR5cGUsXG4gICAgICAgIHBhZ2luYXRpb25XaW5kb3c6IHF1ZXJ5LnBhZ2luYXRpb25XaW5kb3csXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWVyeSA9IHtcbiAgICAgICAgbW9kZWw6IFF1ZXJ5Lk1lc3NhZ2UsXG4gICAgICAgIHJldHVyblR5cGU6ICdvYmplY3QnLFxuICAgICAgICBkYXRhVHlwZTogJ29iamVjdCcsXG4gICAgICAgIHBhZ2luYXRpb25XaW5kb3c6IFF1ZXJ5LnByb3RvdHlwZS5wYWdpbmF0aW9uV2luZG93LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIHJlbW92ZSB3aGVuIG1lc3NhZ2VzIGNhbiBiZSBmZXRjaGVkIHZpYSBxdWVyeSBBUEkgcmF0aGVyIHRoYW4gYEdFVCAvbWVzc2FnZXNgXG4gICAgdGhpcy5fY29udmVyc2F0aW9uSWRTZXQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSBmb3IgbWVzc2FnZXMgaW4gdGhpcyBDb252ZXJzYXRpb24uXG4gICAqXG4gICAqIEBtZXRob2QgZm9yQ29udmVyc2F0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gY29udmVyc2F0aW9uSWRcbiAgICovXG4gIGZvckNvbnZlcnNhdGlvbihjb252ZXJzYXRpb25JZCkge1xuICAgIGlmIChjb252ZXJzYXRpb25JZCkge1xuICAgICAgdGhpcy5fcXVlcnkucHJlZGljYXRlID0gYGNvbnZlcnNhdGlvbi5pZCA9ICcke2NvbnZlcnNhdGlvbklkfSdgO1xuICAgICAgdGhpcy5fY29udmVyc2F0aW9uSWRTZXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fcXVlcnkucHJlZGljYXRlO1xuICAgICAgdGhpcy5fY29udmVyc2F0aW9uSWRTZXQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGFnaW5hdGlvbiB3aW5kb3cvbnVtYmVyIG9mIG1lc3NhZ2VzIHRvIGZldGNoIGZyb20gdGhlIGxvY2FsIGNhY2hlIG9yIHNlcnZlci5cbiAgICpcbiAgICogQ3VycmVudGx5IG9ubHkgcG9zaXRpdmUgaW50ZWdlcnMgYXJlIHN1cHBvcnRlZC5cbiAgICpcbiAgICogQG1ldGhvZCBwYWdpbmF0aW9uV2luZG93XG4gICAqIEBwYXJhbSAge251bWJlcn0gd2luXG4gICAqL1xuICBwYWdpbmF0aW9uV2luZG93KHdpbikge1xuICAgIHRoaXMuX3F1ZXJ5LnBhZ2luYXRpb25XaW5kb3cgPSB3aW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYnVpbHQgcXVlcnkgb2JqZWN0IHRvIHNlbmQgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2FsbGVkIGJ5IGxheWVyLlF1ZXJ5QnVpbGRlci4gWW91IHNob3VsZCBub3QgbmVlZCB0byBjYWxsIHRoaXMuXG4gICAqXG4gICAqIEBtZXRob2QgYnVpbGRcbiAgICovXG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5fY29udmVyc2F0aW9uSWRTZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY29udmVyc2F0aW9uTWlzc2luZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3F1ZXJ5O1xuICB9XG59XG5cbmNsYXNzIEFubm91bmNlbWVudFF1ZXJ5IGV4dGVuZHMgTWVzc2FnZXNRdWVyeSB7XG4gIGJ1aWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9xdWVyeTtcbiAgfVxufVxuXG4vKipcbiAqIFF1ZXJ5IGJ1aWxkZXIgY2xhc3MgZ2VuZXJhdGluZyBxdWVyaWVzIGZvciBhIHNldCBvZiBDb252ZXJzYXRpb25zLlxuICpcbiAqIFVzZWQgaW4gQ3JlYXRpbmcgYW5kIFVwZGF0aW5nIGxheWVyLlF1ZXJ5IGluc3RhbmNlcy5cbiAqIE5vdGUgdGhhdCBhdCB0aGlzIHRpbWUsIHRoZSBvbmx5IHRoaW5nIHdlIGNhbiBxdWVyeSBmb3IgaXNcbiAqIEFMTCBDb252ZXJzYXRpb25zOyBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyB0byBwYWdlIHRocm91Z2ggdGhlIENvbnZlcnNhdGlvbnMuXG4gKlxuICogVG8gZ2V0IHN0YXJ0ZWQ6XG4gKlxuICogICAgICB2YXIgcUJ1aWxkZXIgPSBRdWVyeUJ1aWxkZXJcbiAqICAgICAgIC5jb252ZXJzYXRpb25zKClcbiAqICAgICAgIC5wYWdpbmF0aW9uV2luZG93KDEwMCk7XG4gKiAgICAgIHZhciBxdWVyeSA9IGNsaWVudC5jcmVhdGVRdWVyeShxQnVpbGRlcik7XG4gKlxuICogWW91IGNhbiB0aGVuIGNyZWF0ZSBhZGRpdGlvbmFsIGJ1aWxkZXJzIGFuZCB1cGRhdGUgdGhlIHF1ZXJ5OlxuICpcbiAqICAgICAgdmFyIHFCdWlsZGVyMiA9IFF1ZXJ5QnVpbGRlclxuICogICAgICAgLmNvbnZlcnNhdGlvbnMoKVxuICogICAgICAgLnBhZ2luYXRpb25XaW5kb3coMjAwKTtcbiAqICAgICAgcXVlcnkudXBkYXRlKHFCdWlsZGVyKTtcbiAqXG4gKiBAY2xhc3MgbGF5ZXIuUXVlcnlCdWlsZGVyLkNvbnZlcnNhdGlvbnNRdWVyeVxuICovXG5jbGFzcyBDb252ZXJzYXRpb25zUXVlcnkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHF1ZXJ5IGJ1aWxkZXIgZm9yIGEgc2V0IG9mIGNvbnZlcnNhdGlvbnMuXG4gICAqXG4gICAqIFN0YW5kYXJkIHVzZSBpcyB3aXRob3V0IGFueSBhcmd1bWVudHMuXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBbcXVlcnk9bnVsbF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHF1ZXJ5KSB7XG4gICAgaWYgKHF1ZXJ5KSB7XG4gICAgICB0aGlzLl9xdWVyeSA9IHtcbiAgICAgICAgbW9kZWw6IHF1ZXJ5Lm1vZGVsLFxuICAgICAgICByZXR1cm5UeXBlOiBxdWVyeS5yZXR1cm5UeXBlLFxuICAgICAgICBkYXRhVHlwZTogcXVlcnkuZGF0YVR5cGUsXG4gICAgICAgIHBhZ2luYXRpb25XaW5kb3c6IHF1ZXJ5LnBhZ2luYXRpb25XaW5kb3csXG4gICAgICAgIHNvcnRCeTogcXVlcnkuc29ydEJ5LFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVlcnkgPSB7XG4gICAgICAgIG1vZGVsOiBRdWVyeS5Db252ZXJzYXRpb24sXG4gICAgICAgIHJldHVyblR5cGU6ICdvYmplY3QnLFxuICAgICAgICBkYXRhVHlwZTogJ29iamVjdCcsXG4gICAgICAgIHBhZ2luYXRpb25XaW5kb3c6IFF1ZXJ5LnByb3RvdHlwZS5wYWdpbmF0aW9uV2luZG93LFxuICAgICAgICBzb3J0Qnk6IG51bGwsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwYWdpbmF0aW9uIHdpbmRvdy9udW1iZXIgb2YgbWVzc2FnZXMgdG8gZmV0Y2ggZnJvbSB0aGUgbG9jYWwgY2FjaGUgb3Igc2VydmVyLlxuICAgKlxuICAgKiBDdXJyZW50bHkgb25seSBwb3NpdGl2ZSBpbnRlZ2VycyBhcmUgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIHBhZ2luYXRpb25XaW5kb3dcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aW5cbiAgICogQHJldHVybiB7bGF5ZXIuUXVlcnlCdWlsZGVyfSB0aGlzXG4gICAqL1xuICBwYWdpbmF0aW9uV2luZG93KHdpbikge1xuICAgIHRoaXMuX3F1ZXJ5LnBhZ2luYXRpb25XaW5kb3cgPSB3aW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc29ydGluZyBvcHRpb25zIGZvciB0aGUgQ29udmVyc2F0aW9uLlxuICAgKlxuICAgKiBDdXJyZW50bHkgb25seSBzdXBwb3J0cyBkZXNjZW5kaW5nIG9yZGVyXG4gICAqIEN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIGZpZWxkTmFtZXMgb2YgXCJjcmVhdGVkQXRcIiBhbmQgXCJsYXN0TWVzc2FnZS5zZW50QXRcIlxuICAgKlxuICAgKiBAbWV0aG9kIHNvcnRCeVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGZpZWxkTmFtZSAgLSBmaWVsZCB0byBzb3J0IGJ5XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGFzYyAtIElzIGFuIGFzY2VuZGluZyBzb3J0P1xuICAgKiBAcmV0dXJuIHtsYXllci5RdWVyeUJ1aWxkZXJ9IHRoaXNcbiAgICovXG4gIHNvcnRCeShmaWVsZE5hbWUsIGFzYyA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcXVlcnkuc29ydEJ5ID0gW3sgW2ZpZWxkTmFtZV06IGFzYyA/ICdhc2MnIDogJ2Rlc2MnIH1dO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJ1aWx0IHF1ZXJ5IG9iamVjdCB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIENhbGxlZCBieSBsYXllci5RdWVyeUJ1aWxkZXIuIFlvdSBzaG91bGQgbm90IG5lZWQgdG8gY2FsbCB0aGlzLlxuICAgKlxuICAgKiBAbWV0aG9kIGJ1aWxkXG4gICAqL1xuICBidWlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVlcnk7XG4gIH1cbn1cblxuLyoqXG4gKiBRdWVyeSBidWlsZGVyIGNsYXNzLiBVc2VkIHdpdGggbGF5ZXIuUXVlcnkgdG8gc3BlY2lmeSB3aGF0IGxvY2FsL3JlbW90ZVxuICogZGF0YSBjaGFuZ2VzIHRvIHN1YnNjcmliZSB0by4gIEZvciBleGFtcGxlcywgc2VlIGxheWVyLlF1ZXJ5QnVpbGRlci5NZXNzYWdlc1F1ZXJ5XG4gKiBhbmQgbGF5ZXIuUXVlcnlCdWlsZGVyLkNvbnZlcnNhdGlvbnNRdWVyeS4gIFRoaXMgc3RhdGljIGNsYXNzIGlzIHVzZWQgdG8gaW5zdGFudGlhdGVcbiAqIE1lc3NhZ2VzUXVlcnkgYW5kIENvbnZlcnNhdGlvbnNRdWVyeSBCdWlsZGVyIGluc3RhbmNlczpcbiAqXG4gKiAgICAgIHZhciBjb252ZXJzYXRpb25zUXVlcnlCdWlsZGVyID0gUXVlcnlCdWlsZGVyLmNvbnZlcnNhdGlvbnMoKTtcbiAqICAgICAgdmFyIG1lc3NhZ2VzUXVlcnlCdWlkbGVyID0gUXVlcnlCdWlsZGVyLm1lc3NhZ2VzKCk7XG4gKlxuICogU2hvdWxkIHlvdSB1c2UgdGhlc2UgaW5zdGVhZCBvZiBkaXJlY3RseSB1c2luZyB0aGUgbGF5ZXIuUXVlcnkgY2xhc3M/XG4gKiBUaGF0IGlzIGEgbWF0dGVyIG9mIHByb2dyYW1taW5nIHN0eWxlIGFuZCBwcmVmZXJlbmNlLCB0aGVyZSBpcyBub1xuICogY29ycmVjdCBhbnN3ZXIuXG4gKlxuICogQGNsYXNzIGxheWVyLlF1ZXJ5QnVpbGRlclxuICovXG5jb25zdCBRdWVyeUJ1aWxkZXIgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsYXllci5NZXNzYWdlc1F1ZXJ5IGluc3RhbmNlLlxuICAgKlxuICAgKiBAbWV0aG9kIG1lc3NhZ2VzXG4gICAqIEBzdGF0aWNcbiAgICogQHJldHVybnMge2xheWVyLlF1ZXJ5QnVpbGRlci5NZXNzYWdlc1F1ZXJ5fVxuICAgKi9cbiAgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlc1F1ZXJ5KCk7XG4gIH0sXG5cbiAgYW5ub3VuY2VtZW50cygpIHtcbiAgICByZXR1cm4gbmV3IEFubm91bmNlbWVudFF1ZXJ5KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBsYXllci5Db252ZXJzYXRpb25zUXVlcnkgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBtZXRob2QgY29udmVyc2F0aW9uc1xuICAgKiBAc3RhdGljXG4gICAqIEByZXR1cm5zIHtsYXllci5RdWVyeUJ1aWxkZXIuQ29udmVyc2F0aW9uc1F1ZXJ5fVxuICAgKi9cbiAgY29udmVyc2F0aW9ucygpIHtcbiAgICByZXR1cm4gbmV3IENvbnZlcnNhdGlvbnNRdWVyeSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYWtlcyB0aGUgcmV0dXJuIHZhbHVlIG9mIFF1ZXJ5QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgYW5kIGNyZWF0ZXMgYVxuICAgKiBuZXcgUXVlcnlCdWlsZGVyLlxuICAgKlxuICAgKiBVc2VkIHdpdGhpbiBsYXllci5RdWVyeS5wcm90b3R5cGUudG9CdWlsZGVyLlxuICAgKlxuICAgKiBAbWV0aG9kIGZyb21RdWVyeU9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAqIEBzdGF0aWNcbiAgICovXG4gIGZyb21RdWVyeU9iamVjdChvYmopIHtcbiAgICBzd2l0Y2ggKG9iai5tb2RlbCkge1xuICAgICAgY2FzZSBRdWVyeS5NZXNzYWdlOlxuICAgICAgICByZXR1cm4gbmV3IE1lc3NhZ2VzUXVlcnkob2JqKTtcbiAgICAgIGNhc2UgUXVlcnkuQW5ub3VuY2VtZW50OlxuICAgICAgICByZXR1cm4gbmV3IEFubm91bmNlbWVudFF1ZXJ5KG9iaik7XG4gICAgICBjYXNlIFF1ZXJ5LkNvbnZlcnNhdGlvbjpcbiAgICAgICAgcmV0dXJuIG5ldyBDb252ZXJzYXRpb25zUXVlcnkob2JqKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnlCdWlsZGVyO1xuXG4iLCIvKipcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byBpbnN0YW50aWF0ZSB0aGlzIGNsYXNzOlxuICpcbiAqICAgICAgLy8gMS4gVXNpbmcgYSBRdWVyeSBCdWlsZGVyXG4gKiAgICAgIHZhciBxdWVyeUJ1aWxkZXIgPSBRdWVyeUJ1aWxkZXIuY29udmVyc2F0aW9ucygpLnNvcnRCeSgnbGFzdE1lc3NhZ2UnKTtcbiAqICAgICAgdmFyIHF1ZXJ5ID0gY2xpZW50LmNyZWF0ZVF1ZXJ5KGNsaWVudCwgcXVlcnlCdWlsZGVyKTtcbiAqXG4gKiAgICAgIC8vIDIuIFBhc3NpbmcgcHJvcGVydGllcyBkaXJlY3RseVxuICogICAgICB2YXIgcXVlcnkgPSBjbGllbnQuY3JlYXRlUXVlcnkoe1xuICogICAgICAgIGNsaWVudDogY2xpZW50LFxuICogICAgICAgIG1vZGVsOiBsYXllci5RdWVyeS5Db252ZXJzYXRpb24sXG4gKiAgICAgICAgc29ydEJ5OiBbeydjcmVhdGVkQXQnOiAnZGVzYyd9XVxuICogICAgICB9KTtcbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSB0aGUgZGF0YSBzZWxlY3RlZCBieSB5b3VyIHF1ZXJ5IGFueSB0aW1lIHlvdSB3YW50IHVzaW5nOlxuICpcbiAqICAgICAgcXVlcnkudXBkYXRlKHtcbiAqICAgICAgICBwYWdpbmF0aW9uV2luZG93OiAyMDBcbiAqICAgICAgfSk7XG4gKlxuICogICAgICBxdWVyeS51cGRhdGUoe1xuICogICAgICAgIHByZWRpY2F0ZTogJ2NvbnZlcnNhdGlvbi5pZCA9IFwiJyArIGNvbnYuaWQgKyBcIidcIlxuICogICAgICB9KTtcbiAqXG4gKiAgICAgLy8gT3IgdXNlIHRoZSBRdWVyeSBCdWlsZGVyOlxuICogICAgIHF1ZXJ5QnVpbGRlci5wYWdpbmF0aW9uV2luZG93KDIwMCk7XG4gKiAgICAgcXVlcnkudXBkYXRlKHF1ZXJ5QnVpbGRlcik7XG4gKlxuICogWW91IGNhbiByZWxlYXNlIENvbnZlcnNhdGlvbnMgYW5kIE1lc3NhZ2VzIGhlbGQgaW4gbWVtb3J5IGJ5IHlvdXIgcXVlcmllcyB3aGVuIGRvbmUgd2l0aCB0aGVtOlxuICpcbiAqICAgICAgcXVlcnkuZGVzdHJveSgpO1xuICpcbiAqICMjIyMgc29ydEJ5XG4gKlxuICogTm90ZSB0aGF0IHRoZSBzb3J0QnkgcHJvcGVydHkgaXMgb25seSBzdXBwb3J0ZWQgZm9yIENvbnZlcnNhdGlvbnMgYXQgdGhpcyB0aW1lIGFuZCBvbmx5XG4gKiBzdXBwb3J0cyBcImNyZWF0ZWRBdFwiIGFuZCBcImxhc3RNZXNzYWdlLnNlbnRBdFwiIGFzIHNvcnQgZmllbGRzLlxuICpcbiAqICMjIyMgZGF0YVR5cGVcbiAqXG4gKiBUaGUgbGF5ZXIuUXVlcnkuZGF0YVR5cGUgcHJvcGVydHkgbGV0cyB5b3Ugc3BlY2lmeSB3aGF0IHR5cGUgb2YgZGF0YSBzaG93cyB1cCBpbiB5b3VyIHJlc3VsdHM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHF1ZXJ5ID0gY2xpZW50LmNyZWF0ZVF1ZXJ5KHtcbiAqICAgICBtb2RlbDogbGF5ZXIuUXVlcnkuTWVzc2FnZSxcbiAqICAgICBwcmVkaWNhdGU6IFwiY29udmVyc2F0aW9uLmlkID0gJ2xheWVyOi8vL2NvbnZlcnNhdGlvbnMvdXVpZCdcIixcbiAqICAgICBkYXRhVHlwZTogbGF5ZXIuUXVlcnkuSW5zdGFuY2VEYXRhVHlwZVxuICogfSlcbiAqXG4gKiB2YXIgcXVlcnkgPSBjbGllbnQuY3JlYXRlUXVlcnkoe1xuICogICAgIG1vZGVsOiBsYXllci5RdWVyeS5NZXNzYWdlLFxuICogICAgIHByZWRpY2F0ZTogXCJjb252ZXJzYXRpb24uaWQgPSAnbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy91dWlkJ1wiLFxuICogICAgIGRhdGFUeXBlOiBsYXllci5RdWVyeS5PYmplY3REYXRhVHlwZVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoZSBwcm9wZXJ0eSBkZWZhdWx0cyB0byBsYXllci5RdWVyeS5JbnN0YW5jZURhdGFUeXBlLiAgSW5zdGFuY2VzIHN1cHBvcnQgbWV0aG9kcyBhbmQgbGV0IHlvdSBzdWJzY3JpYmUgdG8gZXZlbnRzIGZvciBkaXJlY3Qgbm90aWZpY2F0aW9uXG4gKiBvZiBjaGFuZ2VzIHRvIGFueSBvZiB0aGUgcmVzdWx0cyBvZiB5b3VyIHF1ZXJ5OlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHF1ZXJ5LmRhdGFbMF0ub24oJ21lc3NhZ2VzOnJlYWQnLCBmdW5jdGlvbigpIHtcbiAqICAgICBhbGVydCgnVGhlIGZpcnN0IG1lc3NhZ2UgaGFzIGJlZW4gcmVhZCEnKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQSB2YWx1ZSBvZiBsYXllci5RdWVyeS5PYmplY3REYXRhVHlwZSB3aWxsIGNhdXNlIHRoZSBkYXRhIHRvIGJlIGFuIGFycmF5IG9mIGltbXV0YWJsZSBvYmplY3RzIHJhdGhlciB0aGFuIGluc3RhbmNlcy4gIE9uZSBjYW4gc3RpbGwgZ2V0IGFuIGluc3RhbmNlIGZyb20gdGhlIFBPSk86XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG0gPSBjbGllbnQuZ2V0TWVzc2FnZShxdWVyeS5kYXRhWzBdLmlkKTtcbiAqIG0ub24oJ21lc3NhZ2VzOnJlYWQnLCBmdW5jdGlvbigpIHtcbiAqICAgICBhbGVydCgnVGhlIGZpcnN0IG1lc3NhZ2UgaGFzIGJlZW4gcmVhZCEnKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogIyMgUXVlcnkgRXZlbnRzXG4gKlxuICogUXVlcmllcyBmaXJlIGV2ZW50cyB3aGVuZXZlciB0aGVpciBkYXRhIGNoYW5nZXMuICBUaGVyZSBhcmUgNSB0eXBlcyBvZiBldmVudHM7XG4gKiBhbGwgZXZlbnRzIGFyZSByZWNlaXZlZCBieSBzdWJzY3JpYmluZyB0byB0aGUgYGNoYW5nZWAgZXZlbnQuXG4gKlxuICogIyMjIDEuIERhdGEgRXZlbnRzXG4gKlxuICogVGhlIERhdGEgZXZlbnQgaXMgZmlyZWQgd2hlbmV2ZXIgYSByZXF1ZXN0IGlzIHNlbnQgdG8gdGhlIHNlcnZlciBmb3IgbmV3IHF1ZXJ5IHJlc3VsdHMuICBUaGlzIGNvdWxkIGhhcHBlbiB3aGVuIGZpcnN0IGNyZWF0aW5nIHRoZSBxdWVyeSwgd2hlbiBwYWdpbmcgZm9yIG1vcmUgZGF0YSwgb3Igd2hlbiBjaGFuZ2luZyB0aGUgcXVlcnkncyBwcm9wZXJ0aWVzLCByZXN1bHRpbmcgaW4gYSBuZXcgcmVxdWVzdCB0byB0aGUgc2VydmVyLlxuICpcbiAqIFRoZSBFdmVudCBvYmplY3Qgd2lsbCBoYXZlIGFuIGBldnQuZGF0YWAgYXJyYXkgb2YgYWxsIG5ld2x5IGFkZGVkIHJlc3VsdHMuICBCdXQgZnJlcXVlbnRseSB5b3UgbWF5IGp1c3Qgd2FudCB0byB1c2UgdGhlIGBxdWVyeS5kYXRhYCBhcnJheSBhbmQgZ2V0IEFMTCByZXN1bHRzLlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHF1ZXJ5Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAqICAgaWYgKGV2dC50eXBlID09PSAnZGF0YScpIHtcbiAqICAgICAgdmFyIG5ld0RhdGEgPSBldnQuZGF0YTtcbiAqICAgICAgdmFyIGFsbERhdGEgPSBxdWVyeS5kYXRhO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBgcXVlcnkub24oJ2NoYW5nZTpkYXRhJywgZnVuY3Rpb24oZXZ0KSB7fWAgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKlxuICogIyMjIDIuIEluc2VydCBFdmVudHNcbiAqXG4gKiBBIG5ldyBDb252ZXJzYXRpb24gb3IgTWVzc2FnZSB3YXMgY3JlYXRlZC4gSXQgbWF5IGhhdmUgYmVlbiBjcmVhdGVkIGxvY2FsbHkgYnkgeW91ciB1c2VyLCBvciBpdCBtYXkgaGF2ZSBiZWVuIHJlbW90ZWx5IGNyZWF0ZWQsIHJlY2VpdmVkIHZpYSB3ZWJzb2NrZXQsIGFuZCBhZGRlZCB0byB0aGUgUXVlcnkncyByZXN1bHRzLlxuICpcbiAqIFRoZSBsYXllci5MYXllckV2ZW50LnRhcmdldCBwcm9wZXJ0eSBjb250YWlucyB0aGUgbmV3bHkgaW5zZXJ0ZWQgb2JqZWN0LlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqICBxdWVyeS5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gKiAgICBpZiAoZXZ0LnR5cGUgPT09ICdpbnNlcnQnKSB7XG4gKiAgICAgICB2YXIgbmV3SXRlbSA9IGV2dC50YXJnZXQ7XG4gKiAgICAgICB2YXIgYWxsRGF0YSA9IHF1ZXJ5LmRhdGE7XG4gKiAgICB9XG4gKiAgfSk7XG4gKiBgYGBcbiAqXG4gKiBOb3RlIHRoYXQgYHF1ZXJ5Lm9uKCdjaGFuZ2U6aW5zZXJ0JywgZnVuY3Rpb24oZXZ0KSB7fWAgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKlxuICogIyMjIDMuIFJlbW92ZSBFdmVudHNcbiAqXG4gKiBBIENvbnZlcnNhdGlvbiBvciBNZXNzYWdlIHdhcyBkZWxldGVkLiBUaGlzIG1heSBoYXZlIGJlZW4gZGVsZXRlZCBsb2NhbGx5IGJ5IHlvdXIgdXNlciwgb3IgaXQgbWF5IGhhdmUgYmVlbiByZW1vdGVseSBkZWxldGVkLCBhIG5vdGlmaWNhdGlvbiByZWNlaXZlZCB2aWEgd2Vic29ja2V0LCBhbmQgcmVtb3ZlZCBmcm9tIHRoZSBRdWVyeSByZXN1bHRzLlxuICpcbiAqIFRoZSBsYXllci5MYXllckV2ZW50LnRhcmdldCBwcm9wZXJ0eSBjb250YWlucyB0aGUgcmVtb3ZlZCBvYmplY3QuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcXVlcnkub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGV2dCkge1xuICogICBpZiAoZXZ0LnR5cGUgPT09ICdyZW1vdmUnKSB7XG4gKiAgICAgICB2YXIgcmVtb3ZlZEl0ZW0gPSBldnQudGFyZ2V0O1xuICogICAgICAgdmFyIGFsbERhdGEgPSBxdWVyeS5kYXRhO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIE5vdGUgdGhhdCBgcXVlcnkub24oJ2NoYW5nZTpyZW1vdmUnLCBmdW5jdGlvbihldnQpIHt9YCBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqXG4gKiAjIyMgNC4gUmVzZXQgRXZlbnRzXG4gKlxuICogQW55IHRpbWUgeW91ciBxdWVyeSdzIG1vZGVsIG9yIHByZWRpY2F0ZSBwcm9wZXJ0aWVzIGhhdmUgYmVlbiBjaGFuZ2VkXG4gKiB0aGUgcXVlcnkgaXMgcmVzZXQsIGFuZCBhIG5ldyByZXF1ZXN0IGlzIHNlbnQgdG8gdGhlIHNlcnZlci4gIFRoZSByZXNldCBldmVudCBpbmZvcm1zIHlvdXIgVUkgdGhhdCB0aGUgY3VycmVudCByZXN1bHQgc2V0IGlzIGVtcHR5LCBhbmQgdGhhdCB0aGUgcmVhc29uIGl0cyBlbXB0eSBpcyB0aGF0IGl0IHdhcyBgcmVzZXRgLiAgVGhpcyBoZWxwcyBkaWZmZXJlbnRpYXRlIGl0IGZyb20gYSBgZGF0YWAgZXZlbnQgdGhhdCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHF1ZXJ5Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAqICAgaWYgKGV2dC50eXBlID09PSAncmVzZXQnKSB7XG4gKiAgICAgICB2YXIgYWxsRGF0YSA9IHF1ZXJ5LmRhdGE7IC8vIFtdXG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogTm90ZSB0aGF0IGBxdWVyeS5vbignY2hhbmdlOnJlc2V0JywgZnVuY3Rpb24oZXZ0KSB7fWAgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKlxuICogIyMjIDUuIFByb3BlcnR5IEV2ZW50c1xuICpcbiAqIElmIGFueSBwcm9wZXJ0aWVzIGNoYW5nZSBpbiBhbnkgb2YgdGhlIG9iamVjdHMgbGlzdGVkIGluIHlvdXIgbGF5ZXIuUXVlcnkuZGF0YSBwcm9wZXJ0eSwgYSBgcHJvcGVydHlgIGV2ZW50IHdpbGwgYmUgZmlyZWQuXG4gKlxuICogVGhlIGxheWVyLkxheWVyRXZlbnQudGFyZ2V0IHByb3BlcnR5IGNvbnRhaW5zIG9iamVjdCB0aGF0IHdhcyBtb2RpZmllZC5cbiAqXG4gKiBTZWUgbGF5ZXIuTGF5ZXJFdmVudC5jaGFuZ2VzIGZvciBkZXRhaWxzIG9uIGhvdyBjaGFuZ2VzIGFyZSByZXBvcnRlZC5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBxdWVyeS5vbignY2hhbmdlJywgZnVuY3Rpb24oZXZ0KSB7XG4gKiAgIGlmIChldnQudHlwZSA9PT0gJ3Byb3BlcnR5Jykge1xuICogICAgICAgdmFyIGNoYW5nZWRJdGVtID0gZXZ0LnRhcmdldDtcbiAqICAgICAgIHZhciBpc1JlYWRDaGFuZ2VzID0gZXZ0LmdldENoYW5nZXNGb3IoJ2lzUmVhZCcpO1xuICogICAgICAgdmFyIHJlY2lwaWVudFN0YXR1c0NoYW5nZXMgPSBldnQuZ2V0Q2hhbmdlc0ZvcigncmVjaXBpZW50U3RhdHVzJyk7XG4gKiAgICAgICBpZiAoaXNSZWFkQ2hhbmdlcy5sZW5ndGgpIHtcbiAqICAgICAgICAgICAuLi5cbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICBpZiAocmVjaXBpZW50U3RhdHVzQ2hhbmdlcy5sZW5ndGgpIHtcbiAqICAgICAgICAgICAuLi5cbiAqICAgICAgIH1cbiAqICAgfVxuICogfSk7XG4gKmBgYFxuICogTm90ZSB0aGF0IGBxdWVyeS5vbignY2hhbmdlOnByb3BlcnR5JywgZnVuY3Rpb24oZXZ0KSB7fWAgaXMgYWxzbyBzdXBwb3J0ZWQuXG4gKlxuICogQGNsYXNzICBsYXllci5RdWVyeVxuICogQGV4dGVuZHMgbGF5ZXIuUm9vdFxuICpcbiAqL1xuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4vcm9vdCcpO1xuY29uc3QgTGF5ZXJFcnJvciA9IHJlcXVpcmUoJy4vbGF5ZXItZXJyb3InKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuY29uc3QgQ09OVkVSU0FUSU9OID0gJ0NvbnZlcnNhdGlvbic7XG5jb25zdCBNRVNTQUdFID0gJ01lc3NhZ2UnO1xuY29uc3QgQU5OT1VOQ0VNRU5UID0gJ0Fubm91bmNlbWVudCc7XG5jb25zdCBmaW5kQ29udklkUmVnZXggPSBuZXcgUmVnRXhwKFxuICAvXmNvbnZlcnNhdGlvbi5pZFxccyo9XFxzKlsnXCJdKGxheWVyOlxcL1xcL1xcL2NvbnZlcnNhdGlvbnNcXC8uezh9LS57NH0tLns0fS0uezR9LS57MTJ9KVsnXCJdJC8pO1xuXG5jbGFzcyBRdWVyeSBleHRlbmRzIFJvb3Qge1xuXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzFdLmJ1aWxkKCk7XG4gICAgICBvcHRpb25zLmNsaWVudCA9IGFyZ3NbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBhcmdzWzBdO1xuICAgIH1cbiAgICBpZiAoJ3BhZ2luYXRpb25XaW5kb3cnIGluIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBhZ2luYXRpb25XaW5kb3cgPSBvcHRpb25zLnBhZ2luYXRpb25XaW5kb3c7XG4gICAgICBvcHRpb25zLnBhZ2luYXRpb25XaW5kb3cgPSBNYXRoLm1pbihRdWVyeS5NYXhQYWdlU2l6ZSwgb3B0aW9ucy5wYWdpbmF0aW9uV2luZG93KTtcbiAgICAgIGlmIChvcHRpb25zLnBhZ2luYXRpb25XaW5kb3cgIT09IHBhZ2luYXRpb25XaW5kb3cpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oYHBhZ2luYXRpb25XaW5kb3cgdmFsdWUgJHtwYWdpbmF0aW9uV2luZG93fSBpbiBRdWVyeSBjb25zdHJ1Y3RvciBgICtcbiAgICAgICAgICBgZXhjZWRlcyBRdWVyeS5NYXhQYWdlU2l6ZSBvZiAke1F1ZXJ5Lk1heFBhZ2VTaXplfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuX2luaXRpYWxQYWdpbmF0aW9uV2luZG93ID0gdGhpcy5wYWdpbmF0aW9uV2luZG93O1xuICAgIGlmICghdGhpcy5jbGllbnQpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG4gICAgdGhpcy5jbGllbnQub24oJ2FsbCcsIHRoaXMuX2hhbmRsZUNoYW5nZUV2ZW50cywgdGhpcyk7XG5cbiAgICBpZiAoIXRoaXMuY2xpZW50LmlzUmVhZHkpIHtcbiAgICAgIHRoaXMuY2xpZW50Lm9uY2UoJ3JlYWR5JywgKCkgPT4gdGhpcy5fcnVuKCksIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9ydW4oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCBhbmQgcmVtb3ZlIHRoaXMgUXVlcnksIGl0cyBzdWJzY3JpcHRpb25zIGFuZCBkYXRhLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jbGllbnQub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuY2xpZW50Ll9yZW1vdmVRdWVyeSh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHByb3BlcnRpZXMgb2YgdGhlIFF1ZXJ5LlxuICAgKlxuICAgKiBDdXJyZW50bHkgc3VwcG9ydHMgdXBkYXRpbmc6XG4gICAqXG4gICAqICogcGFnaW5hdGlvbldpbmRvd1xuICAgKiAqIHByZWRpY2F0ZVxuICAgKiAqIG1vZGVsXG4gICAqXG4gICAqIEFueSBjaGFuZ2UgdG8gcHJlZGljYXRlIG9yIG1vZGVsIHJlc3VsdHMgaW4gY2xlYXJpbmcgYWxsIGRhdGEgZnJvbSB0aGVcbiAgICogcXVlcnkncyByZXN1bHRzIGFuZCB0cmlnZ2VyaW5nIGEgY2hhbmdlIGV2ZW50IHdpdGggW10gYXMgdGhlIG5ldyBkYXRhLlxuICAgKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnByZWRpY2F0ZV0gLSBBIG5ldyBwcmVkaWNhdGUgZm9yIHRoZSBxdWVyeVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubW9kZWxdIC0gQSBuZXcgbW9kZWwgZm9yIHRoZSBRdWVyeVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3BhZ2luYXRpb25XaW5kb3ddIC0gSW5jcmVhc2UvZGVjcmVhc2Ugb3VyIHJlc3VsdCBzaXplIHRvIG1hdGNoIHRoaXMgcGFnaW5hdGlvbiB3aW5kb3cuXG4gICAqIEByZXR1cm4ge2xheWVyLlF1ZXJ5fSB0aGlzXG4gICAqL1xuICB1cGRhdGUob3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IG5lZWRzUmVmcmVzaCxcbiAgICAgIG5lZWRzUmVjcmVhdGU7XG5cbiAgICBjb25zdCBvcHRpb25zQnVpbHQgPSAodHlwZW9mIG9wdGlvbnMuYnVpbGQgPT09ICdmdW5jdGlvbicpID8gb3B0aW9ucy5idWlsZCgpIDogb3B0aW9ucztcblxuICAgIGlmICgncGFnaW5hdGlvbldpbmRvdycgaW4gb3B0aW9uc0J1aWx0ICYmIHRoaXMucGFnaW5hdGlvbldpbmRvdyAhPT0gb3B0aW9uc0J1aWx0LnBhZ2luYXRpb25XaW5kb3cpIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvbldpbmRvdyA9IE1hdGgubWluKFF1ZXJ5Lk1heFBhZ2VTaXplICsgdGhpcy5zaXplLCBvcHRpb25zQnVpbHQucGFnaW5hdGlvbldpbmRvdyk7XG4gICAgICBpZiAodGhpcy5wYWdpbmF0aW9uV2luZG93IDwgb3B0aW9uc0J1aWx0LnBhZ2luYXRpb25XaW5kb3cpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oYHBhZ2luYXRpb25XaW5kb3cgdmFsdWUgJHtvcHRpb25zQnVpbHQucGFnaW5hdGlvbldpbmRvd30gaW4gUXVlcnkudXBkYXRlKCkgYCArXG4gICAgICAgICAgYGluY3JlYXNlcyBzaXplIGdyZWF0ZXIgdGhhbiBRdWVyeS5NYXhQYWdlU2l6ZSBvZiAke1F1ZXJ5Lk1heFBhZ2VTaXplfWApO1xuICAgICAgfVxuICAgICAgbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCdwcmVkaWNhdGUnIGluIG9wdGlvbnNCdWlsdCAmJiB0aGlzLnByZWRpY2F0ZSAhPT0gb3B0aW9uc0J1aWx0LnByZWRpY2F0ZSkge1xuICAgICAgdGhpcy5wcmVkaWNhdGUgPSBvcHRpb25zQnVpbHQucHJlZGljYXRlIHx8ICcnO1xuICAgICAgbmVlZHNSZWNyZWF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICgnbW9kZWwnIGluIG9wdGlvbnNCdWlsdCAmJiB0aGlzLm1vZGVsICE9PSBvcHRpb25zQnVpbHQubW9kZWwpIHtcbiAgICAgIHRoaXMubW9kZWwgPSBvcHRpb25zQnVpbHQubW9kZWw7XG4gICAgICBuZWVkc1JlY3JlYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCdzb3J0QnknIGluIG9wdGlvbnNCdWlsdCAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnNvcnRCeSkgIT09IEpTT04uc3RyaW5naWZ5KG9wdGlvbnNCdWlsdC5zb3J0QnkpKSB7XG4gICAgICB0aGlzLnNvcnRCeSA9IG9wdGlvbnNCdWlsdC5zb3J0Qnk7XG4gICAgICBuZWVkc1JlY3JlYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5lZWRzUmVjcmVhdGUpIHtcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgfVxuICAgIGlmIChuZWVkc1JlY3JlYXRlIHx8IG5lZWRzUmVmcmVzaCkgdGhpcy5fcnVuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWZ0ZXIgcmVkZWZpbmluZyB0aGUgcXVlcnksIHJlc2V0IGl0OiByZW1vdmUgYWxsIGRhdGEvcmVzZXQgYWxsIHN0YXRlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9yZXNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMudG90YWxTaXplID0gMDtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuY2xpZW50Ll9jaGVja0FuZFB1cmdlQ2FjaGUoZGF0YSk7XG4gICAgdGhpcy5pc0ZpcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3ByZWRpY2F0ZSA9IG51bGw7XG4gICAgdGhpcy5wYWdpbmF0aW9uV2luZG93ID0gdGhpcy5faW5pdGlhbFBhZ2luYXRpb25XaW5kb3c7XG4gICAgdGhpcy5pc1Jlc2V0ID0gdHJ1ZTtcbiAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlKHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgdHlwZTogJ3Jlc2V0JyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB5b3VyIHF1ZXJ5IHRvIGl0cyBpbml0aWFsIHN0YXRlIGFuZCB0aGVuIHJlcnVuIGl0LlxuICAgKlxuICAgKiBAbWV0aG9kIHJlc2V0XG4gICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuX3J1bigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgdGhlIHF1ZXJ5LlxuICAgKlxuICAgKiBObywgZG9uJ3QgbXVyZGVyIGl0LCBqdXN0IGZpcmUgaXQuICBObywgZG9uJ3QgbWFrZSBpdCB1bmVtcGxveWVkLFxuICAgKiBqdXN0IGNvbm5lY3QgdG8gdGhlIHNlcnZlciBhbmQgZ2V0IHRoZSByZXN1bHRzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9ydW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ydW4oKSB7XG4gICAgLy8gRmluZCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHdlIG5lZWQgdG8gcmVxdWVzdC5cbiAgICBjb25zdCBwYWdlU2l6ZSA9IE1hdGgubWluKHRoaXMucGFnaW5hdGlvbldpbmRvdyAtIHRoaXMuc2l6ZSwgUXVlcnkuTWF4UGFnZVNpemUpO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZWR1Y3Rpb24gaW4gcGFnaW5hdGlvbiB3aW5kb3csIHRoZW4gdGhpcyB2YXJpYWJsZSB3aWxsIGJlIG5lZ2F0aXZlLCBhbmQgd2UgY2FuIHNocmlua1xuICAgIC8vIHRoZSBkYXRhLlxuICAgIGlmIChwYWdlU2l6ZSA8IDApIHtcbiAgICAgIGNvbnN0IHJlbW92ZWREYXRhID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMucGFnaW5hdGlvbldpbmRvdyk7XG4gICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoMCwgdGhpcy5wYWdpbmF0aW9uV2luZG93KTtcbiAgICAgIHRoaXMuY2xpZW50Ll9jaGVja0FuZFB1cmdlQ2FjaGUocmVtb3ZlZERhdGEpO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKCdjaGFuZ2UnLCB7IGRhdGE6IFtdIH0pO1xuICAgIH0gZWxzZSBpZiAocGFnZVNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gbG9hZCAwIHJlc3VsdHMuXG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsID09PSBDT05WRVJTQVRJT04pIHtcbiAgICAgIHRoaXMuX3J1bkNvbnZlcnNhdGlvbihwYWdlU2l6ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vZGVsID09PSBNRVNTQUdFICYmIHRoaXMucHJlZGljYXRlKSB7XG4gICAgICB0aGlzLl9ydW5NZXNzYWdlKHBhZ2VTaXplKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwgPT09IEFOTk9VTkNFTUVOVCkge1xuICAgICAgdGhpcy5fcnVuQW5ub3VuY2VtZW50KHBhZ2VTaXplKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IENvbnZlcnNhdGlvbnMgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9ydW5Db252ZXJzYXRpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwYWdlU2l6ZSAtIE51bWJlciBvZiBuZXcgcmVzdWx0cyB0byByZXF1ZXN0XG4gICAqL1xuICBfcnVuQ29udmVyc2F0aW9uKHBhZ2VTaXplKSB7XG4gICAgLy8gSWYgbm8gZGF0YSwgcmV0cmlldmUgZGF0YSBmcm9tIGRiIGNhY2hlIGluIHBhcmFsbGVsIHdpdGggbG9hZGluZyBkYXRhIGZyb20gc2VydmVyXG4gICAgaWYgKHRoaXMuaXNSZXNldCkge1xuICAgICAgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLmxvYWRDb252ZXJzYXRpb25zKGNvbnZlcnNhdGlvbnMgPT4gdGhpcy5fYXBwZW5kUmVzdWx0cyh7IGRhdGE6IGNvbnZlcnNhdGlvbnMgfSkpO1xuICAgIH1cbiAgICB0aGlzLmlzUmVzZXQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgYSBwYWdpbmF0aW9uIHJhdGhlciB0aGFuIGFuIGluaXRpYWwgcmVxdWVzdCBpZiB0aGVyZSBpcyBhbHJlYWR5IGRhdGE7IGdldCB0aGUgZnJvbUlkXG4gICAgLy8gd2hpY2ggaXMgdGhlIGlkIG9mIHRoZSBsYXN0IHJlc3VsdC5cbiAgICBjb25zdCBsYXN0Q29udmVyc2F0aW9uID0gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBsYXN0Q29udmVyc2F0aW9uSW5zdGFuY2UgPSAhbGFzdENvbnZlcnNhdGlvbiA/IG51bGwgOiB0aGlzLl9nZXRJbnN0YW5jZShsYXN0Q29udmVyc2F0aW9uKTtcbiAgICBjb25zdCBmcm9tSWQgPSAobGFzdENvbnZlcnNhdGlvbkluc3RhbmNlICYmIGxhc3RDb252ZXJzYXRpb25JbnN0YW5jZS5pc1NhdmVkKCkgP1xuICAgICAgJyZmcm9tX2lkPScgKyBsYXN0Q29udmVyc2F0aW9uSW5zdGFuY2UuaWQgOiAnJyk7XG4gICAgY29uc3Qgc29ydEJ5ID0gdGhpcy5fZ2V0U29ydEZpZWxkKCk7XG5cbiAgICB0aGlzLmlzRmlyaW5nID0gdHJ1ZTtcbiAgICBjb25zdCBmaXJpbmdSZXF1ZXN0ID0gdGhpcy5fZmlyaW5nUmVxdWVzdCA9IGBjb252ZXJzYXRpb25zP3NvcnRfYnk9JHtzb3J0Qnl9JnBhZ2Vfc2l6ZT0ke3BhZ2VTaXplfSR7ZnJvbUlkfWA7XG4gICAgdGhpcy5jbGllbnQueGhyKHtcbiAgICAgIHVybDogZmlyaW5nUmVxdWVzdCxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBzeW5jOiBmYWxzZSxcbiAgICB9LCByZXN1bHRzID0+IHRoaXMuX3Byb2Nlc3NSdW5SZXN1bHRzKHJlc3VsdHMsIGZpcmluZ1JlcXVlc3QpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzb3J0IGZpZWxkIGZvciB0aGUgcXVlcnkuXG4gICAqXG4gICAqIFJldHVybnMgT25lIG9mOlxuICAgKlxuICAgKiAqICdwb3NpdGlvbicgKE1lc3NhZ2VzIG9ubHkpXG4gICAqICogJ2xhc3RfbWVzc2FnZScgKENvbnZlcnNhdGlvbnMgb25seSlcbiAgICogKiAnY3JlYXRlZF9hdCcgKENvbnZlcnNhdGlvbnMgb25seSlcbiAgICogQG1ldGhvZCBfZ2V0U29ydEZpZWxkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0U29ydEZpZWxkKCkge1xuICAgIGlmICh0aGlzLm1vZGVsID09PSBNRVNTQUdFIHx8IHRoaXMubW9kZWwgPT09IEFOTk9VTkNFTUVOVCkgcmV0dXJuICdwb3NpdGlvbic7XG4gICAgaWYgKHRoaXMuc29ydEJ5ICYmIHRoaXMuc29ydEJ5WzBdICYmIHRoaXMuc29ydEJ5WzBdWydsYXN0TWVzc2FnZS5zZW50QXQnXSkgcmV0dXJuICdsYXN0X21lc3NhZ2UnO1xuICAgIHJldHVybiAnY3JlYXRlZF9hdCc7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBDb252ZXJzYXRpb24gVVVJRCBmcm9tIHRoZSBwcmVkaWNhdGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEV4dHJhY3QgdGhlIENvbnZlcnNhdGlvbidzIFVVSUQgZnJvbSB0aGUgcHJlZGljYXRlLi4uIG9yIHJldHVybmVkIHRoZSBjYWNoZWQgdmFsdWUuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldENvbnZlcnNhdGlvblVVSURcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDb252ZXJzYXRpb25QcmVkaWNhdGVJZHMoKSB7XG4gICAgaWYgKHRoaXMucHJlZGljYXRlLm1hdGNoKGZpbmRDb252SWRSZWdleCkpIHtcbiAgICAgIGNvbnN0IGNvbnZlcnNhdGlvbklkID0gdGhpcy5wcmVkaWNhdGUucmVwbGFjZShmaW5kQ29udklkUmVnZXgsICckMScpO1xuXG4gICAgICAvLyBXZSB3aWxsIGFscmVhZHkgaGF2ZSBhIHRoaXMuX3ByZWRpY2F0ZSBpZiB3ZSBhcmUgcGFnaW5nOyBlbHNlIHdlIG5lZWQgdG8gZXh0cmFjdCB0aGUgVVVJRCBmcm9tXG4gICAgICAvLyB0aGUgY29udmVyc2F0aW9uSWQuXG4gICAgICBjb25zdCB1dWlkID0gKHRoaXMuX3ByZWRpY2F0ZSB8fCBjb252ZXJzYXRpb25JZCkucmVwbGFjZSgvXmxheWVyXFw6XFwvXFwvXFwvY29udmVyc2F0aW9uc1xcLy8sICcnKTtcbiAgICAgIGlmICh1dWlkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdXVpZCxcbiAgICAgICAgICBpZDogY29udmVyc2F0aW9uSWQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBNZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBtZXRob2QgX3J1bk1lc3NhZ2VcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwYWdlU2l6ZSAtIE51bWJlciBvZiBuZXcgcmVzdWx0cyB0byByZXF1ZXN0XG4gICAqL1xuICBfcnVuTWVzc2FnZShwYWdlU2l6ZSkge1xuICAgIC8vIFRoaXMgaXMgYSBwYWdpbmF0aW9uIHJhdGhlciB0aGFuIGFuIGluaXRpYWwgcmVxdWVzdCBpZiB0aGVyZSBpcyBhbHJlYWR5IGRhdGE7IGdldCB0aGUgZnJvbUlkXG4gICAgLy8gd2hpY2ggaXMgdGhlIGlkIG9mIHRoZSBsYXN0IHJlc3VsdC5cbiAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHRoaXMuZGF0YVt0aGlzLmRhdGEubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgbGFzdE1lc3NhZ2VJbnN0YW5jZSA9ICFsYXN0TWVzc2FnZSA/IG51bGwgOiB0aGlzLl9nZXRJbnN0YW5jZShsYXN0TWVzc2FnZSk7XG4gICAgbGV0IGZyb21JZCA9IChsYXN0TWVzc2FnZUluc3RhbmNlICYmIGxhc3RNZXNzYWdlSW5zdGFuY2UuaXNTYXZlZCgpID8gJyZmcm9tX2lkPScgKyBsYXN0TWVzc2FnZUluc3RhbmNlLmlkIDogJycpO1xuICAgIGNvbnN0IHByZWRpY2F0ZUlkcyA9IHRoaXMuX2dldENvbnZlcnNhdGlvblByZWRpY2F0ZUlkcygpO1xuXG4gICAgLy8gRG8gbm90aGluZyBpZiB3ZSBkb24ndCBoYXZlIGEgY29udmVyc2F0aW9uIHRvIHF1ZXJ5IG9uXG4gICAgaWYgKHByZWRpY2F0ZUlkcykge1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uSWQgPSAnbGF5ZXI6Ly8vY29udmVyc2F0aW9ucy8nICsgcHJlZGljYXRlSWRzLnV1aWQ7XG4gICAgICBpZiAoIXRoaXMuX3ByZWRpY2F0ZSkgdGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlSWRzLmlkO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uID0gdGhpcy5jbGllbnQuZ2V0Q29udmVyc2F0aW9uKGNvbnZlcnNhdGlvbklkKTtcblxuICAgICAgLy8gSWYgbm8gZGF0YSwgcmV0cmlldmUgZGF0YSBmcm9tIGRiIGNhY2hlIGluIHBhcmFsbGVsIHdpdGggbG9hZGluZyBkYXRhIGZyb20gc2VydmVyXG4gICAgICBpZiAodGhpcy5pc1Jlc2V0KSB7XG4gICAgICAgIHRoaXMuY2xpZW50LmRiTWFuYWdlci5sb2FkTWVzc2FnZXMoY29udmVyc2F0aW9uSWQsIG1lc3NhZ2VzID0+IHRoaXMuX2FwcGVuZFJlc3VsdHMoeyBkYXRhOiBtZXNzYWdlcyB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzUmVzZXQgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlIG9ubHkgTWVzc2FnZSBpcyB0aGUgQ29udmVyc2F0aW9uJ3MgbGFzdE1lc3NhZ2UsIHRoZW4gd2UgcHJvYmFibHkgZ290IHRoaXNcbiAgICAgIC8vIHJlc3VsdCBmcm9tIGBHRVQgL2NvbnZlcnNhdGlvbnNgLCBhbmQgbm90IGZyb20gYEdFVCAvbWVzc2FnZXNgLiAgR2V0IEFMTCBNZXNzYWdlcyxcbiAgICAgIC8vIG5vdCBqdXN0IG1lc3NhZ2VzIGFmdGVyIHRoZSBgbGFzdE1lc3NhZ2VgIGlmIHdlJ3ZlIG5ldmVyIHJlY2VpdmVkIGFueSBtZXNzYWdlcyBmcm9tXG4gICAgICAvLyBgR0VUIC9tZXNzYWdlc2AgKHNhZmV0eSBjb2RlLCBub3QgcmVxdWlyZWQgY29kZSkuICBUaGlzIGFsc28gbWVhbnMgdGhhdCB0aGUgZmlyc3RcbiAgICAgIC8vIFF1ZXJ5IGdldHMgTUFYX1BBR0VfU0laRSByZXN1bHRzIGluc3RlYWQgb2YgTUFYX1BBR0VfU0laRSArIDEgcmVzdWx0cy5cbiAgICAgIGlmIChjb252ZXJzYXRpb24gJiYgY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlICYmXG4gICAgICAgICAgbGFzdE1lc3NhZ2UgJiYgbGFzdE1lc3NhZ2UuaWQgPT09IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5pZCkge1xuICAgICAgICBmcm9tSWQgPSAnJztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGxhc3QgbWVzc2FnZSB3ZSBoYXZlIGxvYWRlZCBpcyBhbHJlYWR5IHRoZSBDb252ZXJzYXRpb24ncyBsYXN0TWVzc2FnZSwgdGhlbiBqdXN0IHJlcXVlc3QgZGF0YSB3aXRob3V0IHBhZ2luZyxcbiAgICAgIC8vIGNvbW1vbiBvY2N1cmVuY2Ugd2hlbiBxdWVyeSBpcyBwb3B1bGF0ZWQgd2l0aCBvbmx5IGEgc2luZ2xlIHJlc3VsdDogY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLlxuICAgICAgLy8gaWYgKGNvbnZlcnNhdGlvbiAmJiBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgJiYgbGFzdE1lc3NhZ2UgJiYgbGFzdE1lc3NhZ2UuaWQgPT09IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5pZCkgZnJvbUlkID0gJyc7XG4gICAgICBjb25zdCBuZXdSZXF1ZXN0ID0gYGNvbnZlcnNhdGlvbnMvJHtwcmVkaWNhdGVJZHMudXVpZH0vbWVzc2FnZXM/cGFnZV9zaXplPSR7cGFnZVNpemV9JHtmcm9tSWR9YDtcblxuICAgICAgLy8gRG9uJ3QgcXVlcnkgb24gdW5zYXZlZCBjb252ZXJzYXRpb25zLCBub3IgcmVwZWF0IHN0aWxsIGZpcmluZyBxdWVyaWVzXG4gICAgICBpZiAoKCFjb252ZXJzYXRpb24gfHwgY29udmVyc2F0aW9uLmlzU2F2ZWQoKSkgJiYgbmV3UmVxdWVzdCAhPT0gdGhpcy5fZmlyaW5nUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmlzRmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZmlyaW5nUmVxdWVzdCA9IG5ld1JlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2xpZW50Lnhocih7XG4gICAgICAgICAgdXJsOiBuZXdSZXF1ZXN0LFxuICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgc3luYzogZmFsc2UsXG4gICAgICAgIH0sIHJlc3VsdHMgPT4gdGhpcy5fcHJvY2Vzc1J1blJlc3VsdHMocmVzdWx0cywgbmV3UmVxdWVzdCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcmVzdWx0cywgdGhlbiBpdHMgYSBuZXcgcXVlcnk7IGF1dG9tYXRpY2FsbHkgcG9wdWxhdGUgaXQgd2l0aCB0aGUgQ29udmVyc2F0aW9uJ3MgbGFzdE1lc3NhZ2UuXG4gICAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoY29udmVyc2F0aW9uICYmIGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IFt0aGlzLl9nZXREYXRhKGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSldO1xuICAgICAgICAgIC8vIFRyaWdnZXIgdGhlIGNoYW5nZSBldmVudFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2Uoe1xuICAgICAgICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5fZ2V0RGF0YShjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UpLFxuICAgICAgICAgICAgcXVlcnk6IHRoaXMsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5wcmVkaWNhdGUubWF0Y2goL1snXCJdLykpIHtcbiAgICAgIExvZ2dlci5lcnJvcignVGhpcyBxdWVyeSBtYXkgbmVlZCB0byBxdW90ZSBpdHMgdmFsdWUnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IE1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZCBfcnVuTWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhZ2VTaXplIC0gTnVtYmVyIG9mIG5ldyByZXN1bHRzIHRvIHJlcXVlc3RcbiAgICovXG4gIF9ydW5Bbm5vdW5jZW1lbnQocGFnZVNpemUpIHtcbiAgICAvLyBJZiBubyBkYXRhLCByZXRyaWV2ZSBkYXRhIGZyb20gZGIgY2FjaGUgaW4gcGFyYWxsZWwgd2l0aCBsb2FkaW5nIGRhdGEgZnJvbSBzZXJ2ZXJcbiAgICBpZiAodGhpcy5pc1Jlc2V0KSB7XG4gICAgICB0aGlzLmNsaWVudC5kYk1hbmFnZXIubG9hZEFubm91bmNlbWVudHMobWVzc2FnZXMgPT4gdGhpcy5fYXBwZW5kUmVzdWx0cyh7IGRhdGE6IG1lc3NhZ2VzIH0pKTtcbiAgICB9XG4gICAgdGhpcy5pc1Jlc2V0ID0gZmFsc2U7XG5cbiAgICAvLyBUaGlzIGlzIGEgcGFnaW5hdGlvbiByYXRoZXIgdGhhbiBhbiBpbml0aWFsIHJlcXVlc3QgaWYgdGhlcmUgaXMgYWxyZWFkeSBkYXRhOyBnZXQgdGhlIGZyb21JZFxuICAgIC8vIHdoaWNoIGlzIHRoZSBpZCBvZiB0aGUgbGFzdCByZXN1bHQuXG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmRhdGFbdGhpcy5kYXRhLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGxhc3RNZXNzYWdlSW5zdGFuY2UgPSAhbGFzdE1lc3NhZ2UgPyBudWxsIDogdGhpcy5fZ2V0SW5zdGFuY2UobGFzdE1lc3NhZ2UpO1xuICAgIGNvbnN0IGZyb21JZCA9IChsYXN0TWVzc2FnZUluc3RhbmNlICYmIGxhc3RNZXNzYWdlSW5zdGFuY2UuaXNTYXZlZCgpID8gJyZmcm9tX2lkPScgKyBsYXN0TWVzc2FnZUluc3RhbmNlLmlkIDogJycpO1xuXG4gICAgLy8gSWYgdGhlIGxhc3QgbWVzc2FnZSB3ZSBoYXZlIGxvYWRlZCBpcyBhbHJlYWR5IHRoZSBDb252ZXJzYXRpb24ncyBsYXN0TWVzc2FnZSwgdGhlbiBqdXN0IHJlcXVlc3QgZGF0YSB3aXRob3V0IHBhZ2luZyxcbiAgICAvLyBjb21tb24gb2NjdXJlbmNlIHdoZW4gcXVlcnkgaXMgcG9wdWxhdGVkIHdpdGggb25seSBhIHNpbmdsZSByZXN1bHQ6IGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZS5cbiAgICAvLyBpZiAoY29udmVyc2F0aW9uICYmIGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSAmJiBsYXN0TWVzc2FnZSAmJiBsYXN0TWVzc2FnZS5pZCA9PT0gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLmlkKSBmcm9tSWQgPSAnJztcbiAgICBjb25zdCBuZXdSZXF1ZXN0ID0gYGFubm91bmNlbWVudHM/cGFnZV9zaXplPSR7cGFnZVNpemV9JHtmcm9tSWR9YDtcblxuICAgIC8vIERvbid0IHJlcGVhdCBzdGlsbCBmaXJpbmcgcXVlcmllc1xuICAgIGlmIChuZXdSZXF1ZXN0ICE9PSB0aGlzLl9maXJpbmdSZXF1ZXN0KSB7XG4gICAgICB0aGlzLmlzRmlyaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZpcmluZ1JlcXVlc3QgPSBuZXdSZXF1ZXN0O1xuICAgICAgdGhpcy5jbGllbnQueGhyKHtcbiAgICAgICAgdXJsOiBuZXdSZXF1ZXN0LFxuICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICBzeW5jOiBmYWxzZSxcbiAgICAgIH0sIHJlc3VsdHMgPT4gdGhpcy5fcHJvY2Vzc1J1blJlc3VsdHMocmVzdWx0cywgbmV3UmVxdWVzdCkpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIHJlc3VsdHMgb2YgdGhlIGBfcnVuYCBtZXRob2Q7IGNhbGxzIF9fYXBwZW5kUmVzdWx0cy5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc1J1blJlc3VsdHNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHRzIC0gRnVsbCB4aHIgcmVzcG9uc2Ugb2JqZWN0IHdpdGggc2VydmVyIHJlc3VsdHNcbiAgICovXG4gIF9wcm9jZXNzUnVuUmVzdWx0cyhyZXN1bHRzLCByZXF1ZXN0VXJsKSB7XG4gICAgaWYgKHJlcXVlc3RVcmwgIT09IHRoaXMuX2ZpcmluZ1JlcXVlc3QgfHwgdGhpcy5pc0Rlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgdGhpcy5pc0ZpcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpcmluZ1JlcXVlc3QgPSAnJztcbiAgICBpZiAocmVzdWx0cy5zdWNjZXNzKSB7XG4gICAgICB0aGlzLl9hcHBlbmRSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgdGhpcy50b3RhbFNpemUgPSByZXN1bHRzLnhoci5nZXRSZXNwb25zZUhlYWRlcignTGF5ZXItQ291bnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicsIHsgZXJyb3I6IHJlc3VsdHMuZGF0YSB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBhcnJheXMgb2YgZGF0YSB0byB0aGUgUXVlcnkgcmVzdWx0cy5cbiAgICpcbiAgICogQG1ldGhvZCAgX2FwcGVuZFJlc3VsdHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBlbmRSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAvLyBGb3IgYWxsIHJlc3VsdHMsIHJlZ2lzdGVyIHRoZW0gd2l0aCB0aGUgY2xpZW50XG4gICAgLy8gSWYgYWxyZWFkeSByZWdpc3RlcmVkIHdpdGggdGhlIGNsaWVudCwgcHJvcGVydGllcyB3aWxsIGJlIHVwZGF0ZWQgYXMgbmVlZGVkXG4gICAgcmVzdWx0cy5kYXRhLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJvb3QpIHJldHVybiBpdGVtO1xuICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Ll9jcmVhdGVPYmplY3QoaXRlbSk7XG4gICAgfSk7XG5cbiAgICAvLyBGaWx0ZXIgcmVzdWx0cyB0byBqdXN0IHRoZSBuZXcgcmVzdWx0c1xuICAgIGNvbnN0IG5ld1Jlc3VsdHMgPSByZXN1bHRzLmRhdGEuZmlsdGVyKGl0ZW0gPT4gdGhpcy5fZ2V0SW5kZXgoaXRlbS5pZCkgPT09IC0xKTtcblxuICAgIC8vIFVwZGF0ZSB0aGlzLmRhdGFcbiAgICBpZiAodGhpcy5kYXRhVHlwZSA9PT0gUXVlcnkuT2JqZWN0RGF0YVR5cGUpIHtcbiAgICAgIHRoaXMuZGF0YSA9IFtdLmNvbmNhdCh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIG5ld1Jlc3VsdHMuZm9yRWFjaChpdGVtSW4gPT4ge1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY2xpZW50Ll9nZXRPYmplY3QoaXRlbUluLmlkKTtcbiAgICAgIGlmICh0aGlzLm1vZGVsID09PSBNRVNTQUdFIHx8IHRoaXMubW9kZWwgPT09IEFOTk9VTkNFTUVOVCkge1xuICAgICAgICBpbmRleCA9IHRoaXMuX2dldEluc2VydE1lc3NhZ2VJbmRleChpdGVtLCBkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZ2V0SW5zZXJ0Q29udmVyc2F0aW9uSW5kZXgoaXRlbSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBkYXRhLnNwbGljZShpbmRleCwgMCwgdGhpcy5fZ2V0RGF0YShpdGVtKSk7XG4gICAgfSk7XG5cblxuICAgIC8vIFRyaWdnZXIgdGhlIGNoYW5nZSBldmVudFxuICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2Uoe1xuICAgICAgdHlwZTogJ2RhdGEnLFxuICAgICAgZGF0YTogbmV3UmVzdWx0cy5tYXAoaXRlbSA9PiB0aGlzLl9nZXREYXRhKHRoaXMuY2xpZW50Ll9nZXRPYmplY3QoaXRlbS5pZCkpKSxcbiAgICAgIHF1ZXJ5OiB0aGlzLFxuICAgICAgdGFyZ2V0OiB0aGlzLmNsaWVudCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29ycmVjdGx5IGZvcm1hdHRlZCBvYmplY3QgcmVwcmVzZW50aW5nIGEgcmVzdWx0LlxuICAgKlxuICAgKiBGb3JtYXQgaXMgc3BlY2lmaWVkIGJ5IHRoZSBgZGF0YVR5cGVgIHByb3BlcnR5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9nZXREYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLlJvb3R9IGl0ZW0gLSBDb252ZXJzYXRpb24gb3IgTWVzc2FnZSBpbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQ29udmVyc2F0aW9uIG9yIE1lc3NhZ2UgaW5zdGFuY2Ugb3IgT2JqZWN0XG4gICAqL1xuICBfZ2V0RGF0YShpdGVtKSB7XG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgPT09IFF1ZXJ5Lk9iamVjdERhdGFUeXBlKSB7XG4gICAgICByZXR1cm4gaXRlbS50b09iamVjdCgpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgaW5wdXQgaXMgaW5zdGFuY2Ugb3Igb2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5Sb290fE9iamVjdH0gaXRlbSAtIENvbnZlcnNhdGlvbiBvciBNZXNzYWdlIG9iamVjdC9pbnN0YW5jZVxuICAgKiBAcmV0dXJuIHtsYXllci5Sb290fVxuICAgKi9cbiAgX2dldEluc3RhbmNlKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFJvb3QpIHJldHVybiBpdGVtO1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5fZ2V0T2JqZWN0KGl0ZW0uaWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzayB0aGUgcXVlcnkgZm9yIHRoZSBpdGVtIG1hdGNoaW5nIHRoZSBJRC5cbiAgICpcbiAgICogUmV0dXJucyB1bmRlZmluZWQgaWYgdGhlIElEIGlzIG5vdCBmb3VuZC5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0SXRlbVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkXG4gICAqIEByZXR1cm4ge09iamVjdH0gQ29udmVyc2F0aW9uIG9yIE1lc3NhZ2Ugb2JqZWN0IG9yIGluc3RhbmNlXG4gICAqL1xuICBfZ2V0SXRlbShpZCkge1xuICAgIHN3aXRjaCAoVXRpbC50eXBlRnJvbUlEKGlkKSkge1xuICAgICAgY2FzZSAnYW5ub3VuY2VtZW50cyc6XG4gICAgICAgIGlmICh0aGlzLm1vZGVsID09PSBBTk5PVU5DRU1FTlQpIHtcbiAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2dldEluZGV4KGlkKTtcbiAgICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHRoaXMuZGF0YVtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgIGlmICh0aGlzLm1vZGVsID09PSBNRVNTQUdFKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9nZXRJbmRleChpZCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZWwgPT09IENPTlZFUlNBVElPTikge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb252ZXJzYXRpb24gPSB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbi5sYXN0TWVzc2FnZSAmJiBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UuaWQgPT09IGlkKSByZXR1cm4gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NvbnZlcnNhdGlvbnMnOlxuICAgICAgICBpZiAodGhpcy5tb2RlbCA9PT0gQ09OVkVSU0FUSU9OKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9nZXRJbmRleChpZCk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB0aGlzLmRhdGFbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGluZGV4IG9mIHRoZSBpdGVtIHJlcHJlc2VudGVkIGJ5IHRoZSBzcGVjaWZpZWQgSUQ7IG9yIHJldHVybiAtMS5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0SW5kZXhcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBfZ2V0SW5kZXgoaWQpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5kYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtpbmRleF0uaWQgPT09IGlkKSByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYW55IGNoYW5nZSBldmVudCByZWNlaXZlZCBmcm9tIHRoZSBsYXllci5DbGllbnQuXG4gICAqXG4gICAqIFRoZXNlIGNhbiBiZSBjYXVzZWQgYnkgd2Vic29ja2V0IGV2ZW50cywgYXMgd2VsbCBhcyBsb2NhbFxuICAgKiByZXF1ZXN0cyB0byBjcmVhdGUvZGVsZXRlL21vZGlmeSBDb252ZXJzYXRpb25zIGFuZCBNZXNzYWdlcy5cbiAgICpcbiAgICogVGhlIGV2ZW50IGRvZXMgbm90IG5lY2Vzc2FyaWx5IGFwcGx5IHRvIHRoaXMgUXVlcnksIGJ1dCB0aGUgUXVlcnlcbiAgICogbXVzdCBleGFtaW5lIGl0IHRvIGRldGVybWluZSBpZiBpdCBhcHBsaWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVDaGFuZ2VFdmVudHNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFwibWVzc2FnZXM6YWRkXCIsIFwiY29udmVyc2F0aW9uczpjaGFuZ2VcIlxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgX2hhbmRsZUNoYW5nZUV2ZW50cyhldmVudE5hbWUsIGV2dCkge1xuICAgIGlmICh0aGlzLm1vZGVsID09PSBDT05WRVJTQVRJT04pIHtcbiAgICAgIHRoaXMuX2hhbmRsZUNvbnZlcnNhdGlvbkV2ZW50cyhldnQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlbCA9PT0gTUVTU0FHRSB8fCB0aGlzLm1vZGVsID09PSBBTk5PVU5DRU1FTlQpIHtcbiAgICAgIHRoaXMuX2hhbmRsZU1lc3NhZ2VFdmVudHMoZXZ0KTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlQ29udmVyc2F0aW9uRXZlbnRzKGV2dCkge1xuICAgIHN3aXRjaCAoZXZ0LmV2ZW50TmFtZSkge1xuXG4gICAgICAvLyBJZiBhIENvbnZlcnNhdGlvbidzIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIENvbnZlcnNhdGlvbiBpcyBpbiB0aGlzXG4gICAgICAvLyBRdWVyeSdzIGRhdGEsIHRoZW4gdXBkYXRlIGl0LlxuICAgICAgY2FzZSAnY29udmVyc2F0aW9uczpjaGFuZ2UnOlxuICAgICAgICB0aGlzLl9oYW5kbGVDb252ZXJzYXRpb25DaGFuZ2VFdmVudChldnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSWYgYSBDb252ZXJzYXRpb24gaXMgYWRkZWQsIGFuZCBpdCBpc24ndCBhbHJlYWR5IGluIHRoZSBRdWVyeSxcbiAgICAgIC8vIGFkZCBpdCBhbmQgdHJpZ2dlciBhbiBldmVudFxuICAgICAgY2FzZSAnY29udmVyc2F0aW9uczphZGQnOlxuICAgICAgICB0aGlzLl9oYW5kbGVDb252ZXJzYXRpb25BZGRFdmVudChldnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSWYgYSBDb252ZXJzYXRpb24gaXMgZGVsZXRlZCwgYW5kIGl0cyBzdGlsbCBpbiBvdXIgZGF0YSxcbiAgICAgIC8vIHJlbW92ZSBpdCBhbmQgdHJpZ2dlciBhbiBldmVudC5cbiAgICAgIGNhc2UgJ2NvbnZlcnNhdGlvbnM6cmVtb3ZlJzpcbiAgICAgICAgdGhpcy5faGFuZGxlQ29udmVyc2F0aW9uUmVtb3ZlRXZlbnQoZXZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETyBXRUItOTY4OiBSZWZhY3RvciB0aGlzIGludG8gZnVuY3Rpb25zIGZvciBpbnN0YW5jZSwgb2JqZWN0LCBzb3J0QnkgY3JlYXRlZEF0LCBzb3J0QnkgbGFzdE1lc3NhZ2VcbiAgX2hhbmRsZUNvbnZlcnNhdGlvbkNoYW5nZUV2ZW50KGV2dCkge1xuICAgIGxldCBpbmRleCA9IHRoaXMuX2dldEluZGV4KGV2dC50YXJnZXQuaWQpO1xuXG4gICAgLy8gSWYgaXRzIGFuIElEIGNoYW5nZSAobWF0Y2hpbmcgRGlzdGluY3QgQ29udmVyc2F0aW9uIHJldHVybmVkIGJ5IHNlcnZlcikgbWFrZSBzdXJlIHRvIHVwZGF0ZSBvdXIgZGF0YS5cbiAgICAvLyBJZiBkYXRhVHlwZSBpcyBhbiBpbnN0YW5jZSwgaXRzIGJlZW4gdXBkYXRlZCBmb3IgdXMuXG4gICAgaWYgKHRoaXMuZGF0YVR5cGUgPT09IFF1ZXJ5Lk9iamVjdERhdGFUeXBlKSB7XG4gICAgICBjb25zdCBpZENoYW5nZXMgPSBldnQuZ2V0Q2hhbmdlc0ZvcignaWQnKTtcbiAgICAgIGlmIChpZENoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoaWRDaGFuZ2VzWzBdLm9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBkYXRhVHlwZSBpcyBcIm9iamVjdFwiIHRoZW4gdXBkYXRlIHRoZSBvYmplY3QgYW5kIG91ciBhcnJheTtcbiAgICAvLyBlbHNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSB1cGRhdGVkLlxuICAgIC8vIElnbm9yZSByZXN1bHRzIHRoYXQgYXJlbid0IGFscmVhZHkgaW4gb3VyIGRhdGE7IFJlc3VsdHMgYXJlIGFkZGVkIHZpYVxuICAgIC8vIGNvbnZlcnNhdGlvbnM6YWRkIGV2ZW50cy4gIFdlYnNvY2tldCBNYW5hZ2VyIGF1dG9tYXRpY2FsbHkgbG9hZHMgYW55dGhpbmcgdGhhdCByZWNlaXZlcyBhbiBldmVudFxuICAgIC8vIGZvciB3aGljaCB3ZSBoYXZlIG5vIG9iamVjdCwgc28gd2UnbGwgZ2V0IHRoZSBhZGQgZXZlbnQgYXQgdGhhdCB0aW1lLlxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IHNvcnRGaWVsZCA9IHRoaXMuX2dldFNvcnRGaWVsZCgpO1xuICAgICAgY29uc3QgcmVvcmRlciA9IGV2dC5oYXNQcm9wZXJ0eSgnbGFzdE1lc3NhZ2UnKSAmJiBzb3J0RmllbGQgPT09ICdsYXN0X21lc3NhZ2UnO1xuXG4gICAgICBpZiAodGhpcy5kYXRhVHlwZSA9PT0gUXVlcnkuT2JqZWN0RGF0YVR5cGUpIHtcbiAgICAgICAgaWYgKCFyZW9yZGVyKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY2hhbmdlZCBDb252ZXJzYXRpb24gd2l0aCBhIG5ldyBpbW11dGFibGUgb2JqZWN0XG4gICAgICAgICAgdGhpcy5kYXRhID0gW1xuICAgICAgICAgICAgLi4udGhpcy5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgIGV2dC50YXJnZXQudG9PYmplY3QoKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZGF0YS5zbGljZShpbmRleCArIDEpLFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9nZXRJbnNlcnRDb252ZXJzYXRpb25JbmRleChldnQudGFyZ2V0LCB0aGlzLmRhdGEpO1xuICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UobmV3SW5kZXgsIDAsIHRoaXMuX2dldERhdGEoZXZ0LnRhcmdldCkpO1xuICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5jb25jYXQoW10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVsc2UgZGF0YVR5cGUgaXMgaW5zdGFuY2Ugbm90IG9iamVjdFxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChyZW9yZGVyKSB7XG4gICAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9nZXRJbnNlcnRDb252ZXJzYXRpb25JbmRleChldnQudGFyZ2V0LCB0aGlzLmRhdGEpO1xuICAgICAgICAgIGlmIChuZXdJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNwbGljZShuZXdJbmRleCwgMCwgZXZ0LnRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgYSAncHJvcGVydHknIGV2ZW50XG4gICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlKHtcbiAgICAgICAgdHlwZTogJ3Byb3BlcnR5JyxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9nZXREYXRhKGV2dC50YXJnZXQpLFxuICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgaXNDaGFuZ2U6IHRydWUsXG4gICAgICAgIGNoYW5nZXM6IGV2dC5jaGFuZ2VzLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgX2dldEluc2VydENvbnZlcnNhdGlvbkluZGV4KGNvbnZlcnNhdGlvbiwgZGF0YSkge1xuICAgIGNvbnN0IHNvcnRGaWVsZCA9IHRoaXMuX2dldFNvcnRGaWVsZCgpO1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoc29ydEZpZWxkID09PSAnY3JlYXRlZF9hdCcpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChjb252ZXJzYXRpb24uY3JlYXRlZEF0ID49IGRhdGFbaW5kZXhdLmNyZWF0ZWRBdCkgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGQxID0gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlID8gY29udmVyc2F0aW9uLmxhc3RNZXNzYWdlLnNlbnRBdCA6IGNvbnZlcnNhdGlvbi5jcmVhdGVkQXQ7XG4gICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBkMiA9IGRhdGFbaW5kZXhdLmxhc3RNZXNzYWdlID8gZGF0YVtpbmRleF0ubGFzdE1lc3NhZ2Uuc2VudEF0IDogZGF0YVtpbmRleF0uY3JlYXRlZEF0O1xuICAgICAgICBpZiAoZDEgPj0gZDIpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuXG4gIF9nZXRJbnNlcnRNZXNzYWdlSW5kZXgobWVzc2FnZSwgZGF0YSkge1xuICAgIGxldCBpbmRleDtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBkYXRhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKG1lc3NhZ2UucG9zaXRpb24gPiBkYXRhW2luZGV4XS5wb3NpdGlvbikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cblxuICBfaGFuZGxlQ29udmVyc2F0aW9uQWRkRXZlbnQoZXZ0KSB7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgQ29udmVyc2F0aW9ucyBhbHJlYWR5IGluIG91ciBkYXRhXG4gICAgY29uc3QgbGlzdCA9IGV2dC5jb252ZXJzYXRpb25zXG4gICAgICAgICAgICAgICAgICAuZmlsdGVyKGNvbnZlcnNhdGlvbiA9PiB0aGlzLl9nZXRJbmRleChjb252ZXJzYXRpb24uaWQpID09PSAtMSk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBsaXN0LmZvckVhY2goY29udmVyc2F0aW9uID0+IHtcbiAgICAgICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9nZXRJbnNlcnRDb252ZXJzYXRpb25JbmRleChjb252ZXJzYXRpb24sIGRhdGEpO1xuICAgICAgICBkYXRhLnNwbGljZShuZXdJbmRleCwgMCwgdGhpcy5fZ2V0RGF0YShjb252ZXJzYXRpb24pKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXaGV0aGVyIHNvcnRpbmcgYnkgbGFzdF9tZXNzYWdlIG9yIGNyZWF0ZWRfYXQsIG5ldyByZXN1bHRzIGdvIGF0IHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgIGlmICh0aGlzLmRhdGFUeXBlID09PSBRdWVyeS5PYmplY3REYXRhVHlwZSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBbXS5jb25jYXQoZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsU2l6ZSArPSBsaXN0Lmxlbmd0aDtcblxuICAgICAgLy8gVHJpZ2dlciBhbiAnaW5zZXJ0JyBldmVudCBmb3IgZWFjaCBpdGVtIGFkZGVkO1xuICAgICAgLy8gdHlwaWNhbGx5IGJ1bGsgaW5zZXJ0cyBoYXBwZW4gdmlhIF9hcHBlbmRSZXN1bHRzKCkuXG4gICAgICBsaXN0LmZvckVhY2goKGNvbnZlcnNhdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0RGF0YShjb252ZXJzYXRpb24pO1xuICAgICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlKHtcbiAgICAgICAgICB0eXBlOiAnaW5zZXJ0JyxcbiAgICAgICAgICBpbmRleDogdGhpcy5kYXRhLmluZGV4T2YoaXRlbSksXG4gICAgICAgICAgdGFyZ2V0OiBpdGVtLFxuICAgICAgICAgIHF1ZXJ5OiB0aGlzLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG5cbiAgX2hhbmRsZUNvbnZlcnNhdGlvblJlbW92ZUV2ZW50KGV2dCkge1xuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICBldnQuY29udmVyc2F0aW9ucy5mb3JFYWNoKGNvbnZlcnNhdGlvbiA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2dldEluZGV4KGNvbnZlcnNhdGlvbi5pZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgICAgZGF0YTogY29udmVyc2F0aW9uLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVR5cGUgPT09IFF1ZXJ5Lk9iamVjdERhdGFUeXBlKSB7XG4gICAgICAgICAgdGhpcy5kYXRhID0gWy4uLnRoaXMuZGF0YS5zbGljZSgwLCBpbmRleCksIC4uLnRoaXMuZGF0YS5zbGljZShpbmRleCArIDEpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy50b3RhbFNpemUgLT0gcmVtb3ZlZC5sZW5ndGg7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHJlbW92ZWRPYmogPT4ge1xuICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICBpbmRleDogcmVtb3ZlZE9iai5pbmRleCxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLl9nZXREYXRhKHJlbW92ZWRPYmouZGF0YSksXG4gICAgICAgIHF1ZXJ5OiB0aGlzLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfaGFuZGxlTWVzc2FnZUV2ZW50cyhldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC5ldmVudE5hbWUpIHtcblxuICAgICAgLy8gSWYgYSBDb252ZXJzYXRpb24ncyBJRCBoYXMgY2hhbmdlZCwgY2hlY2sgb3VyIHByZWRpY2F0ZSwgYW5kIHVwZGF0ZSBpdCBhdXRvbWF0aWNhbGx5IGlmIG5lZWRlZC5cbiAgICAgIGNhc2UgJ2NvbnZlcnNhdGlvbnM6Y2hhbmdlJzpcbiAgICAgICAgaWYgKHRoaXMubW9kZWwgPT09IE1FU1NBR0UpIHRoaXMuX2hhbmRsZU1lc3NhZ2VDb252SWRDaGFuZ2VFdmVudChldnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gSWYgYSBNZXNzYWdlIGhhcyBjaGFuZ2VkIGFuZCBpdHMgaW4gb3VyIHJlc3VsdCBzZXQsIHJlcGxhY2VcbiAgICAgIC8vIGl0IHdpdGggYSBuZXcgaW1tdXRhYmxlIG9iamVjdFxuICAgICAgY2FzZSAnbWVzc2FnZXM6Y2hhbmdlJzpcbiAgICAgIGNhc2UgJ21lc3NhZ2VzOnJlYWQnOlxuICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlQ2hhbmdlRXZlbnQoZXZ0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIElmIE1lc3NhZ2VzIGFyZSBhZGRlZCwgYW5kIHRoZXkgYXJlbid0IGFscmVhZHkgaW4gb3VyIHJlc3VsdCBzZXRcbiAgICAgIC8vIGFkZCB0aGVtLlxuICAgICAgY2FzZSAnbWVzc2FnZXM6YWRkJzpcbiAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZUFkZEV2ZW50KGV2dCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBJZiBhIE1lc3NhZ2UgaXMgZGVsZXRlZCBhbmQgaXRzIGluIG91ciByZXN1bHQgc2V0LCByZW1vdmUgaXRcbiAgICAgIC8vIGFuZCB0cmlnZ2VyIGFuIGV2ZW50XG4gICAgICBjYXNlICdtZXNzYWdlczpyZW1vdmUnOlxuICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlUmVtb3ZlRXZlbnQoZXZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEEgQ29udmVyc2F0aW9uIElEIGNoYW5nZXMgaWYgYSBtYXRjaGluZyBEaXN0aW5jdCBDb252ZXJzYXRpb24gd2FzIGZvdW5kIG9uIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIElmIHRoaXMgUXVlcnkncyBDb252ZXJzYXRpb24ncyBJRCBoYXMgY2hhbmdlZCwgdXBkYXRlIHRoZSBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZU1lc3NhZ2VDb252SWRDaGFuZ2VFdmVudFxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dCAtIEEgTWVzc2FnZSBDaGFuZ2UgRXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYW5kbGVNZXNzYWdlQ29udklkQ2hhbmdlRXZlbnQoZXZ0KSB7XG4gICAgY29uc3QgY2lkQ2hhbmdlcyA9IGV2dC5nZXRDaGFuZ2VzRm9yKCdpZCcpO1xuICAgIGlmIChjaWRDaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuX3ByZWRpY2F0ZSA9PT0gY2lkQ2hhbmdlc1swXS5vbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLl9wcmVkaWNhdGUgPSBjaWRDaGFuZ2VzWzBdLm5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IFwiY29udmVyc2F0aW9uLmlkID0gJ1wiICsgdGhpcy5fcHJlZGljYXRlICsgXCInXCI7XG4gICAgICAgIHRoaXMuX3J1bigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgSUQgb2YgdGhlIG1lc3NhZ2UgaGFzIGNoYW5nZWQsIHRoZW4gdGhlIHBvc2l0aW9uIHByb3BlcnR5IGhhcyBsaWtlbHkgY2hhbmdlZCBhcyB3ZWxsLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB0ZXN0cyB0byBzZWUgaWYgY2hhbmdlcyB0byB0aGUgcG9zaXRpb24gcHJvcGVydHkgaGF2ZSBpbXBhY3RlZCB0aGUgbWVzc2FnZSdzIHBvc2l0aW9uIGluIHRoZVxuICAgKiBkYXRhIGFycmF5Li4uIGFuZCB1cGRhdGVzIHRoZSBhcnJheSBpZiBpdCBoYXMuXG4gICAqXG4gICAqIEBtZXRob2QgX2hhbmRsZU1lc3NhZ2VQb3NpdGlvbkNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dCAgQSBNZXNzYWdlIENoYW5nZSBldmVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggIEluZGV4IG9mIHRoZSBtZXNzYWdlIGluIHRoZSBjdXJyZW50IGRhdGEgYXJyYXlcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIGRhdGEgd2FzIGNoYW5nZWQgYW5kIGEgY2hhbmdlIGV2ZW50IHdhcyBlbWl0dGVkXG4gICAqL1xuICBfaGFuZGxlTWVzc2FnZVBvc2l0aW9uQ2hhbmdlKGV2dCwgaW5kZXgpIHtcbiAgICAvLyBJZiB0aGUgbWVzc2FnZSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgZGF0YSwgdGhlbiB0aGVyZSBpcyBubyBjaGFuZ2UgdG8gb3VyIHF1ZXJ5IHJlc3VsdHMuXG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IHdpdGhvdXQgb3VyIGRhdGEgaXRlbSBhbmQgdGhlbiBmaW5kIG91dCB3aGVyZSB0aGUgZGF0YSBpdGVtIFNob3VsZCBiZSBpbnNlcnRlZC5cbiAgICAvLyBOb3RlOiB3ZSBjb3VsZCBqdXN0IGxvb2t1cCB0aGUgcG9zaXRpb24gaW4gb3VyIGN1cnJlbnQgZGF0YSBhcnJheSwgYnV0IGl0cyB0b28gZWFzeSB0byBpbnRyb2R1Y2VcbiAgICAvLyBlcnJvcnMgd2hlcmUgY29tcGFyaW5nIHRoaXMgbWVzc2FnZSB0byBpdHNlbGYgbWF5IHlpZWxkIGluZGV4IG9yIGluZGV4ICsgMS5cbiAgICBjb25zdCBuZXdEYXRhID0gW1xuICAgICAgLi4udGhpcy5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgIC4uLnRoaXMuZGF0YS5zbGljZShpbmRleCArIDEpLFxuICAgIF07XG4gICAgY29uc3QgbmV3SW5kZXggPSB0aGlzLl9nZXRJbnNlcnRNZXNzYWdlSW5kZXgoZXZ0LnRhcmdldCwgbmV3RGF0YSk7XG5cbiAgICAvLyBJZiB0aGUgZGF0YSBpdGVtIGdvZXMgaW4gdGhlIHNhbWUgaW5kZXggYXMgYmVmb3JlLCB0aGVuIHRoZXJlIGlzIG5vIGNoYW5nZSB0byBiZSBoYW5kbGVkIGhlcmU7XG4gICAgLy8gZWxzZSBpbnNlcnQgdGhlIGl0ZW0gYXQgdGhlIHJpZ2h0IGluZGV4LCB1cGRhdGUgdGhpcy5kYXRhIGFuZCBmaXJlIGEgY2hhbmdlIGV2ZW50XG4gICAgaWYgKG5ld0luZGV4ICE9PSBpbmRleCkge1xuICAgICAgbmV3RGF0YS5zcGxpY2UobmV3SW5kZXgsIDAsIHRoaXMuX2dldERhdGEoZXZ0LnRhcmdldCkpO1xuICAgICAgdGhpcy5kYXRhID0gbmV3RGF0YTtcbiAgICAgIHRoaXMuX3RyaWdnZXJDaGFuZ2Uoe1xuICAgICAgICB0eXBlOiAncHJvcGVydHknLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuX2dldERhdGEoZXZ0LnRhcmdldCksXG4gICAgICAgIHF1ZXJ5OiB0aGlzLFxuICAgICAgICBpc0NoYW5nZTogdHJ1ZSxcbiAgICAgICAgY2hhbmdlczogZXZ0LmNoYW5nZXMsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVNZXNzYWdlQ2hhbmdlRXZlbnQoZXZ0KSB7XG4gICAgbGV0IGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgoZXZ0LnRhcmdldC5pZCk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VzID0gZXZ0LmdldENoYW5nZXNGb3IoJ3Bvc2l0aW9uJyk7XG5cbiAgICAvLyBJZiB0aGVyZSBhcmUgcG9zaXRpb24gY2hhbmdlcywgaGFuZGxlIHRoZW0uICBJZiBhbGwgdGhlIGNoYW5nZXMgYXJlIHBvc2l0aW9uIGNoYW5nZXMsXG4gICAgLy8gZXhpdCB3aGVuIGRvbmUuXG4gICAgaWYgKHBvc2l0aW9uQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9oYW5kbGVNZXNzYWdlUG9zaXRpb25DaGFuZ2UoZXZ0LCBpbmRleCkpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlcy5sZW5ndGggPT09IGV2dC5jaGFuZ2VzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICBpbmRleCA9IHRoaXMuX2dldEluZGV4KGV2dC50YXJnZXQuaWQpOyAvLyBHZXQgdGhlIHVwZGF0ZWQgcG9zaXRpb25cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAodGhpcy5kYXRhVHlwZSA9PT0gUXVlcnkuT2JqZWN0RGF0YVR5cGUpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW1xuICAgICAgICAgIC4uLnRoaXMuZGF0YS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgZXZ0LnRhcmdldC50b09iamVjdCgpLFxuICAgICAgICAgIC4uLnRoaXMuZGF0YS5zbGljZShpbmRleCArIDEpLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZSh7XG4gICAgICAgIHR5cGU6ICdwcm9wZXJ0eScsXG4gICAgICAgIHRhcmdldDogdGhpcy5fZ2V0RGF0YShldnQudGFyZ2V0KSxcbiAgICAgICAgcXVlcnk6IHRoaXMsXG4gICAgICAgIGlzQ2hhbmdlOiB0cnVlLFxuICAgICAgICBjaGFuZ2VzOiBldnQuY2hhbmdlcyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVNZXNzYWdlQWRkRXZlbnQoZXZ0KSB7XG4gICAgLy8gT25seSB1c2UgYWRkZWQgbWVzc2FnZXMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIENvbnZlcnNhdGlvblxuICAgIC8vIGFuZCBub3QgYWxyZWFkeSBpbiBvdXIgcmVzdWx0IHNldFxuICAgIGNvbnN0IGxpc3QgPSBldnQubWVzc2FnZXNcbiAgICAgIC5maWx0ZXIobWVzc2FnZSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBVdGlsLnR5cGVGcm9tSUQobWVzc2FnZS5pZCk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnbWVzc2FnZXMnICYmIHRoaXMubW9kZWwgPT09IE1FU1NBR0UgfHxcbiAgICAgICAgICAgICAgICB0eXBlID09PSAnYW5ub3VuY2VtZW50cycgJiYgdGhpcy5tb2RlbCA9PT0gQU5OT1VOQ0VNRU5UO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIobWVzc2FnZSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBVdGlsLnR5cGVGcm9tSUQobWVzc2FnZS5pZCk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnYW5ub3VuY2VtZW50cycgfHwgbWVzc2FnZS5jb252ZXJzYXRpb25JZCA9PT0gdGhpcy5fcHJlZGljYXRlO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIobWVzc2FnZSA9PiB0aGlzLl9nZXRJbmRleChtZXNzYWdlLmlkKSA9PT0gLTEpXG4gICAgICAubWFwKG1lc3NhZ2UgPT4gdGhpcy5fZ2V0RGF0YShtZXNzYWdlKSk7XG5cbiAgICAvLyBBZGQgdGhlbSB0byBvdXIgcmVzdWx0IHNldCBhbmQgdHJpZ2dlciBhbiBldmVudCBmb3IgZWFjaCBvbmVcbiAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEgPSB0aGlzLmRhdGFUeXBlID09PSBRdWVyeS5PYmplY3REYXRhVHlwZSA/IFtdLmNvbmNhdCh0aGlzLmRhdGEpIDogdGhpcy5kYXRhO1xuICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2dldEluc2VydE1lc3NhZ2VJbmRleChpdGVtLCBkYXRhKTtcbiAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDAsIGl0ZW0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudG90YWxTaXplICs9IGxpc3QubGVuZ3RoO1xuXG4gICAgICAvLyBJbmRleCBjYWxjdWxhdGVkIGFib3ZlIG1heSBzaGlmdCBhZnRlciBhZGRpdGlvbmFsIGluc2VydGlvbnMuICBUaGlzIGhhc1xuICAgICAgLy8gdG8gYmUgZG9uZSBhZnRlciB0aGUgYWJvdmUgaW5zZXJ0aW9ucyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIGxpc3QuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydCcsXG4gICAgICAgICAgaW5kZXg6IHRoaXMuZGF0YS5pbmRleE9mKGl0ZW0pLFxuICAgICAgICAgIHRhcmdldDogaXRlbSxcbiAgICAgICAgICBxdWVyeTogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTWVzc2FnZVJlbW92ZUV2ZW50KGV2dCkge1xuICAgIGNvbnN0IHJlbW92ZWQgPSBbXTtcbiAgICBldnQubWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ2V0SW5kZXgobWVzc2FnZS5pZCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHJlbW92ZWQucHVzaCh7XG4gICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmRhdGFUeXBlID09PSBRdWVyeS5PYmplY3REYXRhVHlwZSkge1xuICAgICAgICAgIHRoaXMuZGF0YSA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuZGF0YS5zbGljZSgwLCBpbmRleCksXG4gICAgICAgICAgICAuLi50aGlzLmRhdGEuc2xpY2UoaW5kZXggKyAxKSxcbiAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnRvdGFsU2l6ZSAtPSByZW1vdmVkLmxlbmd0aDtcbiAgICByZW1vdmVkLmZvckVhY2gocmVtb3ZlZE9iaiA9PiB7XG4gICAgICB0aGlzLl90cmlnZ2VyQ2hhbmdlKHtcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICAgIHRhcmdldDogdGhpcy5fZ2V0RGF0YShyZW1vdmVkT2JqLmRhdGEpLFxuICAgICAgICBpbmRleDogcmVtb3ZlZE9iai5pbmRleCxcbiAgICAgICAgcXVlcnk6IHRoaXMsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF90cmlnZ2VyQ2hhbmdlKGV2dCkge1xuICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgZXZ0KTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgZXZ0LnR5cGUsIGV2dCk7XG4gIH1cbn1cblxuXG5RdWVyeS5wcmVmaXhVVUlEID0gJ2xheWVyOi8vL3F1ZXJpZXMvJztcblxuLyoqXG4gKiBRdWVyeSBmb3IgQ29udmVyc2F0aW9ucy5cbiAqXG4gKiBVc2UgdGhpcyB2YWx1ZSBpbiB0aGUgbW9kZWwgcHJvcGVydHkuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQHN0YXRpY1xuICovXG5RdWVyeS5Db252ZXJzYXRpb24gPSBDT05WRVJTQVRJT047XG5cbi8qKlxuICogUXVlcnkgZm9yIE1lc3NhZ2VzLlxuICpcbiAqIFVzZSB0aGlzIHZhbHVlIGluIHRoZSBtb2RlbCBwcm9wZXJ0eS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblF1ZXJ5Lk1lc3NhZ2UgPSBNRVNTQUdFO1xuXG4vKipcbiAqIFF1ZXJ5IGZvciBBbm5vdW5jZW1lbnRzLlxuICpcbiAqIFVzZSB0aGlzIHZhbHVlIGluIHRoZSBtb2RlbCBwcm9wZXJ0eS5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblF1ZXJ5LkFubm91bmNlbWVudCA9IEFOTk9VTkNFTUVOVDtcblxuLyoqXG4gKiBHZXQgZGF0YSBhcyBQT0pPcy9pbW11dGFibGUgb2JqZWN0cy5cbiAqXG4gKiBZb3VyIFF1ZXJ5IGRhdGEgYW5kIGV2ZW50cyB3aWxsIHByb3ZpZGUgTWVzc2FnZXMvQ29udmVyc2F0aW9ucyBhcyBvYmplY3RzLlxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuUXVlcnkuT2JqZWN0RGF0YVR5cGUgPSAnb2JqZWN0JztcblxuLyoqXG4gKiBHZXQgZGF0YSBhcyBpbnN0YW5jZXMgb2YgbGF5ZXIuTWVzc2FnZSBhbmQgbGF5ZXIuQ29udmVyc2F0aW9uLlxuICpcbiAqIFlvdXIgUXVlcnkgZGF0YSBhbmQgZXZlbnRzIHdpbGwgcHJvdmlkZSBNZXNzYWdlcy9Db252ZXJzYXRpb25zIGFzIGluc3RhbmNlcy5cbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAc3RhdGljXG4gKi9cblF1ZXJ5Lkluc3RhbmNlRGF0YVR5cGUgPSAnaW5zdGFuY2UnO1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBwYWdlIHNpemUgZm9yIHF1ZXJpZXMuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuUXVlcnkuTWF4UGFnZVNpemUgPSAxMDA7XG5cbi8qKlxuICogQWNjZXNzIHRoZSBudW1iZXIgb2YgcmVzdWx0cyBjdXJyZW50bHkgbG9hZGVkLlxuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWVyeS5wcm90b3R5cGUsICdzaXplJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gIXRoaXMuZGF0YSA/IDAgOiB0aGlzLmRhdGEubGVuZ3RoO1xuICB9LFxufSk7XG5cbi8qKiBBY2Nlc3MgdGhlIHRvdGFsIG51bWJlciBvZiByZXN1bHRzIG9uIHRoZSBzZXJ2ZXIuXG4gKlxuICogV2lsbCBiZSAwIHVudGlsIHRoZSBmaXJzdCBxdWVyeSBoYXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZCByZXN1bHRzLlxuICpcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS50b3RhbFNpemUgPSAwO1xuXG5cbi8qKlxuICogQWNjZXNzIHRvIHRoZSBjbGllbnQgc28gaXQgY2FuIGxpc3RlbiB0byB3ZWJzb2NrZXQgYW5kIGxvY2FsIGV2ZW50cy5cbiAqXG4gKiBAdHlwZSB7bGF5ZXIuQ2xpZW50fVxuICogQHByb3RlY3RlZFxuICovXG5RdWVyeS5wcm90b3R5cGUuY2xpZW50ID0gbnVsbDtcblxuLyoqXG4gKiBRdWVyeSByZXN1bHRzLlxuICpcbiAqIEFycmF5IG9mIGRhdGEgcmVzdWx0aW5nIGZyb20gdGhlIFF1ZXJ5OyBlaXRoZXIgYSBsYXllci5Sb290IHN1YmNsYXNzLlxuICpcbiAqIG9yIHBsYWluIE9iamVjdHNcbiAqIEB0eXBlIHtPYmplY3RbXX1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgdHlwZSBvZiBkYXRhIGJlaW5nIHF1ZXJpZWQgZm9yLlxuICpcbiAqIE1vZGVsIGlzIG9uZSBvZlxuICogKiBsYXllci5RdWVyeS5Db252ZXJzYXRpb25cbiAqICogbGF5ZXIuUXVlcnkuTWVzc2FnZVxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5tb2RlbCA9IENPTlZFUlNBVElPTjtcblxuLyoqXG4gKiBXaGF0IHR5cGUgb2YgcmVzdWx0cyB0byByZXF1ZXN0IG9mIHRoZSBzZXJ2ZXIuXG4gKlxuICogTm90IHlldCBzdXBwb3J0ZWQ7IHJldHVyblR5cGUgaXMgb25lIG9mXG4gKlxuICogKiBvYmplY3RcbiAqICogaWRcbiAqICogY291bnRcbiAqXG4gKiBUaGlzIFF1ZXJ5IEFQSSBpcyBkZXNpZ25lZCBvbmx5IGZvciB1c2Ugd2l0aCAnb2JqZWN0Jy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5yZXR1cm5UeXBlID0gJ29iamVjdCc7XG5cbi8qKlxuICogU3BlY2lmeSB3aGF0IGtpbmQgb2YgZGF0YSBhcnJheSB5b3VyIGFwcGxpY2F0aW9uIHJlcXVpcmVzLlxuICpcbiAqIFVzZWQgdG8gc3BlY2lmeSBxdWVyeSBkYXRhVHlwZS4gIE9uZSBvZlxuICogKiBRdWVyeS5PYmplY3REYXRhVHlwZVxuICogKiBRdWVyeS5JbnN0YW5jZURhdGFUeXBlXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuUXVlcnkucHJvdG90eXBlLmRhdGFUeXBlID0gUXVlcnkuSW5zdGFuY2VEYXRhVHlwZTtcblxuLyoqXG4gKiBOdW1iZXIgb2YgcmVzdWx0cyBmcm9tIHRoZSBzZXJ2ZXIgdG8gcmVxdWVzdC9jYWNoZS5cbiAqXG4gKiBUaGUgcGFnaW5hdGlvbiB3aW5kb3cgY2FuIGJlIGluY3JlYXNlZCB0byBkb3dubG9hZCBhZGRpdGlvbmFsIGl0ZW1zLCBvciBkZWNyZWFzZWQgdG8gcHVyZ2UgcmVzdWx0c1xuICogZnJvbSB0aGUgZGF0YSBwcm9wZXJ0eS5cbiAqXG4gKiAgICAgcXVlcnkudXBkYXRlKHtcbiAqICAgICAgIHBhZ2luYXRpb25XaW5kb3c6IDE1MFxuICogICAgIH0pXG4gKlxuICogVGhpcyBjYWxsIHdpbGwgbG9hZCAxNTAgcmVzdWx0cy4gIElmIGl0IHByZXZpb3VzbHkgaGFkIDEwMCxcbiAqIHRoZW4gaXQgd2lsbCBsb2FkIDUwIG1vcmUuIElmIGl0IHByZXZpb3VzbHkgaGFkIDIwMCwgaXQgd2lsbCBkcm9wIDUwLlxuICpcbiAqIE5vdGUgdGhhdCB0aGUgc2VydmVyIHdpbGwgb25seSBwZXJtaXQgMTAwIGF0IGEgdGltZSwgc29cbiAqIHNldHRpbmcgYSBsYXJnZSBwYWdpbmF0aW9uIHdpbmRvdyBtYXkgcmVzdWx0IGluIG1hbnlcbiAqIHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIgdG8gcmVhY2ggdGhlIHNwZWNpZmllZCBwYWdlIHZhbHVlLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLnBhZ2luYXRpb25XaW5kb3cgPSAxMDA7XG5cbi8qKlxuICogU29ydGluZyBjcml0ZXJpYSBmb3IgQ29udmVyc2F0aW9uIFF1ZXJpZXMuXG4gKlxuICogT25seSBzdXBwb3J0cyBhbiBhcnJheSBvZiBvbmUgZmllbGQvZWxlbWVudC5cbiAqIE9ubHkgc3VwcG9ydHMgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICpcbiAqICAgICBbeydjcmVhdGVkQXQnOiAnZGVzYyd9XVxuICogICAgIFt7J2xhc3RNZXNzYWdlLnNlbnRBdCc6ICdkZXNjJ31dXG4gKlxuICogV2h5IHN1Y2ggbGltaXRhdGlvbnM/IFdoeSB0aGlzIHN0cnVjdHVyZT8gIFRoZSBzZXJ2ZXIgd2lsbCBiZSBleHBvc2luZyBhIFF1ZXJ5IEFQSSBhdCB3aGljaCBwb2ludCB0aGVcbiAqIGFib3ZlIHNvcnQgb3B0aW9ucyB3aWxsIG1ha2UgYSBsb3QgbW9yZSBzZW5zZSwgYW5kIGZ1bGwgc29ydGluZyB3aWxsIGJlIHByb3ZpZGVkLlxuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5zb3J0QnkgPSBudWxsO1xuXG4vKipcbiAqIFRoaXMgdmFsdWUgdGVsbHMgdXMgd2hhdCB0byByZXNldCB0aGUgcGFnaW5hdGlvbldpbmRvdyB0byB3aGVuIHRoZSBxdWVyeSBpcyByZWRlZmluZWQuXG4gKlxuICogQHR5cGUge051bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblF1ZXJ5LnByb3RvdHlwZS5faW5pdGlhbFBhZ2luYXRpb25XaW5kb3cgPSAxMDA7XG5cbi8qKlxuICogWW91ciBRdWVyeSdzIFdIRVJFIGNsYXVzZS5cbiAqXG4gKiBDdXJyZW50bHksIHRoZSBvbmx5IHF1ZXJ5IHN1cHBvcnRlZCBpcyBcImNvbnZlcnNhdGlvbi5pZCA9ICdsYXllcjovLy9jb252ZXJzYXRpb25zL3V1aWQnXCJcbiAqIE5vdGUgdGhhdCBib3RoICcgYW5kIFwiIGFyZSBzdXBwb3J0ZWQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5RdWVyeS5wcm90b3R5cGUucHJlZGljYXRlID0gbnVsbDtcblxuUXVlcnkucHJvdG90eXBlLmlzUmVzZXQgPSB0cnVlO1xuXG4vKipcbiAqIFRydWUgaWYgdGhlIFF1ZXJ5IGlzIGNvbm5lY3RpbmcgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBJdCBpcyBub3QgZ2F1cmVudGVlZCB0aGF0IGV2ZXJ5IHVwZGF0ZSgpOyBmb3IgZXhhbXBsZSwgdXBkYXRpbmcgYSBwYWdpbmF0aW9uV2luZG93IHRvIGJlIHNtYWxsZXIsXG4gKiBPciBjaGFuZ2luZyBhIHZhbHVlIHRvIHRoZSBleGlzdGluZyB2YWx1ZSB3b3VsZCBjYXVzZSB0aGUgcmVxdWVzdCBub3QgdG8gZmlyZS5cbiAqIFIgZWNvbW1lbmRlZCBwYXR0ZXJuIGlzOlxuICpcbiAqICAgICAgcXVlcnkudXBkYXRlKHtwYWdpbmF0aW9uV2luZG93OiA1MH0pO1xuICogICAgICBpZiAoIXF1ZXJ5LmlzRmlyaW5nKSB7XG4gKiAgICAgICAgYWxlcnQoXCJEb25lXCIpO1xuICogICAgICB9IGVsc2Uge1xuICogICAgICAgICAgcXVlcnkub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gKiAgICAgICAgICAgIGlmIChldnQudHlwZSA9PSBcImRhdGFcIikgYWxlcnQoXCJEb25lXCIpO1xuICogICAgICAgICAgfSk7XG4gKiAgICAgIH1cbiAqXG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xuUXVlcnkucHJvdG90eXBlLmlzRmlyaW5nID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGxhc3QgcmVxdWVzdCBmaXJlZC5cbiAqXG4gKiBJZiBtdWx0aXBsZSByZXF1ZXN0cyBhcmUgaW5mbGlnaHQsIHRoZSByZXNwb25zZVxuICogbWF0Y2hpbmcgdGhpcyByZXF1ZXN0IGlzIHRoZSBPTkxZIHJlc3BvbnNlIHdlIHdpbGwgcHJvY2Vzcy5cbiAqIEB0eXBlIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5RdWVyeS5wcm90b3R5cGUuX2ZpcmluZ1JlcXVlc3QgPSAnJztcblxuUXVlcnkuX3N1cHBvcnRlZEV2ZW50cyA9IFtcbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBkYXRhIGhhcyBjaGFuZ2VkOyBhbnkgY2hhbmdlIGV2ZW50IHdpbGwgY2F1c2UgdGhpcyBldmVudCB0byB0cmlnZ2VyLlxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqL1xuICAnY2hhbmdlJyxcblxuICAvKipcbiAgICogQSBuZXcgcGFnZSBvZiBkYXRhIGhhcyBiZWVuIGxvYWRlZCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICogQGV2ZW50ICdjaGFuZ2U6ZGF0YSdcbiAgICovXG4gICdjaGFuZ2U6ZGF0YScsXG5cbiAgLyoqXG4gICAqIEFsbCBkYXRhIGZvciB0aGlzIHF1ZXJ5IGhhcyBiZWVuIHJlc2V0IGR1ZSB0byBhIGNoYW5nZSBpbiB0aGUgUXVlcnkgcHJlZGljYXRlLlxuICAgKiBAZXZlbnQgJ2NoYW5nZTpyZXNldCdcbiAgICovXG4gICdjaGFuZ2U6cmVzZXQnLFxuXG4gIC8qKlxuICAgKiBBbiBpdGVtIG9mIGRhdGEgd2l0aGluIHRoaXMgUXVlcnkgaGFzIGhhZCBhIHByb3BlcnR5IGNoYW5nZSBpdHMgdmFsdWUuXG4gICAqIEBldmVudCAnY2hhbmdlOnByb3BlcnR5J1xuICAgKi9cbiAgJ2NoYW5nZTpwcm9wZXJ0eScsXG5cbiAgLyoqXG4gICAqIEEgbmV3IGl0ZW0gb2YgZGF0YSBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBRdWVyeS4gTm90IHRyaWdnZXJlZCBieSBsb2FkaW5nXG4gICAqIGEgbmV3IHBhZ2Ugb2YgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIsIGJ1dCBpcyB0cmlnZ2VyZWQgYnkgbG9jYWxseSBjcmVhdGluZyBhIG1hdGNoaW5nXG4gICAqIGl0ZW0gb2YgZGF0YSwgb3IgcmVjZWl2aW5nIGEgbmV3IGl0ZW0gb2YgZGF0YSB2aWEgd2Vic29ja2V0LlxuICAgKiBAZXZlbnQgJ2NoYW5nZTppbnNlcnQnXG4gICAqL1xuICAnY2hhbmdlOmluc2VydCcsXG5cbiAgLyoqXG4gICAqIEFuIGl0ZW0gb2YgZGF0YSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIFF1ZXJ5LiBOb3QgdHJpZ2dlcmVkIGZvciBldmVyeSByZW1vdmFsLCBidXRcbiAgICogaXMgdHJpZ2dlcmVkIGJ5IGxvY2FsbHkgZGVsZXRpbmcgYSByZXN1bHQsIG9yIHJlY2VpdmluZyBhIHJlcG9ydCBvZiBkZWxldGlvbiB2aWEgd2Vic29ja2V0LlxuICAgKiBAZXZlbnQgJ2NoYW5nZTpyZW1vdmUnXG4gICAqL1xuICAnY2hhbmdlOnJlbW92ZScsXG5cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBkYXRhIGZhaWxlZCB0byBsb2FkIGZyb20gdGhlIHNlcnZlci5cbiAgICogQGV2ZW50IGVycm9yXG4gICAqL1xuICAnZXJyb3InLFxuXS5jb25jYXQoUm9vdC5fc3VwcG9ydGVkRXZlbnRzKTtcblxuUm9vdC5pbml0Q2xhc3MuYXBwbHkoUXVlcnksIFtRdWVyeSwgJ1F1ZXJ5J10pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFF1ZXJ5O1xuIiwiY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuY29uc3QgTGF5ZXJFdmVudCA9IHJlcXVpcmUoJy4vbGF5ZXItZXZlbnQnKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuL2xheWVyLWVycm9yJyk7XG5jb25zdCBFdmVudHMgPSByZXF1aXJlKCdiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZS9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuLypcbiAqIFByb3ZpZGVzIGEgc3lzdGVtIGJ1cyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBieSBhbGwgY29tcG9uZW50cyBvZiB0aGUgc3lzdGVtLlxuICogQ3VycmVudGx5IHVzZWQgdG8gbGlzdGVuIHRvIG1lc3NhZ2VzIHNlbnQgdmlhIHBvc3RNZXNzYWdlLCBidXQgZW52aXNpb25lZCB0b1xuICogZG8gZmFyIG1vcmUuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50Q2xhc3MoKSB7IH1cbkV2ZW50Q2xhc3MucHJvdG90eXBlID0gRXZlbnRzO1xuXG5jb25zdCBTeXN0ZW1CdXMgPSBuZXcgRXZlbnRDbGFzcygpO1xuaWYgKHR5cGVvZiBwb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBhZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ2xheWVyLWRlbGF5ZWQtZXZlbnQnKSB7XG4gICAgICBTeXN0ZW1CdXMudHJpZ2dlcihldmVudC5kYXRhLmludGVybmFsSWQgKyAnLWRlbGF5ZWQtZXZlbnQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIGludGVybmFsSWQgZm9yIGV2ZXJ5IFJvb3QgaW5zdGFuY2VcbmNvbnN0IHVuaXF1ZUlkcyA9IHt9O1xuXG4vLyBSZWdleCBmb3Igc3BsaXR0aW5nIGFuIGV2ZW50IHN0cmluZyBzdWNoIGFzIG9iai5vbignZXZ0TmFtZTEgZXZ0TmFtZTIgZXZ0TmFtZTMnKVxuY29uc3QgZXZlbnRTcGxpdHRlciA9IC9cXHMrLztcblxuLyoqXG4gKiBUaGUgcm9vdCBjbGFzcyBvZiBhbGwgbGF5ZXIgb2JqZWN0cy4gUHJvdmlkZXMgdGhlIGZvbGxvd2luZyB1dGlsaXRpZXNcbiAqXG4gKiAxLiBNaXhlcyBpbiB0aGUgQmFja2JvbmUgZXZlbnQgbW9kZWxcbiAqXG4gKiAgICAgICAgdmFyIHBlcnNvbiA9IG5ldyBQZXJzb24oKTtcbiAqICAgICAgICBwZXJzb24ub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgY29uc29sZS5sb2coJ0kgaGF2ZSBiZWVuIGRlc3Ryb3llZCEnKTtcbiAqICAgICAgICB9KTtcbiAqXG4gKiAgICAgICAgLy8gRmlyZSB0aGUgY29uc29sZSBsb2cgaGFuZGxlcjpcbiAqICAgICAgICBwZXJzb24udHJpZ2dlcignZGVzdHJveScpO1xuICpcbiAqICAgICAgICAvLyBVbnN1YnNjcmliZVxuICogICAgICAgIHBlcnNvbi5vZmYoJ2Rlc3Ryb3knKTtcbiAqXG4gKiAyLiBBZGRzIGEgc3Vic2NyaXB0aW9ucyBvYmplY3Qgc28gdGhhdCBhbnkgZXZlbnQgaGFuZGxlcnMgb24gYW4gb2JqZWN0IGNhbiBiZSBxdWlja2x5IGZvdW5kIGFuZCByZW1vdmVkXG4gKlxuICogICAgICAgIHZhciBwZXJzb24xID0gbmV3IFBlcnNvbigpO1xuICogICAgICAgIHZhciBwZXJzb24yID0gbmV3IFBlcnNvbigpO1xuICogICAgICAgIHBlcnNvbjIub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgY29uc29sZS5sb2coJ0kgaGF2ZSBiZWVuIGRlc3Ryb3llZCEnKTtcbiAqICAgICAgICB9LCBwZXJzb24xKTtcbiAqXG4gKiAgICAgICAgLy8gUG9pbnRlcnMgdG8gcGVyc29uMSBoZWxkIG9udG8gYnkgcGVyc29uMiBhcmUgcmVtb3ZlZFxuICogICAgICAgIHBlcnNvbjEuZGVzdHJveSgpO1xuICpcbiAqIDMuIEFkZHMgc3VwcG9ydCBmb3IgZXZlbnQgbGlzdGVuZXJzIGluIHRoZSBjb25zdHJ1Y3RvclxuICogICAgQW55IGV2ZW50IGhhbmRsZXIgY2FuIGJlIHBhc3NlZCBpbnRvIHRoZSBjb25zdHJ1Y3RvclxuICogICAganVzdCBhcyB0aG91Z2ggaXQgd2VyZSBhIHByb3BlcnR5LlxuICpcbiAqICAgICAgICB2YXIgcGVyc29uID0gbmV3IFBlcnNvbih7XG4gKiAgICAgICAgICAgIGFnZTogMTUwLFxuICogICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJIGhhdmUgYmVlbiBkZXN0cm95ZWQhJyk7XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICB9KTtcbiAqXG4gKiA0LiBBIF9kaXNhYmxlRXZlbnRzIHByb3BlcnR5XG4gKlxuICogICAgICAgIG15TWV0aG9kKCkge1xuICogICAgICAgICAgaWYgKHRoaXMuaXNJbml0aWFsaXppbmcpIHtcbiAqICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlRXZlbnRzID0gdHJ1ZTtcbiAqXG4gKiAgICAgICAgICAgICAgLy8gRXZlbnQgb25seSByZWNlaXZlZCBpZiBfZGlzYWJsZUV2ZW50cyA9IGZhbHNlXG4gKiAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gKiAgICAgICAgICAgICAgdGhpcy5fZGlzYWJsZUV2ZW50cyA9IGZhbHNlO1xuICogICAgICAgICAgfVxuICogICAgICAgIH1cbiAqXG4gKiA1LiBBIF9zdXBwb3J0ZWRFdmVudHMgc3RhdGljIHByb3BlcnR5IGZvciBlYWNoIGNsYXNzXG4gKlxuICogICAgIFRoaXMgcHJvcGVydHkgZGVmaW5lcyB3aGljaCBldmVudHMgY2FuIGJlIHRyaWdnZXJlZC5cbiAqXG4gKiAgICAgKiBBbnkgYXR0ZW1wdCB0byB0cmlnZ2VyXG4gKiAgICAgICBhbiBldmVudCBub3QgaW4gX3N1cHBvcnRlZEV2ZW50cyB3aWxsIGxvZyBhbiBlcnJvci5cbiAqICAgICAqIEFueSBhdHRlbXB0IHRvIHJlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIGFuIGV2ZW50IG5vdCBpbiBfc3VwcG9ydGVkRXZlbnRzIHdpbGxcbiAqICAgICAqdGhyb3cqIGFuIGVycm9yLlxuICpcbiAqICAgICBUaGlzIGFsbG93cyB1cyB0byBpbnN1cmUgZGV2ZWxvcGVycyBvbmx5IHN1YnNjcmliZSB0byB2YWxpZCBldmVudHMuXG4gKlxuICogICAgIFRoaXMgYWxsb3dzIHVzIHRvIGNvbnRyb2wgd2hhdCBldmVudHMgY2FuIGJlIGZpcmVkIGFuZCB3aGljaCBvbmVzIGJsb2NrZWQuXG4gKlxuICogNi4gQWRkcyBhbiBpbnRlcm5hbElkIHByb3BlcnR5XG4gKlxuICogICAgICAgIHZhciBwZXJzb24gPSBuZXcgUGVyc29uKCk7XG4gKiAgICAgICAgY29uc29sZS5sb2cocGVyc29uLmludGVybmFsSWQpOyAvLyAtPiAnUGVyc29uMSdcbiAqXG4gKiA3LiBBZGRzIGEgdG9PYmplY3QgbWV0aG9kIHRvIGNyZWF0ZSBhIHNpbXBsaWZpZWQgUGxhaW4gT2xkIEphdmFjcmlwdCBPYmplY3QgZnJvbSB5b3VyIG9iamVjdFxuICpcbiAqICAgICAgICB2YXIgcGVyc29uID0gbmV3IFBlcnNvbigpO1xuICogICAgICAgIHZhciBzaW1wbGVQZXJzb24gPSBwZXJzb24udG9PYmplY3QoKTtcbiAqXG4gKiA4LiBQcm92aWRlcyBfX2FkanVzdFByb3BlcnR5IG1ldGhvZCBzdXBwb3J0XG4gKlxuICogICAgIEZvciBhbnkgcHJvcGVydHkgb2YgYSBjbGFzcywgYW4gYF9fYWRqdXN0UHJvcGVydHlgIG1ldGhvZCBjYW4gYmUgZGVmaW5lZC4gIElmIGl0cyBkZWZpbmVkLFxuICogICAgIGl0IHdpbGwgYmUgY2FsbGVkIHByaW9yIHRvIHNldHRpbmcgdGhhdCBwcm9wZXJ0eSwgYWxsb3dpbmc6XG4gKlxuICogICAgIEEuIE1vZGlmaWNhdGlvbiBvZiB0aGUgdmFsdWUgdGhhdCBpcyBhY3R1YWxseSBzZXRcbiAqICAgICBCLiBWYWxpZGF0aW9uIG9mIHRoZSB2YWx1ZTsgdGhyb3dpbmcgZXJyb3JzIGlmIGludmFsaWQuXG4gKlxuICogOS4gUHJvdmlkZXMgX191ZHBhdGVQcm9wZXJ0eSBtZXRob2Qgc3VwcG9ydFxuICpcbiAqICAgICBBZnRlciBzZXR0aW5nIGFueSBwcm9wZXJ0eSBmb3Igd2hpY2ggdGhlcmUgaXMgYW4gYF9fdXBkYXRlUHJvcGVydHlgIG1ldGhvZCBkZWZpbmVkLFxuICogICAgIHRoZSBtZXRob2Qgd2lsbCBiZSBjYWxsZWQsIGFsbG93aW5nIHRoZSBuZXcgcHJvcGVydHkgdG8gYmUgYXBwbGllZC5cbiAqXG4gKiAgICAgVHlwaWNhbGx5IHVzZWQgZm9yXG4gKlxuICogICAgIEEuIFRyaWdnZXJpbmcgZXZlbnRzXG4gKiAgICAgQi4gRmlyaW5nIFhIUiByZXF1ZXN0c1xuICogICAgIEMuIFVwZGF0aW5nIHRoZSBVSSB0byBtYXRjaCB0aGUgbmV3IHByb3BlcnR5IHZhbHVlXG4gKlxuICpcbiAqIEBjbGFzcyBsYXllci5Sb290XG4gKiBAYWJzdHJhY3RcbiAqIEBhdXRob3IgTWljaGFlbCBLYW50b3JcbiAqL1xuY2xhc3MgUm9vdCBleHRlbmRzIEV2ZW50Q2xhc3Mge1xuXG4gIC8qKlxuICAgKiBTdXBlcmNsYXNzIGNvbnN0cnVjdG9yIGhhbmRsZXMgY29weWluZyBpbiBwcm9wZXJ0aWVzIGFuZCByZWdpc3RlcmluZyBldmVudCBoYW5kbGVycy5cbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnMgLSBhIGhhc2ggb2YgcHJvcGVydGllcyBhbmQgZXZlbnQgaGFuZGxlcnNcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2RlbGF5ZWRUcmlnZ2VycyA9IFtdO1xuICAgIHRoaXMuX2xhc3REZWxheWVkVHJpZ2dlciA9IERhdGUubm93KCk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBpbnRlcm5hbElkXG4gICAgY29uc3QgbmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAoIXVuaXF1ZUlkc1tuYW1lXSkgdW5pcXVlSWRzW25hbWVdID0gMDtcbiAgICB0aGlzLmludGVybmFsSWQgPSBuYW1lICsgdW5pcXVlSWRzW25hbWVdKys7XG5cbiAgICAvLyBFdmVyeSBjb21wb25lbnQgbGlzdGVucyB0byB0aGUgU3lzdGVtQnVzIGZvciBwb3N0TWVzc2FnZSAodHJpZ2dlckFzeW5jKSBldmVudHNcbiAgICBTeXN0ZW1CdXMub24odGhpcy5pbnRlcm5hbElkICsgJy1kZWxheWVkLWV2ZW50JywgdGhpcy5fcHJvY2Vzc0RlbGF5ZWRUcmlnZ2VycywgdGhpcyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHRlbXBvcmFyeSBpZCBpZiB0aGVyZSBpc24ndCBhbiBpZFxuICAgIGlmICghdGhpcy5pZCAmJiAhb3B0aW9ucy5pZCAmJiB0aGlzLmNvbnN0cnVjdG9yLnByZWZpeFVVSUQpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLmNvbnN0cnVjdG9yLnByZWZpeFVVSUQgKyBVdGlscy5nZW5lcmF0ZVVVSUQoKTtcbiAgICB9XG5cbiAgICAvLyBDb3B5IGluIGFsbCBwcm9wZXJ0aWVzOyBzZXR1cCBhbGwgZXZlbnQgaGFuZGxlcnNcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLl9zdXBwb3J0ZWRFdmVudHMuaW5kZXhPZihrZXkpICE9PSAtMSkge1xuICAgICAgICB0aGlzLm9uKGtleSwgb3B0aW9uc1trZXldKTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRoaXMgJiYgdHlwZW9mIHRoaXNba2V5XSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaXNJbml0aWFsaXppbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgb2JqZWN0LlxuICAgKlxuICAgKiBDbGVhbnMgdXAgYWxsIGV2ZW50cyAvIHN1YnNjcmlwdGlvbnNcbiAgICogYW5kIG1hcmtzIHRoZSBvYmplY3QgYXMgaXNEZXN0cm95ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKExheWVyRXJyb3IuZGljdGlvbmFyeS5hbHJlYWR5RGVzdHJveWVkKTtcblxuICAgIC8vIElmIGFueW9uZSBpcyBsaXN0ZW5pbmcsIG5vdGlmeSB0aGVtXG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG5cbiAgICAvLyBDbGVhbnVwIHBvaW50ZXJzIHRvIFN5c3RlbUJ1cy4gRmFpbHVyZSB0byBjYWxsIGRlc3Ryb3lcbiAgICAvLyB3aWxsIGhhdmUgdmVyeSBzZXJpb3VzIGNvbnNlcXVlbmNlcy4uLlxuICAgIFN5c3RlbUJ1cy5vZmYodGhpcy5pbnRlcm5hbElkICsgJy1kZWxheWVkLWV2ZW50JywgbnVsbCwgdGhpcyk7XG5cbiAgICAvLyBSZW1vdmUgYWxsIGV2ZW50cywgYW5kIGFsbCBwb2ludGVycyBwYXNzZWQgdG8gdGhpcyBvYmplY3QgYnkgb3RoZXIgb2JqZWN0c1xuICAgIHRoaXMub2ZmKCk7XG5cbiAgICAvLyBGaW5kIGFsbCBvZiB0aGUgb2JqZWN0cyB0aGF0IHRoaXMgb2JqZWN0IGhhcyBwYXNzZWQgaXRzZWxmIHRvIGluIHRoZSBmb3JtXG4gICAgLy8gb2YgZXZlbnQgaGFuZGxlcnMgYW5kIHJlbW92ZSBhbGwgcmVmZXJlbmNlcyB0byBpdHNlbGYuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5vZmYobnVsbCwgbnVsbCwgdGhpcykpO1xuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5fZGVsYXllZFRyaWdnZXJzID0gbnVsbDtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNsYXNzIGluc3RhbmNlIHRvIFBsYWluIEphdmFzY3JpcHQgT2JqZWN0LlxuICAgKlxuICAgKiBTdHJpcHMgb3V0IGFsbCBwcml2YXRlIG1lbWJlcnMsIGFuZCBpbnN1cmVzIG5vIGRhdGFzdHJ1Y3R1cmUgbG9vcHMuXG4gICAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnRpbmcgYWxsIHN1Ym9iamVjdHMgdXNpbmcgY2FsbHMgdG8gdG9PYmplY3QuXG4gICAqXG4gICAqICAgICAgY29uc29sZS5kaXIobXlvYmoudG9PYmplY3QoKSk7XG4gICAqXG4gICAqIE5vdGU6IFdoaWxlIGl0IHdvdWxkIGJlIHRlbXB0aW5nIHRvIGhhdmUgbm9DaGlsZHJlbiBkZWZhdWx0IHRvIHRydWUsXG4gICAqIHRoaXMgd291bGQgcmVzdWx0IGluIE1lc3NhZ2UudG9PYmplY3QoKSBub3Qgb3V0cHV0aW5nIGl0cyBNZXNzYWdlUGFydHMuXG4gICAqXG4gICAqIFByaXZhdGUgZGF0YSAoXyBwcmVmaXhlZCBwcm9wZXJ0aWVzKSB3aWxsIG5vdCBiZSBvdXRwdXQuXG4gICAqXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW25vQ2hpbGRyZW49ZmFsc2VdIERvbid0IG91dHB1dCBzdWItY29tcG9uZW50c1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICB0b09iamVjdChub0NoaWxkcmVuID0gZmFsc2UpIHtcbiAgICB0aGlzLl9faW5Ub09iamVjdCA9IHRydWU7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGZvcm1hbGx5IGRlZmluZWQgcHJvcGVydGllc1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpIGlmICghKGtleSBpbiBsYXllci5Sb290LnByb3RvdHlwZSkpIGtleXMucHVzaChrZXkpO1xuXG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXNba2V5XTtcblxuICAgICAgICAvLyBJZ25vcmUgcHJpdmF0ZS9wcm90ZWN0ZWQgcHJvcGVydGllcyBhbmQgZnVuY3Rpb25zXG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignXycpID09PSAwKSByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIGFycmF5cy4uLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgIG9ialtrZXldID0gW107XG4gICAgICAgICAgdi5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBSb290KSB7XG4gICAgICAgICAgICAgIGlmIChub0NoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLl9faW5Ub09iamVjdCkge1xuICAgICAgICAgICAgICAgIG9ialtrZXldLnB1c2goaXRlbS50b09iamVjdCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb2JqW2tleV0ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHN1YmNvbXBvbmVudHNcbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIFJvb3QpIHtcbiAgICAgICAgICBpZiAoIXYuX19pblRvT2JqZWN0ICYmICFub0NoaWxkcmVuKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IHYudG9PYmplY3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBkYXRlcyAoY3JlYXRlcyBhIGNvcHkgdG8gc2VwYXJhdGUgaXQgZnJvbSB0aGUgc291cmNlIG9iamVjdClcbiAgICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IG5ldyBEYXRlKHYpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgc2ltcGxlIHByb3BlcnRpZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb2JqW2tleV0gPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBuby1vcFxuICAgIH1cbiAgICB0aGlzLl9faW5Ub09iamVjdCA9IGZhbHNlO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogTG9nIGEgd2FybmluZyBmb3IgYXR0ZW1wdHMgdG8gc3Vic2NyaWJlIHRvIHVuc3VwcG9ydGVkIGV2ZW50cy5cbiAgICpcbiAgICogQG1ldGhvZCBfd2FybkZvckV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd2FybkZvckV2ZW50KGV2ZW50TmFtZSkge1xuICAgIGlmICghVXRpbHMuaW5jbHVkZXModGhpcy5jb25zdHJ1Y3Rvci5fc3VwcG9ydGVkRXZlbnRzLCBldmVudE5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50ICcgKyBldmVudE5hbWUgKyAnIG5vdCBkZWZpbmVkIGZvciAnICsgdGhpcy50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGFyZSBmb3IgcHJvY2Vzc2luZyBhbiBldmVudCBzdWJzY3JpcHRpb24gY2FsbC5cbiAgICpcbiAgICogSWYgY29udGV4dCBpcyBhIFJvb3QgY2xhc3MsIGFkZCB0aGlzIG9iamVjdCB0byB0aGUgY29udGV4dCdzIHN1YnNjcmlwdGlvbnMuXG4gICAqXG4gICAqIEBtZXRob2QgX3ByZXBhcmVPblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ByZXBhcmVPbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBSb290KSB7XG4gICAgICBpZiAoY29udGV4dC5pc0Rlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTGF5ZXJFcnJvci5kaWN0aW9uYXJ5LmlzRGVzdHJveWVkKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuX3N1YnNjcmlwdGlvbnMucHVzaCh0aGlzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiBuYW1lICE9PSAnYWxsJykge1xuICAgICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgICBjb25zdCBuYW1lcyA9IG5hbWUuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICAgIG5hbWVzLmZvckVhY2gobiA9PiB0aGlzLl93YXJuRm9yRXZlbnQobikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2FybkZvckV2ZW50KG5hbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKG5hbWUpLmZvckVhY2goa2V5TmFtZSA9PiB0aGlzLl93YXJuRm9yRXZlbnQoa2V5TmFtZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gZXZlbnRzLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRleHQgcGFyYW1ldGVyIHNlcnZlcyBkb3VibGUgaW1wb3J0YW5jZSBoZXJlOlxuICAgKlxuICAgKiAxLiBJdCBkZXRlcm1pbmVzIHRoZSBjb250ZXh0IGluIHdoaWNoIHRvIGV4ZWN1dGUgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogMi4gQ3JlYXRlIGEgYmFja2xpbmsgc28gdGhhdCBpZiBlaXRoZXIgc3Vic2NyaWJlciBvciBzdWJzY3JpYmVlIGlzIGRlc3Ryb3llZCxcbiAgICogICAgYWxsIHBvaW50ZXJzIGJldHdlZW4gdGhlbSBjYW4gYmUgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAqXG4gICAqICAgICAgb2JqLm9uKCdzb21lRXZlbnROYW1lIHNvbWVPdGhlckV2ZW50TmFtZScsIG15Y2FsbGJhY2ssIG15Y29udGV4dCk7XG4gICAqXG4gICAqICAgICAgb2JqLm9uKHtcbiAgICogICAgICAgICAgZXZlbnROYW1lMTogY2FsbGJhY2sxLFxuICAgKiAgICAgICAgICBldmVudE5hbWUyOiBjYWxsYmFjazJcbiAgICogICAgICB9LCBteWNvbnRleHQpO1xuICAgKlxuICAgKiBAbWV0aG9kIG9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBoYW5kbGVyIC0gRXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50fSBoYW5kbGVyLmV2ZW50IC0gRXZlbnQgb2JqZWN0IGRlbGl2ZXJlZCB0byB0aGUgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbnRleHQgLSBUaGlzIHBvaW50ZXIgQU5EIGxpbmsgdG8gaGVscCB3aXRoIGNsZWFudXBcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH0gdGhpc1xuICAgKi9cbiAgb24obmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuX3ByZXBhcmVPbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICBFdmVudHMub24uYXBwbHkodGhpcywgW25hbWUsIGhhbmRsZXIsIGNvbnRleHRdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGZpcnN0IG9jY3VyYW5jZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIG9uY2VcbiAgICovXG4gIG9uY2UobmFtZSwgaGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuX3ByZXBhcmVPbihuYW1lLCBoYW5kbGVyLCBjb250ZXh0KTtcbiAgICBFdmVudHMub25jZS5hcHBseSh0aGlzLCBbbmFtZSwgaGFuZGxlciwgY29udGV4dF0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuc3Vic2NyaWJlIGZyb20gZXZlbnRzLlxuICAgKlxuICAgKiAgICAgIC8vIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGlzIGV2ZW50OlxuICAgKiAgICAgIG9iai5vZmYoJ3NvbWVFdmVudE5hbWUnKTtcbiAgICpcbiAgICogICAgICAvLyBSZW1vdmVzIGFsbCBldmVudCBoYW5kbGVycyB1c2luZyB0aGlzIGZ1bmN0aW9uIHBvaW50ZXIgYXMgY2FsbGJhY2tcbiAgICogICAgICBvYmoub2ZmKG51bGwsIGYsIG51bGwpO1xuICAgKlxuICAgKiAgICAgIC8vIFJlbW92ZXMgYWxsIGV2ZW50IGhhbmRsZXJzIHRoYXQgYHRoaXNgIGhhcyBzdWJzY3JpYmVkIHRvOyByZXF1aXJlc1xuICAgKiAgICAgIC8vIG9iai5vbiB0byBiZSBjYWxsZWQgd2l0aCBgdGhpc2AgYXMgaXRzIGBjb250ZXh0YCBwYXJhbWV0ZXIuXG4gICAqICAgICAgb2JqLm9mZihudWxsLCBudWxsLCB0aGlzKTtcbiAgICpcbiAgICogQG1ldGhvZCBvZmZcbiAgICogQHBhcmFtICB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQ7IG51bGwgZm9yIGFsbCBldmVudCBuYW1lc1xuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gaGFuZGxlciAtIEV2ZW50IGhhbmRsZXI7IG51bGwgZm9yIGFsbCBmdW5jdGlvbnNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb250ZXh0IC0gVGhlIGNvbnRleHQgZnJvbSB0aGUgYG9uKClgIGNhbGwgdG8gc2VhcmNoIGZvcjsgbnVsbCBmb3IgYWxsIGNvbnRleHRzXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFRyaWdnZXIgYW4gZXZlbnQgZm9yIGFueSBldmVudCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEV2ZW50cyB0cmlnZ2VyZWQgdGhpcyB3YXkgd2lsbCBiZSBibG9ja2VkIGlmIF9kaXNhYmxlRXZlbnRzID0gdHJ1ZVxuICAgKlxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAgICBOYW1lIG9mIHRoZSBldmVudCB0aGF0IG9uZSBzaG91bGQgc3Vic2NyaWJlIHRvIGluIG9yZGVyIHRvIHJlY2VpdmUgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge01peGVkfSBhcmcgICAgICAgICAgIFZhbHVlcyB0aGF0IHdpbGwgYmUgcGxhY2VkIHdpdGhpbiBhIGxheWVyLkxheWVyRXZlbnRcbiAgICogQHJldHVybiB7bGF5ZXIuUm9vdH0gdGhpc1xuICAgKi9cbiAgdHJpZ2dlciguLi5hcmdzKSB7XG4gICAgaWYgKHRoaXMuX2Rpc2FibGVFdmVudHMpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLl90cmlnZ2VyKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyaWdnZXJzIGFuIGV2ZW50LlxuICAgKlxuICAgKiBAbWV0aG9kIHRyaWdnZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIE5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJuICp0aGlzKiBmb3IgY2hhaW5pbmdcbiAgICovXG4gIF90cmlnZ2VyKC4uLmFyZ3MpIHtcbiAgICBpZiAoIVV0aWxzLmluY2x1ZGVzKHRoaXMuY29uc3RydWN0b3IuX3N1cHBvcnRlZEV2ZW50cywgYXJnc1swXSkpIHtcbiAgICAgIGlmICghVXRpbHMuaW5jbHVkZXModGhpcy5jb25zdHJ1Y3Rvci5faWdub3JlZEV2ZW50cywgYXJnc1swXSkpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKHRoaXMudG9TdHJpbmcoKSArICcgaWdub3JlZCAnICsgYXJnc1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tcHV0ZWRBcmdzID0gdGhpcy5fZ2V0VHJpZ2dlckFyZ3MoLi4uYXJncyk7XG5cbiAgICBFdmVudHMudHJpZ2dlci5hcHBseSh0aGlzLCBjb21wdXRlZEFyZ3MpO1xuXG4gICAgY29uc3QgcGFyZW50UHJvcCA9IHRoaXMuY29uc3RydWN0b3IuYnViYmxlRXZlbnRQYXJlbnQ7XG4gICAgaWYgKHBhcmVudFByb3ApIHtcbiAgICAgIGxldCBwYXJlbnRWYWx1ZSA9IHRoaXNbcGFyZW50UHJvcF07XG4gICAgICBwYXJlbnRWYWx1ZSA9ICh0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdmdW5jdGlvbicpID8gcGFyZW50VmFsdWUuYXBwbHkodGhpcykgOiBwYXJlbnRWYWx1ZTtcbiAgICAgIGlmIChwYXJlbnRWYWx1ZSkgcGFyZW50VmFsdWUudHJpZ2dlciguLi5jb21wdXRlZEFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBsYXllci5MYXllckV2ZW50IGZyb20gYSB0cmlnZ2VyIGNhbGwncyBhcmd1bWVudHMuXG4gICAqXG4gICAqICogSWYgcGFyYW1ldGVyIGlzIGFscmVhZHkgYSBsYXllci5MYXllckV2ZW50LCB3ZSdyZSBkb25lLlxuICAgKiAqIElmIHBhcmFtZXRlciBpcyBhbiBvYmplY3QsIGEgYHRhcmdldGAgcHJvcGVydHkgaXMgYWRkZWQgdG8gdGhhdCBvYmplY3QgYW5kIGl0cyBkZWxpdmVyZWQgdG8gYWxsIHN1YnNjcmliZXJzXG4gICAqICogSWYgdGhlIHBhcmFtZXRlciBpcyBub24tb2JqZWN0IHZhbHVlLCBpdCBpcyBhZGRlZCB0byBhbiBvYmplY3Qgd2l0aCBhIGB0YXJnZXRgIHByb3BlcnR5LCBhbmQgdGhlIHZhbHVlIGlzIHB1dCBpblxuICAgKiAgIHRoZSBgZGF0YWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldFRyaWdnZXJBcmdzXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge01peGVkW119IC0gRmlyc3QgZWxlbWVudCBvZiBhcnJheSBpcyBldmVudE5hbWUsIHNlY29uZCBlbGVtZW50IGlzIGxheWVyLkxheWVyRXZlbnQuXG4gICAqL1xuICBfZ2V0VHJpZ2dlckFyZ3MoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbXB1dGVkQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXG4gICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgIGNvbnN0IG5ld0FyZyA9IHsgdGFyZ2V0OiB0aGlzIH07XG5cbiAgICAgIGlmIChjb21wdXRlZEFyZ3NbMV0gaW5zdGFuY2VvZiBMYXllckV2ZW50KSB7XG4gICAgICAgIC8vIEEgTGF5ZXJFdmVudCB3aWxsIGJlIGFuIGFyZ3VtZW50IHdoZW4gYnViYmxpbmcgZXZlbnRzIHVwOyB0aGVzZSBhcmdzIGNhbiBiZSB1c2VkIGFzLWlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGNvbXB1dGVkQXJnc1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhjb21wdXRlZEFyZ3NbMV0pLmZvckVhY2gobmFtZSA9PiB7bmV3QXJnW25hbWVdID0gY29tcHV0ZWRBcmdzWzFdW25hbWVdO30pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0FyZy5kYXRhID0gY29tcHV0ZWRBcmdzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVkQXJnc1sxXSA9IG5ldyBMYXllckV2ZW50KG5ld0FyZywgY29tcHV0ZWRBcmdzWzBdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZWRBcmdzWzFdID0gbmV3IExheWVyRXZlbnQoeyB0YXJnZXQ6IHRoaXMgfSwgY29tcHV0ZWRBcmdzWzBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcHV0ZWRBcmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgX3RyaWdnZXIoKSBtZXRob2QsIGJ1dCBkZWxheXMgYnJpZWZseSBiZWZvcmUgZmlyaW5nLlxuICAgKlxuICAgKiBXaGVuIHdvdWxkIHlvdSB3YW50IHRvIGRlbGF5IGFuIGV2ZW50P1xuICAgKlxuICAgKiAxLiBUaGVyZSBpcyBhbiBldmVudCByb2xsdXAgdGhhdCBtYXkgYmUgbmVlZGVkIGZvciB0aGUgZXZlbnQ7XG4gICAqICAgIHRoaXMgcmVxdWlyZXMgdGhlIGZyYW1ld29yayB0byBiZSBhYmxlIHRvIHNlZSBBTEwgZXZlbnRzIHRoYXQgaGF2ZSBiZWVuXG4gICAqICAgIGdlbmVyYXRlZCwgcm9sbCB0aGVtIHVwLCBhbmQgVEhFTiBmaXJlIHRoZW0uXG4gICAqIDIuIFRoZSBldmVudCBpcyBpbnRlbmRlZCBmb3IgVUkgcmVuZGVyaW5nLi4uIHdoaWNoIHNob3VsZCBub3QgaG9sZCB1cCB0aGUgcmVzdCBvZlxuICAgKiAgICB0aGlzIGZyYW1ld29yaydzIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogV2hlbiBOT1QgdG8gZGVsYXkgYW4gZXZlbnQ/XG4gICAqXG4gICAqIDEuIExpZmVjeWNsZSBldmVudHMgZnJlcXVlbnRseSByZXF1aXJlIHJlc3BvbnNlIGF0IHRoZSB0aW1lIHRoZSBldmVudCBoYXMgZmlyZWRcbiAgICpcbiAgICogQG1ldGhvZCBfdHJpZ2dlckFzeW5jXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgICAgTmFtZSBvZiB0aGUgZXZlbnQgdGhhdCBvbmUgc2hvdWxkIHN1YnNjcmliZSB0byBpbiBvcmRlciB0byByZWNlaXZlIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtNaXhlZH0gYXJnICAgICAgICAgICBWYWx1ZXMgdGhhdCB3aWxsIGJlIHBsYWNlZCB3aXRoaW4gYSBsYXllci5MYXllckV2ZW50XG4gICAqIEByZXR1cm4ge2xheWVyLlJvb3R9IHRoaXNcbiAgICovXG4gIF90cmlnZ2VyQXN5bmMoLi4uYXJncykge1xuICAgIGNvbnN0IGNvbXB1dGVkQXJncyA9IHRoaXMuX2dldFRyaWdnZXJBcmdzKC4uLmFyZ3MpO1xuICAgIHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5wdXNoKGNvbXB1dGVkQXJncyk7XG5cbiAgICAvLyBOT1RFOiBJdCBpcyB1bmNsZWFyIGF0IHRoaXMgdGltZSBob3cgaXQgaGFwcGVucywgYnV0IG9uIHZlcnkgcmFyZSBvY2Nhc2lvbnMsIHdlIHNlZSBwcm9jZXNzRGVsYXllZFRyaWdnZXJzXG4gICAgLy8gZmFpbCB0byBnZXQgY2FsbGVkIHdoZW4gbGVuZ3RoID0gMSwgYW5kIGFmdGVyIHRoYXQgbGVuZ3RoIGp1c3QgY29udGludW91c2x5IGdyb3dzLiAgU28gd2UgYWRkXG4gICAgLy8gdGhlIF9sYXN0RGVsYXllZFRyaWdnZXIgdGVzdCB0byBpbnN1cmUgdGhhdCBpdCB3aWxsIHN0aWxsIHJ1bi5cbiAgICBjb25zdCBzaG91bGRTY2hlZHVsZVRyaWdnZXIgPSB0aGlzLl9kZWxheWVkVHJpZ2dlcnMubGVuZ3RoID09PSAxIHx8XG4gICAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMubGVuZ3RoICYmIHRoaXMuX2xhc3REZWxheWVkVHJpZ2dlciArIDUwMCA8IERhdGUubm93KCk7XG4gICAgaWYgKHNob3VsZFNjaGVkdWxlVHJpZ2dlcikge1xuICAgICAgdGhpcy5fbGFzdERlbGF5ZWRUcmlnZ2VyID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmICh0eXBlb2YgcG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGphc21pbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogJ2xheWVyLWRlbGF5ZWQtZXZlbnQnLFxuICAgICAgICAgIGludGVybmFsSWQ6IHRoaXMuaW50ZXJuYWxJZCxcbiAgICAgICAgfSwgJyonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcHJvY2Vzc0RlbGF5ZWRUcmlnZ2VycygpLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZXMgYSBzZXQgb2YgZXZlbnRzIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gICAqXG4gICAqIEdpdmVuIGFuIGV2ZW50IHN0cnVjdHVyZSBvZlxuICAgKlxuICAgKiAgICAgIHtcbiAgICogICAgICAgICAgY3VzdG9tTmFtZTogW3ZhbHVlMV1cbiAgICogICAgICB9XG4gICAqICAgICAge1xuICAgKiAgICAgICAgICBjdXN0b21OYW1lOiBbdmFsdWUyXVxuICAgKiAgICAgIH1cbiAgICogICAgICB7XG4gICAqICAgICAgICAgIGN1c3RvbU5hbWU6IFt2YWx1ZTNdXG4gICAqICAgICAgfVxuICAgKlxuICAgKiBNZXJnZSB0aGVtIGludG9cbiAgICpcbiAgICogICAgICB7XG4gICAqICAgICAgICAgIGN1c3RvbU5hbWU6IFt2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzXVxuICAgKiAgICAgIH1cbiAgICpcbiAgICogQG1ldGhvZCBfZm9sZEV2ZW50c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50W119IGV2ZW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgICBOYW1lIG9mIHRoZSBwcm9wZXJ0eSAoaS5lLiAnY3VzdG9tTmFtZScpXG4gICAqIEBwYXJhbSAge2xheWVyLlJvb3R9ICAgIG5ld1RhcmdldCBWYWx1ZSBvZiB0aGUgdGFyZ2V0IGZvciB0aGUgZm9sZGVkIHJlc3VsdGluZyBldmVudFxuICAgKi9cbiAgX2ZvbGRFdmVudHMoZXZlbnRzLCBuYW1lLCBuZXdUYXJnZXQpIHtcbiAgICBjb25zdCBmaXJzdEV2dCA9IGV2ZW50cy5sZW5ndGggPyBldmVudHNbMF1bMV0gOiBudWxsO1xuICAgIGNvbnN0IGZpcnN0RXZ0UHJvcCA9IGZpcnN0RXZ0ID8gZmlyc3RFdnRbbmFtZV0gOiBudWxsO1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldnQsIGkpIHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBmaXJzdEV2dFByb3AucHVzaChldnRbMV1bbmFtZV1bMF0pO1xuICAgICAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuc3BsaWNlKHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5pbmRleE9mKGV2dCksIDEpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuICAgIGlmIChldmVudHMubGVuZ3RoICYmIG5ld1RhcmdldCkgZXZlbnRzWzBdWzFdLnRhcmdldCA9IG5ld1RhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb2xkIGEgc2V0IG9mIENoYW5nZSBldmVudHMgaW50byBhIHNpbmdsZSBDaGFuZ2UgZXZlbnQuXG4gICAqXG4gICAqIEdpdmVuIGEgc2V0IGNoYW5nZSBldmVudHMgb24gdGhpcyBjb21wb25lbnQsXG4gICAqIGZvbGQgYWxsIGNoYW5nZSBldmVudHMgaW50byBhIHNpbmdsZSBldmVudCB2aWFcbiAgICogdGhlIGxheWVyLkxheWVyRXZlbnQncyBjaGFuZ2VzIGFycmF5LlxuICAgKlxuICAgKiBAbWV0aG9kIF9mb2xkQ2hhbmdlRXZlbnRzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9sZENoYW5nZUV2ZW50cygpIHtcbiAgICBjb25zdCBldmVudHMgPSB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuZmlsdGVyKGV2dCA9PiBldnRbMV0uaXNDaGFuZ2UpO1xuICAgIGV2ZW50cy5mb3JFYWNoKChldnQsIGkpID0+IHtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBldmVudHNbMF1bMV0uX21lcmdlQ2hhbmdlcyhldnRbMV0pO1xuICAgICAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuc3BsaWNlKHRoaXMuX2RlbGF5ZWRUcmlnZ2Vycy5pbmRleE9mKGV2dCksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYWxsIGRlbGF5ZWQgZXZlbnRzIGZvciB0aGlzIGNvbXBvZW5udC5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc0RlbGF5ZWRUcmlnZ2Vyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NEZWxheWVkVHJpZ2dlcnMoKSB7XG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHJldHVybjtcbiAgICB0aGlzLl9mb2xkQ2hhbmdlRXZlbnRzKCk7XG5cbiAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoLi4uZXZ0KTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9kZWxheWVkVHJpZ2dlcnMgPSBbXTtcbiAgfVxuXG5cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgY2xhc3MgdGhhdCBpcyBuaWNlciB0aGFuIFtPYmplY3RdLlxuICAgKlxuICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmludGVybmFsSWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkobmV3Q2xhc3MsIHByb3BlcnR5TmFtZSkge1xuICBjb25zdCBwS2V5ID0gJ19fJyArIHByb3BlcnR5TmFtZTtcbiAgY29uc3QgY2FtZWwgPSBwcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eU5hbWUuc3Vic3RyaW5nKDEpO1xuXG4gIGNvbnN0IGhhc0RlZmluaXRpb25zID0gbmV3Q2xhc3MucHJvdG90eXBlWydfX2FkanVzdCcgKyBjYW1lbF0gfHwgbmV3Q2xhc3MucHJvdG90eXBlWydfX3VwZGF0ZScgKyBjYW1lbF0gfHxcbiAgICBuZXdDbGFzcy5wcm90b3R5cGVbJ19fZ2V0JyArIGNhbWVsXTtcbiAgaWYgKGhhc0RlZmluaXRpb25zKSB7XG4gICAgLy8gc2V0IGRlZmF1bHQgdmFsdWVcbiAgICBuZXdDbGFzcy5wcm90b3R5cGVbcEtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbcHJvcGVydHlOYW1lXTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdDbGFzcy5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpc1snX19nZXQnICsgY2FtZWxdID8gdGhpc1snX19nZXQnICsgY2FtZWxdKHBLZXkpIDogdGhpc1twS2V5XTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpblZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSB0aGlzW3BLZXldO1xuICAgICAgICBpZiAoaW5WYWx1ZSAhPT0gaW5pdGlhbCkge1xuICAgICAgICAgIGlmICh0aGlzWydfX2FkanVzdCcgKyBjYW1lbF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXNbJ19fYWRqdXN0JyArIGNhbWVsXShpblZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkgaW5WYWx1ZSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1twS2V5XSA9IGluVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluVmFsdWUgIT09IGluaXRpYWwpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXppbmcgJiYgdGhpc1snX191cGRhdGUnICsgY2FtZWxdKSB7XG4gICAgICAgICAgICB0aGlzWydfX3VwZGF0ZScgKyBjYW1lbF0oaW5WYWx1ZSwgaW5pdGlhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRDbGFzcyhuZXdDbGFzcywgY2xhc3NOYW1lKSB7XG4gIC8vIE1ha2Ugc3VyZSBvdXIgbmV3IGNsYXNzIGhhcyBhIG5hbWUgcHJvcGVydHlcbiAgaWYgKCFuZXdDbGFzcy5uYW1lKSBuZXdDbGFzcy5uYW1lID0gY2xhc3NOYW1lO1xuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgbmV3IGNsYXNzIGhhcyBhIF9zdXBwb3J0ZWRFdmVudHMsIF9pZ25vcmVkRXZlbnRzLCBfaW5PYmplY3RJZ25vcmUgYW5kIEVWRU5UUyBwcm9wZXJ0aWVzXG4gIGlmICghbmV3Q2xhc3MuX3N1cHBvcnRlZEV2ZW50cykgbmV3Q2xhc3MuX3N1cHBvcnRlZEV2ZW50cyA9IFJvb3QuX3N1cHBvcnRlZEV2ZW50cztcbiAgaWYgKCFuZXdDbGFzcy5faWdub3JlZEV2ZW50cykgbmV3Q2xhc3MuX2lnbm9yZWRFdmVudHMgPSBSb290Ll9pZ25vcmVkRXZlbnRzO1xuXG4gIC8vIEdlbmVyYXRlIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzOyB3ZSBkb24ndCBpbmNsdWRlIGFueVxuICAvLyBwcm9wZXJ0aWVzIGZyb20gbGF5ZXIuUm9vdFxuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmV3Q2xhc3MucHJvdG90eXBlKS5maWx0ZXIoa2V5ID0+XG4gICAgbmV3Q2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KGtleSkgJiZcbiAgICAhUm9vdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgIHR5cGVvZiBuZXdDbGFzcy5wcm90b3R5cGVba2V5XSAhPT0gJ2Z1bmN0aW9uJ1xuICApO1xuXG4gIC8vIERlZmluZSBnZXR0ZXJzL3NldHRlcnMgZm9yIGFueSBwcm9wZXJ0eSB0aGF0IGhhcyBfX2FkanVzdCBvciBfX3VwZGF0ZSBtZXRob2RzIGRlZmluZWRcbiAga2V5cy5mb3JFYWNoKG5hbWUgPT4gZGVmaW5lUHJvcGVydHkobmV3Q2xhc3MsIG5hbWUpKTtcbn1cblxuLyoqXG4gKiBTZXQgdG8gdHJ1ZSBvbmNlIGRlc3Ryb3koKSBoYXMgYmVlbiBjYWxsZWQuXG4gKlxuICogQSBkZXN0cm95ZWQgb2JqZWN0IHdpbGwgbGlrZWx5IGNhdXNlIGVycm9ycyBpbiBhbnkgYXR0ZW1wdFxuICogdG8gY2FsbCBtZXRob2RzIG9uIGl0LCBhbmQgd2lsbCBubyBsb25nZXIgdHJpZ2dlciBldmVudHMuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblJvb3QucHJvdG90eXBlLmlzRGVzdHJveWVkID0gZmFsc2U7XG5cbi8qKlxuICogRXZlcnkgaW5zdGFuY2UgaGFzIGl0cyBvd24gaW50ZXJuYWwgSUQuXG4gKlxuICogVGhpcyBJRCBpcyBkaXN0aW5jdCBmcm9tIGFueSBJRHMgYXNzaWduZWQgYnkgdGhlIHNlcnZlci5cbiAqIFRoZSBpbnRlcm5hbCBJRCBpcyBnYXVyZW50ZWVkIG5vdCB0byBjaGFuZ2Ugd2l0aGluIHRoZSBsaWZldGltZSBvZiB0aGUgT2JqZWN0L3Nlc3Npb247XG4gKiBpdCBpcyBwb3NzaWJsZSwgb24gY3JlYXRpbmcgYSBuZXcgb2JqZWN0LCBmb3IgaXRzIGBpZGAgcHJvcGVydHkgdG8gY2hhbmdlLlxuICpcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cblJvb3QucHJvdG90eXBlLmludGVybmFsSWQgPSAnJztcblxuLyoqXG4gKiBUcnVlIHdoaWxlIHdlIGFyZSBpbiB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cblJvb3QucHJvdG90eXBlLmlzSW5pdGlhbGl6aW5nID0gdHJ1ZTtcblxuLyoqXG4gKiBPYmplY3RzIHRoYXQgdGhpcyBvYmplY3QgaXMgbGlzdGVuaW5nIGZvciBldmVudHMgZnJvbS5cbiAqXG4gKiBAdHlwZSB7bGF5ZXIuUm9vdFtdfVxuICovXG5Sb290LnByb3RvdHlwZS5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG5cbi8qKlxuICogRGlzYWJsZSBhbGwgZXZlbnRzIHRyaWdnZXJlZCBvbiB0aGlzIG9iamVjdC5cbiAqIEB0eXBlIHtib29sZWFufVxuICovXG5Sb290LnByb3RvdHlwZS5fZGlzYWJsZUV2ZW50cyA9IGZhbHNlO1xuXG5cblJvb3QuX3N1cHBvcnRlZEV2ZW50cyA9IFsnZGVzdHJveScsICdhbGwnXTtcblJvb3QuX2lnbm9yZWRFdmVudHMgPSBbXTtcbm1vZHVsZS5leHBvcnRzID0gUm9vdDtcbm1vZHVsZS5leHBvcnRzLmluaXRDbGFzcyA9IGluaXRDbGFzcztcbiIsIi8qKlxuICogQSBTeW5jIEV2ZW50IHJlcHJlc2VudHMgYSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIuXG4gKiBBIFN5bmMgRXZlbnQgbWF5IGZpcmUgaW1tZWRpYXRlbHksIG9yIG1heSB3YWl0IGluIHRoZSBsYXllci5TeW5jTWFuYWdlcidzXG4gKiBxdWV1ZSBmb3IgYSBsb25nIGR1cmF0aW9uIGJlZm9yZSBmaXJpbmcuXG4gKlxuICogRE8gTk9UIGNvbmZ1c2UgdGhpcyB3aXRoIGxheWVyLkxheWVyRXZlbnQgd2hpY2ggcmVwcmVzZW50cyBhIGNoYW5nZSBub3RpZmljYXRpb25cbiAqIHRvIHlvdXIgYXBwbGljYXRpb24uICBsYXllci5TeW5jRXZlbnQgcmVwcmVzZW50cyBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0aGF0XG4gKiBpcyBlaXRoZXIgaW4gcHJvZ3Jlc3Mgb3IgaW4gcXVldWUuXG4gKlxuICogR0VUIHJlcXVlc3RzIGFyZSB0eXBpY2FsbHkgTk9UIGRvbmUgdmlhIGEgU3luY0V2ZW50IGFzIHRoZXNlIGFyZSB0eXBpY2FsbHlcbiAqIG5lZWRlZCB0byByZW5kZXIgYSBVSSBhbmQgc2hvdWxkIGVpdGhlciBmYWlsIG9yIHN1Y2NlZWQgcHJvbXB0bHkuXG4gKlxuICogQXBwbGljYXRpb25zIHR5cGljYWxseSBkbyBub3QgaW50ZXJhY3Qgd2l0aCB0aGVzZSBvYmplY3RzLlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuU3luY0V2ZW50XG4gKiBAZXh0ZW5kcyBsYXllci5Sb290XG4gKi9cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi9jbGllbnQtdXRpbHMnKTtcbmNsYXNzIFN5bmNFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsYXllci5TeW5jRXZlbnQuICBTZWUgbGF5ZXIuQ2xpZW50QXV0aGVudGljYXRvciBmb3IgZXhhbXBsZXMgb2YgdXNhZ2UuXG4gICAqXG4gICAqIEBtZXRob2QgIGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge2xheWVyLlN5bmNFdmVudH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChrZXkgaW4gdGhpcykge1xuICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy5kZXBlbmRzKSB0aGlzLmRlcGVuZHMgPSBbXTtcbiAgICBpZiAoIXRoaXMuaWQpIHRoaXMuaWQgPSAnbGF5ZXI6Ly8vc3luY2V2ZW50cy8nICsgVXRpbHMuZ2VuZXJhdGVVVUlEKCk7XG4gICAgaWYgKCF0aGlzLmNyZWF0ZWRBdCkgdGhpcy5jcmVhdGVkQXQgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vdCBzdHJpY3RseSByZXF1aXJlZCwgYnV0IG5pY2UgdG8gY2xlYW4gdGhpbmdzIHVwLlxuICAgKlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgIHRoaXMuZGVwZW5kcyA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFJlYWwgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgX3VwZGF0ZURhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVEYXRhKGNsaWVudCkge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXQgPSBjbGllbnQuX2dldE9iamVjdCh0aGlzLnRhcmdldCk7XG4gICAgaWYgKHRhcmdldCAmJiB0aGlzLm9wZXJhdGlvbiA9PT0gJ1BPU1QnICYmIHRhcmdldC5fZ2V0U2VuZERhdGEpIHtcbiAgICAgIHRoaXMuZGF0YSA9IHRhcmdldC5fZ2V0U2VuZERhdGEodGhpcy5kYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFBPSk8gdmVyc2lvbiBvZiB0aGlzIG9iamVjdCBzdWl0YWJsZSBmb3Igc2VyaWFsaXppbmcgZm9yIHRoZSBuZXR3b3JrXG4gICAqIEBtZXRob2QgdG9PYmplY3RcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KCkge1xuICAgIHJldHVybiB7IGRhdGE6IHRoaXMuZGF0YSB9O1xuICB9XG59XG5cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiBvcGVyYXRpb24gYmVpbmcgcGVyZm9ybWVkLlxuICpcbiAqIEVpdGhlciBHRVQsIFBBVENILCBERUxFVEUsIFBPU1Qgb3IgUFVUXG4gKlxuICogQHByb3BlcnR5IHtTdHJpbmd9XG4gKi9cblN5bmNFdmVudC5wcm90b3R5cGUub3BlcmF0aW9uID0gJyc7XG5cblN5bmNFdmVudC5wcm90b3R5cGUuZnJvbURCID0gZmFsc2U7XG5cblN5bmNFdmVudC5wcm90b3R5cGUuY3JlYXRlZEF0ID0gMDtcblxuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgcmVxdWVzdCBjdXJyZW50bHkgaW4tZmxpZ2h0LlxuICpcbiAqICogU2V0IHRvIHRydWUgYnkgX3hocigpIG1ldGhvZCxcbiAqICogc2V0IHRvIGZhbHNlIG9uIGNvbXBsZXRpb24gYnkgbGF5ZXIuU3luY01hbmFnZXIuXG4gKiAqIHNldCB0byBmYWxzZSBhdXRvbWF0aWNhbGx5IGFmdGVyIDIgbWludXRlc1xuICpcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bmNFdmVudC5wcm90b3R5cGUsICdpc0ZpcmluZycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICB0aGlzLl9faXNGaXJpbmcgPSB2YWx1ZTtcbiAgICBpZiAodmFsdWUpIHRoaXMuX19maXJlZEF0ID0gRGF0ZS5ub3coKTtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2lzRmlyaW5nICYmIERhdGUubm93KCkgLSB0aGlzLl9fZmlyZWRBdCA8IFN5bmNFdmVudC5GSVJJTkdfRVhQSVJJQVRJT04pO1xuICB9LFxufSk7XG5cblN5bmNFdmVudC5wcm90b3R5cGUuaWQgPSAnJztcblxuXG4vKipcbiAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogU2V0IGJ5IGxheWVyLlN5bmNNYW5hZ2VyLlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblN5bmNFdmVudC5wcm90b3R5cGUuc3VjY2VzcyA9IG51bGw7XG5cblxuLyoqXG4gKiBDYWxsYmFjayB0byBmaXJlIG9uIGNvbXBsZXRpbmcgdGhpcyBzeW5jIGV2ZW50LlxuICpcbiAqIFdBUk5JTkc6IFRoZSBuYXR1cmUgb2YgdGhpcyBjYWxsYmFjayBtYXkgY2hhbmdlO1xuICogYSBwZXJzaXN0ZW5jZSBsYXllciB0aGF0IHBlcnNpc3RzIHRoZSBTeW5jTWFuYWdlcidzIHF1ZXVlXG4gKiBtdXN0IGhhdmUgc2VyaWFsaXphYmxlIGNhbGxiYWNrcyAob2JqZWN0IGlkICsgbWV0aG9kIG5hbWU7IG5vdCBhIGZ1bmN0aW9uKVxuICogb3IgbXVzdCBhY2NlcHQgdGhhdCBjYWxsYmFja3MgYXJlIG5vdCBhbHdheXMgZmlyZWQuXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKi9cblN5bmNFdmVudC5wcm90b3R5cGUuY2FsbGJhY2sgPSBudWxsO1xuXG4vKipcbiAqIE51bWJlciBvZiByZXRyaWVzIG9uIHRoaXMgcmVxdWVzdC5cbiAqXG4gKiBSZXRyaWVzIGFyZSBvbmx5IGNvdW50ZWQgaWYgaXRzIGEgNTAyIG9yIDUwM1xuICogZXJyb3IuICBTZXQgYW5kIG1hbmFnZWQgYnkgbGF5ZXIuU3luY01hbmFnZXIuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5TeW5jRXZlbnQucHJvdG90eXBlLnJldHJ5Q291bnQgPSAwO1xuXG4vKipcbiAqIFRoZSB0YXJnZXQgb2YgdGhlIHJlcXVlc3QuXG4gKlxuICogQW55IENvbXBvbmVudDsgdHlwaWNhbGx5IGEgQ29udmVyc2F0aW9uIG9yIE1lc3NhZ2UuXG4gKiBAdHlwZSB7bGF5ZXIuUm9vdH1cbiAqL1xuU3luY0V2ZW50LnByb3RvdHlwZS50YXJnZXQgPSBudWxsO1xuXG4vKipcbiAqIENvbXBvbmVudHMgdGhhdCB0aGlzIHJlcXVlc3QgZGVwZW5kcyB1cG9uLlxuICpcbiAqIEEgbWVzc2FnZSBjYW5ub3QgYmUgc2VudCBpZiBpdHNcbiAqIENvbnZlcnNhdGlvbiBmYWlscyB0byBnZXQgY3JlYXRlZC5cbiAqXG4gKiBOT1RFOiBNYXkgcHJvdmUgcmVkdW5kYW50IHdpdGggdGhlIHRhcmdldCBwcm9wZXJ0eSBhbmQgbmVlZHMgZnVydGhlciByZXZpZXcuXG4gKiBAdHlwZSB7bGF5ZXIuUm9vdFtdfVxuICovXG5TeW5jRXZlbnQucHJvdG90eXBlLmRlcGVuZHMgPSBudWxsO1xuXG4vKipcbiAqIERhdGEgZmllbGQgb2YgdGhlIHhociBjYWxsOyBjYW4gYmUgYW4gT2JqZWN0IG9yIHN0cmluZyAoaW5jbHVkaW5nIEpTT04gc3RyaW5nKVxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU3luY0V2ZW50LnByb3RvdHlwZS5kYXRhID0gbnVsbDtcblxuLyoqXG4gKiBBZnRlciBmaXJpbmcgYSByZXF1ZXN0LCBpZiB0aGF0IGZpcmluZyBzdGF0ZSBmYWlscyB0byBjbGVhciBhZnRlciB0aGlzIG51bWJlciBvZiBtaWxpc2Vjb25kcyxcbiAqIGNvbnNpZGVyIGl0IHRvIG5vIGxvbmdlciBiZSBmaXJpbmcuICBVbmRlciBub3JtYWwgY29uZGl0aW9ucywgZmlyaW5nIHdpbGwgYmUgc2V0IHRvIGZhbHNlIGV4cGxpY2l0bHkuXG4gKiBUaGlzIGNoZWNrIGluc3VyZXMgdGhhdCBhbnkgZmFpbHVyZSBvZiB0aGF0IHByb2Nlc3MgZG9lcyBub3QgbGVhdmUgdXMgc3R1Y2sgd2l0aCBhIGZpcmluZyByZXF1ZXN0XG4gKiBibG9ja2luZyB0aGUgcXVldWUuXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5TeW5jRXZlbnQuRklSSU5HX0VYUElSSUFUSU9OID0gMTAwMCAqIDYwICogMjtcblxuLyoqXG4gKiBBIGxheWVyLlN5bmNFdmVudCBpbnRlbmRlZCB0byBiZSBmaXJlZCBhcyBhbiBYSFIgcmVxdWVzdC5cbiAqXG4gKiBAY2xhc3MgbGF5ZXIuU3luY0V2ZW50LlhIUlN5bmNFdmVudFxuICogQGV4dGVuZHMgbGF5ZXIuU3luY0V2ZW50XG4gKi9cbmNsYXNzIFhIUlN5bmNFdmVudCBleHRlbmRzIFN5bmNFdmVudCB7XG5cbiAgLyoqXG4gICAqIEZpcmUgdGhlIHJlcXVlc3QgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAqXG4gICAqIEFjdHVhbGx5IGl0IGp1c3QgcmV0dXJucyB0aGUgcGFyYW1ldGVycyBuZWVkZWQgdG8gbWFrZSB0aGUgeGhyIGNhbGw6XG4gICAqXG4gICAqICAgICAgdmFyIHhociA9IHJlcXVpcmUoJy4veGhyJyk7XG4gICAqICAgICAgeGhyKGV2ZW50Ll9nZXRSZXF1ZXN0RGF0YShjbGllbnQpKTtcbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0UmVxdWVzdERhdGFcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBfZ2V0UmVxdWVzdERhdGEoY2xpZW50KSB7XG4gICAgdGhpcy5fdXBkYXRlVXJsKGNsaWVudCk7XG4gICAgdGhpcy5fdXBkYXRlRGF0YShjbGllbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgUmVhbCBVUkwuXG4gICAqXG4gICAqIElmIHRoZSB1cmwgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCB0byBzZXQgdGhlIGFjdHVhbCB1cmwuXG4gICAqIFVzZWQgd2hlbiB0aGUgVVJMIGlzIHVua25vd24gdW50aWwgYSBwcmlvciBTeW5jRXZlbnQgaGFzIGNvbXBsZXRlZC5cbiAgICpcbiAgICogQG1ldGhvZCBfdXBkYXRlVXJsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlVXJsKGNsaWVudCkge1xuICAgIGlmICghdGhpcy50YXJnZXQpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXQgPSBjbGllbnQuX2dldE9iamVjdCh0aGlzLnRhcmdldCk7XG4gICAgaWYgKHRhcmdldCAmJiAhdGhpcy51cmwubWF0Y2goL15odHRwKHMpXFw6XFwvXFwvLykpIHtcbiAgICAgIHRoaXMudXJsID0gdGFyZ2V0Ll9nZXRVcmwodGhpcy51cmwpO1xuICAgIH1cbiAgfVxuXG4gIHRvT2JqZWN0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICB9O1xuICB9XG5cbiAgX2dldENyZWF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLm9wZXJhdGlvbiA9PT0gJ1BPU1QnICYmIHRoaXMuZGF0YSA/IHRoaXMuZGF0YS5pZCA6ICcnO1xuICB9XG59XG5cbi8qKlxuICogSG93IGxvbmcgYmVmb3JlIHRoZSByZXF1ZXN0IHRpbWVzIG91dD9cbiAqIEB0eXBlIHtOdW1iZXJ9IFt0aW1lb3V0PTE1MDAwXVxuICovXG5YSFJTeW5jRXZlbnQucHJvdG90eXBlLnRpbWVvdXQgPSAxNTAwMDtcblxuLyoqXG4gKiBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0b1xuICovXG5YSFJTeW5jRXZlbnQucHJvdG90eXBlLnVybCA9ICcnO1xuXG4vKipcbiAqIENvdW50cyBudW1iZXIgb2Ygb25saW5lIHN0YXRlIGNoYW5nZXMuXG4gKlxuICogSWYgdGhpcyBudW1iZXIgYmVjb21lcyBoaWdoIGluIGEgc2hvcnQgdGltZSBwZXJpb2QsIGl0cyBwcm9iYWJseVxuICogZmFpbGluZyBkdWUgdG8gYSBDT1JTIGVycm9yLlxuICovXG5YSFJTeW5jRXZlbnQucHJvdG90eXBlLnJldHVyblRvT25saW5lQ291bnQgPSAwO1xuXG4vKipcbiAqIEhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0XG4gKi9cblhIUlN5bmNFdmVudC5wcm90b3R5cGUuaGVhZGVycyA9IG51bGw7XG5cbi8qKlxuICogUmVxdWVzdCBtZXRob2QuXG4gKi9cblhIUlN5bmNFdmVudC5wcm90b3R5cGUubWV0aG9kID0gJ0dFVCc7XG5cblxuLyoqXG4gKiBBIGxheWVyLlN5bmNFdmVudCBpbnRlbmRlZCB0byBiZSBmaXJlZCBhcyBhIHdlYnNvY2tldCByZXF1ZXN0LlxuICpcbiAqIEBjbGFzcyBsYXllci5TeW5jRXZlbnQuV2Vic29ja2V0U3luY0V2ZW50XG4gKiBAZXh0ZW5kcyBsYXllci5TeW5jRXZlbnRcbiAqL1xuY2xhc3MgV2Vic29ja2V0U3luY0V2ZW50IGV4dGVuZHMgU3luY0V2ZW50IHtcblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWJzb2NrZXQgcmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldFJlcXVlc3REYXRhXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2dldFJlcXVlc3REYXRhKGNsaWVudCkge1xuICAgIHRoaXMuX3VwZGF0ZURhdGEoY2xpZW50KTtcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xuICB9XG5cbiAgdG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YTtcbiAgfVxuXG4gIF9nZXRDcmVhdGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb24gPT09ICdQT1NUJyAmJiB0aGlzLmRhdGEuZGF0YSA/IHRoaXMuZGF0YS5kYXRhLmlkIDogJyc7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFN5bmNFdmVudCwgWEhSU3luY0V2ZW50LCBXZWJzb2NrZXRTeW5jRXZlbnQgfTtcbiIsIi8qKlxuICogQGNsYXNzICBsYXllci5TeW5jTWFuYWdlclxuICogQGV4dGVuZHMgbGF5ZXIuUm9vdFxuICogQHByb3RlY3RlZFxuICpcbiAqIFRoaXMgY2xhc3MgbWFuYWdlc1xuICpcbiAqIDEuIGEgcXVldWUgb2YgcmVxdWVzdHMgdGhhdCBuZWVkIHRvIGJlIG1hZGVcbiAqIDIuIHdoZW4gYSByZXF1ZXN0IHNob3VsZCBiZSBmaXJlZCwgYmFzZWQgb24gYXV0aGVudGljYXRpb24gc3RhdGUsIG9ubGluZSBzdGF0ZSwgd2Vic29ja2V0IGNvbm5lY3Rpb24gc3RhdGUsIGFuZCBwb3NpdGlvbiBpbiB0aGUgcXVldWVcbiAqIDMuIHdoZW4gYSByZXF1ZXN0IHNob3VsZCBiZSBhYm9ydGVkXG4gKiA0LiB0cmlnZ2VyaW5nIGFueSByZXF1ZXN0IGNhbGxiYWNrc1xuICpcbiAqIFRPRE8gV0VCLTg1MDogQ3VycmVudGx5IHRoZSBzeW5jIHF1ZXVlIGlzIG1hbmFnZWQgc29sZWx5IGluIHJ1bnRpbWUgbWVtb3J5LiAgQnV0IHRoZSBxdWV1ZSBzaG91bGQgYmUgc3RvcmVkXG4gKiBpbiBwZXJzaXN0ZW50IG1lbW9yeSBzbyB0aGF0IGEgdGFiLXJlbG9hZCBjYW4gcmVzdG9yZSB0aGUgcXVldWUgd2l0aG91dCBsb3NpbmcgY29tbWFuZHMgdGhhdCB0aGUgdXNlciBoYXNcbiAqIGJlZW4gdG9sZCBoYXZlIGJlZW4gYWNjZXB0ZWQuXG4gKlxuICogVE9ETzogSW4gdGhlIGV2ZW50IG9mIGEgRE5TIGVycm9yLCB3ZSBtYXkgaGF2ZSBhIHZhbGlkIHdlYnNvY2tldCByZWNlaXZpbmcgZXZlbnRzIGFuZCB0ZWxsaW5nIHVzIHdlIGFyZSBvbmxpbmUsXG4gKiBhbmQgYmUgdW5hYmxlIHRvIGNyZWF0ZSBhIFJFU1QgY2FsbC4gIFRoaXMgd2lsbCBiZSBoYW5kbGVkIHdyb25nIGJlY2F1c2UgZXZpZGVuY2Ugd2lsbCBzdWdnZXN0IHRoYXQgd2UgYXJlIG9ubGluZS5cbiAqIFRoaXMgaXNzdWUgZ29lcyBhd2F5IHdoZW4gd2UgdXNlIGJpZGlyZWN0aW9uYWwgd2Vic29ja2V0cyBmb3IgYWxsIHJlcXVlc3RzLlxuICpcbiAqIEFwcGxpY2F0aW9ucyBkbyBub3QgdHlwaWNhbGx5IGludGVyYWN0IHdpdGggdGhpcyBjbGFzcywgYnV0IG1heSBzdWJzY3JpYmUgdG8gaXRzIGV2ZW50c1xuICogdG8gZ2V0IHJpY2hlciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB0aGFuIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSBsYXllci5DbGllbnQgaW5zdGFuY2UuXG4gKi9cbmNvbnN0IFJvb3QgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbmNvbnN0IHsgV2Vic29ja2V0U3luY0V2ZW50IH0gPSByZXF1aXJlKCcuL3N5bmMtZXZlbnQnKTtcbmNvbnN0IHhociA9IHJlcXVpcmUoJy4veGhyJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuL2NsaWVudC11dGlscycpO1xuXG5jbGFzcyBTeW5jTWFuYWdlciBleHRlbmRzIFJvb3Qge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBTeW5jTWFuYWdlci5cbiAgICpcbiAgICogQW4gQXBwbGljYXRpb24gaXMgZXhwZWN0ZWQgdG8gb25seSBoYXZlIG9uZSBTeW5jTWFuYWdlci5cbiAgICpcbiAgICogICAgICB2YXIgc29ja2V0TWFuYWdlciA9IG5ldyBsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXIoe2NsaWVudDogY2xpZW50fSk7XG4gICAqICAgICAgdmFyIHJlcXVlc3RNYW5hZ2VyID0gbmV3IGxheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXIoe2NsaWVudDogY2xpZW50LCBzb2NrZXRNYW5hZ2VyOiBzb2NrZXRNYW5hZ2VyfSk7XG4gICAqXG4gICAqICAgICAgdmFyIG9ubGluZU1hbmFnZXIgPSBuZXcgbGF5ZXIuT25saW5lTWFuYWdlcih7XG4gICAqICAgICAgICAgIHNvY2tldE1hbmFnZXI6IHNvY2tldE1hbmFnZXJcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogICAgICAvLyBOb3cgd2UgY2FuIGluc3RhbnRpYXRlIHRoaXMgdGhpbmcuLi5cbiAgICogICAgICB2YXIgU3luY01hbmFnZXIgPSBuZXcgbGF5ZXIuU3luY01hbmFnZXIoe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICAgICAgb25saW5lTWFuYWdlcjogb25saW5lTWFuYWdlcixcbiAgICogICAgICAgICAgc29ja2V0TWFuYWdlcjogc29ja2V0TWFuYWdlcixcbiAgICogICAgICAgICAgcmVxdWVzdE1hbmFnZXI6IHJlcXVlc3RNYW5hZ2VyXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bGF5ZXIuT25saW5lU3RhdGVNYW5hZ2VyfSBvcHRpb25zLm9ubGluZU1hbmFnZXJcbiAgICogQHBhcmFtIHtsYXllci5XZWJzb2NrZXRzLlJlcXVlc3RNYW5hZ2VyfSBvcHRpb25zLnJlcXVlc3RNYW5hZ2VyXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBvcHRpb25zLmNsaWVudFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIHRoaXMuY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG5cbiAgICAvLyBOb3RlIHdlIGRvIG5vdCBzdG9yZSBhIHBvaW50ZXIgdG8gY2xpZW50Li4uIGl0IGlzIG5vdCBuZWVkZWQuXG4gICAgaWYgKHRoaXMuY2xpZW50KSB7XG4gICAgICB0aGlzLmNsaWVudC5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NOZXh0UmVxdWVzdCgpO1xuICAgICAgICB0aGlzLl9sb2FkUGVyc2lzdGVkUXVldWUoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICB0aGlzLnF1ZXVlID0gW107XG5cbiAgICB0aGlzLm9ubGluZU1hbmFnZXIub24oJ2Rpc2Nvbm5lY3RlZCcsIHRoaXMuX29ubGluZVN0YXRlQ2hhbmdlLCB0aGlzKTtcbiAgICB0aGlzLnNvY2tldE1hbmFnZXIub24oJ2Nvbm5lY3RlZCBkaXNjb25uZWN0ZWQnLCB0aGlzLl9vbmxpbmVTdGF0ZUNoYW5nZSwgdGhpcyk7XG4gIH1cblxuICBpc09ubGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vbmxpbmVNYW5hZ2VyLmlzT25saW5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3Mgc3luYyByZXF1ZXN0IHdoZW4gY29ubmVjdGlvbiBpcyByZXN0b3JlZC5cbiAgICpcbiAgICogQW55IHRpbWUgd2UgZ28gYmFjayBvbmxpbmUgKGFzIHNpZ25hbGVkIGJ5IHRoZSBvbmxpbmVTdGF0ZU1hbmFnZXIpLFxuICAgKiBQcm9jZXNzIHRoZSBuZXh0IFN5bmMgRXZlbnQgKHdpbGwgZG8gbm90aGluZyBpZiBvbmUgaXMgYWxyZWFkeSBmaXJpbmcpXG4gICAqXG4gICAqIEBtZXRob2QgX29ubGluZVN0YXRlQ2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZXZ0TmFtZSAtICdjb25uZWN0ZWQnIG9yICdkaXNjb25uZWN0ZWQnXG4gICAqIEBwYXJhbSAge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgX29ubGluZVN0YXRlQ2hhbmdlKGV2dCkge1xuICAgIGlmIChldnQuZXZlbnROYW1lID09PSAnY29ubmVjdGVkJykge1xuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB0aGlzLnF1ZXVlWzBdLnJldHVyblRvT25saW5lQ291bnQrKztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCksIDEwMCk7XG4gICAgfSBlbHNlIGlmIChldnQuZXZlbnROYW1lID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucXVldWVbMF0uaXNGaXJpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyB4aHIgcmVxdWVzdCB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIElmIHRoZSBxdWV1ZSBpcyBlbXB0eSwgdGhpcyB3aWxsIGJlIGZpcmVkIGltbWVkaWF0ZWx5LlxuICAgKiBJZiB0aGUgcXVldWUgaXMgbm9uLWVtcHR5LCB0aGlzIHdpbGwgd2FpdCB1bnRpbCBhbGwgb3RoZXIgcmVxdWVzdHMgaW4gdGhlIHF1ZXVlIGhhdmUgYmVlbiBmaXJlZC5cbiAgICpcbiAgICogQG1ldGhvZCByZXF1ZXN0XG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIEEgU3luY0V2ZW50IHNwZWNpZnlpbmcgdGhlIHJlcXVlc3QgdG8gYmUgbWFkZVxuICAgKi9cbiAgcmVxdWVzdChyZXF1ZXN0RXZ0KSB7XG4gICAgLy8gSWYgaXRzIGEgUEFUQ0ggcmVxdWVzdCBvbiBhbiBvYmplY3QgdGhhdCBpc24ndCB5ZXQgY3JlYXRlZCxcbiAgICAvLyBkbyBub3QgYWRkIGl0IHRvIHRoZSBxdWV1ZS5cbiAgICBpZiAocmVxdWVzdEV2dC5vcGVyYXRpb24gIT09ICdQQVRDSCcgfHwgIXRoaXMuX2ZpbmRVbmZpcmVkQ3JlYXRlKHJlcXVlc3RFdnQpKSB7XG4gICAgICBsb2dnZXIuaW5mbyhgU3luYyBNYW5hZ2VyIFJlcXVlc3QgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gb24gdGFyZ2V0ICR7cmVxdWVzdEV2dC50YXJnZXR9YCk7XG4gICAgICBsb2dnZXIuZGVidWcocmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICAgIHRoaXMucXVldWUucHVzaChyZXF1ZXN0RXZ0KTtcbiAgICAgIHRoaXMudHJpZ2dlcignc3luYzphZGQnLCB7XG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RFdnQsXG4gICAgICAgIHRhcmdldDogcmVxdWVzdEV2dC50YXJnZXQsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oYFN5bmMgTWFuYWdlciBSZXF1ZXN0IFBBVENIICR7cmVxdWVzdEV2dC50YXJnZXR9IHJlcXVlc3QgaWdub3JlZDsgY3JlYXRlIHJlcXVlc3Qgc3RpbGwgZW5xdWV1ZWRgKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhyZXF1ZXN0RXZ0LnRvT2JqZWN0KCkpO1xuICAgIH1cblxuICAgIC8vIElmIGl0cyBhIERFTEVURSByZXF1ZXN0LCBwdXJnZSBhbGwgb3RoZXIgcmVxdWVzdHMgb24gdGhhdCB0YXJnZXQuXG4gICAgaWYgKHJlcXVlc3RFdnQub3BlcmF0aW9uID09PSAnREVMRVRFJykge1xuICAgICAgdGhpcy5fcHVyZ2VPbkRlbGV0ZShyZXF1ZXN0RXZ0KTtcbiAgICB9XG5cbiAgICAvLyBGaXJlIHRoZSByZXF1ZXN0IGlmIHRoZXJlIGFyZW4ndCBhbnkgZXhpc3RpbmcgcmVxdWVzdHMgYWxyZWFkeSBiZWluZyBwcm9jZXNzZWQuXG4gICAgLy8gSWYgdGhpcyBpc24ndCB0aGUgZmlyc3QgaXRlbSwgYXNzdW1lIHRoYXQgYWxsIG5lY2Vzc2FyeSBsb2dpYyBleGlzdHMgdG8gZmlyZSB0aGVcbiAgICAvLyBleGlzdGluZyByZXF1ZXN0cyBhbmQgdGhlbiBpdCB3aWxsIG1vdmUgb250byB0aGlzIHJlcXVlc3QuXG4gICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID09PSAxIHx8ICF0aGlzLnF1ZXVlWzBdLmlzRmlyaW5nKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZCBjcmVhdGUgcmVxdWVzdCBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICpcbiAgICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiB0YXJnZXQgaGFzIGEgUE9TVCByZXF1ZXN0IHdhaXRpbmcgdG8gY3JlYXRlXG4gICAqIHRoZSByZXNvdXJjZSwgYW5kIHJldHVybiBhbnkgbWF0Y2hpbmcgcmVxdWVzdHMuIFVzZWRcbiAgICogZm9yIGZvbGRpbmcgUEFUQ0ggcmVxdWVzdHMgaW50byBhbiB1bmZpcmVkIENSRUFURS9QT1NUIHJlcXVlc3QuXG4gICAqXG4gICAqIEBtZXRob2QgX2ZpbmRVbmZpcmVkQ3JlYXRlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgX2ZpbmRVbmZpcmVkQ3JlYXRlKHJlcXVlc3RFdnQpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLnF1ZXVlLmZpbHRlcihldnQgPT5cbiAgICAgIGV2dC50YXJnZXQgPT09IHJlcXVlc3RFdnQudGFyZ2V0ICYmIGV2dC5vcGVyYXRpb24gPT09ICdQT1NUJyAmJiAhZXZ0LmlzRmlyaW5nKS5sZW5ndGhcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgdGhlIG5leHQgcmVxdWVzdCBpbiB0aGUgcXVldWUuXG4gICAqXG4gICAqIFJlcXVlc3QgaXMgZGVxdWV1ZWQgb24gY29tcGxldGluZyB0aGUgcHJvY2Vzcy5cbiAgICogSWYgdGhlIGZpcnN0IHJlcXVlc3QgaW4gdGhlIHF1ZXVlIGlzIGZpcmluZywgZG8gbm90aGluZy5cbiAgICpcbiAgICogQG1ldGhvZCBfcHJvY2Vzc05leHRSZXF1ZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc05leHRSZXF1ZXN0KCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgY29uc3QgcmVxdWVzdEV2dCA9IHRoaXMucXVldWVbMF07XG4gICAgaWYgKHRoaXMuaXNPbmxpbmUoKSAmJiByZXF1ZXN0RXZ0ICYmICFyZXF1ZXN0RXZ0LmlzRmlyaW5nKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZVJlcXVlc3QocmVxdWVzdEV2dCwgaXNWYWxpZCA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZVJlcXVlc3QocmVxdWVzdEV2dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3NOZXh0UmVxdWVzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0RXZ0IGluc3RhbmNlb2YgV2Vic29ja2V0U3luY0V2ZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuc29ja2V0TWFuYWdlciAmJiB0aGlzLnNvY2tldE1hbmFnZXIuX2lzT3BlbigpKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYFN5bmMgTWFuYWdlciBXZWJzb2NrZXQgUmVxdWVzdCBGaXJpbmcgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gb24gdGFyZ2V0ICR7cmVxdWVzdEV2dC50YXJnZXR9YCxcbiAgICAgICAgICAgICAgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdE1hbmFnZXIuc2VuZFJlcXVlc3QocmVxdWVzdEV2dC5fZ2V0UmVxdWVzdERhdGEodGhpcy5jbGllbnQpLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9PiB0aGlzLl94aHJSZXN1bHQocmVzdWx0LCByZXF1ZXN0RXZ0KSk7XG4gICAgICAgICAgICByZXF1ZXN0RXZ0LmlzRmlyaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdTeW5jIE1hbmFnZXIgV2Vic29ja2V0IFJlcXVlc3Qgc2tpcHBlZDsgc29ja2V0IGNsb3NlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoYFN5bmMgTWFuYWdlciBYSFIgUmVxdWVzdCBGaXJpbmcgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gJHtyZXF1ZXN0RXZ0LnRhcmdldH1gLFxuICAgICAgICAgICAgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICAgICAgICB4aHIocmVxdWVzdEV2dC5fZ2V0UmVxdWVzdERhdGEodGhpcy5jbGllbnQpLCByZXN1bHQgPT4gdGhpcy5feGhyUmVzdWx0KHJlc3VsdCwgcmVxdWVzdEV2dCkpO1xuICAgICAgICAgIHJlcXVlc3RFdnQuaXNGaXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3RFdnQgJiYgcmVxdWVzdEV2dC5pc0ZpcmluZykge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBTeW5jIE1hbmFnZXIgcHJvY2Vzc05leHQgc2tpcHBlZDsgcmVxdWVzdCBzdGlsbCBmaXJpbmcgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gYCArXG4gICAgICAgIGBvbiB0YXJnZXQgJHtyZXF1ZXN0RXZ0LnRhcmdldH1gLCByZXF1ZXN0RXZ0LnRvT2JqZWN0KCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgc3luY0V2ZW50IHN0aWxsIHZhbGlkP1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBzcGVjaWZpY2FsbHkgdGVzdHMgdG8gc2VlIGlmIHNvbWUgb3RoZXIgdGFiIGhhcyBhbHJlYWR5IHNlbnQgdGhpcyByZXF1ZXN0LlxuICAgKiBJZiBwZXJzaXN0ZW5jZSBvZiB0aGUgc3luY1F1ZXVlIGlzIG5vdCBlbmFibGVkLCB0aGVuIHRoZSBjYWxsYmFjayBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0cnVlLlxuICAgKiBJZiBhbm90aGVyIHRhYiBoYXMgYWxyZWFkeSBzZW50IHRoZSByZXF1ZXN0LCB0aGVuIHRoZSBlbnRyeSB3aWxsIG5vIGxvbmdlciBiZSBpbiBpbmRleGVkREIgYW5kIHRoZSBjYWxsYmFja1xuICAgKiB3aWxsIGNhbGwgZmFsc2UuXG4gICAqXG4gICAqIEBtZXRob2QgX3ZhbGlkYXRlUmVxdWVzdFxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gc3luY0V2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLmlzVmFsaWQgLSBUaGUgcmVxdWVzdCBpcyBzdGlsbCB2YWxpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlUmVxdWVzdChzeW5jRXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLmNsYWltU3luY0V2ZW50KHN5bmNFdmVudCwgaXNGb3VuZCA9PiBjYWxsYmFjayhpc0ZvdW5kKSk7XG4gIH1cblxuICAvKipcbiAgICogVHVybiBkZWR1cGxpY2F0aW9uIGVycm9ycyBpbnRvIHN1Y2Nlc3MgbWVzc2FnZXMuXG4gICAqXG4gICAqIElmIHRoaXMgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIG1hZGUgYnV0IHdlIGZhaWxlZCB0byBnZXQgYSByZXNwb25zZSB0aGUgZmlyc3QgdGltZSBhbmQgd2UgcmV0cmllZCB0aGUgcmVxdWVzdCxcbiAgICogd2Ugd2lsbCByZWlzc3VlIHRoZSByZXF1ZXN0LiAgSWYgdGhlIHByaW9yIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgd2UnbGwgZ2V0IGJhY2sgYSBkZWR1cGxpY2F0aW9uIGVycm9yXG4gICAqIHdpdGggdGhlIGNyZWF0ZWQgb2JqZWN0LiBBcyBmYXIgYXMgdGhlIFdlYlNESyBpcyBjb25jZXJuZWQsIHRoaXMgaXMgYSBzdWNjZXNzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVEZWR1cGxpY2F0aW9uRXJyb3JzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFuZGxlRGVkdXBsaWNhdGlvbkVycm9ycyhyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0LmRhdGEgJiYgcmVzdWx0LmRhdGEuaWQgPT09ICdpZF9pbl91c2UnICYmXG4gICAgICAgIHJlc3VsdC5kYXRhLmRhdGEgJiYgcmVzdWx0LmRhdGEuZGF0YS5pZCA9PT0gcmVzdWx0LnJlcXVlc3QuX2dldENyZWF0ZUlkKCkpIHtcbiAgICAgIHJlc3VsdC5zdWNjZXNzID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5kYXRhID0gcmVzdWx0LmRhdGEuZGF0YTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgcmVzdWx0IG9mIGFuIHhociBjYWxsLCByb3V0aW5nIGl0IHRvIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJSZXN1bHRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHQgIC0gUmVzcG9uc2Ugb2JqZWN0IHJldHVybmVkIGJ5IHhociBjYWxsXG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIFJlcXVlc3Qgb2JqZWN0XG4gICAqL1xuICBfeGhyUmVzdWx0KHJlc3VsdCwgcmVxdWVzdEV2dCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSByZXR1cm47XG4gICAgcmVzdWx0LnJlcXVlc3QgPSByZXF1ZXN0RXZ0O1xuICAgIHJlcXVlc3RFdnQuaXNGaXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9oYW5kbGVEZWR1cGxpY2F0aW9uRXJyb3JzKHJlc3VsdCk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgdGhpcy5feGhyRXJyb3IocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5feGhyU3VjY2VzcyhyZXN1bHQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYXRlZ29yaXplIHRoZSBlcnJvciBmb3IgaGFuZGxpbmcuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldEVycm9yU3RhdGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZXN1bHQgIC0gUmVzcG9uc2Ugb2JqZWN0IHJldHVybmVkIGJ5IHhociBjYWxsXG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdEV2dCAtIFJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGlzT25saW5lIC0gSXMgb3VyIGFwcCBzdGF0ZSBzZXQgdG8gb25saW5lXG4gICAqL1xuICBfZ2V0RXJyb3JTdGF0ZShyZXN1bHQsIHJlcXVlc3RFdnQsIGlzT25saW5lKSB7XG4gICAgY29uc3QgZXJySWQgPSByZXN1bHQuZGF0YSA/IHJlc3VsdC5kYXRhLmlkIDogJyc7XG4gICAgaWYgKCFpc09ubGluZSkge1xuICAgICAgLy8gQ09SUyBlcnJvcnMgbG9vayBpZGVudGljYWwgdG8gb2ZmbGluZTsgYnV0IGlmIG91ciBvbmxpbmUgc3RhdGUgaGFzIHRyYW5zaXRpb25lZCBmcm9tIGZhbHNlIHRvIHRydWUgcmVwZWF0ZWRseSB3aGlsZSBwcm9jZXNzaW5nIHRoaXMgcmVxdWVzdCxcbiAgICAgIC8vIHRoYXRzIGEgaGludCB0aGF0IHRoYXQgaXRzIGEgQ09SUyBlcnJvclxuICAgICAgaWYgKHJlcXVlc3RFdnQucmV0dXJuVG9PbmxpbmVDb3VudCA+PSBTeW5jTWFuYWdlci5NQVhfUkVUUklFU19CRUZPUkVfQ09SU19FUlJPUikge1xuICAgICAgICByZXR1cm4gJ0NPUlMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICdvZmZsaW5lJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVycklkID09PSAnbm90X2ZvdW5kJykge1xuICAgICAgcmV0dXJuICdub3RGb3VuZCc7XG4gICAgfSBlbHNlIGlmIChlcnJJZCA9PT0gJ2lkX2luX3VzZScpIHtcbiAgICAgIHJldHVybiAnaW52YWxpZElkJzsgLy8gVGhpcyBvbmx5IGZpcmVzIGlmIHdlIGdldCBgaWRfaW5fdXNlYCBidXQgbm8gUmVzb3VyY2UsIHdoaWNoIG1lYW5zIHRoZSBVVUlEIHdhcyB1c2VkIGJ5IGFub3RoZXIgdXNlci9hcHAuXG4gICAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSA0MDggfHwgZXJySWQgPT09ICdyZXF1ZXN0X3RpbWVvdXQnKSB7XG4gICAgICBpZiAocmVxdWVzdEV2dC5yZXRyeUNvdW50ID49IFN5bmNNYW5hZ2VyLk1BWF9SRVRSSUVTKSB7XG4gICAgICAgIHJldHVybiAndG9vTWFueUZhaWx1cmVzV2hpbGVPbmxpbmUnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICd2YWxpZGF0ZU9ubGluZUFuZFJldHJ5JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFs1MDIsIDUwMywgNTA0XS5pbmRleE9mKHJlc3VsdC5zdGF0dXMpICE9PSAtMSkge1xuICAgICAgaWYgKHJlcXVlc3RFdnQucmV0cnlDb3VudCA+PSBTeW5jTWFuYWdlci5NQVhfUkVUUklFUykge1xuICAgICAgICByZXR1cm4gJ3Rvb01hbnlGYWlsdXJlc1doaWxlT25saW5lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnc2VydmVyVW5hdmFpbGFibGUnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXJySWQgPT09ICdhdXRoZW50aWNhdGlvbl9yZXF1aXJlZCcgJiYgcmVzdWx0LmRhdGEuZGF0YSAmJiByZXN1bHQuZGF0YS5kYXRhLm5vbmNlKSB7XG4gICAgICByZXR1cm4gJ3JlYXV0aG9yaXplJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICdzZXJ2ZXJSZWplY3RlZFJlcXVlc3QnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgZmFpbGVkIHJlcXVlc3RzLlxuICAgKlxuICAgKiAxLiBJZiB0aGVyZSB3YXMgYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyLCB0aGVuIHRoZSByZXF1ZXN0IGhhcyBwcm9ibGVtc1xuICAgKiAyLiBJZiB3ZSBkZXRlcm1pbmUgd2UgYXJlIG5vdCBpbiBmYWN0IG9ubGluZSwgY2FsbCB0aGUgY29ubmVjdGlvbkVycm9yIGhhbmRsZXJcbiAgICogMy4gSWYgd2UgdGhpbmsgd2UgYXJlIG9ubGluZSwgdmVyaWZ5IHdlIGFyZSBvbmxpbmUgYW5kIHRoZW4gZGV0ZXJtaW5lIGhvdyB0byBoYW5kbGUgaXQuXG4gICAqXG4gICAqIEBtZXRob2QgX3hockVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVzdWx0ICAtIFJlc3BvbnNlIG9iamVjdCByZXR1cm5lZCBieSB4aHIgY2FsbFxuICAgKiBAcGFyYW0gIHtsYXllci5TeW5jRXZlbnR9IHJlcXVlc3RFdnQgLSBSZXF1ZXN0IG9iamVjdFxuICAgKi9cbiAgX3hockVycm9yKHJlc3VsdCkge1xuICAgIGNvbnN0IHJlcXVlc3RFdnQgPSByZXN1bHQucmVxdWVzdDtcblxuICAgIGxvZ2dlci53YXJuKGBTeW5jIE1hbmFnZXIgJHtyZXF1ZXN0RXZ0IGluc3RhbmNlb2YgV2Vic29ja2V0U3luY0V2ZW50ID8gJ1dlYnNvY2tldCcgOiAnWEhSJ30gYCArXG4gICAgICBgJHtyZXF1ZXN0RXZ0Lm9wZXJhdGlvbn0gUmVxdWVzdCBvbiB0YXJnZXQgJHtyZXF1ZXN0RXZ0LnRhcmdldH0gaGFzIEZhaWxlZGAsIHJlcXVlc3RFdnQudG9PYmplY3QoKSk7XG5cbiAgICBjb25zdCBlcnJTdGF0ZSA9IHRoaXMuX2dldEVycm9yU3RhdGUocmVzdWx0LCByZXF1ZXN0RXZ0LCB0aGlzLmlzT25saW5lKCkpO1xuICAgIGxvZ2dlci53YXJuKCdTeW5jIE1hbmFnZXIgRXJyb3IgU3RhdGU6ICcgKyBlcnJTdGF0ZSk7XG4gICAgc3dpdGNoIChlcnJTdGF0ZSkge1xuICAgICAgY2FzZSAndG9vTWFueUZhaWx1cmVzV2hpbGVPbmxpbmUnOlxuICAgICAgICB0aGlzLl94aHJIYW5kbGVTZXJ2ZXJFcnJvcihyZXN1bHQsICdTeW5jIE1hbmFnZXIgU2VydmVyIFVuYXZhaWxhYmxlIFRvbyBMb25nOyByZW1vdmluZyByZXF1ZXN0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbm90Rm91bmQnOlxuICAgICAgICB0aGlzLl94aHJIYW5kbGVTZXJ2ZXJFcnJvcihyZXN1bHQsICdSZXNvdXJjZSBub3QgZm91bmQ7IHByZXN1bWFibHkgZGVsZXRlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludmFsaWRJZCc6XG4gICAgICAgIHRoaXMuX3hockhhbmRsZVNlcnZlckVycm9yKHJlc3VsdCwgJ0lEIHdhcyBub3QgdW5pcXVlOyByZXF1ZXN0IGZhaWxlZCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3ZhbGlkYXRlT25saW5lQW5kUmV0cnknOlxuICAgICAgICAvLyBTZXJ2ZXIgYXBwZWFycyB0byBiZSBodW5nIGJ1dCB3aWxsIGV2ZW50dWFsbHkgcmVjb3Zlci5cbiAgICAgICAgLy8gUmV0cnkgYSBmZXcgdGltZXMgYW5kIHRoZW4gZXJyb3Igb3V0LlxuICAgICAgICB0aGlzLl94aHJWYWxpZGF0ZUlzT25saW5lKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VydmVyVW5hdmFpbGFibGUnOlxuICAgICAgICAvLyBTZXJ2ZXIgaXMgaW4gYSBiYWQgc3RhdGUgYnV0IHdpbGwgZXZlbnR1YWxseSByZWNvdmVyO1xuICAgICAgICAvLyBrZWVwIHJldHJ5aW5nLlxuICAgICAgICB0aGlzLl94aHJIYW5kbGVTZXJ2ZXJVbmF2YWlsYWJsZUVycm9yKHJlcXVlc3RFdnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzpcbiAgICAgICAgLy8gc2Vzc2lvblRva2VuIGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIHZhbGlkOyBmb3J3YXJkIHJlc3BvbnNlXG4gICAgICAgIC8vIG9uIHRvIGNsaWVudC1hdXRoZW50aWNhdG9yIHRvIHByb2Nlc3MuXG4gICAgICAgIC8vIERvIG5vdCByZXRyeSBub3IgYWR2YW5jZSB0byBuZXh0IHJlcXVlc3QuXG4gICAgICAgIGlmIChyZXF1ZXN0RXZ0LmNhbGxiYWNrKSByZXF1ZXN0RXZ0LmNhbGxiYWNrKHJlc3VsdCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXJ2ZXJSZWplY3RlZFJlcXVlc3QnOlxuICAgICAgICAvLyBTZXJ2ZXIgcHJlc3VtYWJseSBkaWQgbm90IGxpa2UgdGhlIGFyZ3VtZW50cyB0byB0aGlzIGNhbGxcbiAgICAgICAgLy8gb3IgdGhlIHVybCB3YXMgaW52YWxpZC4gIERvIG5vdCByZXRyeTsgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gYW5kIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdC5cbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyRXJyb3IocmVzdWx0LCAnU3luYyBNYW5hZ2VyIFNlcnZlciBSZWplY3RzIFJlcXVlc3Q7IHJlbW92aW5nIHJlcXVlc3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdDT1JTJzpcbiAgICAgICAgLy8gQSBwYXR0ZXJuIG9mIG9mZmxpbmUtbGlrZSBmYWlsdXJlcyB0aGF0IHN1Z2dlc3RzIGl0cyBhY3R1YWxseSBhIENPUnMgZXJyb3JcbiAgICAgICAgdGhpcy5feGhySGFuZGxlU2VydmVyRXJyb3IocmVzdWx0LCAnU3luYyBNYW5hZ2VyIFNlcnZlciBkZXRlY3RzIENPUlMtbGlrZSBlcnJvcnM7IHJlbW92aW5nIHJlcXVlc3QnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvZmZsaW5lJzpcbiAgICAgICAgdGhpcy5feGhySGFuZGxlQ29ubmVjdGlvbkVycm9yKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIFdyaXRlIHRoZSBzeW5jIGV2ZW50IGJhY2sgdG8gdGhlIGRhdGFiYXNlIGlmIHdlIGhhdmVuJ3QgY29tcGxldGVkIHByb2Nlc3NpbmcgaXRcbiAgICBpZiAodGhpcy5xdWV1ZS5pbmRleE9mKHJlcXVlc3RFdnQpICE9PSAtMSkge1xuICAgICAgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLndyaXRlU3luY0V2ZW50cyhbcmVxdWVzdEV2dF0sIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgc2VydmVyIHVuYXZhaWxhYmxlIGVycm9yLlxuICAgKlxuICAgKiBJbiB0aGUgZXZlbnQgb2YgYSA1MDIgKEJhZCBHYXRld2F5KSwgNTAzIChzZXJ2aWNlIHVuYXZhaWxhYmxlKVxuICAgKiBvciA1MDQgKGdhdGV3YXkgdGltZW91dCkgZXJyb3IgZnJvbSB0aGUgc2VydmVyXG4gICAqIGFzc3VtZSB3ZSBoYXZlIGFuIGVycm9yIHRoYXQgaXMgc2VsZiBjb3JyZWN0aW5nIG9uIHRoZSBzZXJ2ZXIuXG4gICAqIFVzZSBleHBvbmVudGlhbCBiYWNrb2ZmIHRvIHJldHJ5IHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgZWFjaCBjYWxsIHdpbGwgaW5jcmVtZW50IHJldHJ5Q291bnQ7IHRoZXJlIGlzIGEgbWF4aW11bVxuICAgKiBvZiBNQVhfUkVUUklFUyBiZWZvcmUgaXQgaXMgdHJlYXRlZCBhcyBhbiBlcnJvclxuICAgKlxuICAgKiBAbWV0aG9kICBfeGhySGFuZGxlU2VydmVyVW5hdmFpbGFibGVFcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gcmVxdWVzdFxuICAgKi9cbiAgX3hockhhbmRsZVNlcnZlclVuYXZhaWxhYmxlRXJyb3IocmVxdWVzdCkge1xuICAgIGNvbnN0IG1heERlbGF5ID0gU3luY01hbmFnZXIuTUFYX1VOQVZBSUxBQkxFX1JFVFJZX1dBSVQ7XG4gICAgY29uc3QgZGVsYXkgPSBVdGlscy5nZXRFeHBvbmVudGlhbEJhY2tvZmZTZWNvbmRzKG1heERlbGF5LCBNYXRoLm1pbigxNSwgcmVxdWVzdC5yZXRyeUNvdW50KyspKTtcbiAgICBsb2dnZXIud2FybihgU3luYyBNYW5hZ2VyIFNlcnZlciBVbmF2YWlsYWJsZTsgcmV0cnkgY291bnQgJHtyZXF1ZXN0LnJldHJ5Q291bnR9OyByZXRyeWluZyBpbiAke2RlbGF5fSBzZWNvbmRzYCk7XG4gICAgc2V0VGltZW91dCh0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QuYmluZCh0aGlzKSwgZGVsYXkgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBzZXJ2ZXIgZXJyb3IgaW4gcmVzcG9uc2UgdG8gZmlyaW5nIHN5bmMgZXZlbnQuXG4gICAqXG4gICAqIElmIHRoZXJlIGlzIGEgc2VydmVyIGVycm9yLCBpdHMgcHJlc3VtYWJseSBub24tcmVjb3ZlcmFibGUvbm9uLXJldHJ5YWJsZSBlcnJvciwgc29cbiAgICogd2UncmUgZ29pbmcgdG8gYWJvcnQgdGhpcyByZXF1ZXN0LlxuICAgKlxuICAgKiAxLiBJZiBhIGNhbGxiYWNrIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAqIDIuIElmIGEgcm9sbGJhY2sgY2FsbCBpcyBwcm92aWRlZCwgY2FsbCBpdCB0byB1bmRvIGFueSBwYXRjaC9kZWxldGUvZXRjLi4uIGNoYW5nZXNcbiAgICogMy4gSWYgdGhlIHJlcXVlc3Qgd2FzIHRvIGNyZWF0ZSBhIHJlc291cmNlLCByZW1vdmUgZnJvbSB0aGUgcXVldWUgYWxsIHJlcXVlc3RzXG4gICAqICAgIHRoYXQgZGVwZW5kZWQgdXBvbiB0aGF0IHJlc291cmNlLlxuICAgKiA0LiBBZHZhbmNlIHRvIG5leHQgcmVxdWVzdFxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJIYW5kbGVTZXJ2ZXJFcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICpcbiAgICovXG4gIF94aHJIYW5kbGVTZXJ2ZXJFcnJvcihyZXN1bHQsIGxvZ01zZykge1xuICAgIC8vIEV4ZWN1dGUgYWxsIGNhbGxiYWNrcyBwcm92aWRlZCBieSB0aGUgcmVxdWVzdFxuICAgIGlmIChyZXN1bHQucmVxdWVzdC5jYWxsYmFjaykgcmVzdWx0LnJlcXVlc3QuY2FsbGJhY2socmVzdWx0KTtcbiAgICBsb2dnZXIuZXJyb3IobG9nTXNnLCByZXN1bHQucmVxdWVzdCk7XG4gICAgdGhpcy50cmlnZ2VyKCdzeW5jOmVycm9yJywge1xuICAgICAgdGFyZ2V0OiByZXN1bHQucmVxdWVzdC50YXJnZXQsXG4gICAgICByZXF1ZXN0OiByZXN1bHQucmVxdWVzdCxcbiAgICAgIGVycm9yOiByZXN1bHQuZGF0YSxcbiAgICB9KTtcblxuICAgIHJlc3VsdC5yZXF1ZXN0LnN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIC8vIElmIGEgUE9TVCByZXF1ZXN0IGZhaWxzLCBhbGwgcmVxdWVzdHMgdGhhdCBkZXBlbmQgdXBvbiB0aGlzIG9iamVjdFxuICAgIC8vIG11c3QgYmUgcHVyZ2VkXG4gICAgaWYgKHJlc3VsdC5yZXF1ZXN0Lm9wZXJhdGlvbiA9PT0gJ1BPU1QnKSB7XG4gICAgICB0aGlzLl9wdXJnZURlcGVuZGVudFJlcXVlc3RzKHJlc3VsdC5yZXF1ZXN0KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhpcyByZXF1ZXN0IGFzIHdlbGwgKHNpZGUtZWZmZWN0OiByb2xscyBiYWNrIHRoZSBvcGVyYXRpb24pXG4gICAgdGhpcy5fcmVtb3ZlUmVxdWVzdChyZXN1bHQucmVxdWVzdCk7XG5cbiAgICAvLyBBbmQgZmluYWxseSwgd2UgYXJlIHJlYWR5IHRvIHRyeSB0aGUgbmV4dCByZXF1ZXN0XG4gICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlcmUgaXMgYSBjb25uZWN0aW9uIGVycm9yLCB3YWl0IGZvciByZXRyeS5cbiAgICpcbiAgICogSW4gdGhlIGV2ZW50IG9mIHdoYXQgYXBwZWFycyB0byBiZSBhIGNvbm5lY3Rpb24gZXJyb3IsXG4gICAqIFdhaXQgdW50aWwgYSAnY29ubmVjdGVkJyBldmVudCBiZWZvcmUgcHJvY2Vzc2luZyB0aGUgbmV4dCByZXF1ZXN0IChhY3R1YWxseSByZXByb2Nlc3NpbmcgdGhlIGN1cnJlbnQgZXZlbnQpXG4gICAqXG4gICAqIEBtZXRob2QgX3hockhhbmRsZUNvbm5lY3Rpb25FcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3hockhhbmRsZUNvbm5lY3Rpb25FcnJvcigpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGJlIGRvbmU7IHdlIGFscmVhZHkgaGF2ZSB0aGUgYmVsb3cgZXZlbnQgaGFuZGxlciBzZXR1cFxuICAgIC8vIHRoaXMub25saW5lTWFuYWdlci5vbmNlKCdjb25uZWN0ZWQnLCAoKSA9PiB0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QoKSk7XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IHRoYXQgd2UgYXJlIG9ubGluZSBhbmQgcmV0cnkgcmVxdWVzdC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gd2UgdGhpbmsgd2UncmUgb25saW5lLCBidXRcbiAgICogaGF2ZSBkZXRlcm1pbmVkIHdlIG5lZWQgdG8gdmFsaWRhdGUgdGhhdCBhc3N1bXB0aW9uLlxuICAgKlxuICAgKiBUZXN0IHRoYXQgd2UgaGF2ZSBhIGNvbm5lY3Rpb247IGlmIHdlIGRvLFxuICAgKiByZXRyeSB0aGUgcmVxdWVzdCBvbmNlLCBhbmQgaWYgaXQgZmFpbHMgYWdhaW4sXG4gICAqIF94aHJFcnJvcigpIHdpbGwgZGV0ZXJtaW5lIGl0IHRvIGhhdmUgZmFpbGVkIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIElmIHdlIGFyZSBvZmZsaW5lLCB0aGVuIGxldCBfeGhySGFuZGxlQ29ubmVjdGlvbkVycm9yIGhhbmRsZSBpdC5cbiAgICpcbiAgICogQG1ldGhvZCBfeGhyVmFsaWRhdGVJc09ubGluZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3hoclZhbGlkYXRlSXNPbmxpbmUoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdTeW5jIE1hbmFnZXIgdmVyaWZ5aW5nIG9ubGluZSBzdGF0ZScpO1xuICAgIHRoaXMub25saW5lTWFuYWdlci5jaGVja09ubGluZVN0YXR1cyhpc09ubGluZSA9PiB0aGlzLl94aHJWYWxpZGF0ZUlzT25saW5lQ2FsbGJhY2soaXNPbmxpbmUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB3ZSBoYXZlIHZlcmlmaWVkIHdlIGFyZSBvbmxpbmUsIHJldHJ5IHJlcXVlc3QuXG4gICAqXG4gICAqIFdlIHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgcmVzcG9uc2UgdG8gb3VyIC9ub25jZXMgY2FsbFxuICAgKiB3aGljaCBhc3N1bWluZyB0aGUgc2VydmVyIGlzIGFjdHVhbGx5IGFsaXZlLFxuICAgKiB3aWxsIHRlbGwgdXMgaWYgdGhlIGNvbm5lY3Rpb24gaXMgd29ya2luZy5cbiAgICpcbiAgICogSWYgd2UgYXJlIG9mZmxpbmUsIGZsYWcgdXMgYXMgb2ZmbGluZSBhbmQgbGV0IHRoZSBDb25uZWN0aW9uRXJyb3IgaGFuZGxlciBoYW5kbGUgdGhpc1xuICAgKiBJZiB3ZSBhcmUgb25saW5lLCBnaXZlIHRoZSByZXF1ZXN0IGEgc2luZ2xlIHJldHJ5ICh0aGVyZSBpcyBuZXZlciBtb3JlIHRoYW4gb25lIHJldHJ5KVxuICAgKlxuICAgKiBAbWV0aG9kIF94aHJWYWxpZGF0ZUlzT25saW5lQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gaXNPbmxpbmUgIC0gUmVzcG9uc2Ugb2JqZWN0IHJldHVybmVkIGJ5IHhociBjYWxsXG4gICAqL1xuICBfeGhyVmFsaWRhdGVJc09ubGluZUNhbGxiYWNrKGlzT25saW5lKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdTeW5jIE1hbmFnZXIgb25saW5lIGNoZWNrIHJlc3VsdCBpcyAnICsgaXNPbmxpbmUpO1xuICAgIGlmICghaXNPbmxpbmUpIHtcbiAgICAgIC8vIFRyZWF0IHRoaXMgYXMgYSBDb25uZWN0aW9uIEVycm9yXG4gICAgICB0aGlzLl94aHJIYW5kbGVDb25uZWN0aW9uRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV0cnkgdGhlIHJlcXVlc3QgaW4gY2FzZSB3ZSB3ZXJlIG9mZmxpbmUsIGJ1dCBhcmUgbm93IG9ubGluZS5cbiAgICAgIC8vIE9mIGNvdXJzZSwgaWYgdGhpcyBmYWlscywgZ2l2ZSBpdCB1cCBlbnRpcmVseS5cbiAgICAgIHRoaXMucXVldWVbMF0ucmV0cnlDb3VudCsrO1xuICAgICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBYSFIgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bC5cbiAgICpcbiAgICogQW55IHhociByZXF1ZXN0IHRoYXQgYWN0dWFsbHkgc3VjY2VkZXM6XG4gICAqXG4gICAqIDEuIFJlbW92ZSBpdCBmcm9tIHRoZSBxdWV1ZVxuICAgKiAyLiBDYWxsIGFueSBjYWxsYmFja3NcbiAgICogMy4gQWR2YW5jZSB0byBuZXh0IHJlcXVlc3RcbiAgICpcbiAgICogQG1ldGhvZCBfeGhyU3VjY2Vzc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHJlc3VsdCAgLSBSZXNwb25zZSBvYmplY3QgcmV0dXJuZWQgYnkgeGhyIGNhbGxcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gUmVxdWVzdCBvYmplY3RcbiAgICovXG4gIF94aHJTdWNjZXNzKHJlc3VsdCkge1xuICAgIGNvbnN0IHJlcXVlc3RFdnQgPSByZXN1bHQucmVxdWVzdDtcbiAgICBsb2dnZXIuZGVidWcoYFN5bmMgTWFuYWdlciAke3JlcXVlc3RFdnQgaW5zdGFuY2VvZiBXZWJzb2NrZXRTeW5jRXZlbnQgPyAnV2Vic29ja2V0JyA6ICdYSFInfSBgICtcbiAgICAgIGAke3JlcXVlc3RFdnQub3BlcmF0aW9ufSBSZXF1ZXN0IG9uIHRhcmdldCAke3JlcXVlc3RFdnQudGFyZ2V0fSBoYXMgU3VjY2VlZGVkYCwgcmVxdWVzdEV2dC50b09iamVjdCgpKTtcbiAgICBpZiAocmVzdWx0LmRhdGEpIGxvZ2dlci5kZWJ1ZyhyZXN1bHQuZGF0YSk7XG4gICAgcmVxdWVzdEV2dC5zdWNjZXNzID0gdHJ1ZTtcbiAgICB0aGlzLl9yZW1vdmVSZXF1ZXN0KHJlcXVlc3RFdnQpO1xuICAgIGlmIChyZXF1ZXN0RXZ0LmNhbGxiYWNrKSByZXF1ZXN0RXZ0LmNhbGxiYWNrKHJlc3VsdCk7XG4gICAgdGhpcy5fcHJvY2Vzc05leHRSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3N5bmM6c3VjY2VzcycsIHtcbiAgICAgIHRhcmdldDogcmVxdWVzdEV2dC50YXJnZXQsXG4gICAgICByZXF1ZXN0OiByZXF1ZXN0RXZ0LFxuICAgICAgcmVzcG9uc2U6IHJlc3VsdC5kYXRhLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgU3luY0V2ZW50IHJlcXVlc3QgZnJvbSB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBtZXRob2QgX3JlbW92ZVJlcXVlc3RcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSByZXF1ZXN0RXZ0IC0gU3luY0V2ZW50IFJlcXVlc3QgdG8gcmVtb3ZlXG4gICAqL1xuICBfcmVtb3ZlUmVxdWVzdChyZXF1ZXN0RXZ0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnF1ZXVlLmluZGV4T2YocmVxdWVzdEV2dCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSByZXF1ZXN0cyBmcm9tIHF1ZXVlIHRoYXQgZGVwZW5kIG9uIHNwZWNpZmllZCByZXNvdXJjZS5cbiAgICpcbiAgICogSWYgdGhlcmUgaXMgYSBQT1NUIHJlcXVlc3QgdG8gY3JlYXRlIGEgbmV3IHJlc291cmNlLCBhbmQgdGhlcmUgYXJlIFBBVENILCBERUxFVEUsIGV0Yy4uLlxuICAgKiByZXF1ZXN0cyBvbiB0aGF0IHJlc291cmNlLCBpZiB0aGUgUE9TVCByZXF1ZXN0IGZhaWxzLCB0aGVuIGFsbCBQQVRDSCwgREVMRVRFLCBldGNcbiAgICogcmVxdWVzdHMgbXVzdCBiZSByZW1vdmVkIGZyb20gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgd2UgZG8gbm90IGNhbGwgdGhlIHJvbGxiYWNrIG9uIHRoZXNlIGRlcGVuZGVudCByZXF1ZXN0cyBiZWNhdXNlIHRoZSBleHBlY3RlZFxuICAgKiByb2xsYmFjayBpcyB0byBkZXN0cm95IHRoZSB0aGluZyB0aGF0IHdhcyBjcmVhdGVkLCB3aGljaCBtZWFucyBhbnkgb3RoZXIgcm9sbGJhY2sgaGFzIG5vIGVmZmVjdC5cbiAgICpcbiAgICogQG1ldGhvZCBfcHVyZ2VEZXBlbmRlbnRSZXF1ZXN0c1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5TeW5jRXZlbnR9IHJlcXVlc3QgLSBSZXF1ZXN0IHdob3NlIHRhcmdldCBpcyBubyBsb25nZXIgdmFsaWRcbiAgICovXG4gIF9wdXJnZURlcGVuZGVudFJlcXVlc3RzKHJlcXVlc3QpIHtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIoZXZ0ID0+IGV2dC5kZXBlbmRzLmluZGV4T2YocmVxdWVzdC50YXJnZXQpID09PSAtMSB8fCBldnQgPT09IHJlcXVlc3QpO1xuICB9XG5cblxuICAvKipcbiAgICogUmVtb3ZlIGZyb20gcXVldWUgYWxsIGV2ZW50cyB0aGF0IG9wZXJhdGUgdXBvbiB0aGUgZGVsZXRlZCBvYmplY3QuXG4gICAqXG4gICAqIEBtZXRob2QgX3B1cmdlT25EZWxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7bGF5ZXIuU3luY0V2ZW50fSBldnQgLSBEZWxldGUgZXZlbnQgdGhhdCByZXF1aXJlcyByZW1vdmFsIG9mIG90aGVyIGV2ZW50c1xuICAgKi9cbiAgX3B1cmdlT25EZWxldGUoZXZ0KSB7XG4gICAgdGhpcy5xdWV1ZS5maWx0ZXIocmVxdWVzdCA9PiByZXF1ZXN0LmRlcGVuZHMuaW5kZXhPZihldnQudGFyZ2V0KSAhPT0gLTEgJiYgZXZ0ICE9PSByZXF1ZXN0KVxuICAgICAgLmZvckVhY2gocmVxdWVzdEV2dCA9PiB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc3luYzphYm9ydCcsIHtcbiAgICAgICAgICB0YXJnZXQ6IHJlcXVlc3RFdnQudGFyZ2V0LFxuICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RFdnQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9yZW1vdmVSZXF1ZXN0KHJlcXVlc3RFdnQpO1xuICAgICAgfSk7XG4gIH1cblxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5xdWV1ZS5mb3JFYWNoKGV2dCA9PiBldnQuZGVzdHJveSgpKTtcbiAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZCBhbnkgdW5zZW50IHJlcXVlc3RzIGZyb20gaW5kZXhlZERCLlxuICAgKlxuICAgKiBJZiBwZXJzaXN0ZW5jZSBpcyBkaXNhYmxlZCwgbm90aGluZyB3aWxsIGhhcHBlbjtcbiAgICogZWxzZSBhbGwgcmVxdWVzdHMgZm91bmQgaW4gdGhlIGRhdGFiYXNlIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHF1ZXVlLlxuICAgKiBAbWV0aG9kIF9sb2FkUGVyc2lzdGVkUXVldWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2FkUGVyc2lzdGVkUXVldWUoKSB7XG4gICAgdGhpcy5jbGllbnQuZGJNYW5hZ2VyLmxvYWRTeW5jUXVldWUoZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHRoaXMucXVldWUuY29uY2F0KGRhdGEpO1xuICAgICAgICB0aGlzLl9wcm9jZXNzTmV4dFJlcXVlc3QoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIFdlYnNvY2tldCBNYW5hZ2VyIGZvciBnZXR0aW5nIHNvY2tldCBzdGF0ZS5cbiAqIEB0eXBlIHtsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXJ9XG4gKi9cblN5bmNNYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXRNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBXZWJzb2NrZXQgUmVxdWVzdCBNYW5hZ2VyIGZvciBzZW5kaW5nIHJlcXVlc3RzLlxuICogQHR5cGUge2xheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXJ9XG4gKi9cblN5bmNNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0TWFuYWdlciA9IG51bGw7XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSBPbmxpbmUgU3RhdGUgTWFuYWdlci5cbiAqXG4gKiBTeW5jIE1hbmFnZXIgdXNlcyBvbmxpbmUgc3RhdHVzIHRvIGRldGVybWluZSBpZiBpdCBjYW4gZmlyZSBzeW5jLXJlcXVlc3RzLlxuICogQHByaXZhdGVcbiAqIEB0eXBlIHtsYXllci5PbmxpbmVTdGF0ZU1hbmFnZXJ9XG4gKi9cblN5bmNNYW5hZ2VyLnByb3RvdHlwZS5vbmxpbmVNYW5hZ2VyID0gbnVsbDtcblxuLyoqXG4gKiBUaGUgYXJyYXkgb2YgbGF5ZXIuU3luY0V2ZW50IGluc3RhbmNlcyBhd2FpdGluZyB0byBiZSBmaXJlZC5cbiAqIEB0eXBlIHtsYXllci5TeW5jRXZlbnRbXX1cbiAqL1xuU3luY01hbmFnZXIucHJvdG90eXBlLnF1ZXVlID0gbnVsbDtcblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIENsaWVudCBzbyB0aGF0IHdlIGNhbiBwYXNzIGl0IHRvIFN5bmNFdmVudHMgIHdoaWNoIG1heSBuZWVkIHRvIGxvb2t1cCB0aGVpciB0YXJnZXRzXG4gKi9cblN5bmNNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG4vKipcbiAqIE1heGltdW0gZXhwb25lbnRpYWwgYmFja29mZiB3YWl0LlxuICpcbiAqIElmIHRoZSBzZXJ2ZXIgaXMgcmV0dXJuaW5nIDUwMiwgNTAzIG9yIDUwNCBlcnJvcnMsIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAqIHNob3VsZCBuZXZlciB3YWl0IGxvbmdlciB0aGFuIHRoaXMgbnVtYmVyIG9mIHNlY29uZHMgKDE1IG1pbnV0ZXMpXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5TeW5jTWFuYWdlci5NQVhfVU5BVkFJTEFCTEVfUkVUUllfV0FJVCA9IDYwICogMTU7XG5cbi8qKlxuICogUmV0cmllcyBiZWZvcmUgc3VzcGVjdCBDT1JTIGVycm9yLlxuICpcbiAqIEhvdyBtYW55IHRpbWVzIGNhbiB3ZSB0cmFuc2l0aW9uIGZyb20gb2ZmbGluZSB0byBvbmxpbmUgc3RhdGVcbiAqIHdpdGggdGhpcyByZXF1ZXN0IGF0IHRoZSBmcm9udCBvZiB0aGUgcXVldWUgYmVmb3JlIHdlIGNvbmNsdWRlXG4gKiB0aGF0IHRoZSByZWFzb24gd2Uga2VlcCB0aGlua2luZyB3ZSdyZSBnb2luZyBvZmZsaW5lIGlzXG4gKiBhIENPUlMgZXJyb3IgcmV0dXJuaW5nIGEgc3RhdHVzIG9mIDAuICBJZiB0aGF0IHBhdHRlcm5cbiAqIHNob3dzIDMgdGltZXMgaW4gYSByb3csIHRoZXJlIGlzIGxpa2VseSBhIENPUlMgZXJyb3IuXG4gKiBOb3RlIHRoYXQgQ09SUyBlcnJvcnMgYXBwZWFyIHRvIGphdmFzY3JpcHQgYXMgYSBzdGF0dXM9MCBlcnJvcixcbiAqIHdoaWNoIGlzIHRoZSBzYW1lIGFzIGlmIHRoZSBjbGllbnQgd2VyZSBvZmZsaW5lLlxuICogQHR5cGUge251bWJlcn1cbiAqIEBzdGF0aWNcbiAqL1xuU3luY01hbmFnZXIuTUFYX1JFVFJJRVNfQkVGT1JFX0NPUlNfRVJST1IgPSAzO1xuXG4vKipcbiAqIEFib3J0IHJlcXVlc3QgYWZ0ZXIgdGhpcyBudW1iZXIgb2YgcmV0cmllcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHN0YXRpY1xuICovXG5TeW5jTWFuYWdlci5NQVhfUkVUUklFUyA9IDIwO1xuXG5cblN5bmNNYW5hZ2VyLl9zdXBwb3J0ZWRFdmVudHMgPSBbXG4gIC8qKlxuICAgKiBBIHN5bmMgcmVxdWVzdCBoYXMgZmFpbGVkLlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnR9IGV2dCAtIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXN1bHQudGFyZ2V0IC0gSUQgb2YgdGhlIG1lc3NhZ2UvY29udmVyc2F0aW9uL2V0Yy4gYmVpbmcgb3BlcmF0ZWQgdXBvblxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gcmVzdWx0LnJlcXVlc3QgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0LmVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB7aWQsIGNvZGUsIG1lc3NhZ2UsIHVybH1cbiAgICovXG4gICdzeW5jOmVycm9yJyxcblxuICAvKipcbiAgICogQSBzeW5jIGxheWVyIHJlcXVlc3QgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXN1bHQudGFyZ2V0IC0gSUQgb2YgdGhlIG1lc3NhZ2UvY29udmVyc2F0aW9uL2V0Yy4gYmVpbmcgb3BlcmF0ZWQgdXBvblxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gcmVzdWx0LnJlcXVlc3QgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzdWx0LmRhdGEgLSBudWxsIG9yIGFueSBkYXRhIHJldHVybmVkIGJ5IHRoZSBjYWxsXG4gICAqL1xuICAnc3luYzpzdWNjZXNzJyxcblxuICAvKipcbiAgICogQSBuZXcgc3luYyByZXF1ZXN0IGhhcyBiZWVuIGFkZGVkLlxuICAgKlxuICAgKiBAZXZlbnRcbiAgICogQHBhcmFtIHtsYXllci5TeW5jRXZlbnR9IGV2dCAtIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKi9cbiAgJ3N5bmM6YWRkJyxcblxuICAvKipcbiAgICogQSBzeW5jIHJlcXVlc3QgaGFzIGJlZW4gY2FuY2VsZWQuXG4gICAqXG4gICAqIFR5cGljYWxseSBjYXVzZWQgYnkgYSBuZXcgU3luY0V2ZW50IHRoYXQgZGVsZXRlcyB0aGUgdGFyZ2V0IG9mIHRoaXMgU3luY0V2ZW50XG4gICAqXG4gICAqIEBldmVudFxuICAgKiBAcGFyYW0ge2xheWVyLlN5bmNFdmVudH0gZXZ0IC0gVGhlIHJlcXVlc3Qgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXN1bHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3VsdC50YXJnZXQgLSBJRCBvZiB0aGUgbWVzc2FnZS9jb252ZXJzYXRpb24vZXRjLiBiZWluZyBvcGVyYXRlZCB1cG9uXG4gICAqIEBwYXJhbSB7bGF5ZXIuU3luY0V2ZW50fSByZXN1bHQucmVxdWVzdCAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0XG4gICAqL1xuICAnc3luYzphYm9ydCcsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcyhTeW5jTWFuYWdlcik7XG5tb2R1bGUuZXhwb3J0cyA9IFN5bmNNYW5hZ2VyO1xuIiwiLyoqXG4gKiBUaGUgU3luY2FibGUgYWJzdHJhY3QgY2xhcyByZXByZXNlbnRzIHJlc291cmNlcyB0aGF0IGFyZSBzeW5jYWJsZSB3aXRoIHRoZSBzZXJ2ZXIuXG4gKiBUaGlzIGlzIGN1cnJlbnRseSB1c2VkIGZvciBNZXNzYWdlcyBhbmQgQ29udmVyc2F0aW9ucy5cbiAqIEl0IHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBvYmplY3QncyBzeW5jLCBhcyBvbmUgb2Y6XG4gKlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuTkVXOiBOZXdseSBjcmVhdGVkOyBsb2NhbCBvbmx5LlxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuU0FWSU5HOiBOZXdseSBjcmVhdGVkOyBiZWluZyBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLlNZTkNJTkc6IEV4aXN0cyBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyLCBidXQgY2hhbmdlcyBhcmUgYmVpbmcgc2VudCB0byBzZXJ2ZXIuXG4gKiAgKiBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5TWU5DRUQ6IEV4aXN0cyBvbiBib3RoIGNsaWVudCBhbmQgc2VydmVyIGFuZCBpcyBzeW5jZWQuXG4gKiAgKiBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5MT0FESU5HOiBFeGlzdHMgb24gc2VydmVyOyBsb2FkaW5nIGl0IGludG8gY2xpZW50LlxuICpcbiAqIE5PVEU6IFRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIGZvciBNZXNzYWdlcyB3aGVyZSBpc1NlbmRpbmcgaXMgdHJ1ZSBhbmQgc3luY1N0YXRlICE9PSBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5TQVZJTkcsXG4gKiB3aGljaCBvY2N1cnMgYWZ0ZXIgYHNlbmQoKWAgaGFzIGJlZW4gY2FsbGVkLCBidXQgd2hpbGUgd2FpdGluZyBmb3IgUmljaCBDb250ZW50IHRvIHVwbG9hZCBwcmlvciB0byBhY3R1YWxseVxuICogc2VuZGluZyB0aGlzIHRvIHRoZSBzZXJ2ZXIuXG4gKlxuICogQGNsYXNzIGxheWVyLlN5bmNhYmxlXG4gKiBAZXh0ZW5kcyBsYXllci5Sb290XG4gKiBAYWJzdHJhY3RcbiAqL1xuXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi9yb290Jyk7XG5jb25zdCB7IFNZTkNfU1RBVEUgfSA9IHJlcXVpcmUoJy4vY29uc3QnKTtcbmNvbnN0IExheWVyRXJyb3IgPSByZXF1aXJlKCcuL2xheWVyLWVycm9yJyk7XG5cbmNsYXNzIFN5bmNhYmxlIGV4dGVuZHMgUm9vdCB7XG5cbiAgc3RhdGljIGxvYWQoaWQsIGNsaWVudCkge1xuICAgIGlmICghY2xpZW50IHx8ICEoY2xpZW50IGluc3RhbmNlb2YgUm9vdCkpIHRocm93IG5ldyBFcnJvcihMYXllckVycm9yLmRpY3Rpb25hcnkuY2xpZW50TWlzc2luZyk7XG5cbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBpZCxcbiAgICAgIHVybDogY2xpZW50LnVybCArIGlkLnN1YnN0cmluZyg4KSxcbiAgICAgIGNsaWVudElkOiBjbGllbnQuYXBwSWQsXG4gICAgfTtcblxuICAgIGNvbnN0IENvbnN0cnVjdG9yQ2xhc3MgPSBTeW5jYWJsZS5zdWJjbGFzc2VzLmZpbHRlcihhQ2xhc3MgPT4gb2JqLmlkLmluZGV4T2YoYUNsYXNzLnByZWZpeFVVSUQpID09PSAwKVswXTtcbiAgICBjb25zdCBzeW5jSXRlbSA9IG5ldyBDb25zdHJ1Y3RvckNsYXNzKG9iaik7XG5cbiAgICBzeW5jSXRlbS5fbG9hZCgpO1xuICAgIHJldHVybiBzeW5jSXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIHRoaXMgY29udmVyc2F0aW9uIGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQ2FsbGVkIGZyb20gdGhlIHN0YXRpYyBsYXllci5Db252ZXJzYXRpb24ubG9hZCgpIG1ldGhvZFxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9hZCgpIHtcbiAgICB0aGlzLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuTE9BRElORztcbiAgICB0aGlzLl94aHIoe1xuICAgICAgdXJsOiAnJyxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBzeW5jOiBmYWxzZSxcbiAgICB9LCByZXN1bHQgPT4gdGhpcy5fbG9hZFJlc3VsdChyZXN1bHQpKTtcbiAgfVxuXG5cbiAgX2xvYWRSZXN1bHQocmVzdWx0KSB7XG4gICAgY29uc3QgcHJlZml4ID0gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudFByZWZpeDtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICB0aGlzLnN5bmNTdGF0ZSA9IFNZTkNfU1RBVEUuTkVXO1xuICAgICAgdGhpcy5fdHJpZ2dlckFzeW5jKHByZWZpeCArICc6bG9hZGVkLWVycm9yJywgeyBlcnJvcjogcmVzdWx0LmRhdGEgfSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGVzdHJveSgpLCAxMDApOyAvLyBJbnN1cmUgZGVzdHJveWVkIEFGVEVSIGxvYWRlZC1lcnJvciBldmVudCBoYXMgdHJpZ2dlcmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3BvcHVsYXRlRnJvbVNlcnZlcihyZXN1bHQuZGF0YSk7XG4gICAgICB0aGlzLl9sb2FkZWQocmVzdWx0LmRhdGEpO1xuICAgICAgdGhpcy50cmlnZ2VyKHByZWZpeCArICc6bG9hZGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NpbmcgdGhlIHJlc3VsdCBvZiBhIF9sb2FkKCkgY2FsbC5cbiAgICpcbiAgICogVHlwaWNhbGx5IHVzZWQgdG8gcmVnaXN0ZXIgdGhlIG9iamVjdCBhbmQgY2xlYW51cCBhbnkgcHJvcGVydGllcyBub3QgaGFuZGxlZCBieSBfcG9wdWxhdGVGcm9tU2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9sb2FkZWRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIC0gUmVzcG9uc2UgZGF0YSBmcm9tIHNlcnZlclxuICAgKi9cbiAgX2xvYWRlZChkYXRhKSB7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgaXMgcXVldWVkIGZvciBzeW5jaW5nIHdpdGggdGhlIHNlcnZlci5cbiAgICpcbiAgICogVGhhdCBtZWFucyBpdCBpcyBjdXJyZW50bHkgb3V0IG9mIHN5bmMgd2l0aCB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zZXRTeW5jaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0U3luY2luZygpIHtcbiAgICB0aGlzLl9jbGVhck9iamVjdCgpO1xuICAgIHN3aXRjaCAodGhpcy5zeW5jU3RhdGUpIHtcbiAgICAgIGNhc2UgU1lOQ19TVEFURS5TWU5DRUQ6XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gU1lOQ19TVEFURS5TWU5DSU5HO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1lOQ19TVEFURS5ORVc6XG4gICAgICAgIHRoaXMuc3luY1N0YXRlID0gU1lOQ19TVEFURS5TQVZJTkc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl9zeW5jQ291bnRlcisrO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBpcyBzeW5jZWQgd2l0aCB0aGUgc2VydmVyIGFuZCB1cCB0byBkYXRlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9zZXRTeW5jZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRTeW5jZWQoKSB7XG4gICAgdGhpcy5fY2xlYXJPYmplY3QoKTtcbiAgICBpZiAodGhpcy5fc3luY0NvdW50ZXIgPiAwKSB0aGlzLl9zeW5jQ291bnRlci0tO1xuXG4gICAgdGhpcy5zeW5jU3RhdGUgPSB0aGlzLl9zeW5jQ291bnRlciA9PT0gMCA/IFNZTkNfU1RBVEUuU1lOQ0VEIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgU1lOQ19TVEFURS5TWU5DSU5HO1xuICAgIHRoaXMuaXNTZW5kaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQW55IHRpbWUgdGhlIGluc3RhbmNlIGNoYW5nZXMsIHdlIHNob3VsZCBjbGVhciB0aGUgY2FjaGVkIHRvT2JqZWN0IHZhbHVlXG4gICAqXG4gICAqIEBtZXRob2QgX2NsZWFyT2JqZWN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYXJPYmplY3QoKSB7XG4gICAgdGhpcy5fdG9PYmplY3QgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBpcyBuZXcsIGFuZCBpcyBub3QgeWV0IHF1ZXVlZCBmb3Igc3luY2luZ1xuICAgKlxuICAgKiBAbWV0aG9kIGlzTmV3XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNOZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1N0YXRlID09PSBTWU5DX1NUQVRFLk5FVztcbiAgfVxuXG4gIC8qKlxuICAgKiBPYmplY3QgaXMgbmV3LCBhbmQgaXMgcXVldWVkIGZvciBzeW5jaW5nXG4gICAqXG4gICAqIEBtZXRob2QgaXNTYXZpbmdcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1NhdmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jU3RhdGUgPT09IFNZTkNfU1RBVEUuU0FWSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBkb2VzIG5vdCB5ZXQgZXhpc3Qgb24gc2VydmVyLlxuICAgKlxuICAgKiBAbWV0aG9kIGlzU2F2ZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1NhdmVkKCkge1xuICAgIHJldHVybiAhKHRoaXMuaXNOZXcoKSB8fCB0aGlzLmlzU2F2aW5nKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9iamVjdCBpcyBmdWxseSBzeW5jZWQuXG4gICAqXG4gICAqIEFzIGJlc3Qgd2Uga25vdywgc2VydmVyIGFuZCBjbGllbnQgaGF2ZSB0aGUgc2FtZSB2YWx1ZXMuXG4gICAqXG4gICAqIEBtZXRob2QgaXNTeW5jZWRcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1N5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zeW5jU3RhdGUgPT09IFNZTkNfU1RBVEUuU1lOQ0VEO1xuICB9XG59XG5cblxuLyoqXG4gKiBUaGUgY3VycmVudCBzeW5jIHN0YXRlIG9mIHRoaXMgb2JqZWN0LlxuICpcbiAqIFBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gKlxuICogICogbGF5ZXIuU1lOQ19TVEFURS5ORVc6IE5ld2x5IGNyZWF0ZWQ7IGxvY2FsIG9ubHkuXG4gKiAgKiBsYXllci5Db25zdGFudHMuU1lOQ19TVEFURS5TQVZJTkc6IE5ld2x5IGNyZWF0ZWQ7IGJlaW5nIHNlbnQgdG8gdGhlIHNlcnZlclxuICogICogbGF5ZXIuQ29uc3RhbnRzLlNZTkNfU1RBVEUuU1lOQ0lORzogRXhpc3RzIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIGJ1dCBjaGFuZ2VzIGFyZSBiZWluZyBzZW50IHRvIHNlcnZlci5cbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLlNZTkNFRDogRXhpc3RzIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgYW5kIGlzIHN5bmNlZC5cbiAqICAqIGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLkxPQURJTkc6IEV4aXN0cyBvbiBzZXJ2ZXI7IGxvYWRpbmcgaXQgaW50byBjbGllbnQuXG4gKlxuICogTk9URTogVGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgZm9yIE1lc3NhZ2VzIHdoZXJlIGlzU2VuZGluZyBpcyB0cnVlIGFuZCBzeW5jU3RhdGUgIT09IGxheWVyLkNvbnN0YW50cy5TWU5DX1NUQVRFLlNBVklORyxcbiAqIHdoaWNoIG9jY3VycyBhZnRlciBgc2VuZCgpYCBoYXMgYmVlbiBjYWxsZWQsIGJ1dCB3aGlsZSB3YWl0aW5nIGZvciBSaWNoIENvbnRlbnQgdG8gdXBsb2FkIHByaW9yIHRvIGFjdHVhbGx5XG4gKiBzZW5kaW5nIHRoaXMgdG8gdGhlIHNlcnZlci5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5TeW5jYWJsZS5wcm90b3R5cGUuc3luY1N0YXRlID0gU1lOQ19TVEFURS5ORVc7XG5cbi8qKlxuICogTnVtYmVyIG9mIHN5bmMgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gcmVxdWVzdGVkLlxuICpcbiAqIENvdW50cyBkb3duIHRvIHplcm87IG9uY2UgaXQgcmVhY2hlcyB6ZXJvLCBhbGwgc3luY1xuICogcmVxdWVzdHMgaGF2ZSBiZWVuIGNvbXBsZXRlZC5cbiAqXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQHByaXZhdGVcbiAqL1xuU3luY2FibGUucHJvdG90eXBlLl9zeW5jQ291bnRlciA9IDA7XG5cbi8qKlxuICogUHJlZml4IHRvIHVzZSB3aGVuIHRyaWdnZXJpbmcgZXZlbnRzXG4gKi9cblN5bmNhYmxlLmV2ZW50UHJlZml4ID0gJyc7XG5cbi8qKlxuICogSXMgdGhlIG9iamVjdCBsb2FkaW5nIGZyb20gdGhlIHNlcnZlcj9cbiAqXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bmNhYmxlLnByb3RvdHlwZSwgJ2lzTG9hZGluZycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1N0YXRlID09PSBTWU5DX1NUQVRFLkxPQURJTkc7XG4gIH0sXG59KTtcblxuLyoqXG4gKiBBcnJheSBvZiBjbGFzc2VzIHRoYXQgYXJlIHN1YmNsYXNzZXMgb2YgU3luY2FibGUuXG4gKlxuICogVXNlZCBieSBGYWN0b3J5IGZ1bmN0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuU3luY2FibGUuc3ViY2xhc3NlcyA9IFtdO1xuXG5TeW5jYWJsZS5fc3VwcG9ydGVkRXZlbnRzID0gW10uY29uY2F0KFJvb3QuX3N1cHBvcnRlZEV2ZW50cyk7XG5TeW5jYWJsZS5pbk9iamVjdElnbm9yZSA9IFJvb3QuaW5PYmplY3RJZ25vcmU7XG5tb2R1bGUuZXhwb3J0cyA9IFN5bmNhYmxlO1xuIiwiLyoqXG4gKiBUaGUgVHlwaW5nSW5kaWNhdG9yTGlzdGVuZXIgcmVjZWl2ZXMgVHlwaW5nIEluZGljYXRvciBzdGF0ZVxuICogZm9yIG90aGVyIHVzZXJzIHZpYSBhIHdlYnNvY2tldCwgYW5kIG5vdGlmaWVzXG4gKiB0aGUgY2xpZW50IG9mIHRoZSB1cGRhdGVkIHN0YXRlLiAgVHlwaWNhbCBhcHBsaWNhdGlvbnNcbiAqIGRvIG5vdCBhY2Nlc3MgdGhpcyBjb21wb25lbnQgZGlyZWN0bHksIGJ1dCBETyBzdWJzY3JpYmVcbiAqIHRvIGV2ZW50cyBwcm9kdWNlZCBieSB0aGlzIGNvbXBvbmVudDpcbiAqXG4gKiAgICAgIGNsaWVudC5vbigndHlwaW5nLWluZGljYXRvci1jaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAqICAgICAgICBpZiAoZXZ0LmNvbnZlcnNhdGlvbklkID09IGNvbnZlcnNhdGlvbklDYXJlQWJvdXQpIHtcbiAqICAgICAgICAgIGNvbnNvbGUubG9nKCdUaGUgZm9sbG93aW5nIHVzZXJzIGFyZSB0eXBpbmc6ICcgKyBldnQudHlwaW5nLmpvaW4oJywgJykpO1xuICogICAgICAgICAgY29uc29sZS5sb2coJ1RoZSBmb2xsb3dpbmcgdXNlcnMgYXJlIHBhdXNlZDogJyArIGV2dC5wYXVzZWQuam9pbignLCAnKSk7XG4gKiAgICAgICAgfVxuICogICAgICB9KTtcbiAqXG4gKiBAY2xhc3MgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdJbmRpY2F0b3JMaXN0ZW5lclxuICogQGV4dGVuZHMge2xheWVyLlJvb3R9XG4gKi9cblxuY29uc3QgUm9vdCA9IHJlcXVpcmUoJy4uL3Jvb3QnKTtcbmNvbnN0IENsaWVudFJlZ2lzdHJ5ID0gcmVxdWlyZSgnLi4vY2xpZW50LXJlZ2lzdHJ5Jyk7XG5cbmNvbnN0IHtTVEFSVEVELCBQQVVTRUQsIEZJTklTSEVEfSA9IHJlcXVpcmUoJy4vdHlwaW5nLWluZGljYXRvcnMnKTtcbmNsYXNzIFR5cGluZ0luZGljYXRvckxpc3RlbmVyIGV4dGVuZHMgUm9vdCB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBUeXBpbmcgSW5kaWNhdG9yIExpc3RlbmVyIGZvciB0aGlzIENsaWVudC5cbiAgICpcbiAgICogQG1ldGhvZCBjb25zdHJ1Y3RvclxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBwYXJhbSAge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jbGllbnRJZCAtIElEIG9mIHRoZSBjbGllbnQgdGhpcyBiZWxvbmdzIHRvXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIHN0YXRlIG9mIGFsbCBDb252ZXJzYXRpb25zLCBpbmRpY2F0aW5nIHdobyBpcyB0eXBpbmcgYW5kIHdobyBpcyBwYXVzZWQuXG4gICAgICpcbiAgICAgKiBQZW9wbGUgd2hvIGFyZSBzdG9wcGVkIGFyZSByZW1vdmVkIGZyb20gdGhpcyBzdGF0ZS5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gc3RhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlID0ge307XG4gICAgdGhpcy5fcG9sbElkID0gMDtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLl9nZXRDbGllbnQoKTtcbiAgICBjbGllbnQub24oJ3JlYWR5JywgKCkgPT4gdGhpcy5fY2xpZW50UmVhZHkoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGNsaWVudCBpcyByZWFkeVxuICAgKlxuICAgKiBAbWV0aG9kIF9jbGllbnRSZWFkeVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NsaWVudFJlYWR5KCkge1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuX2dldENsaWVudCgpO1xuICAgIHRoaXMudXNlcklkID0gY2xpZW50LnVzZXJJZDtcbiAgICBjb25zdCB3cyA9IGNsaWVudC5zb2NrZXRNYW5hZ2VyO1xuICAgIHdzLm9uKCdtZXNzYWdlJywgdGhpcy5faGFuZGxlU29ja2V0RXZlbnQsIHRoaXMpO1xuICAgIHRoaXMuX3N0YXJ0UG9sbGluZygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhpcyBldmVudCBpcyByZWxldmFudCB0byByZXBvcnQgb24uXG4gICAqIE11c3QgYmUgYSB0eXBpbmcgaW5kaWNhdG9yIHNpZ25hbCB0aGF0IGlzIHJlcG9ydGluZyBvblxuICAgKiBzb21lb25lIG90aGVyIHRoYW4gdGhpcyB1c2VyLlxuICAgKlxuICAgKiBAbWV0aG9kIF9pc1JlbGV2YW50RXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgV2Vic29ja2V0IGV2ZW50IGRhdGFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc1JlbGV2YW50RXZlbnQoZXZ0KSB7XG4gICAgcmV0dXJuIGV2dC50eXBlID09PSAnc2lnbmFsJyAmJlxuICAgICAgZXZ0LmJvZHkudHlwZSA9PT0gJ3R5cGluZ19pbmRpY2F0b3InICYmXG4gICAgICBldnQuYm9keS5kYXRhLnVzZXJfaWQgIT09IHRoaXMudXNlcklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHJlY2VpdmVzIHdlYnNvY2tldCBldmVudHMgYW5kXG4gICAqIGlmIHRoZXkgYXJlIHR5cGluZyBpbmRpY2F0b3IgZXZlbnRzLCB1cGRhdGVzIGl0cyBzdGF0ZS5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlU29ja2V0RXZlbnRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtsYXllci5MYXllckV2ZW50fSBldnRJbiAtIEFsbCB3ZWJzb2NrZXQgZXZlbnRzXG4gICAqL1xuICBfaGFuZGxlU29ja2V0RXZlbnQoZXZ0SW4pIHtcbiAgICBjb25zdCBldnQgPSBldnRJbi5kYXRhO1xuXG4gICAgaWYgKHRoaXMuX2lzUmVsZXZhbnRFdmVudChldnQpKSB7XG4gICAgICBjb25zdCB1c2VySWQgPSBldnQuYm9keS5kYXRhLnVzZXJfaWQ7XG4gICAgICBjb25zdCBzdGF0ZSA9IGV2dC5ib2R5LmRhdGEuYWN0aW9uO1xuICAgICAgY29uc3QgY29udmVyc2F0aW9uSWQgPSBldnQuYm9keS5vYmplY3QuaWQ7XG4gICAgICBsZXQgc3RhdGVFbnRyeSA9IHRoaXMuc3RhdGVbY29udmVyc2F0aW9uSWRdO1xuICAgICAgaWYgKCFzdGF0ZUVudHJ5KSB7XG4gICAgICAgIHN0YXRlRW50cnkgPSB0aGlzLnN0YXRlW2NvbnZlcnNhdGlvbklkXSA9IHtcbiAgICAgICAgICB1c2Vyczoge30sXG4gICAgICAgICAgdHlwaW5nOiBbXSxcbiAgICAgICAgICBwYXVzZWQ6IFtdLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgc3RhdGVFbnRyeS51c2Vyc1t1c2VySWRdID0ge1xuICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KCksXG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIH07XG4gICAgICBpZiAoc3RhdGVFbnRyeS51c2Vyc1t1c2VySWRdLnN0YXRlID09PSBGSU5JU0hFRCkge1xuICAgICAgICBkZWxldGUgc3RhdGVFbnRyeS51c2Vyc1t1c2VySWRdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVTdGF0ZShzdGF0ZUVudHJ5LCBzdGF0ZSwgdXNlcklkKTtcblxuICAgICAgdGhpcy50cmlnZ2VyKCd0eXBpbmctaW5kaWNhdG9yLWNoYW5nZScsIHtcbiAgICAgICAgY29udmVyc2F0aW9uSWQsXG4gICAgICAgIHR5cGluZzogc3RhdGVFbnRyeS50eXBpbmcsXG4gICAgICAgIHBhdXNlZDogc3RhdGVFbnRyeS5wYXVzZWQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgc3RhdGUgb2YgYSBzaW5nbGUgc3RhdGVFbnRyeTsgYSBzdGF0ZUVudHJ5XG4gICAqIHJlcHJlc2VudHMgYSBzaW5nbGUgQ29udmVyc2F0aW9uJ3MgdHlwaW5nIGluZGljYXRvciBkYXRhLlxuICAgKlxuICAgKiBVcGRhdGVzIHR5cGluZyBhbmQgcGF1c2VkIGFycmF5cyBmb2xsb3dpbmcgaW1tdXRhYmxlIHN0cmF0ZWdpZXNcbiAgICogaW4gaG9wZSB0aGF0IHRoaXMgd2lsbCBoZWxwIEZsZXggYmFzZWQgYXJjaGl0ZWN0dXJlcy5cbiAgICpcbiAgICogQG1ldGhvZCBfdXBkYXRlU3RhdGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzdGF0ZUVudHJ5IC0gQSBDb252ZXJzYXRpb24ncyB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmV3U3RhdGUgICAtIHN0YXJ0ZWQsIHBhdXNlZCBvciBmaW5pc2hlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHVzZXJJZCAgICAgLSBJRCBvZiB0aGUgdXNlciB3aG9zZSBzdGF0ZSBoYXMgY2hhbmdlZFxuICAgKi9cbiAgX3VwZGF0ZVN0YXRlKHN0YXRlRW50cnksIG5ld1N0YXRlLCB1c2VySWQpIHtcbiAgICBjb25zdCB0eXBpbmdJbmRleCA9IHN0YXRlRW50cnkudHlwaW5nLmluZGV4T2YodXNlcklkKTtcbiAgICBpZiAobmV3U3RhdGUgIT09IFNUQVJURUQgJiYgdHlwaW5nSW5kZXggIT09IC0xKSB7XG4gICAgICBzdGF0ZUVudHJ5LnR5cGluZyA9IFtcbiAgICAgICAgLi4uc3RhdGVFbnRyeS50eXBpbmcuc2xpY2UoMCwgdHlwaW5nSW5kZXgpLFxuICAgICAgICAuLi5zdGF0ZUVudHJ5LnR5cGluZy5zbGljZSh0eXBpbmdJbmRleCArIDEpLFxuICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgcGF1c2VkSW5kZXggPSBzdGF0ZUVudHJ5LnBhdXNlZC5pbmRleE9mKHVzZXJJZCk7XG4gICAgaWYgKG5ld1N0YXRlICE9PSBQQVVTRUQgJiYgcGF1c2VkSW5kZXggIT09IC0xKSB7XG4gICAgICBzdGF0ZUVudHJ5LnBhdXNlZCA9IFtcbiAgICAgICAgLi4uc3RhdGVFbnRyeS5wYXVzZWQuc2xpY2UoMCwgcGF1c2VkSW5kZXgpLFxuICAgICAgICAuLi5zdGF0ZUVudHJ5LnBhdXNlZC5zbGljZShwYXVzZWRJbmRleCArIDEpLFxuICAgICAgXTtcbiAgICB9XG5cblxuICAgIGlmIChuZXdTdGF0ZSA9PT0gU1RBUlRFRCAmJiB0eXBpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgIHN0YXRlRW50cnkudHlwaW5nID0gWy4uLnN0YXRlRW50cnkudHlwaW5nLCB1c2VySWRdO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhdGUgPT09IFBBVVNFRCAmJiBwYXVzZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHN0YXRlRW50cnkucGF1c2VkID0gWy4uLnN0YXRlRW50cnkucGF1c2VkLCB1c2VySWRdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBbnkgdGltZSBhIHN0YXRlIGNoYW5nZSBiZWNvbWVzIG1vcmUgdGhhbiA2IHNlY29uZHMgc3RhbGUsXG4gICAqIGFzc3VtZSB0aGF0IHRoZSB1c2VyIGlzICdmaW5pc2hlZCcuXG4gICAqXG4gICAqIEluIHRoZW9yeSwgd2Ugc2hvdWxkXG4gICAqIHJlY2VpdmUgYSBuZXcgZXZlbnQgZXZlcnkgMi41IHNlY29uZHMuICBJZiB0aGUgY3VycmVudCB1c2VyXG4gICAqIGhhcyBnb25lIG9mZmxpbmUsIGxhY2sgb2YgdGhpcyBjb2RlIHdvdWxkIGNhdXNlIHRoZSBwZW9wbGVcbiAgICogY3VycmVudGx5IGZsYWdnZWQgYXMgdHlwaW5nIGFzIHN0aWxsIHR5cGluZyBob3VycyBmcm9tIG5vdy5cbiAgICpcbiAgICogRm9yIHRoaXMgZmlyc3QgcGFzcywgd2UganVzdCBtYXJrIHRoZSB1c2VyIGFzICdmaW5pc2hlZCdcbiAgICogYnV0IGEgZnV0dXJlIHBhc3MgbWF5IG1vdmUgZnJvbSAnc3RhcnRlZCcgdG8gJ3BhdXNlZCdcbiAgICogYW5kICdwYXVzZWQgdG8gJ2ZpbmlzaGVkJ1xuICAgKlxuICAgKiBAbWV0aG9kIF9zdGFydFBvbGxpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdGFydFBvbGxpbmcoKSB7XG4gICAgaWYgKHRoaXMuX3BvbGxJZCkgcmV0dXJuO1xuICAgIHRoaXMuX3BvbGxJZCA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX3BvbGwoKSwgNTAwMCk7XG4gIH1cblxuICBfcG9sbCgpIHtcbiAgICBjb25zdCBjb252ZXJzYXRpb25JZHMgPSBPYmplY3Qua2V5cyh0aGlzLnN0YXRlKTtcblxuICAgIGNvbnZlcnNhdGlvbklkcy5mb3JFYWNoKGlkID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZVtpZF07XG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnN0YXRlW2lkXS51c2VycylcbiAgICAgICAgLmZvckVhY2goKHVzZXJJZCkgPT4ge1xuICAgICAgICAgIGlmIChEYXRlLm5vdygpID49IHN0YXRlLnVzZXJzW3VzZXJJZF0uc3RhcnRUaW1lICsgNjAwMCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUoc3RhdGUsIEZJTklTSEVELCB1c2VySWQpO1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnVzZXJzW3VzZXJJZF07XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3R5cGluZy1pbmRpY2F0b3ItY2hhbmdlJywge1xuICAgICAgICAgICAgICBjb252ZXJzYXRpb25JZDogaWQsXG4gICAgICAgICAgICAgIHR5cGluZzogc3RhdGUudHlwaW5nLFxuICAgICAgICAgICAgICBwYXVzZWQ6IHN0YXRlLnBhdXNlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBDbGllbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2xhc3MuICBVc2VzIHRoZSBjbGllbnRJZFxuICAgKiBwcm9wZXJ0eS5cbiAgICpcbiAgICogQG1ldGhvZCBfZ2V0Q2xpZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7bGF5ZXIuQ2xpZW50fVxuICAgKi9cbiAgX2dldENsaWVudCgpIHtcbiAgICByZXR1cm4gQ2xpZW50UmVnaXN0cnkuZ2V0KHRoaXMuY2xpZW50SWQpO1xuICB9XG59XG5cbi8qKlxuICogc2V0VGltZW91dCBJRCBmb3IgcG9sbGluZyBmb3Igc3RhdGVzIHRvIHRyYW5zaXRpb25cbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5UeXBpbmdJbmRpY2F0b3JMaXN0ZW5lci5wcm90b3R5cGUuX3BvbGxJZCA9IDA7XG5cbi8qKlxuICogSUQgb2YgdGhlIGNsaWVudCB0aGlzIGluc3RhbmNlIGlzIGFzc29jaWF0ZWQgd2l0aFxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuVHlwaW5nSW5kaWNhdG9yTGlzdGVuZXIucHJvdG90eXBlLmNsaWVudElkID0gJyc7XG5cblR5cGluZ0luZGljYXRvckxpc3RlbmVyLmJ1YmJsZUV2ZW50UGFyZW50ID0gJ19nZXRDbGllbnQnO1xuXG5cblR5cGluZ0luZGljYXRvckxpc3RlbmVyLl9zdXBwb3J0ZWRFdmVudHMgPSBbXG4gIC8qKlxuICAgKiBUaGVyZSBoYXMgYmVlbiBhIGNoYW5nZSBpbiB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlIG9mIG90aGVyIHVzZXJzLlxuICAgKiBAZXZlbnQgY2hhbmdlXG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGV2dC50eXBpbmcgLSBBcnJheSBvZiB1c2VySWRzIG9mIHBlb3BsZSB3aG8gYXJlIHR5cGluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBldnQucGF1c2VkIC0gQXJyYXkgb2YgdXNlcklkcyBvZiBwZW9wbGUgd2hvIGFyZSBwYXVzZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dC5jb252ZXJzYXRpb25JZCAtIElEIG9mIHRoZSBDb252ZXJhdGlvbiB0aGF0IGhhcyBjaGFuZ2VkIHR5cGluZyBpbmRpY2F0b3Igc3RhdGVcbiAgICovXG4gICd0eXBpbmctaW5kaWNhdG9yLWNoYW5nZScsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuXG5Sb290LmluaXRDbGFzcy5hcHBseShUeXBpbmdJbmRpY2F0b3JMaXN0ZW5lciwgW1R5cGluZ0luZGljYXRvckxpc3RlbmVyLCAnVHlwaW5nSW5kaWNhdG9yTGlzdGVuZXInXSk7XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGluZ0luZGljYXRvckxpc3RlbmVyO1xuIiwiLyoqXG4gKiBTdGF0aWMgcHJvcGVydGllcyBoZXJlIG9ubHkgbmVlZGVkIGlmIHlvdXIgZGlyZWN0bHkgdXNpbmdcbiAqIHRoZSBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ1B1Ymxpc2hlciAobm90IG5lZWRlZCBpZlxuICogeW91IGFyZSB1c2luZyB0aGUgbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5UeXBpbmdMaXN0ZW5lcikuXG4gKlxuICogICAgICB0eXBpbmdQdWJsaXNoZXIuc2V0U3RhdGUobGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5TVEFSVEVEKTtcbiAqXG4gKiBAY2xhc3MgIGxheWVyLlR5cGluZ0luZGljYXRvcnNcbiAqIEBzdGF0aWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBUeXBpbmcgaGFzIHN0YXJ0ZWQvcmVzdW1lZFxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKiBAc3RhdGljXG4gICAqL1xuICBTVEFSVEVEOiAnc3RhcnRlZCcsXG5cbiAgLyoqXG4gICAqIFR5cGluZyBoYXMgcGF1c2VkXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIFBBVVNFRDogJ3BhdXNlZCcsXG5cbiAgLyoqXG4gICAqIFR5cGluZyBoYXMgZmluaXNoZWRcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQHN0YXRpY1xuICAgKi9cbiAgRklOSVNIRUQ6ICdmaW5pc2hlZCcsXG59O1xuIiwiY29uc3QgVHlwaW5nUHVibGlzaGVyID0gcmVxdWlyZSgnLi90eXBpbmctcHVibGlzaGVyJyk7XG5jb25zdCB7U1RBUlRFRCwgUEFVU0VELCBGSU5JU0hFRH0gPSByZXF1aXJlKCcuL3R5cGluZy1pbmRpY2F0b3JzJyk7XG5cbi8qKlxuICogVGhlIFR5cGluZyBMaXN0ZW5lciBDbGFzcyBsaXN0ZW5zIHRvIGtleWJvYXJkIGV2ZW50cyBvblxuICogeW91ciB0ZXh0IGZpZWxkLCBhbmQgdXNlcyB0aGUgbGF5ZXIuVHlwaW5nUHVibGlzaGVyIHRvXG4gKiBzZW5kIHN0YXRlIGJhc2VkIG9uIGtleWJvYXJkIGJlaGF2aW9yLlxuICpcbiAqICAgICAgdmFyIHR5cGluZ0xpc3RlbmVyID0gY2xpZW50LmNyZWF0ZVR5cGluZ0xpc3RlbmVyKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdteXRleHRhcmVhJykpO1xuICpcbiAqICBZb3UgY2hhbmdlIHdoYXQgQ29udmVyc2F0aW9uXG4gKiAgdGhlIHR5cGluZyBpbmRpY2F0b3IgcmVwb3J0cyB5b3VyIHVzZXIgdG8gYmUgdHlwaW5nXG4gKiAgaW4gYnkgY2FsbGluZzpcbiAqXG4gKiAgICAgIHR5cGluZ0xpc3RlbmVyLnNldENvbnZlcnNhdGlvbihteVNlbGVjdGVkQ29udmVyc2F0aW9uKTtcbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgb2YgY2xlYW5pbmcgdXAgYWxsIHBvaW50ZXJzIHRvIHlvdXIgaW5wdXQgc28gaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkOlxuICpcbiAqIDEuIERlc3Ryb3kgdGhlIGxpc3RlbmVyOlxuICpcbiAqICAgICAgICB0eXBpbmdMaXN0ZW5lci5kZXN0cm95KCk7XG4gKlxuICogMi4gUmVtb3ZlIG9yIHJlcGxhY2UgdGhlIGlucHV0OlxuICpcbiAqICAgICAgICB0eXBpbmdMaXN0ZW5lci5zZXRJbnB1dChudWxsKTtcbiAqICAgICAgICB0eXBpbmdMaXN0ZW5lci5zZXRJbnB1dChuZXdJbnB1dCk7XG4gKlxuICogQGNsYXNzICBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ0xpc3RlbmVyXG4gKi9cbmNsYXNzIFR5cGluZ0xpc3RlbmVyIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgVHlwaW5nTGlzdGVuZXIgdGhhdCBsaXN0ZW5zIGZvciB0aGUgdXNlcidzIHR5cGluZy5cbiAgICpcbiAgICogVGhlIFR5cGluZ0xpc3RlbmVyIG5lZWRzXG4gICAqIHRvIGtub3cgd2hhdCBDb252ZXJzYXRpb24gdGhlIHVzZXIgaXMgdHlwaW5nIGludG8uLi4gYnV0IGl0IGRvZXMgbm90IHJlcXVpcmUgdGhhdCBwYXJhbWV0ZXIgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSAge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jbGllbnRJZCAtIFRoZSBJRCBvZiB0aGUgY2xpZW50OyB1c2VkIHNvIHRoYXQgdGhlIFR5cGluZ1B1Ymxpc2hlciBjYW4gYWNjZXNzIGl0cyB3ZWJzb2NrZXQgbWFuYWdlcipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2FyZ3MuaW5wdXQ9bnVsbF0gLSBBIFRleHQgZWRpdG9yIGRvbSBub2RlIHRoYXQgd2lsbCBoYXZlIHR5cGluZyBpbmRpY2F0b3JzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5jb252ZXJzYXRpb249bnVsbF0gLSBUaGUgQ29udmVyc2F0aW9uIE9iamVjdCBvciBJbnN0YW5jZSB0aGF0IHRoZSBpbnB1dCB3aWxsIHNlbmQgbWVzc2FnZXMgdG9cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmNsaWVudElkID0gYXJncy5jbGllbnRJZDtcbiAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGFyZ3MuY29udmVyc2F0aW9uO1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFR5cGluZ1B1Ymxpc2hlcih7XG4gICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIGNvbnZlcnNhdGlvbjogdGhpcy5jb252ZXJzYXRpb24sXG4gICAgfSk7XG5cbiAgICB0aGlzLmludGVydmFsSWQgPSAwO1xuICAgIHRoaXMubGFzdEtleUlkID0gMDtcblxuICAgIHRoaXMuX2hhbmRsZUtleVByZXNzID0gdGhpcy5faGFuZGxlS2V5UHJlc3MuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVLZXlEb3duID0gdGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2V0SW5wdXQoYXJncy5pbnB1dCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3JlbW92ZUlucHV0KHRoaXMuaW5wdXQpO1xuICAgIHRoaXMucHVibGlzaGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIGlucHV0IGJlaW5nIHRyYWNrZWQgYnkgeW91ciBUeXBpbmdMaXN0ZW5lci5cbiAgICpcbiAgICogSWYgeW91IGFyZSByZW1vdmluZyB5b3VyIGlucHV0IGZyb20gdGhlIERPTSwgeW91IGNhbiBzaW1wbHkgY2FsbFxuICAgKlxuICAgKiAgICAgdHlwaW5nTGlzdGVuZXIuc2V0SW5wdXQobnVsbCk7XG4gICAqXG4gICAqIEFuZCBhbGwgZXZlbnQgaGFuZGxlcnMgd2lsbCBiZSByZW1vdmVkLCBhbGxvd2luZyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAqIHRvIGNsZWFudXAgeW91ciBpbnB1dC5cbiAgICpcbiAgICogWW91IGNhbiBhbHNvIGNhbGwgc2V0SW5wdXQgd2l0aCBhIG5ld2x5IGNyZWF0ZWQgaW5wdXQ6XG4gICAqXG4gICAqICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgKiAgICAgdHlwaW5nTGlzdGVuZXIuc2V0SW5wdXQoaW5wdXQpO1xuICAgKlxuICAgKiBAbWV0aG9kIHNldElucHV0XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGlucHV0IC0gVGV4dGFyZWEgb3IgdGV4dCBpbnB1dFxuICAgKi9cbiAgc2V0SW5wdXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgIT09IHRoaXMuaW5wdXQpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUlucHV0KHRoaXMuaW5wdXQpO1xuICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuXG4gICAgICAvLyBVc2Uga2V5cHJlc3MgcmF0aGVyIHRoYW4ga2V5ZG93biBiZWNhdXNlIHRoZSB1c2VyIGhpdHRpbmcgYWx0LXRhYiB0byBjaGFuZ2VcbiAgICAgIC8vIHdpbmRvd3MsIGFuZCBvdGhlciBtZXRhIGtleXMgc2hvdWxkIG5vdCByZXN1bHQgaW4gdHlwaW5nIGluZGljYXRvcnNcbiAgICAgIHRoaXMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVLZXlQcmVzcyk7XG4gICAgICB0aGlzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9oYW5kbGVLZXlEb3duKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW51cCBhbmQgcmVtb3ZlIGFsbCBsaW5rcyBhbmQgY2FsbGJhY2tzIGtlZXBpbmcgaW5wdXQgZnJvbSBiZWluZyBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVtb3ZlSW5wdXRcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaW5wdXQgLSBUZXh0YXJlYSBvciB0ZXh0IGlucHV0XG4gICAqL1xuICBfcmVtb3ZlSW5wdXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgdGhpcy5faGFuZGxlS2V5UHJlc3MpO1xuICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX2hhbmRsZUtleURvd24pO1xuICAgICAgdGhpcy5pbnB1dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgQ29udmVyc2F0aW9uOyB0aGlzIHNob3VsZCBzZXQgdGhlIHN0YXRlIG9mIHRoZSBvbGQgQ29udmVyc2F0aW9uIHRvIFwiZmluaXNoZWRcIi5cbiAgICpcbiAgICogVXNlIHRoaXMgd2hlbiB0aGUgdXNlciBoYXMgY2hhbmdlZCBDb252ZXJzYXRpb25zIGFuZCB5b3Ugd2FudCB0byByZXBvcnQgb24gdHlwaW5nIHRvIGEgbmV3XG4gICAqIENvbnZlcnNhdGlvbi5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRDb252ZXJzYXRpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSBjb252IC0gVGhlIG5ldyBDb252ZXJzYXRpb24gT2JqZWN0IG9yIEluc3RhbmNlXG4gICAqL1xuICBzZXRDb252ZXJzYXRpb24oY29udikge1xuICAgIGlmIChjb252ICE9PSB0aGlzLmNvbnZlcnNhdGlvbikge1xuICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252O1xuICAgICAgdGhpcy5wdWJsaXNoZXIuc2V0Q29udmVyc2F0aW9uKGNvbnYpO1xuICAgIH1cbiAgfVxuXG5cbiAgLyoqXG4gICAqIFdoZW5ldmVyIHRoZSBrZXkgaXMgcHJlc3NlZCwgc2VuZCBhIFwic3RhcnRlZFwiIG9yIFwiZmluaXNoZWRcIiBldmVudC5cbiAgICpcbiAgICogSWYgaXRzIGEgXCJzdGFydFwiIGV2ZW50LCBzY2hlZHVsZSBhIHBhdXNlLXRlc3QgdGhhdCB3aWxsIHNlbmRcbiAgICogYSBcInBhdXNlXCIgZXZlbnQgaWYgdHlwaW5nIHN0b3BzLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVLZXlQcmVzc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtLZXlib2FyZEV2ZW50fSBldnRcbiAgICovXG4gIF9oYW5kbGVLZXlQcmVzcyhldnQpIHtcbiAgICBpZiAodGhpcy5sYXN0S2V5SWQpIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5sYXN0S2V5SWQpO1xuICAgIHRoaXMubGFzdEtleUlkID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5sYXN0S2V5SWQgPSAwO1xuICAgICAgY29uc3QgaXNFbXB0eSA9ICFCb29sZWFuKHRoaXMuaW5wdXQudmFsdWUpO1xuICAgICAgdGhpcy5zZW5kKGlzRW1wdHkgPyBGSU5JU0hFRCA6IFNUQVJURUQpO1xuICAgIH0sIDUwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWJvYXJkIGtleXMgbm90IHJlcG9ydGVkIGJ5IG9uIGJ5IGtleXByZXNzIGV2ZW50cy5cbiAgICpcbiAgICogVGhlc2Uga2V5cyBjYW4gYmUgZGV0ZWN0ZWQgd2l0aCBrZXlEb3duIGV2ZW50IGhhbmRsZXJzLiBUaGUgb25lc1xuICAgKiBjdXJyZW50bHkgaGFuZGxlZCBoZXJlIGFyZSBiYWNrc3BhY2UsIGRlbGV0ZSBhbmQgZW50ZXIuXG4gICAqIFdlIG1heSBhZGQgbW9yZSBsYXRlci5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlS2V5RG93blxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtLZXlib2FyZEV2ZW50fSBldnRcbiAgICovXG4gIF9oYW5kbGVLZXlEb3duKGV2dCkge1xuICAgIGlmIChbOCwgNDYsIDEzXS5pbmRleE9mKGV2dC5rZXlDb2RlKSAhPT0gLTEpIHRoaXMuX2hhbmRsZUtleVByZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCB0aGUgc3RhdGUgdG8gdGhlIHB1Ymxpc2hlci5cbiAgICpcbiAgICogSWYgeW91ciBhcHBsaWNhdGlvbiByZXF1aXJlc1xuICAgKiB5b3UgdG8gZGlyZWN0bHkgY29udHJvbCB0aGUgc3RhdGUsIHlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZDtcbiAgICogaG93ZXZlciwgYXMgbG9uZyBhcyB5b3UgdXNlIHRoaXMgVHlwaW5nTGlzdGVuZXIsIGtleWJvYXJkXG4gICAqIGV2ZW50cyB3aWxsIG92ZXJ3cml0ZSBhbnkgc3RhdGUgY2hhbmdlcyB5b3Ugc2VuZC5cbiAgICpcbiAgICogQ29tbW9uIHVzZSBjYXNlIGZvciB0aGlzOiBBZnRlciBhIG1lc3NhZ2UgaXMgc2VudCwgeW91IHdhbnQgdG8gY2xlYXIgYW55IHR5cGluZyBpbmRpY2F0b3JzOlxuICAgKlxuICAgKiAgICAgIGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAqICAgICAgICBtZXNzYWdlLnNlbmQoKTtcbiAgICogICAgICAgIHR5cGluZ0luZGljYXRvcnMuc2VuZChsYXllci5UeXBpbmdJbmRpY2F0b3JzLkZJTklTSEVEKTtcbiAgICogICAgICB9XG4gICAqXG4gICAqIEBtZXRob2Qgc2VuZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlIC0gT25lIG9mIFwic3RhcnRlZFwiLCBcInBhdXNlZFwiLCBcImZpbmlzaGVkXCJcbiAgICovXG4gIHNlbmQoc3RhdGUpIHtcbiAgICB0aGlzLnB1Ymxpc2hlci5zZXRTdGF0ZShzdGF0ZSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUeXBpbmdMaXN0ZW5lcjtcbiIsIi8qKlxuICogVGhlIFR5cGluZ1B1Ymxpc2hlcidzIGpvYiBpczpcbiAqXG4gKiAgMS4gU2VuZCBzdGF0ZSBjaGFuZ2VzIHRvIHRoZSBzZXJ2ZXJcbiAqICAyLiBJbnN1cmUgdGhhdCB0aGUgc2VydmVyIGlzIG5vdCBmbG9vZGVkIHdpdGggcmVwZWF0ZWQgc3RhdGUgY2hhbmdlcyBvZiB0aGUgc2FtZSB2YWx1ZVxuICogIDMuIEF1dG9tYXRpY2FsbHkgdHJhbnNpdGlvbiBzdGF0ZXMgd2hlbiBubyBuZXcgc3RhdGVzIG9yIG9sZCBzdGF0ZXMgYXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBXaG8gaXMgdGhlIFR5cGluZyBQdWJsaXNoZXIgZm9yPyAgSXRzIHVzZWQgYnkgdGhlIGxheWVyLlR5cGluZ0luZGljYXRvcnMuVHlwaW5nTGlzdGVuZXI7IGlmIHlvdXIgdXNpbmdcbiAqIHRoZSBUeXBpbmdMaXN0ZW5lciwgeW91IGRvbid0IG5lZWQgdGhpcy4gIElmIHlvdSB3YW50IHRvIHByb3ZpZGUgeW91ciBvd24gbG9naWMgZm9yIHdoZW4gdG8gc2VuZCB0eXBpbmdcbiAqIHN0YXRlcywgdGhlbiB5b3UgbmVlZCB0aGUgVHlwaW5nUHVibGlzaGVyLlxuICpcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSB1c2luZzpcbiAqXG4gKiAgICAgICAgdmFyIHB1Ymxpc2hlciA9IGNsaWVudC5jcmVhdGVUeXBpbmdQdWJsaXNoZXIoKTtcbiAqXG4gKiBUbyB0ZWxsIHRoZSBQdWJsaXNoZXIgd2hpY2ggQ29udmVyc2F0aW9uIGl0cyByZXBvcnRpbmcgYWN0aXZpdHkgb24sIHVzZTpcbiAqXG4gKiAgICAgICAgcHVibGlzaGVyLnNldENvbnZlcnNhdGlvbihteVNlbGVjdGVkQ29udmVyc2F0aW9uKTtcbiAqXG4gKiBUbyB0aGVuIHVzZSB0aGUgaW5zdGFuY2U6XG4gKlxuICogICAgICAgIHB1Ymxpc2hlci5zZXRTdGF0ZShsYXllci5UeXBpbmdJbmRpY2F0b3JzLlNUQVJURUQpO1xuICogICAgICAgIHB1Ymxpc2hlci5zZXRTdGF0ZShsYXllci5UeXBpbmdJbmRpY2F0b3JzLlBBVVNFRCk7XG4gKiAgICAgICAgcHVibGlzaGVyLnNldFN0YXRlKGxheWVyLlR5cGluZ0luZGljYXRvcnMuRklOSVNIRUQpO1xuICpcbiAqIE5vdGUgdGhhdCB0aGUgYFNUQVJURURgIHN0YXRlIG9ubHkgbGFzdHMgZm9yIDIuNSBzZWNvbmRzLCBzbyB5b3VcbiAqIG11c3QgcmVwZWF0ZWRseSBjYWxsIHNldFN0YXRlIGZvciBhcyBsb25nIGFzIHRoaXMgc3RhdGUgc2hvdWxkIGNvbnRpbnVlLlxuICogVGhpcyBpcyB0eXBpY2FsbHkgZG9uZSBieSBzaW1wbHkgY2FsbGluZyBgc2V0U3RhdGUoU1RBUlRFRClgIGV2ZXJ5IHRpbWUgYSB1c2VyIGhpdHNcbiAqIGEga2V5LlxuICpcbiAqIEEgZmV3IHJ1bGVzIGZvciBob3cgdGhlICpwdWJsaXNoZXIqIHdvcmtzIGludGVybmFsbHk6XG4gKlxuICogIC0gaXQgbWFpbnRhaW5zIGFuIGluZGljYXRvciBzdGF0ZSBmb3IgdGhlIGN1cnJlbnQgY29udmVyc2F0aW9uXG4gKiAgLSBpZiBhcHAgY2FsbHMgIGBzZXRTdGF0ZShsYXllci5UeXBpbmdJbmRpY2F0b3JzLlNUQVJURUQpO2AgcHVibGlzaGVyIHNlbmRzIHRoZSBldmVudCBpbW1lZGlhdGVseVxuICogIC0gaWYgYXBwIGNhbGxzIHRoZSBzYW1lIG1ldGhvZCB1bmRlciBfMi41IHNlY29uZHNfIHdpdGggdGhlIHNhbWUgdHlwaW5nIGluZGljYXRvciBzdGF0ZSAoYHN0YXJ0ZWRgKSwgcHVibGlzaGVyIHdhaXRzXG4gKiAgICBmb3IgdGhvc2UgMi41IHNlY29uZHMgdG8gcGFzcyBhbmQgdGhlbiBwdWJsaXNoZXMgdGhlIGVwaGVtZXJhbCBldmVudFxuICogIC0gaWYgYXBwIGNhbGxzIHRoZSBzYW1lIG1ldGhvZHMgbXVsdGlwbGUgdGltZXMgd2l0aGluIF8yLjUgc2Vjb25kc18gd2l0aCB0aGUgc2FtZSB2YWx1ZSxcbiAqICAgIHB1Ymxpc2hlciB3YWl0cyB1bnRpbCBlbmQgb2YgMi41IHNlY29uZCBwZXJpb2QgYW5kIHNlbmRzIHRoZSBzdGF0ZSBvbmx5IG9uY2UuXG4gKiAgLSBpZiBhcHAgY2FsbHMgdGhlIHNhbWUgbWV0aG9kIHVuZGVyIF8yLjUgc2Vjb25kc18gd2l0aCBhIGRpZmZlcmVudCB0eXBpbmcgaW5kaWNhdG9yIHN0YXRlIChzYXkgYHBhdXNlZGApLFxuICogICAgcHVibGlzaGVyIGltbWVkaWF0ZWx5IHNlbmRzIHRoZSBldmVudFxuICogIC0gaWYgMi41IHNlY29uZHMgcGFzc2VzIHdpdGhvdXQgYW55IGV2ZW50cywgc3RhdGUgdHJhbnNpdGlvbnMgZnJvbSAnc3RhcnRlZCcgdG8gJ3BhdXNlZCdcbiAqICAtIGlmIDIuNSBzZWNvbmRzIHBhc3NlcyB3aXRob3V0IGFueSBldmVudHMsIHN0YXRlIHRyYW5zaXRpb25zIGZyb20gJ3BhdXNlZCcgdG8gJ2ZpbmlzaGVkJ1xuICpcbiAqIEBjbGFzcyBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlR5cGluZ1B1Ymxpc2hlclxuICogQHByb3RlY3RlZFxuICovXG5cbmNvbnN0IElOVEVSVkFMID0gMjUwMDtcbmNvbnN0IHsgU1RBUlRFRCwgUEFVU0VELCBGSU5JU0hFRCB9ID0gcmVxdWlyZSgnLi90eXBpbmctaW5kaWNhdG9ycycpO1xuY29uc3QgQ2xpZW50UmVnaXN0cnkgPSByZXF1aXJlKCcuLi9jbGllbnQtcmVnaXN0cnknKTtcblxuY2xhc3MgVHlwaW5nUHVibGlzaGVyIHtcblxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBUeXBpbmcgUHVibGlzaGVyLiAgU2VlIGxheWVyLkNsaWVudC5jcmVhdGVUeXBpbmdQdWJsaXNoZXIuXG4gICAqXG4gICAqIFRoZSBUeXBpbmdQdWJsaXNoZXIgbmVlZHNcbiAgICogdG8ga25vdyB3aGF0IENvbnZlcnNhdGlvbiBpdHMgcHVibGlzaGluZyBjaGFuZ2VzIGZvci4uLlxuICAgKiBidXQgaXQgZG9lcyBub3QgcmVxdWlyZSB0aGF0IHBhcmFtZXRlciBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBtZXRob2QgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsaWVudElkIC0gVGhlIElEIGZvciB0aGUgY2xpZW50IGZyb20gd2hpY2ggd2Ugd2lsbCBnZXQgYWNjZXNzIHRvIHRoZSB3ZWJzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb252ZXJzYXRpb249bnVsbF0gLSBUaGUgQ29udmVyc2F0aW9uIE9iamVjdCBvciBJbnN0YW5jZSB0aGF0IG1lc3NhZ2VzIGFyZSBiZWluZyB0eXBlZCB0by5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmNsaWVudElkID0gYXJncy5jbGllbnRJZDtcbiAgICBpZiAoYXJncy5jb252ZXJzYXRpb24pIHRoaXMuY29udmVyc2F0aW9uID0gdGhpcy5fZ2V0Q2xpZW50KCkuZ2V0Q29udmVyc2F0aW9uKGFyZ3MuY29udmVyc2F0aW9uLmlkKTtcbiAgICB0aGlzLnN0YXRlID0gRklOSVNIRUQ7XG4gICAgdGhpcy5fbGFzdE1lc3NhZ2VUaW1lID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hpY2ggQ29udmVyc2F0aW9uIHdlIGFyZSByZXBvcnRpbmcgb24gc3RhdGUgY2hhbmdlcyBmb3IuXG4gICAqXG4gICAqIElmIHRoaXMgaW5zdGFuY2UgbWFuYWdlZCBhIHByZXZpb3VzIENvbnZlcnNhdGlvbixcbiAgICogaXRzIHN0YXRlIGlzIGltbWVkaWF0ZWx5IHRyYW5zaXRpb25lZCB0byBcImZpbmlzaGVkXCIuXG4gICAqXG4gICAqIEBtZXRob2Qgc2V0Q29udmVyc2F0aW9uXG4gICAqIEBwYXJhbSAge09iamVjdH0gY29udiAtIENvbnZlcnNhdGlvbiBPYmplY3Qgb3IgSW5zdGFuY2VcbiAgICovXG4gIHNldENvbnZlcnNhdGlvbihjb252KSB7XG4gICAgdGhpcy5zZXRTdGF0ZShGSU5JU0hFRCk7XG4gICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ID8gdGhpcy5fZ2V0Q2xpZW50KCkuZ2V0Q29udmVyc2F0aW9uKGNvbnYuaWQpIDogbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gRklOSVNIRUQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3RhdGUgYW5kIGVpdGhlciBzZW5kcyB0aGUgc3RhdGUgdG8gdGhlIHNlcnZlciBvciBzY2hlZHVsZXMgaXQgdG8gYmUgc2VudC5cbiAgICpcbiAgICogQG1ldGhvZCBzZXRTdGF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlIC0gT25lIG9mXG4gICAqICogbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5TVEFSVEVEXG4gICAqICogbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5QQVVTRURcbiAgICogKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLkZJTklTSEVEXG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgIC8vIFdlIGhhdmUgYSBmcmVzaCBzdGF0ZTsgd2hhdGV2ZXIgb3VyIHBhdXNlTG9vcCB3YXMgZG9pbmdcbiAgICAvLyBjYW4gYmUgY2FuY2VsZWQuLi4gYW5kIHJlc3RhcnRlZCBsYXRlci5cbiAgICBpZiAodGhpcy5fcGF1c2VMb29wSWQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcGF1c2VMb29wSWQpO1xuICAgICAgdGhpcy5fcGF1c2VMb29wSWQgPSAwO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udmVyc2F0aW9uKSByZXR1cm47XG5cbiAgICAvLyBJZiBpdHMgYSBuZXcgc3RhdGUsIHNlbmQgaXQgaW1tZWRpYXRlbHkuXG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICB0aGlzLl9zZW5kKHN0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBObyBuZWVkIHRvIHJlc2VuZCAnZmluaXNoZWQnIHN0YXRlXG4gICAgZWxzZSBpZiAoc3RhdGUgPT09IEZJTklTSEVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgaXRzIGFuIGV4aXN0aW5nIHN0YXRlIHRoYXQgaGFzbid0IGJlZW4gc2VudCBpbiB0aGVcbiAgICAvLyBsYXN0IDIuNSBzZWNvbmRzLCBzZW5kIGl0IGltbWVkaWF0ZWx5LlxuICAgIGVsc2UgaWYgKERhdGUubm93KCkgPiB0aGlzLl9sYXN0TWVzc2FnZVRpbWUgKyBJTlRFUlZBTCkge1xuICAgICAgdGhpcy5fc2VuZChzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gRWxzZSBzY2hlZHVsZSBpdCB0byBiZSBzZW50LlxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0TWVzc2FnZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgdGVzdCB0byBhdXRvbWF0aWNhbGx5IHRyYW5zaXRpb24gaWYgMi41IHNlY29uZHMgd2l0aG91dCBhbnkgc2V0U3RhdGUgY2FsbHNcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gRklOSVNIRUQpIHRoaXMuX3N0YXJ0UGF1c2VMb29wKCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgbG9vcCB0byBhdXRvbWF0aWNhbGx5IGNoYW5nZSB0byBuZXh0IHN0YXRlLlxuICAgKlxuICAgKiBBbnkgdGltZSB3ZSBhcmUgc2V0IHRvICdzdGFydGVkJyBvciAncGF1c2VkJyB3ZSBzaG91bGQgdHJhbnNpdGlvblxuICAgKiB0byB0aGUgbmV4dCBzdGF0ZSBhZnRlciAyLjUgc2Vjb25kcyBvZiBubyBzZXRTdGF0ZSBjYWxscy5cbiAgICpcbiAgICogVGhlIDIuNSBzZWNvbmQgc2V0VGltZW91dCBpcyBjYW5jZWxlZC9yZXN0YXJ0ZWQgZXZlcnkgY2FsbCB0byBzZXRTdGF0ZSgpXG4gICAqXG4gICAqIEBtZXRob2QgX3N0YXJ0UGF1c2VMb29wXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RhcnRQYXVzZUxvb3AoKSB7XG4gICAgaWYgKHRoaXMuX3BhdXNlTG9vcElkKSByZXR1cm47XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpbnRlcnZhbCBpcyBjYW5jZWxlZCBldmVyeSBjYWxsIHRvIHNldFN0YXRlLlxuICAgIHRoaXMuX3BhdXNlTG9vcElkID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBQQVVTRUQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShGSU5JU0hFRCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShQQVVTRUQpO1xuICAgICAgfVxuICAgIH0sIElOVEVSVkFMKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlIHRoZSBuZXh0IHN0YXRlIHJlZnJlc2ggbWVzc2FnZS5cbiAgICpcbiAgICogSXQgc2hvdWxkIGJlIGF0IGxlYXN0IElOVEVSVkFMIG1zIGFmdGVyXG4gICAqIHRoZSBsYXN0IHN0YXRlIG1lc3NhZ2Ugb2YgdGhlIHNhbWUgc3RhdGVcbiAgICpcbiAgICogQG1ldGhvZCBfc2NoZWR1bGVOZXh0TWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0YXRlIC0gT25lIG9mXG4gICAqICogbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5TVEFSVEVEXG4gICAqICogbGF5ZXIuVHlwaW5nSW5kaWNhdG9ycy5QQVVTRURcbiAgICogKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLkZJTklTSEVEXG4gICAqL1xuICBfc2NoZWR1bGVOZXh0TWVzc2FnZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9zY2hlZHVsZUlkKSBjbGVhclRpbWVvdXQodGhpcy5fc2NoZWR1bGVJZCk7XG4gICAgY29uc3QgZGVsYXkgPSBJTlRFUlZBTCAtIE1hdGgubWluKERhdGUubm93KCkgLSB0aGlzLl9sYXN0TWVzc2FnZVRpbWUsIElOVEVSVkFMKTtcbiAgICB0aGlzLl9zY2hlZHVsZUlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zY2hlZHVsZUlkID0gMDtcbiAgICAgIC8vIElmIHRoZSBzdGF0ZSBkaWRuJ3QgY2hhbmdlIHdoaWxlIHdhaXRpbmcuLi5cbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBzdGF0ZSkgdGhpcy5fc2VuZChzdGF0ZSk7XG4gICAgfSwgZGVsYXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzdGF0ZSBjaGFuZ2UgdG8gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZCBzZW5kXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3RhdGUgLSBPbmUgb2ZcbiAgICogKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlNUQVJURURcbiAgICogKiBsYXllci5UeXBpbmdJbmRpY2F0b3JzLlBBVVNFRFxuICAgKiAqIGxheWVyLlR5cGluZ0luZGljYXRvcnMuRklOSVNIRURcbiAgICovXG4gIF9zZW5kKHN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLmNvbnZlcnNhdGlvbi5pc1NhdmVkKCkpIHJldHVybjtcbiAgICB0aGlzLl9sYXN0TWVzc2FnZVRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHdzID0gdGhpcy5fZ2V0Q2xpZW50KCkuc29ja2V0TWFuYWdlcjtcbiAgICB3cy5zZW5kU2lnbmFsKHtcbiAgICAgICd0eXBlJzogJ3R5cGluZ19pbmRpY2F0b3InLFxuICAgICAgJ29iamVjdCc6IHtcbiAgICAgICAgJ2lkJzogdGhpcy5jb252ZXJzYXRpb24uaWQsXG4gICAgICB9LFxuICAgICAgJ2RhdGEnOiB7XG4gICAgICAgICdhY3Rpb24nOiBzdGF0ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBDbGllbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGF5ZXIuTWVzc2FnZS5cbiAgICpcbiAgICogVXNlcyB0aGUgY2xpZW50SWQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBtZXRob2QgZ2V0Q2xpZW50XG4gICAqIEByZXR1cm4ge2xheWVyLkNsaWVudH1cbiAgICovXG4gIF9nZXRDbGllbnQoKSB7XG4gICAgcmV0dXJuIENsaWVudFJlZ2lzdHJ5LmdldCh0aGlzLmNsaWVudElkKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgZGVsZXRlIHRoaXMuY29udmVyc2F0aW9uO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9zY2hlZHVsZUlkKTtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3BhdXNlTG9vcElkKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBUeXBpbmdQdWJsaXNoZXI7XG4iLCIvKipcbiAqIExheWVyIGRvZXMgbm90IGF0IHRoaXMgdGltZSBoYXZlIGEgY29uY2VwdCBvZiBVc2Vycywgc28gdGhpcyBjbGFzc1xuICogaXMgbW9yZSBvZiBhIGNvbnZlbmllbmNlL3V0aWxpdHkgdGhhbiByZXF1aXJlZCB1c2UuXG4gKlxuICogVGhlIG1haW4gY29udmVuaWVuY2VzIHByb3ZpZGVkIGJ5IHRoaXMgY2xhc3MgYXJlIHRoYXQgd2hlblxuICogdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgY2xpZW50LnVzZXJzYCAgYXJyYXksXG4gKiBhbmQgdGhlIGBjbGllbnQuYWRkVXNlcih1c2VyKWAgbWV0aG9kLCBlYWNoIGluc3RhbmNlXG4gKiB3aWxsIGxvb2sgZm9yL21vbml0b3IgZm9yIENvbnZlcnNhdGlvbnMgdGhhdCBhcmUgZGlyZWN0XG4gKiBtZXNzYWdlcyBiZXR3ZWVuIHRoZSBjdXJyZW50bHkgYXV0aGVudGljYXRlZCB1c2VyIGFuZFxuICogdGhlIHVzZXIgcmVwcmVzZW50ZWQgYnkgdGhpcyBVc2VyIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGlmIGxpc3RpbmcgdXNlcnMgYW5kIHdhbnQgdG8gc2hvdyB0aGVpciBsYXN0XG4gKiBtZXNzYWdlIG9yIHRoZWlyIHVucmVhZCBtZXNzYWdlIGNvdW50LlxuICpcbiAqICAgICAgY2xpZW50LmFkZFVzZXIobmV3IGxheWVyLlVzZXIoe1xuICogICAgICAgICAgZGlzcGxheU5hbWU6ICdGcmVkJyxcbiAqICAgICAgICAgIGlkOiAnZnJlZDEyMzQnLFxuICogICAgICAgICAgZGF0YToge1xuICogICAgICAgICAgICAgIGE6ICdhJyxcbiAqICAgICAgICAgICAgICBiOiAnYicsXG4gKiAgICAgICAgICAgICAgbGFzdE5hbWU6ICdIdWg/J1xuICogICAgICAgICAgfVxuICogICAgICB9KSk7XG4gKlxuICogVGhlIGlkIHdpbGwgYmUgd2hhdCBpcyB1c2VkIHRvIGZpbmQgbWF0Y2hpbmcgQ29udmVyc2F0aW9ucy5cbiAqXG4gKiBkaXNwbGF5TmFtZSBpcyBub3QgcmVxdWlyZWQsIGJ1dCBpcyBhIGNvbnZlbmllbnQgcGxhY2VcbiAqIHRvIHN0b3JlIGEgZGlzcGxheWFibGUgbmFtZS5cbiAqXG4gKiBUaGUgZGF0YSBwcm9wZXJ0eSBjb250YWlucyBhbiBhcmJpdHJhcnkgamF2YXNjcmlwdCBvYmplY3RcbiAqIHdpdGggYW55IHJlbGV2YW50IGRldGFpbHMgb2YgeW91ciB1c2VyLlxuICpcbiAqIFRPRE86IFJlcGxhY2UgY2xpZW50IHdpdGggY2xpZW50SWRcbiAqXG4gKiBAY2xhc3MgIGxheWVyLlVzZXJcbiAqIEBleHRlbmRzIGxheWVyLlJvb3RcbiAqIEBwcml2YXRlIC8vIE1ha2UgdGhpcyBwdWJsaWMgd2hlbiBJZGVudGl0aWVzIGlzIHJlbGVhc2VkXG4gKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFJvb3QgPSByZXF1aXJlKFwiLi9yb290XCIpO1xudmFyIFV0aWwgPSByZXF1aXJlKFwiLi9jbGllbnQtdXRpbHNcIik7XG5jbGFzcyBVc2VyIGV4dGVuZHMgUm9vdCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vbihcImFsbFwiLCB0aGlzLl9jbGVhck9iamVjdCwgdGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgQ2xpZW50IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBpcyBjYWxsZWQgYXMgYSBzaWRlLWVmZmVjdCBvZiBgY2xpZW50LmFkZFVzZXIodXNlcilgXG4gICAgICpcbiAgICAgKiBJZiB5b3UgZGlyZWN0bHkgbWFuaXB1bGF0ZSBgY2xpZW50LnVzZXJzYCwgaW5zdGVhZCBvZiBjYWxsaW5nXG4gICAgICogYWRkVXNlcigpLCB5b3UgbWF5IG5lZWQgdG8gY2FsbCB0aGlzIG1ldGhvZCBhbmQgc2V0IHRoZSBjbGllbnQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIHNldENsaWVudFxuICAgICAqIEBwYXJhbSAge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAgICovXG4gICAgc2V0Q2xpZW50KGNsaWVudCkge1xuICAgICAgICBpZiAoY2xpZW50KSB7XG4gICAgICAgICAgICB2YXIgY29udmVyc2F0aW9ucyA9IE9iamVjdC5rZXlzKGNsaWVudC5fY29udmVyc2F0aW9uc0hhc2gpLm1hcChpZCA9PiBjbGllbnQuZ2V0Q29udmVyc2F0aW9uKGlkKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMucGFydGljaXBhbnRzLmxlbmd0aCA9PSAyICYmIGMucGFydGljaXBhbnRzLmluZGV4T2YodGhpcy5pZCkgIT0gLTE7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIFV0aWwuc29ydEJ5KGNvbnZlcnNhdGlvbnMsIGZ1bmN0aW9uKGNvbnZlcnNhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2UgPyBjb252ZXJzYXRpb24ubGFzdE1lc3NhZ2Uuc2VudEF0IDogbnVsbDtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNvbnZlcnNhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb25zWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGllbnQub24oXCJjb252ZXJzYXRpb25zOmFkZFwiLCB0aGlzLl9jaGVja05ld0NvbnZlcnNhdGlvbiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2hlcyBhbGwgbmV3IENvbnZlcnNhdGlvbnMgZm9yIG1hdGNoaW5nIENvbnZlcnNhdGlvbi5cbiAgICAgKlxuICAgICAqIEEgbWF0Y2hpbmcgQ29udmVyc2F0aW9uIGlzIGEgZGlyZWN0IG1lc3NhZ2UgY29udmVyc2F0aW9uXG4gICAgICogYmV0d2VlbiB0aGlzIHVzZXIgYW5kIHRoZSBjbGllbnQncyBhdXRoZW50aWNhdGVkIHVzZXIuXG4gICAgICpcbiAgICAgKiBJZiBpdHMgYSBtYXRjaCwgdXBkYXRlcyB0aGlzLmNvbnZlcnNhdGlvbiBhbmQgc3RvcHNcbiAgICAgKiBsaXN0ZW5pbmcgZm9yIG5ldyBDb252ZXJzYXRpb25zLlxuICAgICAqXG4gICAgICogQG1ldGhvZCBfY2hlY2tOZXdDb252ZXJzYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgICAqL1xuICAgIF9jaGVja05ld0NvbnZlcnNhdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGNvbnZlcnNhdGlvbnMgPSBldnQuY29udmVyc2F0aW9ucztcbiAgICAgICAgY29udmVyc2F0aW9ucy5mb3JFYWNoKGNvbnZlcnNhdGlvbiA9PiB7XG4gICAgICAgICAgICBpZiAoY29udmVyc2F0aW9uLnBhcnRpY2lwYW50cy5sZW5ndGggPT0gMiAmJiBjb252ZXJzYXRpb24ucGFydGljaXBhbnRzLmluZGV4T2YodGhpcy5pZCkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbiA9IGNvbnZlcnNhdGlvbjtcbiAgICAgICAgICAgICAgICBjb252ZXJzYXRpb24uY2xpZW50Lm9mZihudWxsLCBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXcgdmFsdWVzIGZvciB0aGUgQ29udmVyc2F0aW9uIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQW55IHRpbWUgYSBuZXcgQ29udmVyc2F0aW9uIGlzIGFzc2lnbmVkIHRvIHRoaXMgcHJvcGVydHksXG4gICAgICogc3Vic2NyaWJlIHRvIGl0cyBcImRlc3Ryb3lcIiBldmVudCBhbmQgdHJpZ2dlciBhIFwiY29udmVyc2F0aW9uczpjaGFuZ2VcIlxuICAgICAqIGV2ZW50IG9uIHRoaXMgdXNlci5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgX191cGRhdGVDb252ZXJzYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge2xheWVyLkNvbnZlcnNhdGlvbn0gY29udmVyc2F0aW9uXG4gICAgICogQHBhcmFtICB7bGF5ZXIuQ29udmVyc2F0aW9ufSBvbGRDb252ZXJzYXRpb25cbiAgICAgKi9cbiAgICBfX3VwZGF0ZUNvbnZlcnNhdGlvbihjb252ZXJzYXRpb24sIG9sZENvbnZlcnNhdGlvbikge1xuICAgICAgICBpZiAob2xkQ29udmVyc2F0aW9uKSBvbGRDb252ZXJzYXRpb24ub2ZmKG51bGwsIG51bGwsIHRoaXMpO1xuICAgICAgICBpZiAoY29udmVyc2F0aW9uKSBjb252ZXJzYXRpb24ub24oXCJkZXN0cm95XCIsIHRoaXMuX2Rlc3Ryb3lDb252ZXJzYXRpb24sIHRoaXMpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoXCJjb252ZXJzYXRpb25zOmNoYW5nZVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgQ29udmVyc2F0aW9uIGlzIGRlc3Ryb3llZCwgdGhpcyB1c2VyIGhhcyBubyBDb252ZXJzYXRpb24uXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIF9kZXN0cm95Q29udmVyc2F0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICAgKi9cbiAgICBfZGVzdHJveUNvbnZlcnNhdGlvbihldnQpIHtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBudWxsO1xuICAgIH1cblxuICAgIHRvT2JqZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RvT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl90b09iamVjdCA9IHN1cGVyLnRvT2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvT2JqZWN0O1xuICAgIH1cblxuICAgIF9jbGVhck9iamVjdCgpIHsgZGVsZXRlIHRoaXMuX3RvT2JqZWN0O31cbn1cblxuLyoqXG4gKiBDdXN0b20gdXNlciBkYXRhLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgaGFzIG5vIGJ1aWx0LWluIG1lYW5pbmc7IGJ1dCBpcyBpbnRlbmRlZCB0byBsZXQgeW91IHN0b3JlIGEgY3VzdG9tIGRhdGEuXG4gKiBJbml0aWFsaXplIHRoaXMgdmlhIGNvbnN0cnVjdG9yOlxuICpcbiAqICAgICAgICAgbmV3IGxheWVyLlVzZXIoe1xuICogICAgICAgICAgICAgZGF0YToge1xuICogICAgICAgICAgICAgICAgIGFnZTogMTA5LFxuICogICAgICAgICAgICAgICAgIG5pY2tOYW1lOiBcIkZyZWRkeVwiXG4gKiAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgaWQ6IFwiZnJlZFwiXG4gKiAgICAgICAgIH0pO1xuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblVzZXIucHJvdG90eXBlLmRhdGEgPSBudWxsO1xuXG4vKipcbiAqIFlvdXIgVXNlciBJRC5cbiAqXG4gKiBUaGlzIElEIHNob3VsZCBtYXRjaCB1cCB3aXRoIHRoZSBJRHMgdXNlZCBpbiBwYXJ0aWNpcGFudHMgaW4gQ29udmVyc2F0aW9ucztcbiAqIHN1Y2ggSURzIGFyZSBiYXNlZCBvbiB5b3VyIG93biB1c2VyIElEcyB3aGljaCBhcmUgcGFzc2VkIHRvIHRoZSBMYXllciBzZXJ2aWNlcyB2aWEgSWRlbnRpdHkgVG9rZW5zLlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuVXNlci5wcm90b3R5cGUuaWQgPSBcIlwiO1xuXG4vKipcbiAqIFlvdXIgdXNlcidzIGRpc3BsYXlhYmxlIG5hbWUuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBoYXMgbm8gYnVpbHQtaW4gbWVhbmluZzsgYnV0IGlzIGludGVuZGVkIHRvIGxldCB5b3Ugc3RvcmUgYSBjdXN0b20gc3RyaW5nXG4gKiBmb3IgaG93IHRvIHJlbmRlciB0aGlzIHVzZXIuICBJbml0aWFsaXplIHRoaXMgdmlhIGNvbnN0cnVjdG9yOlxuICpcbiAqICAgICAgICAgbmV3IGxheWVyLlVzZXIoe1xuICogICAgICAgICAgICAgZGlzcGxheU5hbWU6IFwiRnJlZGR5XCIsXG4gKiAgICAgICAgICAgICBpZDogXCJmcmVkXCJcbiAqICAgICAgICAgfSk7XG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuVXNlci5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBcIlwiO1xuXG4vKipcbiAqIENTUyBDbGFzcyBmb3IgdXNlciBpY29uLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgaGFzIG5vIGJ1aWx0LWluIG1lYW5pbmc7IHVzZSB0aGlzIGlmIHlvdXIgcmVuZGVyaW5nIGVuZ2luZSBuZWVkcyB0aGlzO1xuICoganVzdCBwYXNzIGl0IGludG8gdGhlIGNvbnN0cnVjdG9yO1xuICpcbiAqICAgICAgICAgbmV3IGxheWVyLlVzZXIoe1xuICogICAgICAgICAgICAgaWNvbkNsYXNzOiBcInVua25vd24tZmFjZVwiLFxuICogICAgICAgICAgICAgaWQ6IFwiZnJlZFwiXG4gKiAgICAgICAgIH0pO1xuICpcbiAqIEB0eXBlIHtTdHJpbmd9XG4gKi9cblVzZXIucHJvdG90eXBlLmljb25DbGFzcyA9IFwiXCI7XG5cbi8qKlxuICogVGhlIFVzZXIncyBDb252ZXJzYXRpb24uXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBpcyBtYW5hZ2VkIGJ5IHRoZSB1c2VyIGNsYXNzIGFuZCBpcyBzZXQgdG8gYWx3YXlzIHBvaW50IHRvIGFueSBtYXRjaGluZyBEaXJlY3RcbiAqIE1lc3NhZ2UgY29udmVyc2F0aW9uIGJldHdlZW4gdGhpcyB1c2VyIGFuZCB0aGUgY3VycmVudGx5IGF1dGhlbnRpY2F0ZWQgdXNlci4gIFVzZWZ1bFxuICogZm9yIHJlbmRlcmluZyBpbiBhIFVzZXIgTGlzdCBhbmQgc2hvd2luZyB1bnJlYWQgY291bnRzLCBsYXN0IG1lc3NhZ2UsIGV0Yy4uLlxuICogQ2FuIGFsc28gYmUgdXNlZCB3aGVuIHNlbGVjdGluZyB0aGUgdXNlciB0byBxdWlja2x5IHJlc3VtZSBhIENvbnZlcnNhdGlvbi5cbiAqIEB0eXBlIHtsYXllci5Db252ZXJzYXRpb259XG4gKi9cblVzZXIucHJvdG90eXBlLmNvbnZlcnNhdGlvbiA9IG51bGw7XG5Vc2VyLnByb3RvdHlwZS5fdG9PYmplY3QgPSBudWxsO1xuXG5Vc2VyLl9zdXBwb3J0ZWRFdmVudHMgPSBbXCJjb252ZXJzYXRpb25zOmNoYW5nZVwiXS5jb25jYXQoUm9vdC5fc3VwcG9ydGVkRXZlbnRzKTtcblJvb3QuaW5pdENsYXNzLmFwcGx5KFVzZXIsIFtVc2VyLCBcIlVzZXJcIl0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVzZXI7XG4iLCIvKipcbiAqIEBjbGFzcyAgbGF5ZXIuV2Vic29ja2V0cy5DaGFuZ2VNYW5hZ2VyXG4gKiBAcHJpdmF0ZVxuICpcbiAqIFRoaXMgY2xhc3MgbGlzdGVucyBmb3IgYGNoYW5nZWAgZXZlbnRzIGZyb20gdGhlIHdlYnNvY2tldCBzZXJ2ZXIsXG4gKiBhbmQgcHJvY2Vzc2VzIHRoZW0uXG4gKi9cbmNvbnN0IFV0aWxzID0gcmVxdWlyZSgnLi4vY2xpZW50LXV0aWxzJyk7XG5jb25zdCBsb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IE1lc3NhZ2UgPSByZXF1aXJlKCcuLi9tZXNzYWdlJyk7XG5jb25zdCBDb252ZXJzYXRpb24gPSByZXF1aXJlKCcuLi9jb252ZXJzYXRpb24nKTtcblxuXG5jbGFzcyBXZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY2hhbmdlIG1hbmFnZXJcbiAgICpcbiAgICogICAgICB2YXIgd2Vic29ja2V0Q2hhbmdlTWFuYWdlciA9IG5ldyBsYXllci5XZWJzb2NrZXRzLkNoYW5nZU1hbmFnZXIoe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICAgICAgc29ja2V0TWFuYWdlcjogY2xpZW50LldlYnNvY2tldHMuU29ja2V0TWFuYWdlclxuICAgKiAgICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2xheWVyLkNsaWVudH0gY2xpZW50XG4gICAqIEBwYXJhbSB7bGF5ZXIuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyfSBzb2NrZXRNYW5hZ2VyXG4gICAqIEByZXR1cm5zIHtsYXllci5XZWJzb2NrZXRzLkNoYW5nZU1hbmFnZXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgICBvcHRpb25zLnNvY2tldE1hbmFnZXIub24oJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVDaGFuZ2UsIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBDaGFuZ2UgcGFja2V0IGZyb20gdGhlIHNlcnZlci5cbiAgICpcbiAgICogQG1ldGhvZCBfaGFuZGxlQ2hhbmdlXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSAge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgX2hhbmRsZUNoYW5nZShldnQpIHtcbiAgICBpZiAoZXZ0LmRhdGEudHlwZSA9PT0gJ2NoYW5nZScpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGV2dC5kYXRhLmJvZHk7XG4gICAgICBzd2l0Y2ggKG1zZy5vcGVyYXRpb24pIHtcbiAgICAgICAgY2FzZSAnY3JlYXRlJzpcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgV2Vic29ja2V0IENoYW5nZSBFdmVudDogQ3JlYXRlICR7bXNnLm9iamVjdC50eXBlfSAke21zZy5vYmplY3QuaWR9YCk7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKG1zZy5kYXRhKTtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVDcmVhdGUobXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICBsb2dnZXIuaW5mbyhgV2Vic29ja2V0IENoYW5nZSBFdmVudDogRGVsZXRlICR7bXNnLm9iamVjdC50eXBlfSAke21zZy5vYmplY3QuaWR9YCk7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKG1zZy5kYXRhKTtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVEZWxldGUobXNnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncGF0Y2gnOlxuICAgICAgICAgIGxvZ2dlci5pbmZvKGBXZWJzb2NrZXQgQ2hhbmdlIEV2ZW50OiBQYXRjaCAke21zZy5vYmplY3QudHlwZX0gJHttc2cub2JqZWN0LmlkfTogJHttc2cuZGF0YS5tYXAob3AgPT4gb3AucHJvcGVydHkpLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgbG9nZ2VyLmRlYnVnKG1zZy5kYXRhKTtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVQYXRjaChtc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9jZXNzIGEgY3JlYXRlIG9iamVjdCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVDcmVhdGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtc2dcbiAgICovXG4gIF9oYW5kbGVDcmVhdGUobXNnKSB7XG4gICAgbXNnLmRhdGEuZnJvbVdlYnNvY2tldCA9IHRydWU7XG4gICAgdGhpcy5jbGllbnQuX2NyZWF0ZU9iamVjdChtc2cuZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBkZWxldGUgb2JqZWN0IG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbiAgICogQWxsIG9iamVjdHMgdGhhdCBjYW4gYmUgZGVsZXRlZCBmcm9tIHRoZSBzZXJ2ZXIgc2hvdWxkXG4gICAqIHByb3ZpZGUgYSBfZGVsZXRlZCgpIG1ldGhvZCB0byBiZSBjYWxsZWQgcHJpb3IgdG8gZGVzdHJveSgpLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVEZWxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBtc2dcbiAgICovXG4gIF9oYW5kbGVEZWxldGUobXNnKSB7XG4gICAgaWYgKG1zZy5kYXRhLm1vZGUgPT09ICdteV9kZXZpY2VzJyAmJiBtc2cuZGF0YS5mcm9tX3Bvc2l0aW9uKSB7XG4gICAgICB0aGlzLmNsaWVudC5fcHVyZ2VNZXNzYWdlc0J5UG9zaXRpb24obXNnLm9iamVjdC5pZCwgbXNnLmRhdGEuZnJvbV9wb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuX2dldE9iamVjdChtc2cpO1xuICAgICAgaWYgKGVudGl0eSkge1xuICAgICAgICBlbnRpdHkuX2RlbGV0ZWQoKTtcbiAgICAgICAgZW50aXR5LmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT24gcmVjZWl2aW5nIGFuIHVwZGF0ZS9wYXRjaCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICAgKiBydW4gdGhlIExheWVyUGFyc2VyIG9uIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVQYXRjaFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1zZ1xuICAgKi9cbiAgX2hhbmRsZVBhdGNoKG1zZykge1xuICAgIC8vIENhbiBvbmx5IHBhdGNoIGEgY2FjaGVkIG9iamVjdFxuICAgIGNvbnN0IGVudGl0eSA9IHRoaXMuX2dldE9iamVjdChtc2cpO1xuICAgIGlmIChlbnRpdHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVudGl0eS5faW5MYXllclBhcnNlciA9IHRydWU7XG4gICAgICAgIFV0aWxzLmxheWVyUGFyc2Uoe1xuICAgICAgICAgIG9iamVjdDogZW50aXR5LFxuICAgICAgICAgIHR5cGU6IG1zZy5vYmplY3QudHlwZSxcbiAgICAgICAgICBvcGVyYXRpb25zOiBtc2cuZGF0YSxcbiAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgZW50aXR5Ll9pbkxheWVyUGFyc2VyID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCd3ZWJzb2NrZXQtbWFuYWdlcjogRmFpbGVkIHRvIGhhbmRsZSBldmVudCcsIG1zZy5kYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChVdGlscy50eXBlRnJvbUlEKG1zZy5vYmplY3QuaWQpKSB7XG4gICAgICAgIGNhc2UgJ2NvbnZlcnNhdGlvbnMnOlxuICAgICAgICAgIGlmIChDb252ZXJzYXRpb24uX2xvYWRSZXNvdXJjZUZvclBhdGNoKG1zZy5kYXRhKSkgdGhpcy5jbGllbnQuZ2V0Q29udmVyc2F0aW9uKG1zZy5vYmplY3QuaWQsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZXNzYWdlcyc6XG4gICAgICAgICAgaWYgKE1lc3NhZ2UuX2xvYWRSZXNvdXJjZUZvclBhdGNoKG1zZy5kYXRhKSkgdGhpcy5jbGllbnQuZ2V0TWVzc2FnZShtc2cub2JqZWN0LmlkLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYW5ub3VuY2VtZW50cyc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgb2JqZWN0IHNwZWNpZmllZCBieSB0aGUgYG9iamVjdGAgcHJvcGVydHkgb2YgdGhlIHdlYnNvY2tldCBwYWNrZXQuXG4gICAqXG4gICAqIEBtZXRob2QgX2dldE9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG1zZ1xuICAgKiBAcmV0dXJuIHtsYXllci5Sb290fVxuICAgKi9cbiAgX2dldE9iamVjdChtc2cpIHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuX2dldE9iamVjdChtc2cub2JqZWN0LmlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3QgcmVxdWlyZWQsIGJ1dCBkZXN0cm95IGlzIGJlc3QgcHJhY3RpY2VcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBDbGllbnQgdGhhdCBvd25zIHRoaXMuXG4gKiBAdHlwZSB7bGF5ZXIuQ2xpZW50fVxuICovXG5XZWJzb2NrZXRDaGFuZ2VNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYnNvY2tldENoYW5nZU1hbmFnZXI7XG4iLCIvKipcbiAqIEBjbGFzcyAgbGF5ZXIuV2Vic29ja2V0cy5SZXF1ZXN0TWFuYWdlclxuICogQHByaXZhdGVcbiAqXG4gKiBUaGlzIGNsYXNzIGFsbG93cyBvbmUgdG8gc2VuZCByZXF1ZXN0cyB0byB0aGUgd2Vic29ja2V0IHNlcnZlciwgYW5kIHByb3ZpZGUgYSBjYWxsYmFjayxcbiAqIEFuZCBoYXZlIHRoYXQgY2FsbGJhY2sgZWl0aGVyIGNhbGxlZCBieSB0aGUgY29ycmVjdCB3ZWJzb2NrZXQgc2VydmVyIHJlc3BvbnNlLCBvclxuICogYmUgY2FsbGVkIHdpdGggYSB0aW1lb3V0LlxuICovXG5jb25zdCBVdGlscyA9IHJlcXVpcmUoJy4uL2NsaWVudC11dGlscycpO1xuY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBMYXllckVycm9yID0gcmVxdWlyZSgnLi4vbGF5ZXItZXJyb3InKTtcblxuLy8gV2FpdCAxNSBzZWNvbmRzIGZvciBhIHJlc3BvbnNlIGFuZCB0aGVuIGdpdmUgdXBcbmNvbnN0IERFTEFZX1VOVElMX1RJTUVPVVQgPSAxNSAqIDEwMDA7XG5cbmNsYXNzIFdlYnNvY2tldFJlcXVlc3RNYW5hZ2VyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB3ZWJzb2NrZXQgY2hhbmdlIG1hbmFnZXJcbiAgICpcbiAgICogICAgICB2YXIgd2Vic29ja2V0UmVxdWVzdE1hbmFnZXIgPSBuZXcgbGF5ZXIuV2Vic29ja2V0cy5SZXF1ZXN0TWFuYWdlcih7XG4gICAqICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgKiAgICAgICAgICBzb2NrZXRNYW5hZ2VyOiBjbGllbnQuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyXG4gICAqICAgICAgfSk7XG4gICAqXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7bGF5ZXIuQ2xpZW50fSBjbGllbnRcbiAgICogQHBhcmFtIHtsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXJ9IHNvY2tldE1hbmFnZXJcbiAgICogQHJldHVybnMge2xheWVyLldlYnNvY2tldHMuUmVxdWVzdE1hbmFnZXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgICB0aGlzLnNvY2tldE1hbmFnZXIgPSBvcHRpb25zLnNvY2tldE1hbmFnZXI7XG4gICAgdGhpcy5zb2NrZXRNYW5hZ2VyLm9uKHtcbiAgICAgIG1lc3NhZ2U6IHRoaXMuX2hhbmRsZVJlc3BvbnNlLFxuICAgICAgZGlzY29ubmVjdGVkOiB0aGlzLl9yZXNldCxcbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX3JlcXVlc3RDYWxsYmFja3MgPSB7fTtcbiAgfVxuXG4gIF9yZXNldCgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzID0ge307XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGEgcmVzcG9uc2UgdG8gYSByZXF1ZXN0LlxuICAgKlxuICAgKiBAbWV0aG9kIF9oYW5kbGVSZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtsYXllci5MYXllckV2ZW50fSBldnRcbiAgICovXG4gIF9oYW5kbGVSZXNwb25zZShldnQpIHtcbiAgICBpZiAoZXZ0LmRhdGEudHlwZSA9PT0gJ3Jlc3BvbnNlJykge1xuICAgICAgY29uc3QgbXNnID0gZXZ0LmRhdGEuYm9keTtcbiAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IG1zZy5yZXF1ZXN0X2lkO1xuICAgICAgY29uc3QgZGF0YSA9IG1zZy5zdWNjZXNzID8gbXNnLmRhdGEgOiBuZXcgTGF5ZXJFcnJvcihtc2cuZGF0YSk7XG4gICAgICBsb2dnZXIuZGVidWcoYFdlYnNvY2tldCByZXNwb25zZSAke3JlcXVlc3RJZH0gJHttc2cuc3VjY2VzcyA/ICdTdWNjZXNzZnVsJyA6ICdGYWlsZWQnfWApO1xuICAgICAgaWYgKHJlcXVlc3RJZCAmJiB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF0pIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdENhbGxiYWNrc1tyZXF1ZXN0SWRdLmNhbGxiYWNrKHtcbiAgICAgICAgICBzdWNjZXNzOiBtc2cuc3VjY2VzcyxcbiAgICAgICAgICBmdWxsRGF0YTogZXZ0LmRhdGEsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IGZvciBzZW5kaW5nIGEgcmVxdWVzdDsgYnVpbGRzIGluIGhhbmRsaW5nIGZvciBjYWxsYmFja3NcbiAgICpcbiAgICogICAgbWFuYWdlci5zZW5kUmVxdWVzdCh7XG4gICAqICAgICAgb3BlcmF0aW9uOiBcImRlbGV0ZVwiLFxuICAgKiAgICAgIG9iamVjdDoge2lkOiBcImxheWVyOi8vL2NvbnZlcnNhdGlvbnMvdXVpZFwifSxcbiAgICogICAgICBkYXRhOiB7ZGVsZXRpb25fbW9kZTogXCJhbGxfcGFydGljaXBhbnRzXCJ9XG4gICAqICAgIH0sIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgKiAgICAgICAgYWxlcnQocmVzdWx0LnN1Y2Nlc3MgPyBcIllheVwiIDogXCJCb29cIik7XG4gICAqICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kIHNlbmRSZXF1ZXN0XG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSAtIERhdGEgdG8gc2VuZCB0byB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEhhbmRsZXIgZm9yIHN1Y2Nlc3MvZmFpbHVyZSBjYWxsYmFja1xuICAgKi9cbiAgc2VuZFJlcXVlc3QoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX2lzT3BlbigpKSB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrID8gdW5kZWZpbmVkIDogY2FsbGJhY2sobmV3IExheWVyRXJyb3Ioe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZGF0YTogeyBpZDogJ25vdF9jb25uZWN0ZWQnLCBjb2RlOiAwLCBtZXNzYWdlOiAnV2ViU29ja2V0IG5vdCBjb25uZWN0ZWQnIH0sXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSBVdGlscy5jbG9uZShkYXRhKTtcbiAgICBib2R5LnJlcXVlc3RfaWQgPSAncicgKyB0aGlzLl9uZXh0UmVxdWVzdElkKys7XG4gICAgbG9nZ2VyLmRlYnVnKGBSZXF1ZXN0ICR7Ym9keS5yZXF1ZXN0X2lkfSBpcyBzZW5kaW5nYCk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW2JvZHkucmVxdWVzdF9pZF0gPSB7XG4gICAgICAgIGRhdGU6IERhdGUubm93KCksXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNvY2tldE1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICBib2R5LFxuICAgIH0pO1xuICAgIHRoaXMuX3NjaGVkdWxlQ2FsbGJhY2tDbGVhbnVwKCk7XG4gIH1cblxuICAvKipcbiAgICogRmxhZ3MgYSByZXF1ZXN0IGFzIGhhdmluZyBmYWlsZWQgaWYgbm8gcmVzcG9uc2Ugd2l0aGluIDIgbWludXRlc1xuICAgKlxuICAgKiBAbWV0aG9kIF9zY2hlZHVsZUNhbGxiYWNrQ2xlYW51cFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NjaGVkdWxlQ2FsbGJhY2tDbGVhbnVwKCkge1xuICAgIGlmICghdGhpcy5fY2FsbGJhY2tDbGVhbnVwSWQpIHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrQ2xlYW51cElkID0gc2V0VGltZW91dCh0aGlzLl9ydW5DYWxsYmFja0NsZWFudXAuYmluZCh0aGlzKSwgREVMQVlfVU5USUxfVElNRU9VVCArIDUwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgY2FsbGJhY2sgd2l0aCBhbiBlcnJvci5cbiAgICpcbiAgICogTk9URTogQmVjYXVzZSB3ZSBjYWxsIHJlcXVlc3RzIHRoYXQgZXhwZWN0IHJlc3BvbnNlcyBzZXJpYWxseSBpbnN0ZWFkIG9mIGluIHBhcmFsbGVsLFxuICAgKiBjdXJyZW50bHkgdGhlcmUgc2hvdWxkIG9ubHkgZXZlciBiZSBhIHNpbmdsZSBlbnRyeSBpbiBfcmVxdWVzdENhbGxiYWNrcy4gIFRoaXMgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICAgKlxuICAgKiBAbWV0aG9kIF9ydW5DYWxsYmFja0NsZWFudXBcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ydW5DYWxsYmFja0NsZWFudXAoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tDbGVhbnVwSWQgPSAwO1xuICAgIC8vIElmIHRoZSB3ZWJzb2NrZXQgaXMgY2xvc2VkLCBpZ25vcmUgYWxsIGNhbGxiYWNrcy4gIFRoZSBTeW5jIE1hbmFnZXIgd2lsbCByZWlzc3VlIHRoZXNlIHJlcXVlc3RzIGFzIHNvb24gYXMgaXQgZ2V0c1xuICAgIC8vIGEgJ2Nvbm5lY3RlZCcgZXZlbnQuLi4gdGhleSBoYXZlIG5vdCBmYWlsZWQuICBNYXkgbmVlZCB0byByZXRoaW5rIHRoaXMgZm9yIGNhc2VzIHdoZXJlIHRoaXJkIHBhcnRpZXMgYXJlIGRpcmVjdGx5XG4gICAgLy8gY2FsbGluZyB0aGUgd2Vic29ja2V0IG1hbmFnZXIgYnlwYXNzaW5nIHRoZSBzeW5jIG1hbmFnZXIuXG4gICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQgfHwgIXRoaXMuX2lzT3BlbigpKSByZXR1cm47XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHRoaXMuX3JlcXVlc3RDYWxsYmFja3MpLmZvckVhY2gocmVxdWVzdElkID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrQ29uZmlnID0gdGhpcy5fcmVxdWVzdENhbGxiYWNrc1tyZXF1ZXN0SWRdO1xuICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaGFzbid0IGV4cGlyZWQsIHdlJ2xsIG5lZWQgdG8gcmVzY2hlZHVsZSBjYWxsYmFjayBjbGVhbnVwOyBlbHNlIGlmIGl0cyBleHBpcmVkLi4uXG4gICAgICBpZiAoY2FsbGJhY2tDb25maWcgJiYgbm93IDwgY2FsbGJhY2tDb25maWcuZGF0ZSArIERFTEFZX1VOVElMX1RJTUVPVVQpIHtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGhhcyBiZWVuIG5vIGRhdGEgZnJvbSB0aGUgc2VydmVyLCB0aGVyZSdzIHByb2JhYmx5IGEgcHJvYmxlbSB3aXRoIHRoZSB3ZWJzb2NrZXQ7IHJlY29ubmVjdC5cbiAgICAgICAgaWYgKG5vdyA+IHRoaXMuc29ja2V0TWFuYWdlci5fbGFzdERhdGFGcm9tU2VydmVyVGltZXN0YW1wICsgREVMQVlfVU5USUxfVElNRU9VVCkge1xuICAgICAgICAgIHRoaXMuc29ja2V0TWFuYWdlci5fcmVjb25uZWN0KGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9zY2hlZHVsZUNhbGxiYWNrQ2xlYW51cCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgcmVxdWVzdCBpc24ndCByZXNwb25kaW5nIGFuZCB0aGUgc29ja2V0IGlzIGdvb2Q7IGZhaWwgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgdGhpcy5fdGltZW91dFJlcXVlc3QocmVxdWVzdElkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjb3VudCkgdGhpcy5fc2NoZWR1bGVDYWxsYmFja0NsZWFudXAoKTtcbiAgfVxuXG4gIF90aW1lb3V0UmVxdWVzdChyZXF1ZXN0SWQpIHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyLndhcm4oJ1dlYnNvY2tldCByZXF1ZXN0IHRpbWVvdXQnKTtcbiAgICAgIHRoaXMuX3JlcXVlc3RDYWxsYmFja3NbcmVxdWVzdElkXS5jYWxsYmFjayh7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBkYXRhOiBuZXcgTGF5ZXJFcnJvcih7XG4gICAgICAgICAgaWQ6ICdyZXF1ZXN0X3RpbWVvdXQnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgc2VydmVyIGlzIG5vdCByZXNwb25kaW5nLiBXZSBrbm93IGhvdyBtdWNoIHRoYXQgc3Vja3MuJyxcbiAgICAgICAgICB1cmw6ICdodHRwczovZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3dlYnNkaycsXG4gICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICBzdGF0dXM6IDQwOCxcbiAgICAgICAgICBodHRwU3RhdHVzOiA0MDgsXG4gICAgICAgIH0pLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBEbyBub3RoaW5nXG4gICAgfVxuICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0Q2FsbGJhY2tzW3JlcXVlc3RJZF07XG4gIH1cblxuICBfaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLnNvY2tldE1hbmFnZXIuX2lzT3BlbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tDbGVhbnVwSWQpIGNsZWFyVGltZW91dCh0aGlzLl9jYWxsYmFja0NsZWFudXBJZCk7XG4gICAgdGhpcy5fcmVxdWVzdENhbGxiYWNrcyA9IG51bGw7XG4gIH1cbn1cblxuV2Vic29ja2V0UmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLl9uZXh0UmVxdWVzdElkID0gMTtcblxuLyoqXG4gKiBUaGUgQ2xpZW50IHRoYXQgb3ducyB0aGlzLlxuICogQHR5cGUge2xheWVyLkNsaWVudH1cbiAqL1xuV2Vic29ja2V0UmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLmNsaWVudCA9IG51bGw7XG5cbldlYnNvY2tldFJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5fcmVxdWVzdENhbGxiYWNrcyA9IG51bGw7XG5cbldlYnNvY2tldFJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5fY2FsbGJhY2tDbGVhbnVwSWQgPSAwO1xuXG5XZWJzb2NrZXRSZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc29ja2V0TWFuYWdlciA9IG51bGw7XG5cbm1vZHVsZS5leHBvcnRzID0gV2Vic29ja2V0UmVxdWVzdE1hbmFnZXI7XG5cbiIsIi8qKlxuICogVGhpcyBjb21wb25lbnQgbWFuYWdlc1xuICpcbiAqIDEuIHJlY2lldmluZyB3ZWJzb2NrZXQgZXZlbnRzXG4gKiAyLiBQcm9jZXNzaW5nIHRoZW1cbiAqIDMuIFRyaWdnZXJpbmcgZXZlbnRzIG9uIGNvbXBsZXRpbmcgdGhlbVxuICogNC4gU2VuZGluZyB0aGVtXG4gKlxuICogQXBwbGljYXRpb25zIHR5cGljYWxseSBkbyBub3QgaW50ZXJhY3Qgd2l0aCB0aGlzIGNvbXBvbmVudCwgYnV0IG1heSBzdWJzY3JpYmVcbiAqIHRvIHRoZSBgbWVzc2FnZWAgZXZlbnQgaWYgdGhleSB3YW50IHJpY2hlciBldmVudCBpbmZvcm1hdGlvbiB0aGFuIGlzIGF2YWlsYWJsZVxuICogdGhyb3VnaCB0aGUgbGF5ZXIuQ2xpZW50IGNsYXNzLlxuICpcbiAqIEBjbGFzcyAgbGF5ZXIuV2Vic29ja2V0cy5Tb2NrZXRNYW5hZ2VyXG4gKiBAZXh0ZW5kcyBsYXllci5Sb290XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBSb290ID0gcmVxdWlyZSgnLi4vcm9vdCcpO1xuY29uc3QgVXRpbHMgPSByZXF1aXJlKCcuLi9jbGllbnQtdXRpbHMnKTtcbmNvbnN0IGxvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG5jbGFzcyBTb2NrZXRNYW5hZ2VyIGV4dGVuZHMgUm9vdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgd2Vic29ja2V0IG1hbmFnZXJcbiAgICpcbiAgICogICAgICB2YXIgc29ja2V0TWFuYWdlciA9IG5ldyBsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXIoe1xuICAgKiAgICAgICAgICBjbGllbnQ6IGNsaWVudCxcbiAgICogICAgICB9KTtcbiAgICpcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtsYXllci5DbGllbnR9IGNsaWVudFxuICAgKiBAcmV0dXJuIHtsYXllci5XZWJzb2NrZXRzLlNvY2tldE1hbmFnZXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLmNsaWVudCkgdGhyb3cgbmV3IEVycm9yKCdTb2NrZXRNYW5hZ2VyIHJlcXVpcmVzIGEgY2xpZW50Jyk7XG5cbiAgICAvLyBJbnN1cmUgdGhhdCBvbi9vZmYgbWV0aG9kcyBkb24ndCBuZWVkIHRvIGNhbGwgYmluZCwgdGhlcmVmb3JlIG1ha2luZyBpdCBlYXN5XG4gICAgLy8gdG8gYWRkL3JlbW92ZSBmdW5jdGlvbnMgYXMgZXZlbnQgbGlzdGVuZXJzLlxuICAgIHRoaXMuX29uTWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uT3BlbiA9IHRoaXMuX29uT3Blbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU29ja2V0Q2xvc2UgPSB0aGlzLl9vblNvY2tldENsb3NlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25FcnJvciA9IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKTtcblxuICAgIC8vIElmIHRoZSBjbGllbnQgaXMgYXV0aGVudGljYXRlZCwgc3RhcnQgaXQgdXAuXG4gICAgaWYgKHRoaXMuY2xpZW50LmlzQXV0aGVudGljYXRlZCAmJiB0aGlzLmNsaWVudC5vbmxpbmVNYW5hZ2VyLmlzT25saW5lKSB7XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaWVudC5vbignb25saW5lJywgdGhpcy5fb25saW5lU3RhdGVDaGFuZ2UsIHRoaXMpO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIENsaWVudCB0cmlnZ2VycyBhIHJlYWR5IGV2ZW50IHdlIG5lZWQgdG8gcmVjb25uZWN0LlxuICAgIHRoaXMuY2xpZW50Lm9uKCdhdXRoZW50aWNhdGVkJywgdGhpcy5jb25uZWN0LCB0aGlzKTtcblxuICAgIHRoaXMuX2xhc3RUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuIHdlIHdhbnQgdG8gcmVzZXQgYWxsIHdlYnNvY2tldCBzdGF0ZTsgdGhpcyB3b3VsZCBiZSBkb25lIGFmdGVyIGEgbGVuZ3RoeSBwZXJpb2RcbiAgICogb2YgYmVpbmcgZGlzY29ubmVjdGVkLiAgVGhpcyBwcmV2ZW50cyBFdmVudC5yZXBsYXkgZnJvbSBiZWluZyBjYWxsZWQgb24gcmVjb25uZWN0aW5nLlxuICAgKlxuICAgKiBAbWV0aG9kIF9yZXNldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0KCkge1xuICAgIHRoaXMuX2xhc3RUaW1lc3RhbXAgPSAwO1xuICAgIHRoaXMuX2xhc3REYXRhRnJvbVNlcnZlclRpbWVzdGFtcCA9IDA7XG4gICAgdGhpcy5fbGFzdENvdW50ZXIgPSBudWxsO1xuICAgIHRoaXMuX2hhc0NvdW50ZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luUmVwbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5fbmVlZHNSZXBsYXlGcm9tID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVyIGlzIHRyaWdnZXJlZCBhbnkgdGltZSB0aGUgY2xpZW50J3Mgb25saW5lIHN0YXRlIGNoYW5nZXMuXG4gICAqIElmIGdvaW5nIG9ubGluZSB3ZSBuZWVkIHRvIHJlY29ubmVjdCAoaS5lLiB3aWxsIGNsb3NlIGFueSBleGlzdGluZyB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgYW5kIHRoZW4gb3BlbiBhIG5ldyBjb25uZWN0aW9uKVxuICAgKiBJZiBnb2luZyBvZmZsaW5lLCBjbG9zZSB0aGUgd2Vic29ja2V0IGFzIGl0cyBubyBsb25nZXIgdXNlZnVsL3JlbGV2YW50LlxuICAgKiBAbWV0aG9kIF9vbmxpbmVTdGF0ZUNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2xheWVyLkxheWVyRXZlbnR9IGV2dFxuICAgKi9cbiAgX29ubGluZVN0YXRlQ2hhbmdlKGV2dCkge1xuICAgIGlmICghdGhpcy5jbGllbnQuaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgaWYgKGV2dC5pc09ubGluZSkge1xuICAgICAgdGhpcy5fcmVjb25uZWN0KGV2dC5yZXNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVjb25uZWN0IHRvIHRoZSBzZXJ2ZXIsIG9wdGlvbmFsbHkgcmVzZXR0aW5nIGFsbCBkYXRhIGlmIG5lZWRlZC5cbiAgICogQG1ldGhvZCBfcmVjb25uZWN0XG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzZXRcbiAgICovXG4gIF9yZWNvbm5lY3QocmVzZXQpIHtcbiAgICAvLyBUaGUgc3luYyBtYW5hZ2VyIHdpbGwgcmVpc3N1ZSBhbnkgcmVxdWVzdHMgb25jZSBpdCByZWNlaXZlcyBhICdjb25uZWN0JyBldmVudCBmcm9tIHRoZSB3ZWJzb2NrZXQgbWFuYWdlci5cbiAgICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGhhdmUgYW4gZXJyb3IgY2FsbGJhY2sgYXQgdGhpcyB0aW1lLlxuICAgIC8vIE5vdGUgdGhhdCBjYWxscyB0aGF0IGNvbWUgZnJvbSBzb3VyY2VzIG90aGVyIHRoYW4gdGhlIHN5bmMgbWFuYWdlciBtYXkgc3VmZmVyIGZyb20gdGhpcy5cbiAgICAvLyBPbmNlIHRoZSB3ZWJzb2NrZXQgaW1wbGVtZW50cyByZXRyeSByYXRoZXIgdGhhbiB0aGUgc3luYyBtYW5hZ2VyLCB3ZSBtYXkgbmVlZCB0byBlbmFibGUgaXRcbiAgICAvLyB0byB0cmlnZ2VyIGEgY2FsbGJhY2sgYWZ0ZXIgc3VmZmljaWVudCB0aW1lLiAgSnVzdCBkZWxldGUgYWxsIGNhbGxiYWNrcy5cbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgaWYgKHJlc2V0KSB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbm5lY3QgdG8gdGhlIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICpcbiAgICogQG1ldGhvZCBjb25uZWN0XG4gICAqIEBwYXJhbSAge2xheWVyLlN5bmNFdmVudH0gZXZ0IC0gSWdub3JlZCBwYXJhbWV0ZXJcbiAgICovXG4gIGNvbm5lY3QoZXZ0KSB7XG4gICAgaWYgKHRoaXMuY2xpZW50LmlzRGVzdHJveWVkIHx8ICF0aGlzLmNsaWVudC5pc09ubGluZSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fY2xvc2luZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fbGFzdENvdW50ZXIgPSAtMTtcblxuICAgIC8vIExvYWQgdXAgb3VyIHdlYnNvY2tldCBjb21wb25lbnQgb3Igc2hpbVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgY29uc3QgV1MgPSB0eXBlb2YgV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJyA/IHJlcXVpcmUoJ3dlYnNvY2tldCcpLnczY3dlYnNvY2tldCA6IFdlYlNvY2tldDtcblxuICAgIC8vIEdldCB0aGUgVVJMIGFuZCBjb25uZWN0IHRvIGl0XG4gICAgY29uc3QgdXJsID0gdGhpcy5jbGllbnQudXJsLnJlcGxhY2UoL15odHRwLywgJ3dzJykgK1xuICAgICAgJy93ZWJzb2NrZXQ/c2Vzc2lvbl90b2tlbj0nICtcbiAgICAgIHRoaXMuY2xpZW50LnNlc3Npb25Ub2tlbjtcbiAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV1ModXJsLCAnbGF5ZXItMS4wJyk7XG5cbiAgICAvLyBJZiBpdHMgdGhlIHNoaW0sIHNldCB0aGUgZXZlbnQgaGFubGVyc1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5fc29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbmNsb3NlID0gdGhpcy5fb25Tb2NrZXRDbG9zZTtcbiAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSB0aGlzLl9vbk9wZW47XG4gICAgICB0aGlzLl9zb2NrZXQub25lcnJvciA9IHRoaXMuX29uRXJyb3I7XG4gICAgfVxuXG4gICAgLy8gSWYgaXRzIGEgcmVhbCB3ZWJzb2NrZXQsIGFkZCB0aGUgZXZlbnQgaGFuZGxlcnNcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlKTtcbiAgICAgIHRoaXMuX3NvY2tldC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMuX29uU29ja2V0Q2xvc2UpO1xuICAgICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLl9vbk9wZW4pO1xuICAgICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciBhIGZhaWx1cmUgaWYgaXQgdGFrZXMgPj0gNSBzZWNvbmRzIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb25cbiAgICB0aGlzLl9jb25uZWN0aW9uRmFpbGVkSWQgPSBzZXRUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25GYWlsZWQuYmluZCh0aGlzKSwgNTAwMCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBzY2hlZHVsZWQgY2FsbCB0byBfY29ubmVjdGlvbkZhaWxlZCB0aGF0IGlzIHVzZWQgdG8gaW5zdXJlIHRoZSB3ZWJzb2NrZXQgZG9lcyBub3QgZ2V0IHN0dWNrXG4gICAqIGluIENPTk5FQ1RJTkcgc3RhdGUuIFRoaXMgY2FsbCBpcyB1c2VkIGFmdGVyIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQgb3IgZmFpbGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jbGVhckNvbm5lY3Rpb25GYWlsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhckNvbm5lY3Rpb25GYWlsZWQoKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25GYWlsZWRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25GYWlsZWRJZCk7XG4gICAgICB0aGlzLl9jb25uZWN0aW9uRmFpbGVkSWQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYWZ0ZXIgNSBzZWNvbmRzIG9mIGVudGVyaW5nIENPTk5FQ1RJTkcgc3RhdGUgd2l0aG91dCBnZXR0aW5nIGFuIGVycm9yIG9yIGEgY29ubmVjdGlvbi5cbiAgICogQ2FsbHMgX29uRXJyb3Igd2hpY2ggd2lsbCBjYXVzZSB0aGlzIGF0dGVtcHQgdG8gYmUgc3RvcHBlZCBhbmQgYW5vdGhlciBjb25uZWN0aW9uIGF0dGVtcHQgdG8gYmUgc2NoZWR1bGVkLlxuICAgKlxuICAgKiBAbWV0aG9kIF9jb25uZWN0aW9uRmFpbGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29ubmVjdGlvbkZhaWxlZCgpIHtcbiAgICB0aGlzLl9jb25uZWN0aW9uRmFpbGVkSWQgPSAwO1xuICAgIGNvbnN0IG1zZyA9ICdXZWJzb2NrZXQgZmFpbGVkIHRvIGNvbm5lY3QgdG8gc2VydmVyJztcbiAgICBsb2dnZXIud2Fybihtc2cpO1xuXG4gICAgLy8gVE9ETzogQXQgdGhpcyB0aW1lIHRoZXJlIGlzIGxpdHRsZSBpbmZvcm1hdGlvbiBvbiB3aGF0IGhhcHBlbnMgd2hlbiBjbG9zaW5nIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gdGhhdCBpcyBzdHVjayBpblxuICAgIC8vIHJlYWR5U3RhdGU9Q09OTkVDVElORy4gIERvZXMgaXQgdGhyb3cgYW4gZXJyb3I/ICBEb2VzIGl0IGNhbGwgdGhlIG9uQ2xvc2Ugb3Igb25FcnJvciBldmVudCBoYW5kbGVycz9cbiAgICAvLyBSZW1vdmUgYWxsIGV2ZW50IGhhbmRsZXJzIHNvIHRoYXQgY2FsbGluZyBjbG9zZSB3b24ndCB0cmlnZ2VyIGFueSBjYWxscy5cbiAgICB0cnkge1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JlbW92ZVNvY2tldEV2ZW50cygpO1xuICAgICAgdGhpcy5fc29ja2V0LmNsb3NlKCk7XG4gICAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIE5vLW9wXG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGNhbiBjYWxsIG91ciBlcnJvciBoYW5kbGVyLlxuICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKG1zZykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpcyByZXBvcnRpbmcgdGhhdCBpdHMgbm93IG9wZW4uXG4gICAqXG4gICAqIEBtZXRob2QgX29uT3BlblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uT3BlbigpIHtcbiAgICB0aGlzLl9jbGVhckNvbm5lY3Rpb25GYWlsZWQoKTtcbiAgICBpZiAodGhpcy5faXNPcGVuKCkpIHtcbiAgICAgIHRoaXMuX2xvc3RDb25uZWN0aW9uQ291bnQgPSAwO1xuICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb25uZWN0ZWQnKTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnV2Vic29ja2V0IENvbm5lY3RlZCcpO1xuICAgICAgaWYgKHRoaXMuX2hhc0NvdW50ZXIpIHtcbiAgICAgICAgdGhpcy5yZXBsYXlFdmVudHModGhpcy5fbGFzdFRpbWVzdGFtcCwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZXNjaGVkdWxlUGluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUZXN0cyB0byBzZWUgaWYgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzIG9wZW4uICBVc2UgdGhlIGlzT3BlbiBwcm9wZXJ0eVxuICAgKiBmb3IgZXh0ZXJuYWwgdGVzdHMuXG4gICAqIEBtZXRob2QgX2lzT3BlblxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIF9pc09wZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiBmYWxzZTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodHlwZW9mIFdlYlNvY2tldCA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiB0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIG5vdCBpc09wZW4sIHByZXN1bWFibHkgZmFpbGVkIHRvIGNvbm5lY3RcbiAgICogQW55IG90aGVyIGVycm9yIGNhbiBiZSBpZ25vcmVkLi4uIGlmIHRoZSBjb25uZWN0aW9uIGhhc1xuICAgKiBmYWlsZWQsIG9uQ2xvc2Ugd2lsbCBoYW5kbGUgaXQuXG4gICAqXG4gICAqIEBtZXRob2QgX29uRXJyb3JcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7RXJyb3J9IGVyciAtIFdlYnNvY2tldCBlcnJvclxuICAgKi9cbiAgX29uRXJyb3IoZXJyKSB7XG4gICAgaWYgKHRoaXMuX2Nsb3NpbmcpIHJldHVybjtcbiAgICB0aGlzLl9jbGVhckNvbm5lY3Rpb25GYWlsZWQoKTtcbiAgICBsb2dnZXIuZGVidWcoJ1dlYnNvY2tldCBFcnJvciBjYXVzaW5nIHdlYnNvY2tldCB0byBjbG9zZScsIGVycik7XG4gICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0RXZlbnRzKCk7XG4gICAgICB0aGlzLl9sb3N0Q29ubmVjdGlvbkNvdW50Kys7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlY29ubmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vblNvY2tldENsb3NlKCk7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IG1ldGhvZCBmb3Igc2VuZGluZyBhIHNpZ25hbFxuICAgKlxuICAgKiAgICBtYW5hZ2VyLnNlbmRTaWduYWwoe1xuICAgICAgICAgICd0eXBlJzogJ3R5cGluZ19pbmRpY2F0b3InLFxuICAgICAgICAgICdvYmplY3QnOiB7XG4gICAgICAgICAgICAnaWQnOiB0aGlzLmNvbnZlcnNhdGlvbi5pZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2RhdGEnOiB7XG4gICAgICAgICAgICAnYWN0aW9uJzogc3RhdGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgKlxuICAgKiBAbWV0aG9kIHNlbmRTaWduYWxcbiAgICogQHBhcmFtICB7T2JqZWN0fSBib2R5IC0gU2lnbmFsIGJvZHlcbiAgICovXG4gIHNlbmRTaWduYWwoYm9keSkge1xuICAgIGlmICh0aGlzLl9pc09wZW4oKSkge1xuICAgICAgdGhpcy5fc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0eXBlOiAnc2lnbmFsJyxcbiAgICAgICAgYm9keSxcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIHNlbmRpbmcgYSBDb3VudGVyLnJlYWQgcmVxdWVzdFxuICAgKlxuICAgKiBAbWV0aG9kIGdldENvdW50ZXJcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FsbGJhY2suc3VjY2Vzc1xuICAgKiBAcGFyYW0ge251bWJlcn0gY2FsbGJhY2subGFzdENvdW50ZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNhbGxiYWNrLm5ld0NvdW50ZXJcbiAgICovXG4gIGdldENvdW50ZXIoY2FsbGJhY2spIHtcbiAgICBsb2dnZXIuZGVidWcoJ1dlYnNvY2tldCByZXF1ZXN0OiBnZXRDb3VudGVyJyk7XG4gICAgdGhpcy5jbGllbnQuc29ja2V0UmVxdWVzdE1hbmFnZXIuc2VuZFJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnQ291bnRlci5yZWFkJyxcbiAgICB9LCAocmVzdWx0KSA9PiB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1dlYnNvY2tldCByZXNwb25zZTogZ2V0Q291bnRlciAnICsgcmVzdWx0LmRhdGEuY291bnRlcik7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSwgcmVzdWx0LmRhdGEuY291bnRlciwgcmVzdWx0LmZ1bGxEYXRhLmNvdW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxheXMgYWxsIG1pc3NlZCBjaGFuZ2UgcGFja2V0cyBzaW5jZSB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKlxuICAgKiBAbWV0aG9kIHJlcGxheUV2ZW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8bnVtYmVyfSAgIHRpbWVzdGFtcCAtIElzbyBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmc7IGlmIG51bWJlciB3aWxsIGJlIHRyYW5zZm9ybWVkIGludG8gZm9ybWF0dGVkIGRhdGUgc3RyaW5nLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gaWYgdHJ1ZSwgY2FuY2VsIGFueSBpbiBwcm9ncmVzcyByZXBsYXlFdmVudHMgYW5kIHN0YXJ0IGEgbmV3IG9uZVxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIE9wdGlvbmFsIGNhbGxiYWNrIGZvciBjb21wbGV0aW9uXG4gICAqL1xuICByZXBsYXlFdmVudHModGltZXN0YW1wLCBmb3JjZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRpbWVzdGFtcCkgcmV0dXJuO1xuICAgIGlmIChmb3JjZSkgdGhpcy5faW5SZXBsYXkgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHRpbWVzdGFtcCA9IG5ldyBEYXRlKHRpbWVzdGFtcCkudG9JU09TdHJpbmcoKTtcblxuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHdhaXRpbmcgZm9yIGEgcmVwbGF5IHRvIGNvbXBsZXRlLCByZWNvcmQgdGhlIHRpbWVzdGFtcCBmcm9tIHdoaWNoIHdlXG4gICAgLy8gbmVlZCB0byByZXBsYXkgb24gb3VyIG5leHQgcmVwbGF5IHJlcXVlc3RcbiAgICAvLyBJZiB3ZSBhcmUgc2ltcGx5IHVuYWJsZSB0byByZXBsYXkgYmVjYXVzZSB3ZSdyZSBkaXNjb25uZWN0ZWQsIGNhcHR1cmUgdGhlIF9uZWVkc1JlcGxheUZyb21cbiAgICBpZiAodGhpcy5faW5SZXBsYXkgfHwgIXRoaXMuX2lzT3BlbigpKSB7XG4gICAgICBpZiAoIXRoaXMuX25lZWRzUmVwbGF5RnJvbSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ1dlYnNvY2tldCByZXF1ZXN0OiByZXBsYXlFdmVudHMgdXBkYXRpbmcgX25lZWRzUmVwbGF5RnJvbScpO1xuICAgICAgICB0aGlzLl9uZWVkc1JlcGxheUZyb20gPSB0aW1lc3RhbXA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2luUmVwbGF5ID0gdHJ1ZTtcbiAgICAgIGxvZ2dlci5pbmZvKCdXZWJzb2NrZXQgcmVxdWVzdDogcmVwbGF5RXZlbnRzJyk7XG4gICAgICB0aGlzLmNsaWVudC5zb2NrZXRSZXF1ZXN0TWFuYWdlci5zZW5kUmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogJ0V2ZW50LnJlcGxheScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBmcm9tX3RpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICB9LFxuICAgICAgfSwgcmVzdWx0ID0+IHRoaXMuX3JlcGxheUV2ZW50c0NvbXBsZXRlKHRpbWVzdGFtcCwgY2FsbGJhY2ssIHJlc3VsdC5zdWNjZXNzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZvciBoYW5kbGluZyBjb21wbGV0aW9uIG9mIHJlcGxheS5cbiAgICpcbiAgICogQG1ldGhvZCBfcmVwbGF5RXZlbnRzQ29tcGxldGVcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtICB7RGF0ZX0gICAgIHRpbWVzdGFtcFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICBzdWNjZXNzXG4gICAqL1xuICBfcmVwbGF5RXZlbnRzQ29tcGxldGUodGltZXN0YW1wLCBjYWxsYmFjaywgc3VjY2Vzcykge1xuICAgIHRoaXMuX2luUmVwbGF5ID0gZmFsc2U7XG5cbiAgICAvLyBJZiByZXBsYXkgd2FzIGNvbXBsZXRlZCwgYW5kIG5vIG90aGVyIHJlcXVlc3RzIGZvciByZXBsYXksIHRoZW4gdHJpZ2dlciBzeW5jZWQ7XG4gICAgLy8gd2UncmUgZG9uZS5cbiAgICBpZiAoc3VjY2VzcyAmJiAhdGhpcy5fbmVlZHNSZXBsYXlGcm9tKSB7XG4gICAgICBsb2dnZXIuaW5mbygnV2Vic29ja2V0IHJlcGxheSBjb21wbGV0ZScpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdzeW5jZWQnKTtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBJZiByZXBsYXlFdmVudHMgd2FzIGNhbGxlZCBkdXJpbmcgYSByZXBsYXksIHRoZW4gcmVwbGF5XG4gICAgLy8gZnJvbSB0aGUgZ2l2ZW4gdGltZXN0YW1wLiAgSWYgcmVxdWVzdCBmYWlsZWQsIHRoZW4gd2UgbmVlZCB0byByZXRyeSBmcm9tIF9sYXN0VGltZXN0YW1wXG4gICAgZWxzZSBpZiAoc3VjY2VzcyAmJiB0aGlzLl9uZWVkc1JlcGxheUZyb20pIHtcbiAgICAgIGxvZ2dlci5pbmZvKCdXZWJzb2NrZXQgcmVwbGF5IHBhcnRpYWxseSBjb21wbGV0ZScpO1xuICAgICAgY29uc3QgdCA9IHRoaXMuX25lZWRzUmVwbGF5RnJvbTtcbiAgICAgIHRoaXMuX25lZWRzUmVwbGF5RnJvbSA9IG51bGw7XG4gICAgICB0aGlzLnJlcGxheUV2ZW50cyh0KTtcbiAgICB9XG5cbiAgICAvLyBXZSBuZXZlciBnb3QgYSBkb25lIGV2ZW50LiAgV2UgYWxzbyBkaWRuJ3QgbWlzcyBhbnkgY291bnRlcnMsIHNvIHRoZSBsYXN0XG4gICAgLy8gbWVzc2FnZSB3ZSByZWNlaXZlZCB3YXMgdmFsaWQ7IHNvIGxldHMganVzdCB1c2UgdGhhdCBhcyBvdXIgdGltZXN0YW1wIGFuZFxuICAgIC8vIHRyeSBhZ2FpbiB1bnRpbCB3ZSBETyBnZXQgYSBFdmVudC5SZXBsYXkgY29tcGxldGlvbiBwYWNrZXRcbiAgICBlbHNlIHtcbiAgICAgIGxvZ2dlci5pbmZvKCdXZWJzb2NrZXQgcmVwbGF5IHJldHJ5Jyk7XG4gICAgICB0aGlzLnJlcGxheUV2ZW50cyh0aW1lc3RhbXApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgbmV3IHdlYnNvY2tldCBwYWNrZXQgZnJvbSB0aGUgc2VydmVyXG4gICAqXG4gICAqIEBtZXRob2QgX29uTWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGV2dCAtIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICBfb25NZXNzYWdlKGV2dCkge1xuICAgIHRoaXMuX2xvc3RDb25uZWN0aW9uQ291bnQgPSAwO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2dC5kYXRhKTtcbiAgICAgIGNvbnN0IHNraXBwZWRDb3VudGVyID0gdGhpcy5fbGFzdENvdW50ZXIgKyAxICE9PSBtc2cuY291bnRlcjtcbiAgICAgIHRoaXMuX2hhc0NvdW50ZXIgPSB0cnVlO1xuICAgICAgdGhpcy5fbGFzdENvdW50ZXIgPSBtc2cuY291bnRlcjtcbiAgICAgIHRoaXMuX2xhc3REYXRhRnJvbVNlcnZlclRpbWVzdGFtcCA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIElmIHdlJ3ZlIG1pc3NlZCBhIGNvdW50ZXIsIHJlcGxheSB0byBnZXQ7IG5vdGUgdGhhdCB3ZSBoYWQgdG8gdXBkYXRlIF9sYXN0Q291bnRlclxuICAgICAgLy8gZm9yIHJlcGxheUV2ZW50cyB0byB3b3JrIGNvcnJlY3RseS5cbiAgICAgIGlmIChza2lwcGVkQ291bnRlcikge1xuICAgICAgICB0aGlzLnJlcGxheUV2ZW50cyh0aGlzLl9sYXN0VGltZXN0YW1wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2xhc3RUaW1lc3RhbXAgPSBuZXcgRGF0ZShtc2cudGltZXN0YW1wKS5nZXRUaW1lKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignbWVzc2FnZScsIHtcbiAgICAgICAgZGF0YTogbXNnLFxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3Jlc2NoZWR1bGVQaW5nKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0xheWVyLVdlYnNvY2tldDogRmFpbGVkIHRvIGhhbmRsZSB3ZWJzb2NrZXQgbWVzc2FnZTogJyArIGVyciArICdcXG4nLCBldnQuZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlc2NoZWR1bGUgYSBwaW5nIHJlcXVlc3Qgd2hpY2ggaGVscHMgdXMgdmVyaWZ5IHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgc3RpbGwgYWxpdmUsXG4gICAqIGFuZCB0aGF0IHdlIGhhdmVuJ3QgbWlzc2VkIGFueSBldmVudHMuXG4gICAqXG4gICAqIEBtZXRob2QgX3Jlc2NoZWR1bGVQaW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVzY2hlZHVsZVBpbmcoKSB7XG4gICAgaWYgKHRoaXMuX25leHRQaW5nSWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9uZXh0UGluZ0lkKTtcbiAgICB9XG4gICAgdGhpcy5fbmV4dFBpbmdJZCA9IHNldFRpbWVvdXQodGhpcy5fcGluZy5iaW5kKHRoaXMpLCB0aGlzLnBpbmdGcmVxdWVuY3kpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBjb3VudGVyIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB0byB2ZXJpZnkgdGhhdCB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkIGFuZFxuICAgKiBoYXZlIG5vdCBtaXNzZWQgYW55IGV2ZW50cy5cbiAgICpcbiAgICogQG1ldGhvZCBfcGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BpbmcoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdXZWJzb2NrZXQgcGluZycpO1xuICAgIHRoaXMuX25leHRQaW5nSWQgPSAwO1xuICAgIGlmICh0aGlzLl9pc09wZW4oKSkge1xuICAgICAgLy8gTk9URTogb25NZXNzYWdlIHdpbGwgYWxyZWFkeSBoYXZlIGNhbGxlZCByZXNjaGVkdWxlUGluZywgYnV0IGlmIHRoZXJlIHdhcyBubyByZXNwb25zZSwgdGhlbiB0aGUgZXJyb3IgaGFuZGxlciB3b3VsZCBOT1QgaGF2ZSBjYWxsZWQgaXQuXG4gICAgICB0aGlzLmdldENvdW50ZXIodGhpcy5fcmVzY2hlZHVsZVBpbmcuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogQ2xvc2UgdGhlIHdlYnNvY2tldC5cbiAgICpcbiAgICogQG1ldGhvZCBjbG9zZVxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgbG9nZ2VyLmRlYnVnKCdXZWJzb2NrZXQgY2xvc2UgcmVxdWVzdGVkJyk7XG4gICAgdGhpcy5fY2xvc2luZyA9IHRydWU7XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICAvLyBDbG9zZSBhbGwgZXZlbnQgaGFuZGxlcnMgYW5kIHNldCBzb2NrZXQgdG8gbnVsbFxuICAgICAgLy8gd2l0aG91dCB3YWl0aW5nIGZvciBicm93c2VyIGV2ZW50IHRvIGNhbGxcbiAgICAgIC8vIF9vblNvY2tldENsb3NlIGFzIHRoZSBuZXh0IGNvbW1hbmQgYWZ0ZXIgY2xvc2VcbiAgICAgIC8vIG1pZ2h0IHJlcXVpcmUgY3JlYXRpbmcgYSBuZXcgc29ja2V0XG4gICAgICB0aGlzLl9vblNvY2tldENsb3NlKCk7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcbiAgICAgIHRoaXMuX3NvY2tldCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwYWNrZXQgYWNyb3NzIHRoZSB3ZWJzb2NrZXRcbiAgICogQG1ldGhvZCBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAgICovXG4gIHNlbmQob2JqKSB7XG4gICAgdGhpcy5fc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBpZiAodGhpcy5fbmV4dFBpbmdJZCkgY2xlYXJUaW1lb3V0KHRoaXMuX25leHRQaW5nSWQpO1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgc29ja2V0IGhhcyBjbG9zZWQgKG9yIGlmIHRoZSBjbG9zZSBtZXRob2QgZm9yY2VzIGl0IGNsb3NlZClcbiAgICogUmVtb3ZlIGFsbCBldmVudCBoYW5kbGVycyBhbmQgaWYgYXBwcm9wcmlhdGUsIHNjaGVkdWxlIGEgcmV0cnkuXG4gICAqXG4gICAqIEBtZXRob2QgX29uU29ja2V0Q2xvc2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vblNvY2tldENsb3NlKCkge1xuICAgIGxvZ2dlci5kZWJ1ZygnV2Vic29ja2V0IGNsb3NlZCcpO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9jbG9zaW5nKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZVJlY29ubmVjdCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbW92ZVNvY2tldEV2ZW50cygpO1xuICAgIHRoaXMudHJpZ2dlcignZGlzY29ubmVjdGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZXZlbnQgaGFuZGxlcnMgb24gdGhlIGN1cnJlbnQgc29ja2V0LlxuICAgKlxuICAgKiBAbWV0aG9kIF9yZW1vdmVTb2NrZXRFdmVudHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW1vdmVTb2NrZXRFdmVudHMoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBXZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnICYmIHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xuICAgICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5fb25Tb2NrZXRDbG9zZSk7XG4gICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMuX29uT3Blbik7XG4gICAgICB0aGlzLl9zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fc29ja2V0Lm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICB0aGlzLl9zb2NrZXQub25jbG9zZSA9IG51bGw7XG4gICAgICB0aGlzLl9zb2NrZXQub25vcGVuID0gbnVsbDtcbiAgICAgIHRoaXMuX3NvY2tldC5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGUgYW4gYXR0ZW1wdCB0byByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci4gIElmIHRoZSBvbmxpbmVNYW5hZ2VyXG4gICAqIGRlY2xhcmVzIHVzIHRvIGJlIG9mZmxpbmUsIGRvbid0IGJvdGhlciByZWNvbm5lY3RpbmcuICBBIHJlY29ubmVjdFxuICAgKiBhdHRlbXB0IHdpbGwgYmUgdHJpZ2dlcmVkIGFzIHNvb24gYXMgdGhlIG9ubGluZSBtYW5hZ2VyIHJlcG9ydHMgd2UgYXJlIG9ubGluZSBhZ2Fpbi5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBkdXJhdGlvbiBvZiBvdXIgZGVsYXkgY2FuIG5vdCBleGNlZGUgdGhlIG9ubGluZU1hbmFnZXIncyBwaW5nIGZyZXF1ZW5jeVxuICAgKiBvciBpdCB3aWxsIGRlY2xhcmUgdXMgdG8gYmUgb2ZmbGluZSB3aGlsZSB3ZSBhdHRlbXB0IGEgcmVjb25uZWN0LlxuICAgKlxuICAgKiBAbWV0aG9kIF9zY2hlZHVsZVJlY29ubmVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NjaGVkdWxlUmVjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWVkIHx8ICF0aGlzLmNsaWVudC5pc09ubGluZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgbWF4RGVsYXkgPSAodGhpcy5jbGllbnQub25saW5lTWFuYWdlci5waW5nRnJlcXVlbmN5IC0gMTAwMCkgLyAxMDAwO1xuICAgIGNvbnN0IGRlbGF5ID0gVXRpbHMuZ2V0RXhwb25lbnRpYWxCYWNrb2ZmU2Vjb25kcyhtYXhEZWxheSwgTWF0aC5taW4oMTUsIHRoaXMuX2xvc3RDb25uZWN0aW9uQ291bnQpKTtcbiAgICBsb2dnZXIuZGVidWcoJ1dlYnNvY2tldCBSZWNvbm5lY3QgaW4gJyArIGRlbGF5ICsgJyBzZWNvbmRzJyk7XG4gICAgdGhpcy5fcmVjb25uZWN0SWQgPSBzZXRUaW1lb3V0KHRoaXMuY29ubmVjdC5iaW5kKHRoaXMpLCBkZWxheSAqIDEwMDApO1xuICB9XG59XG5cbi8qKlxuICogSXMgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGN1cnJlbnRseSBvcGVuP1xuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblNvY2tldE1hbmFnZXIucHJvdG90eXBlLmlzT3BlbiA9IGZhbHNlO1xuXG4vKipcbiAqIHNldFRpbWVvdXQgSUQgZm9yIGNhbGxpbmcgY29ubmVjdCgpXG4gKiBAcHJpdmF0ZVxuICogQHR5cGUge051bWJlcn1cbiAqL1xuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX3JlY29ubmVjdElkID0gMDtcblxuLyoqXG4gKiBzZXRUaW1lb3V0IElEIGZvciBjYWxsaW5nIF9jb25uZWN0aW9uRmFpbGVkKClcbiAqIEBwcml2YXRlXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Tb2NrZXRNYW5hZ2VyLnByb3RvdHlwZS5fY29ubmVjdGlvbkZhaWxlZElkID0gMDtcblxuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX2xhc3RUaW1lc3RhbXAgPSAwO1xuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX2xhc3REYXRhRnJvbVNlcnZlclRpbWVzdGFtcCA9IDA7XG5Tb2NrZXRNYW5hZ2VyLnByb3RvdHlwZS5fbGFzdENvdW50ZXIgPSBudWxsO1xuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX2hhc0NvdW50ZXIgPSBmYWxzZTtcblxuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX2luUmVwbGF5ID0gZmFsc2U7XG5Tb2NrZXRNYW5hZ2VyLnByb3RvdHlwZS5fbmVlZHNSZXBsYXlGcm9tID0gbnVsbDtcblxuLyoqXG4gKiBGcmVxdWVuY3kgd2l0aCB3aGljaCB0aGUgd2Vic29ja2V0IGNoZWNrcyB0byBzZWUgaWYgYW55IHdlYnNvY2tldCBub3RpZmljYXRpb25zXG4gKiBoYXZlIGJlZW4gbWlzc2VkLlxuICogQHR5cGUge051bWJlcn1cbiAqL1xuU29ja2V0TWFuYWdlci5wcm90b3R5cGUucGluZ0ZyZXF1ZW5jeSA9IDMwMDAwO1xuXG4vKipcbiAqIFRoZSBDbGllbnQgdGhhdCBvd25zIHRoaXMuXG4gKiBAdHlwZSB7bGF5ZXIuQ2xpZW50fVxuICovXG5Tb2NrZXRNYW5hZ2VyLnByb3RvdHlwZS5jbGllbnQgPSBudWxsO1xuXG4vKipcbiAqIFRoZSBTb2NrZXQgQ29ubmVjdGlvbiBpbnN0YW5jZVxuICogQHR5cGUge1dlYnNvY2tldH1cbiAqL1xuU29ja2V0TWFuYWdlci5wcm90b3R5cGUuX3NvY2tldCA9IG51bGw7XG5cbi8qKlxuICogSXMgdGhlIHdlYnNvY2tldCBjb25uZWN0aW9uIGJlaW5nIGNsb3NlZCBieSBhIGNhbGwgdG8gY2xvc2UoKT9cbiAqIElmIHNvLCB3ZSBjYW4gaWdub3JlIGFueSBlcnJvcnMgdGhhdCBzaWduYWwgdGhlIHNvY2tldCBhcyBjbG9zaW5nLlxuICogQHR5cGUge0Jvb2xlYW59XG4gKi9cblNvY2tldE1hbmFnZXIucHJvdG90eXBlLl9jbG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogTnVtYmVyIG9mIGZhaWxlZCBhdHRlbXB0cyB0byByZWNvbm5lY3QuXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Tb2NrZXRNYW5hZ2VyLnByb3RvdHlwZS5fbG9zdENvbm5lY3Rpb25Db3VudCA9IDA7XG5cblxuU29ja2V0TWFuYWdlci5fc3VwcG9ydGVkRXZlbnRzID0gW1xuICAvKipcbiAgICogQSBkYXRhIHBhY2tldCBoYXMgYmVlbiByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAqIEBldmVudCBtZXNzYWdlXG4gICAqIEBwYXJhbSB7bGF5ZXIuTGF5ZXJFdmVudH0gbGF5ZXJFdmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gbGF5ZXJFdmVudC5kYXRhIC0gVGhlIGRhdGEgdGhhdCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gICAqL1xuICAnbWVzc2FnZScsXG5cbiAgLyoqXG4gICAqIFRoZSB3ZWJzb2NrZXQgaXMgbm93IGNvbm5lY3RlZC5cbiAgICogQGV2ZW50IGNvbm5lY3RlZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICAnY29ubmVjdGVkJyxcblxuICAvKipcbiAgICogVGhlIHdlYnNvY2tldCBpcyBubyBsb25nZXIgY29ubmVjdGVkXG4gICAqIEBldmVudCBkaXNjb25uZWN0ZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgJ2Rpc2Nvbm5lY3RlZCcsXG5cbiAgLyoqXG4gICAqIFdlYnNvY2tldCBldmVudHMgd2VyZSBtaXNzZWQ7IHdlIGFyZSByZXN5bmNpbmcgd2l0aCB0aGUgc2VydmVyXG4gICAqIEBldmVudCByZXBsYXktYmVndW5cbiAgICovXG4gICdzeW5jaW5nJyxcblxuICAvKipcbiAgICogV2Vic29ja2V0IGV2ZW50cyB3ZXJlIG1pc3NlZDsgd2UgcmVzeW5jZWQgd2l0aCB0aGUgc2VydmVyIGFuZCBhcmUgbm93IGRvbmVcbiAgICogQGV2ZW50IHJlcGxheS1iZWd1blxuICAgKi9cbiAgJ3N5bmNlZCcsXG5dLmNvbmNhdChSb290Ll9zdXBwb3J0ZWRFdmVudHMpO1xuUm9vdC5pbml0Q2xhc3MuYXBwbHkoU29ja2V0TWFuYWdlciwgW1NvY2tldE1hbmFnZXIsICdTb2NrZXRNYW5hZ2VyJ10pO1xubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXRNYW5hZ2VyO1xuIiwiLyoqXG4gKiBCYXNpYyBYSFIgTGlicmFyeSB3aXRoIHNvbWUgbm90aW9ucyBoYXJkY29kZWQgaW5cbiAqIG9mIHdoYXQgdGhlIExheWVyIHNlcnZlciBleHBlY3RzL3JldHVybnMuXG4gKlxuICAgIGxheWVyLnhocih7XG4gICAgICB1cmw6ICdodHRwOi8vbXkuY29tL215ZGF0YScsXG4gICAgICBkYXRhOiB7aGV5OiAnaG8nLCB0aGVyZTogJ2ZvbGsnfSxcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgIGhlYWRlcnM6IHsnZnJlZCc6ICdKb2UnfSxcbiAgICAgIHRpbWVvdXQ6IDUwMDAwXG4gICAgfSwgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGVycm9ySGFuZGxlcihyZXN1bHQuZGF0YSwgcmVzdWx0LmhlYWRlcnMsIHJlc3VsdC5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VjY2Vzc0hhbmRsZXIocmVzdWx0LmRhdGEsIHJlc3VsdC5oZWFkZXJzLCByZXN1bHQueGhyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAqXG4gKiBAY2xhc3MgbGF5ZXIueGhyXG4gKi9cblxuLyoqXG4gKiBTZW5kIGEgUmVxdWVzdC5cbiAqXG4gKiBAbWV0aG9kICB4aHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy51cmxcbiAqIEBwYXJhbSB7TWl4ZWR9IFtvcHRpb25zLmRhdGE9bnVsbF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mb3JtYXQ9JyddIC0gc2V0IHRvICdqc29uJyB0byBnZXQgcmVzdWx0IHBhcnNlZCBhcyBqc29uIChpbiBjYXNlIHRoZXJlIGlzIG5vIG9idmlvdXMgQ29udGVudC1UeXBlIGluIHRoZSByZXNwb25zZSlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5oZWFkZXJzPXt9XSAtIE5hbWUgdmFsdWUgcGFpcnMgZm9yICBoZWFkZXJzIGFuZCB0aGVpciB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50aW1lb3V0PTBdIC0gV2hlbiBkb2VzIHRoZSByZXF1ZXN0IGV4cGlyZS90aW1lb3V0IGluIG1pbGlzZWNvbmRzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWxsYmFjay5yZXN1bHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYWxsYmFjay5yZXN1bHQuc3RhdHVzIC0gaHR0cCBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtib29sZWFufSBjYWxsYmFjay5yZXN1bHQuc3VjY2VzcyAtIHRydWUgaWYgaXQgd2FzIGEgc3VjY2Vzc2Z1bCByZXNwb25zZVxuICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0gY2FsbGJhY2sucmVzdWx0LnhociAtIFRoZSBYSFIgb2JqZWN0IHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sucmVzdWx0LmRhdGEgLSAgVGhlIHBhcnNlZCByZXNwb25zZSBib2R5XG4gKlxuICogVE9ETzpcbiAqXG4gKiAxLiBNYWtlIHRoaXMgYSBzdWJjbGFzcyBvZiBSb290IGFuZCBtYWtlIGl0IGEgc2luZ2xldG9uIHNvIGl0IGNhbiBpbmhlcml0IGEgcHJvcGVyIGV2ZW50IHN5c3RlbVxuICogMi4gUmVzdWx0IHNob3VsZCBiZSBhIGxheWVyLlNlcnZlclJlc3BvbnNlIGluc3RhbmNlXG4gKiAzLiBTaG91bGQgb25seSBhY2Nlc3MgbGluayBoZWFkZXJzIGlmIHJlcXVlc3RlZDsgYW5ub3lpbmcgaGF2aW5nIGl0IHRocm93IGVycm9ycyBldmVyeSBvdGhlciB0aW1lLlxuICovXG5cbi8vIERvbid0IHNldCB4aHIgdG8gd2luZG93LlhNTEh0dHBSZXF1ZXN0IGFzIGl0IHdpbGwgYnlwYXNzIGphc21pbmUnc1xuLy8gYWpheCBsaWJyYXJ5XG5jb25zdCBYaHIgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gcmVxdWlyZSgneGhyMicpIDogbnVsbDtcblxuZnVuY3Rpb24gcGFyc2VMaW5rSGVhZGVycyhsaW5rSGVhZGVyKSB7XG4gIGlmICghbGlua0hlYWRlcikgcmV0dXJuIHt9O1xuXG4gIC8vIFNwbGl0IHBhcnRzIGJ5IGNvbW1hXG4gIGNvbnN0IHBhcnRzID0gbGlua0hlYWRlci5zcGxpdCgnLCcpO1xuICBjb25zdCBsaW5rcyA9IHt9O1xuXG4gIC8vIFBhcnNlIGVhY2ggcGFydCBpbnRvIGEgbmFtZWQgbGlua1xuICBwYXJ0cy5mb3JFYWNoKHBhcnQgPT4ge1xuICAgIGNvbnN0IHNlY3Rpb24gPSBwYXJ0LnNwbGl0KCc7Jyk7XG4gICAgaWYgKHNlY3Rpb24ubGVuZ3RoICE9PSAyKSByZXR1cm47XG4gICAgY29uc3QgdXJsID0gc2VjdGlvblswXS5yZXBsYWNlKC88KC4qKT4vLCAnJDEnKS50cmltKCk7XG4gICAgY29uc3QgbmFtZSA9IHNlY3Rpb25bMV0ucmVwbGFjZSgvcmVsPSc/KC4qKSc/LywgJyQxJykudHJpbSgpO1xuICAgIGxpbmtzW25hbWVdID0gdXJsO1xuICB9KTtcblxuICByZXR1cm4gbGlua3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IHJlcSA9IFhociA/IG5ldyBYaHIoKSA6IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICBjb25zdCBtZXRob2QgPSAocmVxdWVzdC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgY29uc3Qgb25sb2FkID0gZnVuY3Rpb24gb25sb2FkKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAnY29udGVudC10eXBlJzogdGhpcy5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyksXG4gICAgfTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdWNjZXNzOiB0aGlzLnN0YXR1cyAmJiB0aGlzLnN0YXR1cyA8IDMwMCxcbiAgICAgIHhocjogdGhpcyxcbiAgICB9O1xuICAgIGNvbnN0IGlzSlNPTiA9IChTdHJpbmcoaGVhZGVyc1snY29udGVudC10eXBlJ10pLnNwbGl0KC87LylbMF0ubWF0Y2goL15hcHBsaWNhdGlvblxcL2pzb24vKSB8fFxuICAgICAgICAgICByZXF1ZXN0LmZvcm1hdCA9PT0gJ2pzb24nKTtcblxuICAgIGlmICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InIHx8IHRoaXMucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAvLyBEYW1uaXQsIHRoaXMucmVzcG9uc2UgaXMgYSBmdW5jdGlvbiBpZiB1c2luZyBqYXNtaW5lIHRlc3QgZnJhbWV3b3JrLlxuICAgICAgcmVzdWx0LmRhdGEgPSB0eXBlb2YgdGhpcy5yZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMucmVzcG9uc2VUZXh0IDogdGhpcy5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzSlNPTiAmJiB0aGlzLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc3VsdC5kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlc3VsdC5kYXRhID0ge1xuICAgICAgICAgICAgY29kZTogOTk5LFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludmFsaWQgSlNPTiBmcm9tIHNlcnZlcicsXG4gICAgICAgICAgICByZXNwb25zZTogdGhpcy5yZXNwb25zZVRleHQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXN1bHQuc3RhdHVzID0gOTk5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQuZGF0YSA9IHRoaXMucmVzcG9uc2VUZXh0O1xuICAgICAgfVxuXG5cbiAgICAgIG1vZHVsZS5leHBvcnRzLnRyaWdnZXIoe1xuICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgIHN0YXR1czogIXRoaXMucmVzcG9uc2VUZXh0ICYmICF0aGlzLnN0YXR1cyA/ICdjb25uZWN0aW9uOmVycm9yJyA6ICdjb25uZWN0aW9uOnN1Y2Nlc3MnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5yZXNwb25zZVRleHQgJiYgIXRoaXMuc3RhdHVzKSB7XG4gICAgICAgIHJlc3VsdC5zdGF0dXMgPSA0MDg7XG4gICAgICAgIHJlc3VsdC5kYXRhID0ge1xuICAgICAgICAgIGlkOiAncmVxdWVzdF90aW1lb3V0JyxcbiAgICAgICAgICBtZXNzYWdlOiAnVGhlIHNlcnZlciBpcyBub3QgcmVzcG9uZGluZyBwbGVhc2UgdHJ5IGFnYWluIGluIGEgZmV3IG1pbnV0ZXMnLFxuICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3dlYnNkaycsXG4gICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICBzdGF0dXM6IDQwOCxcbiAgICAgICAgICBodHRwU3RhdHVzOiA0MDgsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdHVzID09PSA0MDQgJiYgdHlwZW9mIHJlc3VsdC5kYXRhICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXN1bHQuZGF0YSA9IHtcbiAgICAgICAgICBpZDogJ29wZXJhdGlvbl9ub3RfZm91bmQnLFxuICAgICAgICAgIG1lc3NhZ2U6ICdFbmRwb2ludCAnICsgKHJlcXVlc3QubWV0aG9kIHx8ICdHRVQnKSArICcgJyArIHJlcXVlc3QudXJsICsgJyBkb2VzIG5vdCBleGlzdCcsXG4gICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBodHRwU3RhdHVzOiA0MDQsXG4gICAgICAgICAgY29kZTogMTA2LFxuICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3dlYnNkaycsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQuZGF0YSA9PT0gJ3N0cmluZycgJiYgdGhpcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgIHJlc3VsdC5kYXRhID0ge1xuICAgICAgICAgIGlkOiAndW5rbm93bl9lcnJvcicsXG4gICAgICAgICAgbWVzc2FnZTogcmVzdWx0LmRhdGEsXG4gICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBodHRwU3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBjb2RlOiAwLFxuICAgICAgICAgIHVybDogJ2h0dHBzOi8vZGV2ZWxvcGVyLmxheWVyLmNvbS9kb2NzL3dlYnNkaycsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QuaGVhZGVycyAmJiAocmVxdWVzdC5oZWFkZXJzLmFjY2VwdCB8fCAnJykubWF0Y2goL2FwcGxpY2F0aW9uXFwvdm5kLmxheWVyXFwranNvbi8pKSB7XG4gICAgICBjb25zdCBsaW5rcyA9IHRoaXMuZ2V0UmVzcG9uc2VIZWFkZXIoJ2xpbmsnKTtcbiAgICAgIGlmIChsaW5rcykgcmVzdWx0LkxpbmtzID0gcGFyc2VMaW5rSGVhZGVycyhsaW5rcyk7XG4gICAgfVxuICAgIHJlc3VsdC54aHIgPSB0aGlzO1xuXG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhyZXN1bHQpO1xuICB9O1xuXG4gIHJlcS5vbmxvYWQgPSBvbmxvYWQ7XG5cbiAgLy8gVU5URVNURUQhISFcbiAgcmVxLm9uZXJyb3IgPSByZXEub250aW1lb3V0ID0gb25sb2FkO1xuXG4gIC8vIFJlcGxhY2UgYWxsIGhlYWRlcnMgaW4gYXJiaXRyYXJ5IGNhc2Ugd2l0aCBhbGwgbG93ZXIgY2FzZVxuICAvLyBmb3IgZWFzeSBtYXRjaGluZy5cbiAgY29uc3QgaGVhZGVyc0xpc3QgPSBPYmplY3Qua2V5cyhyZXF1ZXN0LmhlYWRlcnMgfHwge30pO1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIGhlYWRlcnNMaXN0LmZvckVhY2goaGVhZGVyID0+IHtcbiAgICBpZiAoaGVhZGVyLnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IHJlcXVlc3QuaGVhZGVyc1toZWFkZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW2hlYWRlci50b0xvd2VyQ2FzZSgpXSA9IHJlcXVlc3QuaGVhZGVyc1toZWFkZXJdO1xuICAgIH1cbiAgfSk7XG4gIHJlcXVlc3QuaGVhZGVycyA9IGhlYWRlcnM7XG5cbiAgbGV0IGRhdGEgPSAnJztcbiAgaWYgKHJlcXVlc3QuZGF0YSkge1xuICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgcmVxdWVzdC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgZGF0YSA9IHJlcXVlc3QuZGF0YTtcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QuaGVhZGVycyAmJiAoXG4gICAgICAgIFN0cmluZyhyZXF1ZXN0LmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKS5tYXRjaCgvXmFwcGxpY2F0aW9uXFwvanNvbi8pIHx8XG4gICAgICAgIFN0cmluZyhyZXF1ZXN0LmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSA9PT0gJ2FwcGxpY2F0aW9uL3ZuZC5sYXllci1wYXRjaCtqc29uJylcbiAgICApIHtcbiAgICAgIGRhdGEgPSB0eXBlb2YgcmVxdWVzdC5kYXRhID09PSAnc3RyaW5nJyA/IHJlcXVlc3QuZGF0YSA6IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QuZGF0YSk7XG4gICAgfSBlbHNlIGlmIChyZXF1ZXN0LmRhdGEgJiYgdHlwZW9mIHJlcXVlc3QuZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlcXVlc3QuZGF0YSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGRhdGEpIGRhdGEgKz0gJyYnO1xuICAgICAgICBkYXRhICs9IG5hbWUgKyAnPScgKyByZXF1ZXN0LmRhdGFbbmFtZV07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHJlcXVlc3QuZGF0YTsgLy8gU29tZSBmb3JtIG9mIHJhdyBzdHJpbmcvZGF0YVxuICAgIH1cbiAgfVxuICBpZiAoZGF0YSkge1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICByZXF1ZXN0LnVybCArPSAnPycgKyBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHJlcS5vcGVuKG1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xuICBpZiAocmVxdWVzdC50aW1lb3V0KSByZXEudGltZW91dCA9IHJlcXVlc3QudGltZW91dDtcbiAgaWYgKHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKSByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgaWYgKHJlcXVlc3QucmVzcG9uc2VUeXBlKSByZXEucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG5cbiAgaWYgKHJlcXVlc3QuaGVhZGVycykge1xuICAgIE9iamVjdC5rZXlzKHJlcXVlc3QuaGVhZGVycykuZm9yRWFjaChoZWFkZXJOYW1lID0+IHJlcS5zZXRSZXF1ZXN0SGVhZGVyKGhlYWRlck5hbWUsIHJlcXVlc3QuaGVhZGVyc1toZWFkZXJOYW1lXSkpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgcmVxLnNlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxLnNlbmQoZGF0YSk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG59O1xuXG5jb25zdCBsaXN0ZW5lcnMgPSBbXTtcbm1vZHVsZS5leHBvcnRzLmFkZENvbm5lY3Rpb25MaXN0ZW5lciA9IGZ1bmMgPT4gbGlzdGVuZXJzLnB1c2goZnVuYyk7XG5cbm1vZHVsZS5leHBvcnRzLnRyaWdnZXIgPSAoZXZ0KSA9PiB7XG4gIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmMgPT4ge1xuICAgIGZ1bmMoZXZ0KTtcbiAgfSk7XG59O1xuIl19
